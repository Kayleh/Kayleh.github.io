<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="pIti0h4vOD" />
  <!-- <meta name="baidu-site-verification" content="L6Lm9d5Crl"/> -->
  
  
  
  
  <title>Interview(updateing) | Kayleh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Interview(updateing)">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview(updateing)">
<meta property="og:url" content="http://dqlcr5.coding-pages.com/2020/07/02/Interview(updating)/index.html">
<meta property="og:site_name" content="Kayleh">
<meta property="og:description" content="Interview(updateing)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://dqlcr5.coding-pages.com/2020/07/02/Interview(updating)/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9.png">
<meta property="og:image" content="http://dqlcr5.coding-pages.com/2020/07/02/Interview(updating)/308572_1537878284540_B6C31D01D41C9E1714958F9C56D01D8F.png">
<meta property="article:published_time" content="2020-07-02T12:45:07.000Z">
<meta property="article:modified_time" content="2020-07-11T04:46:33.971Z">
<meta property="article:author" content="Kayleh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://dqlcr5.coding-pages.com/2020/07/02/Interview(updating)/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9.png">
  
    <link rel="alternative" href="/atom.xml" title="Kayleh" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/1.jpeg">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/2.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Kayleh</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/">主页</a></li>
                        
                            <li><a  href="/tags/resume">简历</a></li>
                        
                            <li><a  href="http://39.108.121.213/" target="_blank" rel="noopener">Wizard社区</a></li>
                        
                            <li><a  href="https://github.com/Kayleh" target="_blank" rel="noopener">关注我</a></li>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/tags/frame">开发框架</a></li>
                        
                            <li><a  href="/tags/DesignPatterns">设计模式</a></li>
                        
                            <li><a  href="/tags/dataAlgorithm">数据结构算法</a></li>
                        
                            <li><a  href="/">前端领域/平面设计</a></li>
                        
                            <li><a  href="/">数据采集/爬虫</a></li>
                        
                            <li><a  href="/tags/maintain">维护</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/Kayleh.github.io" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="https://weibo.com/5737136689/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="https://www.zhihu.com/people/ni-hui-gan-xie-wo-de" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Concurrency/" style="font-size: 10px;">Concurrency</a> <a href="/tags/DesignPatterns/" style="font-size: 20px;">DesignPatterns</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Operating-Systems/" style="font-size: 10px;">Operating Systems</a> <a href="/tags/dataAlgorithm/" style="font-size: 17.5px;">dataAlgorithm</a> <a href="/tags/frame/" style="font-size: 15px;">frame</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/maintain/" style="font-size: 12.5px;">maintain</a> <a href="/tags/resume/" style="font-size: 10px;">resume</a> <a href="/tags/safe/" style="font-size: 12.5px;">safe</a> <a href="/tags/sql/" style="font-size: 12.5px;">sql</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.csdn.net/key1379">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jianshu.com/u/30643eb3e669">简书</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/ni-hui-gan-xie-wo-de">知乎</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">不会剪辑的平面设计师不是好程序员</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Kayleh</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/2.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Kayleh</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/tags/resume">简历</a></li>
                
                    <li><a href="http://39.108.121.213/" target="_blank" rel="noopener">Wizard社区</a></li>
                
                    <li><a href="https://github.com/Kayleh" target="_blank" rel="noopener">关注我</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/frame">开发框架</a></li>
                
                    <li><a href="/tags/DesignPatterns">设计模式</a></li>
                
                    <li><a href="/tags/dataAlgorithm">数据结构算法</a></li>
                
                    <li><a href="/">前端领域/平面设计</a></li>
                
                    <li><a href="/">数据采集/爬虫</a></li>
                
                    <li><a href="/tags/maintain">维护</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/Kayleh.github.io" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="https://weibo.com/5737136689/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="https://www.zhihu.com/people/ni-hui-gan-xie-wo-de" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-Interview(updating)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2020/07/02/Interview(updating)/" class="article-date">
      <time datetime="2020-07-02T12:45:07.000Z" itemprop="datePublished">2020-07-02</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Interview(updateing)
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Interview-updateing"><a href="#Interview-updateing" class="headerlink" title="Interview(updateing)"></a>Interview(updateing)</h1><a id="more"></a>

<h1 id="J2SE"><a href="#J2SE" class="headerlink" title="J2SE"></a>J2SE</h1><h2 id="Object-oriented"><a href="#Object-oriented" class="headerlink" title="Object-oriented"></a>Object-oriented</h2><h3 id="关于Synchronized和lock"><a href="#关于Synchronized和lock" class="headerlink" title="关于Synchronized和lock"></a>关于Synchronized和lock</h3><p><code>synchronized</code>是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。</p>
<p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p> volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。 </p>
<h3 id="请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><a href="#请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？" class="headerlink" title="请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"></a>请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</h3><p> synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。<br>synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。 </p>
<h3 id="若对一个类不重写，它的equals-方法是如何比较的？"><a href="#若对一个类不重写，它的equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的equals()方法是如何比较的？"></a>若对一个类不重写，它的equals()方法是如何比较的？</h3><p> 比较是对象的地址。 </p>
<h3 id="请解释hashCode-和equals-方法有什么联系？"><a href="#请解释hashCode-和equals-方法有什么联系？" class="headerlink" title="请解释hashCode()和equals()方法有什么联系？"></a>请解释hashCode()和equals()方法有什么联系？</h3><p>Java对象的eqauls方法和hashCode方法是这样规定的：</p>
<p>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p>
<p>➁ 如果两个对象的hashCode相同，它们并不一定相同。</p>
<h3 id="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p> 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。<br>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 </p>
<h3 id="请说明Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#请说明Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h3><p> <strong>Java中的方法重载</strong>发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。</p>
<p>与此相对，<strong>方法覆盖</strong>是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 </p>
<h3 id="Query接口的list方法和iterate方法有什么区别？"><a href="#Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="Query接口的list方法和iterate方法有什么区别？"></a>Query接口的list方法和iterate方法有什么区别？</h3><p> ① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。<br>②  list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题 </p>
<h3 id="面向对象的”六原则一法则”。"><a href="#面向对象的”六原则一法则”。" class="headerlink" title="面向对象的”六原则一法则”。"></a>面向对象的”六原则一法则”。</h3><p> - <strong>单一职责原则：一个类只做它该做的事情</strong>。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- <strong>开闭原则</strong>：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- <strong>依赖倒转原则</strong>：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）<strong>里氏替换原则</strong>：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）<strong>- 接口隔离原则</strong>：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- <strong>合成聚合复用原则</strong>：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- <strong>迪米特法则</strong>：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。 </p>
<h3 id="如何通过反射获取和设置对象私有字段的值？"><a href="#如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="如何通过反射获取和设置对象私有字段的值？"></a>如何通过反射获取和设置对象私有字段的值？</h3><p> 可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。</p>
<p>下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">    Method m = str.getClass().getMethod(<span class="string">"toUpperCase"</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p> 方法的重载和重写都是实现多态的方式，</p>
<p>区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 </p>
<h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？</h3><p> 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：</p>
<p>(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</p>
<p>(2)如果两个对象的hashCode相同，它们并不一定相同。</p>
<p>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 </p>
<h3 id="请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"><a href="#请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？" class="headerlink" title="请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"></a>请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</h3><p> 一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性.内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。 </p>
<h3 id="请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><a href="#请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？" class="headerlink" title="请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？"></a>请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</h3><p> Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。</p>
<p>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。 </p>
<h3 id="请说明Java的接口和C-的虚类的相同和不同处"><a href="#请说明Java的接口和C-的虚类的相同和不同处" class="headerlink" title="请说明Java的接口和C++的虚类的相同和不同处"></a>请说明Java的接口和C++的虚类的相同和不同处</h3><p> 由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。 </p>
<h3 id="当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p> 是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 </p>
<h3 id="请你说说Static-Nested-Class-和-Inner-Class的不同"><a href="#请你说说Static-Nested-Class-和-Inner-Class的不同" class="headerlink" title="请你说说Static Nested Class 和 Inner Class的不同"></a>请你说说Static Nested Class 和 Inner Class的不同</h3><p> Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance).Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能Access Outer Class的动态成员(instance member).而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员, 这个概念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member),反过来就可以, 一个CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). </p>
<h3 id="请你讲讲abstract-class和interface有什么区别"><a href="#请你讲讲abstract-class和interface有什么区别" class="headerlink" title="请你讲讲abstract class和interface有什么区别?"></a>请你讲讲abstract class和interface有什么区别?</h3><p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>
<p>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<h3 id="请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型"><a href="#请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?"></a>请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?</h3><p> 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 </p>
<h3 id="请说明一下final-finally-finalize的区别。"><a href="#请说明一下final-finally-finalize的区别。" class="headerlink" title="请说明一下final, finally, finalize的区别。"></a>请说明一下final, finally, finalize的区别。</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>finally是异常处理语句结构的一部分，表示总是执行。<br>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源<br>回收，例如关闭文件等。 </p>
<h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><p><strong>抽象：</strong><br>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只<br>是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。<br><strong>继承：</strong><br>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派<br>生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br><strong>封装：</strong><br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<br><strong>多态：</strong><br>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 </p>
<h3 id="请说明Comparable和Comparator接口的作用以及它们的区别。"><a href="#请说明Comparable和Comparator接口的作用以及它们的区别。" class="headerlink" title="请说明Comparable和Comparator接口的作用以及它们的区别。"></a>请说明Comparable和Comparator接口的作用以及它们的区别。</h3><p> Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 </p>
<h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><p> Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别 </p>
<h3 id="请说明Java是否支持多继承？"><a href="#请说明Java是否支持多继承？" class="headerlink" title="请说明Java是否支持多继承？"></a>请说明Java是否支持多继承？</h3><p> Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 </p>
<h3 id="如何通过反射创建对象？"><a href="#如何通过反射创建对象？" class="headerlink" title="如何通过反射创建对象？"></a>如何通过反射创建对象？</h3><ul>
<li>方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()</li>
<li>方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); </li>
</ul>
<h3 id="是否可以在static环境中访问非static变量？"><a href="#是否可以在static环境中访问非static变量？" class="headerlink" title="是否可以在static环境中访问非static变量？"></a>是否可以在static环境中访问非static变量？</h3><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 </p>
<h3 id="extends-和super-泛型限定符"><a href="#extends-和super-泛型限定符" class="headerlink" title="extends 和super 泛型限定符"></a>extends 和super 泛型限定符</h3><p>（1）泛型中上界和下界的定义</p>
<p>上界&lt;? extend Fruit&gt;</p>
<p>下界&lt;? super Apple&gt;</p>
<p>（2）上界和下界的特点</p>
<p>上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）</p>
<p>下界的list只能add，不能get</p>
<p> （3）示例代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上界</span></span><br><span class="line">    List&lt;? extends Fruit&gt; flistTop = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    flistTop.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//add Fruit对象会报错</span></span><br><span class="line">    <span class="comment">//flist.add(new Fruit());</span></span><br><span class="line">    Fruit fruit1 = flistTop.get(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//下界</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> Apple&gt; flistBottem = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    <span class="comment">//get Apple对象会报错</span></span><br><span class="line">    <span class="comment">//Apple apple = flistBottem.get(0);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）上界&lt;? extend Fruit&gt; ，表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。</p>
<p>下界&lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object 。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。</p>
<p>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。</p>
<h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p> 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          List list = new ArrayList();</span></span><br><span class="line"><span class="comment">          list.add("qqyumidi");</span></span><br><span class="line"><span class="comment">          list.add("corn");</span></span><br><span class="line"><span class="comment">          list.add(100);</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">  </span><br><span class="line">         List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">         list.add(<span class="string">"qqyumidi"</span>);</span><br><span class="line">         list.add(<span class="string">"corn"</span>);</span><br><span class="line">         <span class="comment">//list.add(100);   // 1  提示编译错误</span></span><br><span class="line">  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">             String name = list.get(i); <span class="comment">// 2</span></span><br><span class="line">             System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<String>，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 </String></p>
<h3 id="静态变量存在什么位置"><a href="#静态变量存在什么位置" class="headerlink" title="静态变量存在什么位置"></a>静态变量存在什么位置</h3><p>方法区</p>
<h3 id="解释类加载机制，双亲委派模型，好处是什么？"><a href="#解释类加载机制，双亲委派模型，好处是什么？" class="headerlink" title="解释类加载机制，双亲委派模型，好处是什么？"></a>解释类加载机制，双亲委派模型，好处是什么？</h3><p>某个特定的类加载器在接到加载类的请求时， 首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 </p>
<p> 使用双亲委派模型的好处在于使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。 </p>
<blockquote>
<p>双亲委派机制的意义主要是保护一些基本类不受影响。<br>比如常用的 String类， 其全限定名是 java.lang.String， 只是 java.lang 这个包下的类在使用的时候，可以不用 import 而直接使用。<br>像这种基本类 按照双亲委派机制 都应该从 rt.jar 里去获取，而不应该从自定义加载器里去获取某个开发人员自己写的 java.lang.String, 毕竟开发人员自己写的 java.lang.String 可能有很多 bug, 通过这种方式，无论如何大家使用的都是 rt.jar 里的 java.lang.String 类了。 </p>
</blockquote>
<h3 id="请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？"><a href="#请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？" class="headerlink" title="请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？"></a>请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？</h3><p>StringBuffer线程安全，StringBuilder线程不安全，</p>
<p>底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。</p>
<h3 id="请说明String是否能能继承？"><a href="#请说明String是否能能继承？" class="headerlink" title="请说明String是否能能继承？"></a>请说明String是否能能继承？</h3><p> 不能，char数组用final修饰的。 </p>
<h3 id="说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h3><p> “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 </p>
<h3 id="请说明重载和重写的区别，相同参数不同返回值能重载吗？"><a href="#请说明重载和重写的区别，相同参数不同返回值能重载吗？" class="headerlink" title="请说明重载和重写的区别，相同参数不同返回值能重载吗？"></a>请说明重载和重写的区别，相同参数不同返回值能重载吗？</h3><p><strong>重载(Overloading)</strong></p>
<p>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。</p>
<p>重载Overloading是一个类中多态性的一种表现。</p>
<p>（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。</p>
<p>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</p>
<p>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</p>
<p><strong>重写（Overriding）</strong></p>
<p>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。</p>
<p>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。</p>
<p>方法重写又称方法覆盖。</p>
<p>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。</p>
<p>如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</p>
<p>（3）子类函数的访问修饰权限不能少于父类的。</p>
<h3 id="请列举你所知道的Object类的方法并简要说明。"><a href="#请列举你所知道的Object类的方法并简要说明。" class="headerlink" title="请列举你所知道的Object类的方法并简要说明。"></a>请列举你所知道的Object类的方法并简要说明。</h3><p>Object()默认构造方法。</p>
<p>clone() 创建并返回此对象的一个副本。</p>
<p>equals(Object obj) 指示某个其他对象是否与此对象“相等”。</p>
<p>finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<p>getClass()返回一个对象的运行时类。</p>
<p>hashCode()返回该对象的哈希码值。 </p>
<p>notify()唤醒在此对象监视器上等待的单个线程。</p>
<p>notifyAll()唤醒在此对象监视器上等待的所有线程。</p>
<p>toString()返回该对象的字符串表示。</p>
<p>wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>
<p>wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</p>
<p>wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 </p>
<h3 id="类和对象的区别"><a href="#类和对象的区别" class="headerlink" title="类和对象的区别"></a>类和对象的区别</h3><p>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。</p>
<p>比如：“人”是一个类，而“教师”则是“人”的一个实例。</p>
<p>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。</p>
<h3 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h3><p>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<p>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p>
<h3 id="请讲讲Java有哪些特性，并举一个和多态有关的例子。"><a href="#请讲讲Java有哪些特性，并举一个和多态有关的例子。" class="headerlink" title="请讲讲Java有哪些特性，并举一个和多态有关的例子。"></a>请讲讲Java有哪些特性，并举一个和多态有关的例子。</h3><p> 封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） </p>
<h3 id="请你讲讲wait方法的底层原理"><a href="#请你讲讲wait方法的底层原理" class="headerlink" title="请你讲讲wait方法的底层原理"></a>请你讲讲wait方法的底层原理</h3><p>ObjectSynchronizer::wait方法通过object的对象中找到ObjectMonitor对象调用方法 void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)</p>
<p>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队列的末尾中然后在ObjectMonitor::exit释放锁，接着 thread_ParkEvent-&gt;park 也就是wait。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set三个接口存取元素时，各有什么特点？"></a>List、Map、Set三个接口存取元素时，各有什么特点？</h3><p> List以特定索引来存取元素，可以有重复元素。</p>
<p>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</p>
<p>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</p>
<p>Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 </p>
<h3 id="阐述ArrayList、Vector、LinkedList的存储性能和特性"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性</h3><p> ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以<strong>索引数据快而插入数据慢</strong>，Vector中的方法由于<strong>添加了synchronized修饰</strong>，因此Vector是线程安全的容器，但性能上较ArrayList差，<strong>因此已经是Java中的遗留容器</strong>。</p>
<p>LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 </p>
<h3 id="判断List、Set、Map是否继承自Collection接口？"><a href="#判断List、Set、Map是否继承自Collection接口？" class="headerlink" title="判断List、Set、Map是否继承自Collection接口？"></a>判断List、Set、Map是否继承自Collection接口？</h3><p> List、Set 是，Map 不是。</p>
<p>Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素</p>
<p>（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 </p>
<h3 id="你所知道的常用集合类以及主要方法？"><a href="#你所知道的常用集合类以及主要方法？" class="headerlink" title="你所知道的常用集合类以及主要方法？"></a>你所知道的常用集合类以及主要方法？</h3><p>最常用的集合类是List 和 Map。</p>
<p>List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。</p>
<p>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p>
<h3 id="说明Collection-和-Collections的区别"><a href="#说明Collection-和-Collections的区别" class="headerlink" title="说明Collection 和 Collections的区别"></a>说明Collection 和 Collections的区别</h3><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 </p>
<h3 id="说明ArrayList-Vector-LinkedList的存储性能和特性是什么？"><a href="#说明ArrayList-Vector-LinkedList的存储性能和特性是什么？" class="headerlink" title="说明ArrayList,Vector,LinkedList的存储性能和特性是什么？"></a>说明ArrayList,Vector,LinkedList的存储性能和特性是什么？</h3><p> ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 </p>
<h3 id="ArrayList和LinkedList的区别？-链表和数组的优缺点"><a href="#ArrayList和LinkedList的区别？-链表和数组的优缺点" class="headerlink" title="ArrayList和LinkedList的区别？(链表和数组的优缺点)"></a>ArrayList和LinkedList的区别？(链表和数组的优缺点)</h3><p> ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 </p>
<h3 id="说明HashMap和Hashtable的区别？"><a href="#说明HashMap和Hashtable的区别？" class="headerlink" title="说明HashMap和Hashtable的区别？"></a>说明HashMap和Hashtable的区别？</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。 </p>
<h3 id="请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？"><a href="#请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？" class="headerlink" title="请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？"></a>请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<h3 id="说说Iterator和ListIterator的区别？"><a href="#说说Iterator和ListIterator的区别？" class="headerlink" title="说说Iterator和ListIterator的区别？"></a>说说Iterator和ListIterator的区别？</h3><p>Iterator和ListIterator的区别是：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 </p>
<h3 id="请简单说明一下什么是迭代器？"><a href="#请简单说明一下什么是迭代器？" class="headerlink" title="请简单说明一下什么是迭代器？"></a>请简单说明一下什么是迭代器？</h3><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,<br>每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.<br>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.</p>
<p><img src="/2020/07/02/Interview(updating)/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9.png" alt="img"> </p>
<h3 id="解释为什么集合类没有实现Cloneable和Serializable接口？"><a href="#解释为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="解释为什么集合类没有实现Cloneable和Serializable接口？"></a>解释为什么集合类没有实现Cloneable和Serializable接口？</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。<br><strong>实现Serializable序列化的作用</strong>：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。 </p>
<h3 id="Java集合类框架的基本接口有哪些？"><a href="#Java集合类框架的基本接口有哪些？" class="headerlink" title="Java集合类框架的基本接口有哪些？"></a>Java集合类框架的基本接口有哪些？</h3><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。 </p>
<h3 id="ConcurrentHashMap的原理？"><a href="#ConcurrentHashMap的原理？" class="headerlink" title="ConcurrentHashMap的原理？"></a>ConcurrentHashMap的原理？</h3><p> ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。</p>
<p>HashEntry 用来封装映射表的键 / 值对；</p>
<p>Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。</p>
<p>一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型</span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型</span></span><br><span class="line">  </span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图： </p>
<p> 插入三个节点后桶的结构示意图： </p>
<p> <img src="/2020/07/02/Interview(updating)/308572_1537878284540_B6C31D01D41C9E1714958F9C56D01D8F.png" alt="img"> </p>
<p> 注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。 </p>
<p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。 </p>
<h3 id="解释一下TreeMap"><a href="#解释一下TreeMap" class="headerlink" title="解释一下TreeMap?"></a>解释一下TreeMap?</h3><p>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。<br>TreeMap的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 </p>
<h3 id="请说明ArrayList是否会越界？"><a href="#请说明ArrayList是否会越界？" class="headerlink" title="请说明ArrayList是否会越界？"></a>请说明ArrayList是否会越界？</h3><p>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。 </p>
<h3 id="说明concurrenthashmap有什么优势以及1-7和1-8区别？"><a href="#说明concurrenthashmap有什么优势以及1-7和1-8区别？" class="headerlink" title="说明concurrenthashmap有什么优势以及1.7和1.8区别？"></a>说明concurrenthashmap有什么优势以及1.7和1.8区别？</h3><p>Concurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</p>
<p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p>
<h3 id="TreeMap的底层实现？"><a href="#TreeMap的底层实现？" class="headerlink" title="TreeMap的底层实现？"></a>TreeMap的底层实现？</h3><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p>
<p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：</p>
<p>性质1：每个节点要么是红色，要么是黑色。</p>
<p>性质2：根节点永远是黑色的。</p>
<p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>
<p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>
<p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<h3 id="说明ConcurrentHashMap锁加在了哪些地方？"><a href="#说明ConcurrentHashMap锁加在了哪些地方？" class="headerlink" title="说明ConcurrentHashMap锁加在了哪些地方？"></a>说明ConcurrentHashMap锁加在了哪些地方？</h3><p>加在每个Segment 上面。</p>
<h3 id="解释HashMap的容量为什么是2的n次幂？"><a href="#解释HashMap的容量为什么是2的n次幂？" class="headerlink" title="解释HashMap的容量为什么是2的n次幂？"></a>解释HashMap的容量为什么是2的n次幂？</h3><p>负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。 </p>
<h3 id="请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"><a href="#请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？" class="headerlink" title="请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"></a>请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？</h3><p>ArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。</p>
<h3 id="如果hashMap的key是一个自定义的类，怎么办？"><a href="#如果hashMap的key是一个自定义的类，怎么办？" class="headerlink" title="如果hashMap的key是一个自定义的类，怎么办？"></a>如果hashMap的key是一个自定义的类，怎么办？</h3><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p>
<h3 id="解释一下hashMap具体如何实现的？"><a href="#解释一下hashMap具体如何实现的？" class="headerlink" title="解释一下hashMap具体如何实现的？"></a>解释一下hashMap具体如何实现的？</h3><p> Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。 </p>
<h2 id="THREAD"><a href="#THREAD" class="headerlink" title="THREAD"></a>THREAD</h2><h3 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h3><p>通过合理的时间调度，避开共享资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证一个客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。 </p>
<h3 id="简要说明一下线程的基本状态以及状态之间的关系？"><a href="#简要说明一下线程的基本状态以及状态之间的关系？" class="headerlink" title="简要说明一下线程的基本状态以及状态之间的关系？"></a>简要说明一下线程的基本状态以及状态之间的关系？</h3><p>其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。 </p>
<h3 id="解释一下什么是线程池（thread-pool）？"><a href="#解释一下什么是线程池（thread-pool）？" class="headerlink" title="解释一下什么是线程池（thread pool）？"></a>解释一下什么是线程池（thread pool）？</h3><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：<br>- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br>- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。<br>- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br>- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。<br>- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 </p>
<h3 id="举例说明同步和异步"><a href="#举例说明同步和异步" class="headerlink" title="举例说明同步和异步"></a>举例说明同步和异步</h3><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 </p>
<h3 id="介绍一下线程同步和线程调度的相关方法。"><a href="#介绍一下线程同步和线程调度的相关方法。" class="headerlink" title="介绍一下线程同步和线程调度的相关方法。"></a>介绍一下线程同步和线程调度的相关方法。</h3><p> - wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；<br>- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；<br>- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。 </p>
<h3 id="请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h3><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<h3 id="请简述一下线程的sleep-方法和yield-方法有什么区别？"><a href="#请简述一下线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="请简述一下线程的sleep()方法和yield()方法有什么区别？"></a>请简述一下线程的sleep()方法和yield()方法有什么区别？</h3><p>①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p>
<p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p>
<p>② 线程执行sleep()方法后转入阻塞（blocked）状态，</p>
<p>而执行yield()方法后转入就绪（ready）状态；</p>
<h3 id="Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用，请说明原因？"><a href="#Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用，请说明原因？" class="headerlink" title="Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用，请说明原因？"></a>Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用，请说明原因？</h3><p>有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法，</p>
<p>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。</p>
<p>调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 </p>
<h3 id="多线程和同步有几种实现方法-并且这些实现方法具体内容都是什么"><a href="#多线程和同步有几种实现方法-并且这些实现方法具体内容都是什么" class="headerlink" title="多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么?"></a>多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么?</h3><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<h3 id="说出你所知道的线程同步的方法"><a href="#说出你所知道的线程同步的方法" class="headerlink" title="说出你所知道的线程同步的方法"></a>说出你所知道的线程同步的方法</h3><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 </p>
<h3 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h3><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。</p>
<h3 id="请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"><a href="#请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。" class="headerlink" title="请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"></a>请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">ThreadTest1 tt=<span class="keyword">new</span> ThreadTest1();</span><br><span class="line">Inc inc=tt.<span class="keyword">new</span> Inc();</span><br><span class="line">Dec dec=tt.<span class="keyword">new</span> Dec();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(inc);</span><br><span class="line">t.start();</span><br><span class="line">t=<span class="keyword">new</span> Thread(dec);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">j++;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"-inc:"</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">j--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"-dec:"</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">inc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">dec();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"><a href="#说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？" class="headerlink" title="说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"></a>说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？</h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。<br>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 </p>
<h3 id="明一下sleep-和-wait-有什么区别？"><a href="#明一下sleep-和-wait-有什么区别？" class="headerlink" title="明一下sleep() 和 wait() 有什么区别？"></a>明一下sleep() 和 wait() 有什么区别？</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 </p>
<h3 id="请你说明一下在监视器-Monitor-内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？"><a href="#请你说明一下在监视器-Monitor-内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？" class="headerlink" title="请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？"></a>请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h3 id="分析一下同步方法和同步代码块的区别是什么？"><a href="#分析一下同步方法和同步代码块的区别是什么？" class="headerlink" title="分析一下同步方法和同步代码块的区别是什么？"></a>分析一下同步方法和同步代码块的区别是什么？</h3><p>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法。 </p>
<h3 id="请详细描述一下线程从创建到死亡的几种状态都有哪些？"><a href="#请详细描述一下线程从创建到死亡的几种状态都有哪些？" class="headerlink" title="请详细描述一下线程从创建到死亡的几种状态都有哪些？"></a>请详细描述一下线程从创建到死亡的几种状态都有哪些？</h3><ol>
<li>新建( new )：新创建了一个线程对象。</li>
<li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>
<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li>
<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br>   (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>   (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>   (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</li>
<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 </li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a  href="/2020/07/02/Interview(updating)/">Interview(updateing)</a></p>
        <p><span>文章作者:</span><a  href="/" title="访问 Kayleh 的个人博客">Kayleh</a></p>
        <p><span>发布时间:</span>2020年07月02日 - 20时45分</p>
        <p><span>最后更新:</span>2020年07月11日 - 12时46分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/07/02/Interview(updating)/" title="Interview(updateing)">http://dqlcr5.coding-pages.com/2020/07/02/Interview(updating)/</a>
            <span class="copy-path" data-clipboard-text="原文: http://dqlcr5.coding-pages.com/2020/07/02/Interview(updating)/　　作者: Kayleh" title=""></span>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a  href="/2020/07/02/Linux/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <!-- <strong class="article-nav-caption">&lt</strong> -->

      <div class="article-nav-title">
        
          Linux
        
      </div>
    </a>
  
  
    <a  href="/2020/06/28/C-prime-plus/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">C prime plus</div>
      <strong class="article-nav-caption">></strong>
      <!-- <strong class="article-nav-caption">&gt</strong> -->

    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Interview-updateing"><span class="toc-number">1.</span> <span class="toc-text">Interview(updateing)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#J2SE"><span class="toc-number">2.</span> <span class="toc-text">J2SE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-oriented"><span class="toc-number">2.1.</span> <span class="toc-text">Object-oriented</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于Synchronized和lock"><span class="toc-number">2.1.1.</span> <span class="toc-text">关于Synchronized和lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">2.1.2.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><span class="toc-number">2.1.3.</span> <span class="toc-text">请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#若对一个类不重写，它的equals-方法是如何比较的？"><span class="toc-number">2.1.4.</span> <span class="toc-text">若对一个类不重写，它的equals()方法是如何比较的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请解释hashCode-和equals-方法有什么联系？"><span class="toc-number">2.1.5.</span> <span class="toc-text">请解释hashCode()和equals()方法有什么联系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><span class="toc-number">2.1.6.</span> <span class="toc-text">什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><span class="toc-number">2.1.7.</span> <span class="toc-text">请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query接口的list方法和iterate方法有什么区别？"><span class="toc-number">2.1.8.</span> <span class="toc-text">Query接口的list方法和iterate方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的”六原则一法则”。"><span class="toc-number">2.1.9.</span> <span class="toc-text">面向对象的”六原则一法则”。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何通过反射获取和设置对象私有字段的值？"><span class="toc-number">2.1.10.</span> <span class="toc-text">如何通过反射获取和设置对象私有字段的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="toc-number">2.1.11.</span> <span class="toc-text">请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？"><span class="toc-number">2.1.12.</span> <span class="toc-text">两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，该说法是否正确，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"><span class="toc-number">2.1.13.</span> <span class="toc-text">请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><span class="toc-number">2.1.14.</span> <span class="toc-text">请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明Java的接口和C-的虚类的相同和不同处"><span class="toc-number">2.1.15.</span> <span class="toc-text">请说明Java的接口和C++的虚类的相同和不同处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><span class="toc-number">2.1.16.</span> <span class="toc-text">当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你说说Static-Nested-Class-和-Inner-Class的不同"><span class="toc-number">2.1.17.</span> <span class="toc-text">请你说说Static Nested Class 和 Inner Class的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你讲讲abstract-class和interface有什么区别"><span class="toc-number">2.1.18.</span> <span class="toc-text">请你讲讲abstract class和interface有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型"><span class="toc-number">2.1.19.</span> <span class="toc-text">请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明一下final-finally-finalize的区别。"><span class="toc-number">2.1.20.</span> <span class="toc-text">请说明一下final, finally, finalize的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的特征有哪些方面"><span class="toc-number">2.1.21.</span> <span class="toc-text">面向对象的特征有哪些方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明Comparable和Comparator接口的作用以及它们的区别。"><span class="toc-number">2.1.22.</span> <span class="toc-text">请说明Comparable和Comparator接口的作用以及它们的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口和抽象类的区别是什么？"><span class="toc-number">2.1.23.</span> <span class="toc-text">接口和抽象类的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明Java是否支持多继承？"><span class="toc-number">2.1.24.</span> <span class="toc-text">请说明Java是否支持多继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何通过反射创建对象？"><span class="toc-number">2.1.25.</span> <span class="toc-text">如何通过反射创建对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是否可以在static环境中访问非static变量？"><span class="toc-number">2.1.26.</span> <span class="toc-text">是否可以在static环境中访问非static变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-和super-泛型限定符"><span class="toc-number">2.1.27.</span> <span class="toc-text">extends 和super 泛型限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是泛型？"><span class="toc-number">2.1.28.</span> <span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量存在什么位置"><span class="toc-number">2.1.29.</span> <span class="toc-text">静态变量存在什么位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释类加载机制，双亲委派模型，好处是什么？"><span class="toc-number">2.1.30.</span> <span class="toc-text">解释类加载机制，双亲委派模型，好处是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？"><span class="toc-number">2.1.31.</span> <span class="toc-text">请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明String是否能能继承？"><span class="toc-number">2.1.32.</span> <span class="toc-text">请说明String是否能能继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><span class="toc-number">2.1.33.</span> <span class="toc-text">说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明重载和重写的区别，相同参数不同返回值能重载吗？"><span class="toc-number">2.1.34.</span> <span class="toc-text">请说明重载和重写的区别，相同参数不同返回值能重载吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请列举你所知道的Object类的方法并简要说明。"><span class="toc-number">2.1.35.</span> <span class="toc-text">请列举你所知道的Object类的方法并简要说明。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象的区别"><span class="toc-number">2.1.36.</span> <span class="toc-text">类和对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String为什么不可变？"><span class="toc-number">2.1.37.</span> <span class="toc-text">String为什么不可变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请讲讲Java有哪些特性，并举一个和多态有关的例子。"><span class="toc-number">2.1.38.</span> <span class="toc-text">请讲讲Java有哪些特性，并举一个和多态有关的例子。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你讲讲wait方法的底层原理"><span class="toc-number">2.1.39.</span> <span class="toc-text">请你讲讲wait方法的底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">2.2.</span> <span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List、Map、Set三个接口存取元素时，各有什么特点？"><span class="toc-number">2.2.1.</span> <span class="toc-text">List、Map、Set三个接口存取元素时，各有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阐述ArrayList、Vector、LinkedList的存储性能和特性"><span class="toc-number">2.2.2.</span> <span class="toc-text">阐述ArrayList、Vector、LinkedList的存储性能和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断List、Set、Map是否继承自Collection接口？"><span class="toc-number">2.2.3.</span> <span class="toc-text">判断List、Set、Map是否继承自Collection接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你所知道的常用集合类以及主要方法？"><span class="toc-number">2.2.4.</span> <span class="toc-text">你所知道的常用集合类以及主要方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明Collection-和-Collections的区别"><span class="toc-number">2.2.5.</span> <span class="toc-text">说明Collection 和 Collections的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明ArrayList-Vector-LinkedList的存储性能和特性是什么？"><span class="toc-number">2.2.6.</span> <span class="toc-text">说明ArrayList,Vector,LinkedList的存储性能和特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList和LinkedList的区别？-链表和数组的优缺点"><span class="toc-number">2.2.7.</span> <span class="toc-text">ArrayList和LinkedList的区别？(链表和数组的优缺点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明HashMap和Hashtable的区别？"><span class="toc-number">2.2.8.</span> <span class="toc-text">说明HashMap和Hashtable的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？"><span class="toc-number">2.2.9.</span> <span class="toc-text">请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说说Iterator和ListIterator的区别？"><span class="toc-number">2.2.10.</span> <span class="toc-text">说说Iterator和ListIterator的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请简单说明一下什么是迭代器？"><span class="toc-number">2.2.11.</span> <span class="toc-text">请简单说明一下什么是迭代器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释为什么集合类没有实现Cloneable和Serializable接口？"><span class="toc-number">2.2.12.</span> <span class="toc-text">解释为什么集合类没有实现Cloneable和Serializable接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java集合类框架的基本接口有哪些？"><span class="toc-number">2.2.13.</span> <span class="toc-text">Java集合类框架的基本接口有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap的原理？"><span class="toc-number">2.2.14.</span> <span class="toc-text">ConcurrentHashMap的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释一下TreeMap"><span class="toc-number">2.2.15.</span> <span class="toc-text">解释一下TreeMap?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请说明ArrayList是否会越界？"><span class="toc-number">2.2.16.</span> <span class="toc-text">请说明ArrayList是否会越界？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明concurrenthashmap有什么优势以及1-7和1-8区别？"><span class="toc-number">2.2.17.</span> <span class="toc-text">说明concurrenthashmap有什么优势以及1.7和1.8区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap的底层实现？"><span class="toc-number">2.2.18.</span> <span class="toc-text">TreeMap的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明ConcurrentHashMap锁加在了哪些地方？"><span class="toc-number">2.2.19.</span> <span class="toc-text">说明ConcurrentHashMap锁加在了哪些地方？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释HashMap的容量为什么是2的n次幂？"><span class="toc-number">2.2.20.</span> <span class="toc-text">解释HashMap的容量为什么是2的n次幂？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"><span class="toc-number">2.2.21.</span> <span class="toc-text">请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果hashMap的key是一个自定义的类，怎么办？"><span class="toc-number">2.2.22.</span> <span class="toc-text">如果hashMap的key是一个自定义的类，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释一下hashMap具体如何实现的？"><span class="toc-number">2.2.23.</span> <span class="toc-text">解释一下hashMap具体如何实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#THREAD"><span class="toc-number">2.3.</span> <span class="toc-text">THREAD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保证线程安全？"><span class="toc-number">2.3.1.</span> <span class="toc-text">如何保证线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简要说明一下线程的基本状态以及状态之间的关系？"><span class="toc-number">2.3.2.</span> <span class="toc-text">简要说明一下线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释一下什么是线程池（thread-pool）？"><span class="toc-number">2.3.3.</span> <span class="toc-text">解释一下什么是线程池（thread pool）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举例说明同步和异步"><span class="toc-number">2.3.4.</span> <span class="toc-text">举例说明同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍一下线程同步和线程调度的相关方法。"><span class="toc-number">2.3.5.</span> <span class="toc-text">介绍一下线程同步和线程调度的相关方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><span class="toc-number">2.3.6.</span> <span class="toc-text">请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请简述一下线程的sleep-方法和yield-方法有什么区别？"><span class="toc-number">2.3.7.</span> <span class="toc-text">请简述一下线程的sleep()方法和yield()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用，请说明原因？"><span class="toc-number">2.3.8.</span> <span class="toc-text">Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用，请说明原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程和同步有几种实现方法-并且这些实现方法具体内容都是什么"><span class="toc-number">2.3.9.</span> <span class="toc-text">多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说出你所知道的线程同步的方法"><span class="toc-number">2.3.10.</span> <span class="toc-text">说出你所知道的线程同步的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动一个线程是用run-还是start"><span class="toc-number">2.3.11.</span> <span class="toc-text">启动一个线程是用run()还是start()?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"><span class="toc-number">2.3.12.</span> <span class="toc-text">请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"><span class="toc-number">2.3.13.</span> <span class="toc-text">说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#明一下sleep-和-wait-有什么区别？"><span class="toc-number">2.3.14.</span> <span class="toc-text">明一下sleep() 和 wait() 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请你说明一下在监视器-Monitor-内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？"><span class="toc-number">2.3.15.</span> <span class="toc-text">请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析一下同步方法和同步代码块的区别是什么？"><span class="toc-number">2.3.16.</span> <span class="toc-text">分析一下同步方法和同步代码块的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请详细描述一下线程从创建到死亡的几种状态都有哪些？"><span class="toc-number">2.3.17.</span> <span class="toc-text">请详细描述一下线程从创建到死亡的几种状态都有哪些？</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <section id="comments">
<link rel="stylesheet" href="/css/gitment.min.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'Interview(updateing)', // 可选。默认为 location.href
  owner: 'Kayleh',
  repo: 'Kayleh.github.io',
  oauth: {
    client_id: '18b262108cfc988352c9',
    client_secret: 'd205b1ca0ce30fec1eec1100a1101fffcc55aadc',
  },
})
gitment.render('comments')
</script>

</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2020/07/02/Linux/" title="上一篇: Linux">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2020/06/28/C-prime-plus/" title="下一篇: C prime plus">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/09/MYSQL/">MYSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/Linux/">Linux</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/Interview(updating)/">Interview(updateing)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/C-prime-plus/">C prime plus</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/27/Redis/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/19/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/">编码算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">哈希算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">插值查找算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">二分查找算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">线性查找算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">模板方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">访问者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">状态模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">备忘录模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">中介者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">迭代器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">解释器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">命令模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/%E7%AE%80%E5%8E%86/">RESUME</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">享元模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">外观模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">装饰器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">组合模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">桥接模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE/">HTTP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/08/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/08/%E5%8E%9F%E5%9E%8B/">原型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/08/%E7%94%9F%E6%88%90%E5%99%A8/">生成器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">工厂设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/">合成复用原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/">迪米特法则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/">开闭原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/04/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/">里氏替换原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/">依赖倒转原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/">接口隔离原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/">单一职责原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/31/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/">XSS跨站脚本攻击</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/30/SQL%E6%B3%A8%E5%85%A5%E5%BC%8F%E6%94%BB%E5%87%BB/">SQL注入式攻击</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/%E7%BB%B4%E6%8A%A42/">维护2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/20/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/">二叉排序树</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/18/%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/17/7%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">7种排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/14/%E9%98%9F%E5%88%97/">队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/13/Inversion-of-Control%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/">Inversion of Control控制反转</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/%E9%93%BE%E8%A1%A8/">链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/11/%E6%A0%88Stack/">栈Stack</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/SparseArray%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/">SparseArray稀疏数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/%E7%BB%B4%E6%8A%A41/">维护1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/Java-memory-model%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java memory model内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81/">面向对象的特征</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/26/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/">动态数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">斐波那契数列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/Spring%E3%80%81SpringMVC%E3%80%81Mybatis%E6%95%B4%E5%90%88/">Spring、SpringMVC、Mybatis整合</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/%E5%9B%9E%E6%96%87%E6%95%B0/">回文数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/%E3%80%90SpringMVC%E3%80%91-@ModelAttribute/">【SpringMVC】-@ModelAttribute</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/Spring%E6%9E%B6%E6%9E%84/">Spring架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/">并发:原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/unix/">unix的常用指令</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/Rest%E6%9E%B6%E6%9E%84/Rest%E6%9E%B6%E6%9E%84/">Rest架构风格</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/SpringMVC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">SpringMVC环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/HelloWord/hello-world/">Hello World</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 Kayleh
            </div>
            <div class="footer-right">
                <!-- <a href="http://hexo.io/" target="_blank">
                    Hexo &nbsp;&nbsp;
                </a>
                <a href="https://github.com/maochunguang" target="_blank">
                    Blog
                </a>  -->
                by Kayleh @2020
            </div>
        </div>

        

        <div class="visit">
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                你是第
                <span id="site-visit">
                    <!-- 访问数 -->
                    <span id="busuanzi_value_site_uv">

                    </span>
                </span>
                访问该站的人哦~
            </span>
            
            
            <!-- <span>, </span> -->
            
            

            <span class="post-meta-divider">|</span>

            <span id="busuanzi_container_page_pv" style='display:none'>
                <span id="page-visit">
                    本页阅读量:
                    <span id="busuanzi_value_page_pv">
                        <!--本页阅读量-->
                    </span>
                </span>
            </span>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

            <span class="post-meta-divider">|</span>

            <span id="busuanzi_container_site_pv">
                本站总访问量
                <span id="busuanzi_value_site_pv">
                </span>次
            </span>

            <!-- <span class="post-meta-divider">|</span> -->
            <!-- <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv" </span>人</span> -->

            
        </div>
        
    </div>
</footer>
    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = ;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?05JpXkxLDz";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>

<script type="text/javascript" src="/js/clicklove.js"></script>

  </div>
</body>
</html>