<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AIO blocking model | Kayleh</title><meta name="description" content="AIO模型1. 在系统层面分析IO模型当我们从网络中或者其他进程中接收到数据时，这个数据会先被拷贝到系统内核的缓冲区，然后从内核的缓冲区中再复制到我们应用程序对应的缓冲区中，这样我们才能实现从应用程序中取得这个数据。 1.1 BIO模型  我们的应用程序会首先调用特定的函数，这样才能去访问我们的操作系统。拿我们的BIO聊天室来说，我们在服务器上，想看一下客户端从网络上传递过来的数据有没有准备好，那"><meta name="keywords" content="network"><meta name="author" content="Kayleh"><meta name="copyright" content="Kayleh"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/favicon.png"><link rel="canonical" href="https://kayleh.top/AIO%E6%A8%A1%E5%9E%8B/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="preconnect" href="//zz.bdstatic.com"><meta name="google-site-verification" content="LQn0xwjfEU_V6CXCA0qAdwM4qRXtblIbfy5KuzEKaRg"><meta property="og:type" content="article"><meta property="og:title" content="AIO blocking model"><meta property="og:url" content="https://kayleh.top/AIO%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="Kayleh"><meta property="og:description" content="AIO模型1. 在系统层面分析IO模型当我们从网络中或者其他进程中接收到数据时，这个数据会先被拷贝到系统内核的缓冲区，然后从内核的缓冲区中再复制到我们应用程序对应的缓冲区中，这样我们才能实现从应用程序中取得这个数据。 1.1 BIO模型  我们的应用程序会首先调用特定的函数，这样才能去访问我们的操作系统。拿我们的BIO聊天室来说，我们在服务器上，想看一下客户端从网络上传递过来的数据有没有准备好，那"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/kayleh/cdn2/index10.jpg"><meta property="article:published_time" content="2020-12-04T19:57:07.000Z"><meta property="article:modified_time" content="2021-04-11T17:11:28.086Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '1'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-7457165067653912",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?24f5d46da7ff42ae73ccea4ea7114e1b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG={root:"/",hexoversion:"4.2.0",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:{limitDay:10,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},bookmark:{message_prev:"按",message_next:"键将本页加入书签"},runtime_unit:"天",runtime:!1,copyright:void 0,ClickShowText:void 0,medium_zoom:!0,fancybox:!1,Snackbar:void 0,justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},baiduPush:!0,highlightCopy:!0,highlightLang:!0,isPhotoFigcaption:!1,islazyload:!0,isanchor:!0}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isSidebar:!0,postUpdate:"2021-04-12 01:11:28"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><meta http-equiv="Content-Type" content="text/html;charset=gb2312"><meta name="sogou_site_verification" content="7uatD8cGg5"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Kayleh" type="application/atom+xml"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/2.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">190</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://home.kayleh.top/" target="_blank" rel="noopener"><i class="fa-fw fa fa-reply"></i><span> return</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="https://shell.kayleh.top/" target="_blank" rel="noopener"><i class="fa-fw fa fa-bolt"></i><span> shell</span></a></div><div class="menus_item"><a class="site-page" href="/en"><i class="fa-fw fa fa-info-circle"></i><span> English</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-id-card"></i><span> 我?</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="mailto:kaylehisdied@gmail.com"><i class="fa-fw fa fa-envelope"></i><span> mail</span></a></li><li><a class="site-page" href="/2020/06/11/RESUME/"><i class="fa-fw fa fa-envelope-open"></i><span> resume</span></a></li></ul></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AIO模型"><span class="toc-text">AIO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-在系统层面分析IO模型"><span class="toc-text">1. 在系统层面分析IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-BIO模型"><span class="toc-text">1.1 BIO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-NIO模型"><span class="toc-text">1.2 NIO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-IO多路复用"><span class="toc-text">1.2.1 IO多路复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-AIO模型（异步IO）"><span class="toc-text">1.3 AIO模型（异步IO）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-异步调用机制"><span class="toc-text">2. 异步调用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-AIO中的异步操作"><span class="toc-text">2.1 AIO中的异步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-通过Future进行异步调用"><span class="toc-text">2.2 通过Future进行异步调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-通过CompletionHandler（多用）"><span class="toc-text">2.3 通过CompletionHandler（多用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-实战（回音服务器）"><span class="toc-text">3. 实战（回音服务器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-服务器端"><span class="toc-text">3.1 服务器端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-字段"><span class="toc-text">3.1.1 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-主方法"><span class="toc-text">3.1.2 主方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-AcceptHandler的实现"><span class="toc-text">3.1.3 AcceptHandler的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-ClientHandler的实现"><span class="toc-text">3.1.4 ClientHandler的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-客户端"><span class="toc-text">3.2 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-字段"><span class="toc-text">3.2.1 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-主方法"><span class="toc-text">3.2.2 主方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-代码"><span class="toc-text">4. 代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-服务器端"><span class="toc-text">4.1 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-客户端"><span class="toc-text">4.2 客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-测试结果"><span class="toc-text">5. 测试结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实战"><span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-AIO模型分析"><span class="toc-text">1. AIO模型分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-聊天室分析"><span class="toc-text">2. 聊天室分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-服务器端"><span class="toc-text">2.1 服务器端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-字段"><span class="toc-text">2.1.1 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-主方法"><span class="toc-text">2.1.2 主方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-AcceptHandler"><span class="toc-text">2.1.3 AcceptHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-ClientHandler（处理读写请求）"><span class="toc-text">2.1.4 ClientHandler（处理读写请求）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-添加和删除用户"><span class="toc-text">2.1.5 添加和删除用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-接收和转发方法"><span class="toc-text">2.1.6 接收和转发方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-客户端"><span class="toc-text">2.2 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-主方法"><span class="toc-text">2.2.1 主方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-发送消息"><span class="toc-text">2.2.2 发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-用户的输入线程"><span class="toc-text">2.2.3 用户的输入线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-测试结果"><span class="toc-text">3. 测试结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-完整代码"><span class="toc-text">4. 完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-服务器端-1"><span class="toc-text">4.1 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-客户端-1"><span class="toc-text">4.2 客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-三种模型的适用场景"><span class="toc-text">1. 三种模型的适用场景</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/kayleh/cdn2/index10.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Kayleh</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://home.kayleh.top/" target="_blank" rel="noopener"><i class="fa-fw fa fa-reply"></i><span> return</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="https://shell.kayleh.top/" target="_blank" rel="noopener"><i class="fa-fw fa fa-bolt"></i><span> shell</span></a></div><div class="menus_item"><a class="site-page" href="/en"><i class="fa-fw fa fa-info-circle"></i><span> English</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-id-card"></i><span> 我?</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="mailto:kaylehisdied@gmail.com"><i class="fa-fw fa fa-envelope"></i><span> mail</span></a></li><li><a class="site-page" href="/2020/06/11/RESUME/"><i class="fa-fw fa fa-envelope-open"></i><span> resume</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">AIO blocking model</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-04T19:57:07.000Z" title="发表于 2020-12-05 03:57:07">2020-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-11T17:11:28.086Z" title="更新于 2021-04-12 01:11:28">2021-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h1><h2 id="1-在系统层面分析IO模型"><a href="#1-在系统层面分析IO模型" class="headerlink" title="1. 在系统层面分析IO模型"></a>1. 在系统层面分析IO模型</h2><p>当我们从网络中或者其他进程中接收到数据时，这个数据会<code>先</code>被拷贝到<code>系统内核的缓冲区</code>，然后从内核的缓冲区中再复制到我们<code>应用程序对应的缓冲区</code>中，这样我们才能实现从应用程序中取得这个数据。</p><h3 id="1-1-BIO模型"><a href="#1-1-BIO模型" class="headerlink" title="1.1 BIO模型"></a>1.1 BIO模型</h3><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723190512937.png" alt="在这里插入图片描述"></p><ul><li>我们的应用程序会首先<code>调用特定的函数</code>，这样才能去访问我们的操作系统。拿我们的BIO聊天室来说，我们在服务器上，想看一下客户端从网络上传递过来的数据有没有准备好，那么它会去询问操作系统有没有收到新的数据，如果没有收到，它会<code>一直阻塞</code>在这里，直到收到消息，并且已经<code>从系统内核缓冲区中拷贝到应用程序的缓冲区</code>中，这样这个调用才能够成功返回。这就是阻塞式IO，我们在等待的过程中，什么都做不了。</li></ul><h3 id="1-2-NIO模型"><a href="#1-2-NIO模型" class="headerlink" title="1.2 NIO模型"></a>1.2 NIO模型</h3><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723191219755.png" alt="在这里插入图片描述"></p><ul><li>当我们的应用程序进行系统调用，询问数据有没有准备好，没有准备好的话，因为它是<code>非阻塞的</code>，所以<code>直接返回</code>；直到系统已经将内核缓冲区中的数据复制到应用程序的缓冲区中，这时我们再去询问数据有没有准备好的话，就能够获取到我们想要的数据了。但是它并不包括Selector监听模式，仅仅是NIO中的非阻塞式模型。</li></ul><h4 id="1-2-1-IO多路复用"><a href="#1-2-1-IO多路复用" class="headerlink" title="1.2.1 IO多路复用"></a>1.2.1 IO多路复用</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/202007231924362.png" alt="在这里插入图片描述"></p><ul><li>这个模式对应的就是我们NIO聊天室中采用的模式，使用了Selector监听</li><li>首先我们的应用程序发起新的询问，是不是有可用的数据进行操作了，如果数据这时没有准备好，<code>并不会如上NIO直接返回</code>，而是说，我们要求内核<code>监听</code>我们这个IO通道，直到它有了数据可以供我们的程序进行操作了，再来通知我们，这个监听的过程，就像我们聊天室中的<code>select()方法</code>，它是<code>阻塞</code>的。直到数据已经在系统内核缓存区中准备好了，它会通知你一下，告诉你可以执行系统调用，将缓存区中的数据复制到应用程序缓存区中，这时我们才真正获取到了我们想要的数据</li><li>在这个时候，系统内核能够监听多个IO通道，跟我们的聊天室一样，它也监听了多个通道，只要其中任何一个IO通道有了新的状态更新，那么这个监听都会返回给我们应用程序说，其中的IO通道有一个或者多个出现了状态的变化，你要不要对其进行处理一下，我们便可以根据它返回的条件，进行特定的处理。（Selector可以翻译成为IO多路复用器）</li></ul><h3 id="1-3-AIO模型（异步IO）"><a href="#1-3-AIO模型（异步IO）" class="headerlink" title="1.3 AIO模型（异步IO）"></a>1.3 AIO模型（异步IO）</h3><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723194710403.png" alt="在这里插入图片描述"></p><ul><li>BIO和NIO都是同步IO模型，这里我们说说AIO（异步）模型</li><li>同步IO模型是当我们访问的这个数据无论有没有准备好，都会返回给你结果；当数据没有准备好的时候，我们没有能够获取数据，<code>如果我们再也不发起获取数据的请求，那么我们永远都不会再获取到这个数据</code>。异步IO就不同了，当你请求这个数据没有请求到，而<code>之后这个数据准备好了，它就会回去通知你</code>，可以来取这个数据了</li><li>我们来看一下这个流程：我们去请求数据，数据没有准备好，我们没有被阻塞，而是<code>直接返回</code>了。在应用程序层面，虽然我们没有再发起新的请求，但是在系统后台，会监听这个我们请求数据的状态，当我们需要的数据已经准备好了，并且已经存在于系统内核缓存区中了，系统后台还会将这个数据拷贝到我们的应用程序缓存区中，到这里，系统内核会<code>递交给我们一个信号</code>，告诉你，你之前想要的这个数据，已经准备好给你了，你可以进行使用了。</li><li>它的<code>异步</code>体现在：我们程序只对数据发起了一次请求，没有请求到，就直接返回了，而之后，当这个数据已经准备好的时候，系统回来通知我们，而不需要我们再次发起请求，就能获取到这个数据，这就体现了异步的特点。A就是asynchronous，也就是异步的意思</li></ul><hr><h2 id="2-异步调用机制"><a href="#2-异步调用机制" class="headerlink" title="2. 异步调用机制"></a>2. 异步调用机制</h2><h3 id="2-1-AIO中的异步操作"><a href="#2-1-AIO中的异步操作" class="headerlink" title="2.1 AIO中的异步操作"></a>2.1 AIO中的异步操作</h3><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723205527982.png" alt="在这里插入图片描述"></p><ul><li>客户端对应AsynchronousSocketChannel</li><li>服务端对应AsynchronousServerSocketChannel</li><li>建立连接为connect/accept</li><li>读操作为read</li><li>写操作为write</li></ul><h3 id="2-2-通过Future进行异步调用"><a href="#2-2-通过Future进行异步调用" class="headerlink" title="2.2 通过Future进行异步调用"></a>2.2 通过Future进行异步调用</h3><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723210814302.png" alt="在这里插入图片描述"></p><ul><li>注意其中Future的get()方法是阻塞式的</li></ul><h3 id="2-3-通过CompletionHandler（多用）"><a href="#2-3-通过CompletionHandler（多用）" class="headerlink" title="2.3 通过CompletionHandler（多用）"></a>2.3 通过CompletionHandler（多用）</h3><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723210919682.png" alt="在这里插入图片描述"></p><ul><li>在执行操作的时候，传入CompletionHandler参数</li></ul><hr><h2 id="3-实战（回音服务器）"><a href="#3-实战（回音服务器）" class="headerlink" title="3. 实战（回音服务器）"></a>3. 实战（回音服务器）</h2><h3 id="3-1-服务器端"><a href="#3-1-服务器端" class="headerlink" title="3.1 服务器端"></a>3.1 服务器端</h3><h4 id="3-1-1-字段"><a href="#3-1-1-字段" class="headerlink" title="3.1.1 字段"></a>3.1.1 字段</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723211230958.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-主方法"><a href="#3-1-2-主方法" class="headerlink" title="3.1.2 主方法"></a>3.1.2 主方法</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723211619641.png" alt="在这里插入图片描述"></p><h4 id="3-1-3-AcceptHandler的实现"><a href="#3-1-3-AcceptHandler的实现" class="headerlink" title="3.1.3 AcceptHandler的实现"></a>3.1.3 AcceptHandler的实现</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723211813626.png" alt="在这里插入图片描述"></p><h4 id="3-1-4-ClientHandler的实现"><a href="#3-1-4-ClientHandler的实现" class="headerlink" title="3.1.4 ClientHandler的实现"></a>3.1.4 ClientHandler的实现</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723213343220.png" alt="在这里插入图片描述"></p><h3 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h3><h4 id="3-2-1-字段"><a href="#3-2-1-字段" class="headerlink" title="3.2.1 字段"></a>3.2.1 字段</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/2020072321343625.png" alt="在这里插入图片描述"></p><h4 id="3-2-2-主方法"><a href="#3-2-2-主方法" class="headerlink" title="3.2.2 主方法"></a>3.2.2 主方法</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723213746283.png" alt="在这里插入图片描述"></p><hr><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><h3 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.io.Closeable;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.HashMap;
import java.util.Map;

public class Server {
    private static final String LOCALHOST = "localhost";
    private static final int DEFAULT_PORT = 8888;

    private AsynchronousServerSocketChannel serverChannel;

    private void close(Closeable closeable){
        try {
            closeable.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void start(){
        try {
            //绑定端口号,调用的open方法（无参），这个参数类型为AsynchronousChannelGroup，其中包含共享的系统资源，如线程池，
            //因为我们没有传入参数，会从默认的ProviderHolder中，提供一个我们需要的AsynchronousServerSocketChannel对象
            //Handler会在不同的线程中进行处理，如我们的AcceptHandler和ClientHandler，它就是动用的共享资源：线程，来执行
            serverChannel = AsynchronousServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(LOCALHOST,DEFAULT_PORT));
            System.out.println("服务器启动成功，监听端口号：" + DEFAULT_PORT);

            while (true){
                //该accept方法为异步调用，没有需要返回的结果也会返回，即没有收到客户连接的请求时
                //就会返回结果了；但是我们要保证在有客户连接的时候，主线程还在运行，否则主线程返回
                //服务器就直接宕机了，我们采用下面的小技巧来避免这种情况

                //accept在系统层面完成的时候（系统帮助我们完成了这个IO处理），返回的结果会被AcceptHandler来处理，
                //成功时执行的completed方法，失败执行的是failed方法
                //附带对象无；AcceptHandler为实现接口CompletionHandler的类，处理accept请求
                serverChannel.accept(null,new AcceptHandler());

                //用这个来避免while过于频繁，相当于将主线程阻塞，以保证建立连接时与客户端的响应
                System.in.read();
            }


        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            close(serverChannel);
        }
    }

    /**
     * 程序处理accept请求的时候，并不是在主线程中执行的，
     * 而是从AsynchronousChannelGroup中取出另一个线程来执行
     * CompletionHandler泛型为，第一个为返回的结果类型；第二个为附带的对象类型
      */
    private class AcceptHandler implements CompletionHandler<asynchronoussocketchannel ,object> {
        /**
         * completed 该方法对应的是，我们之前上方调用accept方法，正常返回了，那么会执行该方法
         * @param result 方法执行成功的返回值
         * @param attachment 附带信息
         */
        @Override
        public void completed(AsynchronousSocketChannel result, Object attachment) {
            if(serverChannel.isOpen()){
                //确保服务器还在运行
                //服务器继续等待下一个客户端来请求，但是这里并不是产生过多的accept方法压栈
                //而造成的栈溢出问题，这在底层已经进行保护了
                serverChannel.accept(null,this);
            }

            //处理已连接客户端的读写操作
            AsynchronousSocketChannel clientChannel = result;
            if(clientChannel != null && clientChannel.isOpen()){
                ClientHandler handler = new ClientHandler(clientChannel);
                ByteBuffer buffer = ByteBuffer.allocate(1024);

                Map<string ,object> attachmentInfo = new HashMap<>();
                attachmentInfo.put("type","read");
                attachmentInfo.put("buffer",buffer);

                //依靠ClientHandler异步处理，读写操作，将其回传给客户端
                clientChannel.read(buffer,attachmentInfo,handler);
            }

        }

        @Override
        public void failed(Throwable exc, Object attachment) {
            //失败时的调用
        }
    }

    private class ClientHandler implements CompletionHandler<Integer,Map<string ,object>> {
        private AsynchronousSocketChannel clientChannel;

        public ClientHandler(AsynchronousSocketChannel clientChannel) {
            this.clientChannel = clientChannel;
        }

        @Override
        public void completed(Integer result, Map<string , object> attachment) {
            String type = (String) attachment.get("type");
            ByteBuffer buffer = (ByteBuffer) attachment.get("buffer");
            if("read".equals(type)){
                //已经读取到了客户端传过来的消息，将其回音给客户端
                buffer.flip();//回音要读缓冲区
                attachment.put("type","write");
                clientChannel.write(buffer,attachment,this);
            }else if ("write".equals(type)){
                //将其回传给客户端后，等待客户端的新的信息
                //将这里将再次进行异步调用，读取客户端发来的信息存储在缓冲区中
                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                attachment.put("type","read");
                attachment.put("buffer",byteBuffer);
                clientChannel.read(byteBuffer,attachment,this);
            }
        }

        @Override
        public void failed(Throwable exc, Map<string , object> attachment) {

        }
    }

    public static void main(String[] args) {
        Server server = new Server();
        server.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></string></string></string></string></asynchronoussocketchannel></code></pre><h3 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.io.*;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

public class Client {

    private final String LOCALHOST = "localhost";
    private final int DEFAULT_PORT = 8888;

    AsynchronousSocketChannel clientChannel;

    private void close(Closeable closeable){
        try {
            closeable.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void start(){
        try {
            clientChannel = AsynchronousSocketChannel.open();

            Future<void> connect = clientChannel.connect(new InetSocketAddress(LOCALHOST, DEFAULT_PORT));
            connect.get();//阻塞式调用，直到有结果才返回

            //读取用户的输入
            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

            while (true){
                String input = in.readLine();
                byte[] inputBytes = input.getBytes();
                ByteBuffer buffer = ByteBuffer.wrap(inputBytes);

                //向服务器发送消息
                Future<integer> write = clientChannel.write(buffer);
                write.get();

                //接收服务器传来的消息
                buffer.flip();
                Future<integer> read = clientChannel.read(buffer);
                read.get();

                String s = new String(buffer.array());
                System.out.println(s);

                buffer.clear();
            }


        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }finally {
            close(clientChannel);
        }
    }

    public static void main(String[] args) {
        Client client = new Client();
        client.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></integer></integer></void></code></pre><h2 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h2><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723214442368.png" alt="在这里插入图片描述"></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="1-AIO模型分析"><a href="#1-AIO模型分析" class="headerlink" title="1. AIO模型分析"></a>1. AIO模型分析</h2><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724200020715.png" alt="在这里插入图片描述"></p><ul><li>AsynchronousServerSocket：它属于一个<code>AsynchronousChannelGroup</code>，这个通道组，其实是被多个异步通道共享的资源群组，这里边我们之前提到过，有一个非常重要的资源：<code>线程池</code>，系统会利用线程池中的线程，来处理一些handler请求。系统利用这个资源组还为我们做了很多的事情，包括它能在数据准备好的时候通知我们和利用handler做一些异步的操作。当我们在创建AsynchronousServerSocket时(open())，我们可以自定义一个通道组，当然我们不传参的时候，系统会默认给我们一个群组。</li></ul><hr><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724195923945.png" alt="在这里插入图片描述"></p><ul><li>当客户端请求与服务器建立连接时，系统会异步的调用AcceptHandler来处理连接请求，成功建立连接后，会返回一个AsynchronousSocketChannel对象，<code>每个对象</code>还会有一个<code>ClientHandler</code>来处理读写请求，在请求处理的过程中，并不是在主线程中完成的，而是通道组利用线程池资源，在不同的线程中完成异步处理。</li></ul><hr><h2 id="2-聊天室分析"><a href="#2-聊天室分析" class="headerlink" title="2. 聊天室分析"></a>2. 聊天室分析</h2><h3 id="2-1-服务器端"><a href="#2-1-服务器端" class="headerlink" title="2.1 服务器端"></a>2.1 服务器端</h3><h4 id="2-1-1-字段"><a href="#2-1-1-字段" class="headerlink" title="2.1.1 字段"></a>2.1.1 字段</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/2020072420461170.png" alt="在这里插入图片描述"></p><h4 id="2-1-2-主方法"><a href="#2-1-2-主方法" class="headerlink" title="2.1.2 主方法"></a>2.1.2 主方法</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724204906660.png" alt="在这里插入图片描述"></p><h4 id="2-1-3-AcceptHandler"><a href="#2-1-3-AcceptHandler" class="headerlink" title="2.1.3 AcceptHandler"></a>2.1.3 AcceptHandler</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724205358130.png" alt="在这里插入图片描述"></p><h4 id="2-1-4-ClientHandler（处理读写请求）"><a href="#2-1-4-ClientHandler（处理读写请求）" class="headerlink" title="2.1.4 ClientHandler（处理读写请求）"></a>2.1.4 ClientHandler（处理读写请求）</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724205908451.png" alt="在这里插入图片描述"></p><h4 id="2-1-5-添加和删除用户"><a href="#2-1-5-添加和删除用户" class="headerlink" title="2.1.5 添加和删除用户"></a>2.1.5 添加和删除用户</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/2020072421010985.png" alt="在这里插入图片描述"></p><h4 id="2-1-6-接收和转发方法"><a href="#2-1-6-接收和转发方法" class="headerlink" title="2.1.6 接收和转发方法"></a>2.1.6 接收和转发方法</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210243585.png" alt="在这里插入图片描述"></p><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><p>客户端中使用的Future来处理异步请求，非常简单</p><h4 id="2-2-1-主方法"><a href="#2-2-1-主方法" class="headerlink" title="2.2.1 主方法"></a>2.2.1 主方法</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210613293.png" alt="在这里插入图片描述"></p><h4 id="2-2-2-发送消息"><a href="#2-2-2-发送消息" class="headerlink" title="2.2.2 发送消息"></a>2.2.2 发送消息</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210719163.png" alt="在这里插入图片描述"></p><h4 id="2-2-3-用户的输入线程"><a href="#2-2-3-用户的输入线程" class="headerlink" title="2.2.3 用户的输入线程"></a>2.2.3 用户的输入线程</h4><p><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210827857.png" alt="在这里插入图片描述"></p><hr><h2 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3. 测试结果"></a>3. 测试结果</h2><ul><li>服务器端显示<br><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210901364.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><h3 id="4-1-服务器端-1"><a href="#4-1-服务器端-1" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">package server;

import java.io.Closeable;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousChannelGroup;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ChatServer {

    private static final String LOCALHOST = "localhost";
    private static final int DEFAULT_PORT = 8888;
    private static final String QUIT = "quit";
    private static final int BUFFER = 1024;

    private AsynchronousServerSocketChannel serverChannel;
    private AsynchronousChannelGroup asynchronousChannelGroup;
    private List<clienthandler> connectedClients;
    private Charset charset = StandardCharsets.UTF_8;
    private int port;

    public ChatServer(int port) {
        this.port = port;
        connectedClients = new ArrayList<>();
    }

    public ChatServer() {
        this(DEFAULT_PORT);
    }

    public void start(){
        try {
            //自定义ChannelGroup
            ExecutorService executorService = Executors.newFixedThreadPool(10);
            asynchronousChannelGroup = AsynchronousChannelGroup.withThreadPool(executorService);

            serverChannel = AsynchronousServerSocketChannel.open(asynchronousChannelGroup);
            serverChannel.bind(new InetSocketAddress(LOCALHOST,port));
            System.out.println("服务器已经启动成功，随时等待客户端连接...");

            while (true){
                serverChannel.accept(null,new AcceptHandler());

                System.in.read();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            close(serverChannel);
        }
    }

    private class AcceptHandler implements CompletionHandler<asynchronoussocketchannel ,object> {
        @Override
        public void completed(AsynchronousSocketChannel clientChannel, Object attachment) {
            if(serverChannel.isOpen())
                serverChannel.accept(null,this);

            if(clientChannel != null && clientChannel.isOpen()){
                ClientHandler clientHandler = new ClientHandler(clientChannel);

                ByteBuffer buffer = ByteBuffer.allocate(BUFFER);
                addClient(clientHandler);
                clientChannel.read(buffer,buffer,clientHandler);
            }

        }

        @Override
        public void failed(Throwable exc, Object attachment) {
            System.out.println("连接失败：" + exc.getMessage());
        }
    }

    private class ClientHandler implements CompletionHandler<integer ,bytebuffer>{

        private AsynchronousSocketChannel clientChannel;

        public ClientHandler(AsynchronousSocketChannel clientChannel) {
            this.clientChannel = clientChannel;
        }

        public AsynchronousSocketChannel getClientChannel() {
            return clientChannel;
        }

        @Override
        public void completed(Integer result, ByteBuffer buffer) {
            if(buffer != null){
                //buffer不为空的时候，这要执行的是read之后的回调方法
                if(result <= 0){
                    //客户端异常，将客户端从连接列表中移除
                    removeClient(this);
                }else{
                    buffer.flip();
                    String fwdMsg = receive(buffer);
                    System.out.println(getClientName(clientChannel) + fwdMsg);
                    forwardMsg(clientChannel,fwdMsg);
                    buffer.clear();

                    if(readyToQuit(fwdMsg)){
                        removeClient(this);
                    }else {
                        clientChannel.read(buffer,buffer,this);
                    }
                }
            }
        }

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) {
            System.out.println("读写操作失败：" + exc.getMessage());
        }
    }

    private synchronized void addClient(ClientHandler clientHandler) {
        connectedClients.add(clientHandler);
        System.out.println(getClientName(clientHandler.getClientChannel()) + "已经连接");
    }

    private synchronized void removeClient(ClientHandler clientHandler) {
        AsynchronousSocketChannel clientChannel = clientHandler.getClientChannel();
        connectedClients.remove(clientHandler);
        System.out.println(getClientName(clientChannel) + "已经断开连接");
        close(clientChannel);
    }

    private void close(Closeable closeable){
        try {
            closeable.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private boolean readyToQuit(String msg){
        return QUIT.equals(msg);
    }

    private synchronized String receive(ByteBuffer buffer) {
        return String.valueOf(charset.decode(buffer));
    }

    private synchronized void forwardMsg(AsynchronousSocketChannel clientChannel,String fwdMsg) {
        for (ClientHandler connectedHandler : connectedClients) {
            AsynchronousSocketChannel client = connectedHandler.getClientChannel();
            if(!client.equals(clientChannel)){
                //注意这个try，catch是自己加的
                try {
                    //将消息存入缓存区中
                    ByteBuffer buffer = charset.encode(getClientName(client) + fwdMsg);
                    //写给每个客户端
                    client.write(buffer,null,connectedHandler);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

    }

    private String getClientName(AsynchronousSocketChannel clientChannel) {
        int port = -1;
        try {
            InetSocketAddress remoteAddress = (InetSocketAddress) clientChannel.getRemoteAddress();
            port = remoteAddress.getPort();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "客户端[" + port + "]:";
    }

    public static void main(String[] args) {
        ChatServer chatServer = new ChatServer();
        chatServer.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></integer></asynchronoussocketchannel></clienthandler></code></pre><h3 id="4-2-客户端-1"><a href="#4-2-客户端-1" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">package client;

import java.io.Closeable;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

public class ChatClient {

    private static final String LOCALHOST = "localhost";
    private static final int DEFAULT_PORT = 8888;
    private final String QUIT = "quit";
    private final int BUFFER = 1024;

    private String host;
    private int port;
    private AsynchronousSocketChannel clientChannel;
    private Charset charset = StandardCharsets.UTF_8;

    public ChatClient() {
        this(LOCALHOST,DEFAULT_PORT);
    }

    public ChatClient(String host,int port){
        this.host = host;
        this.port = port;
    }

    public void start(){
        try {
            clientChannel = AsynchronousSocketChannel.open();
            Future<void> connect = clientChannel.connect(new InetSocketAddress(host, port));
            connect.get();
            System.out.println("与服务已成功建立连接");
            new Thread(new UserInputHandler(this)).start();

            ByteBuffer buffer = ByteBuffer.allocate(BUFFER);
            while (clientChannel.isOpen()){
                Future<integer> read = clientChannel.read(buffer);
                int result = read.get();
                if(result <= 0){
                    //这里是，当我们输入quit时，在服务器端会自动将我们移除
                    //所以这里关闭就好了
                    close(clientChannel);
                }else {
                    buffer.flip();
                    String msg = String.valueOf(charset.decode(buffer));
                    System.out.println(msg);
                    buffer.clear();
                }
            }
        } catch (IOException | InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }finally {
            close(clientChannel);
        }
    }

    public void sendMsg(String msg){
        if(msg.isEmpty()){
            return;
        }else {
            ByteBuffer buffer = charset.encode(msg);
            Future<integer> write = clientChannel.write(buffer);
            try {
                write.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
    }

    private void close(Closeable closeable){
        try {
            closeable.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public boolean readyToQuit(String msg){
        return QUIT.equals(msg);
    }

    public static void main(String[] args) {
        ChatClient chatClient = new ChatClient();
        chatClient.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></integer></integer></void></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class UserInputHandler implements Runnable{
    private ChatClient client;

    public UserInputHandler(ChatClient client) {
        this.client = client;
    }

    @Override
    public void run() {
        BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));

        while (true){
            try {
                String msg = consoleReader.readLine();
                client.sendMsg(msg);

                if(client.readyToQuit(msg)){
                    System.out.println("成功退出聊天室");
                    break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1-三种模型的适用场景"><a href="#1-三种模型的适用场景" class="headerlink" title="1. 三种模型的适用场景"></a>1. 三种模型的适用场景</h2><ol><li>BIO：适用于连接数目少，而且服务器资源对于我们已知的连接来说，比较充足，开发简单</li><li>NIO：相对BIO来说，开发难度较高，但是客户连接数目比较高。值得我们注意的是，由于NIO是单一的线程轮询来处理数据，需要避免每个任务执行的时间过长，防止其他线程出现过长的等待</li><li>AIO：接受的连接数目多，相对于NIO来说，是异步出来，可以接受某个任务花费过长的时间，但是开发难度比较高，维护起来也不简单。</li></ol><ul><li>附：可以使用JDK文件夹下面的VisualVM来监控程序的使用情况<br><img src="/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200725151809156.png" alt="在这里插入图片描述"></li></ul><hr></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Kayleh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kayleh.top/AIO%E6%A8%A1%E5%9E%8B/">https://kayleh.top/AIO%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kayleh.top" target="_blank">Kayleh</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/network/">network</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f41058e8051f381" async></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/wechatpay.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><div class="post-ad"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7457165067653912" data-ad-slot="9837525717" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/indexbg.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM classloader and parent delegation-mechanism</div></div></a></div><div class="next-post pull-right"><a href="/NIO%E6%A8%A1%E5%9E%8B/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/index1.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NIO blocking model</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/BIO阻塞模型/" title="BIO blocking model"><img class="relatedPosts_cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/yasina.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-03</div><div class="relatedPosts_title">BIO blocking model</div></div></a></div><div class="relatedPosts_item"><a href="/BIO、NIO、AIO区别/" title="the difference of BIO、NIO、AIO"><img class="relatedPosts_cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/index4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-20</div><div class="relatedPosts_title">the difference of BIO、NIO、AIO</div></div></a></div><div class="relatedPosts_item"><a href="/I-O模型/" title="I/O model"><img class="relatedPosts_cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/index5.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-03</div><div class="relatedPosts_title">I/O model</div></div></a></div><div class="relatedPosts_item"><a href="/Java网络编程/" title="Java network programming"><img class="relatedPosts_cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/index1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-03</div><div class="relatedPosts_title">Java network programming</div></div></a></div><div class="relatedPosts_item"><a href="/NIO模型/" title="NIO blocking model"><img class="relatedPosts_cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn/img/index1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-05</div><div class="relatedPosts_title">NIO blocking model</div></div></a></div><div class="relatedPosts_item"><a href="/TCP-IP/" title="TCP/IP"><img class="relatedPosts_cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/index10.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-27</div><div class="relatedPosts_title">TCP/IP</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/gh/kayleh/cdn2/index10.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Kayleh</div><div class="footer_custom_text">all rights reserved.</div></div><div style="text-align:center"><a href="https://info.flagcounter.com/cDh1" target="_blank" rel="noopener"><img src="https://s11.flagcounter.com/count/cDh1/bg_49B1F5/txt_000000/border_49B1F5/columns_4/maxflags_16/viewers_0/labels_1/pageviews_0/flags_0/percent_1/" alt="Flag Counter" border="0"></a></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'FgNaybmwy1yu74JH4lXMgH5S-gzGzoHsz',
      appKey: 'OBHyEdMVsi8FSFA0aqJNh4HE',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="/js/third-party/click_heart.js" async></script><script>!function(t,e,o,c,n,i,a){t.DaoVoiceObject=n,t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},t[n].l=+new Date,i=e.createElement(o),a=e.getElementsByTagName(o)[0],i.async=1,i.src=c,i.charset="utf-8",a.parentNode.insertBefore(i,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/38b1c911.js","daovoice")</script><script>var isChatBtn = false
daovoice('init', {
  app_id: '38b1c911',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script></div><script src="/live2d-widget/autoload.js"></script></body></html>