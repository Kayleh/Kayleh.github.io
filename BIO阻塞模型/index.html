<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Kayleh"><title>BIO blocking model · Kayleh</title><meta name="description" content="BIO阻塞模型1. BIO阻塞模型简述BIO模型中服务端与客户端的响应过程

服务器serverSocket先要和端口进行绑定
绑定完成后，执行accept方法，等待客户端的连接，这个方法是阻塞式调用，也就是说，要一直等待客户端的连接响应，不做其他事情，一直等，（被阻塞的还有InputStream."><meta name="keywords" content=""><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Kayleh</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">대문</a></li><li><a href="/archives">아카이브</a></li><li><a href="/categories">카테고리</a></li><li><a href="/tags">태그</a></li><li><a href="/google8102e2f35ce9e391.html"></a></li><li><a href="/mainfest.json"></a></li><li><a href="/link/index.html">友人帐</a></li><li><a href="/about/index.html">about</a></li><li class="soc"><a href="https://github.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://twitter.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter">&nbsp;</i></a><a href="https://www.instagram.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-instagram">&nbsp;</i></a><a href="https://kayleh.top/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>BIO blocking model</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-12-03</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/network/" title="network" class="a-tag">network</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h1 id="BIO阻塞模型"><a href="#BIO阻塞模型" class="headerlink" title="BIO阻塞模型"></a>BIO阻塞模型</h1><h2 id="1-BIO阻塞模型"><a href="#1-BIO阻塞模型" class="headerlink" title="1. BIO阻塞模型"></a>1. BIO阻塞模型</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200720183138508.png" alt="在这里插入图片描述"><br>简述BIO模型中服务端与客户端的响应过程</p><ol><li>服务器<code>serverSocket</code>先要和<code>端口</code>进行<code>绑定</code></li><li>绑定完成后，执行<code>accept方法</code>，等待客户端的连接，这个方法是<code>阻塞式调用</code>，也就是说，要一直等待客户端的连接响应，不做其他事情，一直等，（被阻塞的还有InputStream.read()、OutputStream.write()，这两个也会一直等待客户端的响应）</li><li>客户端创建<code>Socket</code>对象，<code>绑定</code>服务器的<code>ip地址</code>与<code>端口号</code>，与服务器进行连接</li><li>服务器接收到客户端的连接请求，accept方法获取到<code>客户端的socket信息</code>，连接成功</li><li>服务器与客户端创建各自的<code>io流</code>，实现<code>全双工通信</code></li><li>之后便可以随时<code>结束连接</code></li></ol><hr><h2 id="2-简单实战演示"><a href="#2-简单实战演示" class="headerlink" title="2. 简单实战演示"></a>2. 简单实战演示</h2><h3 id="2-1-服务器"><a href="#2-1-服务器" class="headerlink" title="2.1 服务器"></a>2.1 服务器</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;


public class Server {
    public static void main(String[] args) {
        final int DEFAULT_PORT = 8888;
        final String QUIT = "quit";
        ServerSocket serverSocket = null;

        try {
            //绑定端口号
            serverSocket = new ServerSocket(DEFAULT_PORT);
            System.out.println("服务器已经启动，绑定端口号：" + DEFAULT_PORT);

            while (true){
                //等待客户端的连接
                Socket socket = serverSocket.accept();
                System.out.println("客户端" + socket.getPort() + ":" + "已经连接");

                //获取io流
                BufferedReader reader = new BufferedReader(
                        new InputStreamReader(socket.getInputStream())
                );
                BufferedWriter writer = new BufferedWriter(
                        new OutputStreamWriter(socket.getOutputStream())
                );

                //读取客户发送的信息
                String msg = null;
                while ((msg = reader.readLine()) != null) {
                    System.out.println("客户端" + socket.getPort() + ":" + msg);
                    //回复消息
                    writer.write( msg + " ok" +"\n");
                    writer.flush();
                    System.out.println("服务器：" + msg + " ok");

                    if(msg.equals(QUIT)){
                        System.out.println("客户端" + socket.getPort() + ":断开连接" );
                        break;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(serverSocket != null){
                try {
                    serverSocket.close();
                    System.out.println("服务器Socket关闭");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">

import java.io.*;
import java.net.Socket;
import java.net.UnknownHostException;

public class Client {
    public static void main(String[] args) {
        final int DEFAULT_SERVER_PORT = 8888;
        final String DEFAULT_ADDRESS = "127.0.0.1";
        final String QUIT = "quit";

        Socket socket = null;
        BufferedWriter writer = null;

        try {
            //创建Socket
            socket = new Socket(DEFAULT_ADDRESS,DEFAULT_SERVER_PORT);

            //创建io流
            writer = new BufferedWriter(
                    new OutputStreamWriter(socket.getOutputStream())
            );
            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(socket.getInputStream())
            );

            //等待用户输入信息
            while (true) {
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                String msg = consoleReader.readLine();
                //向服务器发送消息
                writer.write(msg + "\n");
                writer.flush();
                System.out.println("客户端"+ ":" + msg);
                String line = reader.readLine();
                System.out.println("服务器：" + line);
                //退出判断
                if(msg.equals(QUIT)){
                    break;
                }
            }
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(writer != null){
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-响应结果"><a href="#2-3-响应结果" class="headerlink" title="2.3 响应结果"></a>2.3 响应结果</h3><ul><li><strong>客户端</strong><br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200720183847235.png" alt="在这里插入图片描述"></li><li><strong>服务器</strong><br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200720183859453.png" alt="在这里插入图片描述"></li></ul><h2 id="3-加深理解"><a href="#3-加深理解" class="headerlink" title="3. 加深理解"></a>3. 加深理解</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721182800674.png" alt="在这里插入图片描述"></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="1-概念图解"><a href="#1-概念图解" class="headerlink" title="1. 概念图解"></a>1. 概念图解</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721171646426.png" alt="在这里插入图片描述"></p><ul><li>BIO模型：客户端每有一个请求，服务端都要有一个线程来单独处理这个请求，典型的<code>一请求一应答</code>，java 1.4版本之前</li><li>对于聊天室服务器，它有多个线程，其中一个为图上的<code>Acceptor线程</code>（ChatServer），它实现的就是对来自客户端的请求不断响应，创建分配处理线程；对应客户端的每一个请求，都有一个单独的处理线程</li><li>对于客户端来说，它有两个线程，其中一个线程与服务器<code>建立连接，并接收来自服务器的消息</code>；另一个线程则用来<code>处理用户的输入，并将消息发送到服务器</code></li></ul><h3 id="1-1-伪异步的优化"><a href="#1-1-伪异步的优化" class="headerlink" title="1.1 伪异步的优化"></a>1.1 伪异步的优化</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721172110567.png" alt="在这里插入图片描述"></p><ul><li>使用线程池的原因是因为防止一大批用户的响应，造成服务器过载，实现线程的复用，减少不停的创建删除线程造成的资源郎芬，这样也实现了BIO的伪异步IO通信</li></ul><p><a href="https://www.cnblogs.com/haimishasha/p/10625026.html#autoid-1-0-0" target="_blank" rel="noopener">I/O模型系列之三：IO通信模型BIO NIO AIO</a></p><hr><h2 id="2-聊天服务器中的要点"><a href="#2-聊天服务器中的要点" class="headerlink" title="2. 聊天服务器中的要点"></a>2. 聊天服务器中的要点</h2><h3 id="2-1-字段"><a href="#2-1-字段" class="headerlink" title="2.1 字段"></a>2.1 字段</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721183219259.png" alt="在这里插入图片描述"></p><h3 id="2-2-转发消息方法"><a href="#2-2-转发消息方法" class="headerlink" title="2.2 转发消息方法"></a>2.2 转发消息方法</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721184044934.png" alt="在这里插入图片描述"></p><h3 id="2-3-添加客户方法"><a href="#2-3-添加客户方法" class="headerlink" title="2.3 添加客户方法"></a>2.3 添加客户方法</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/2020072118380045.png" alt="在这里插入图片描述"></p><h3 id="2-4-移除客户方法"><a href="#2-4-移除客户方法" class="headerlink" title="2.4 移除客户方法"></a>2.4 移除客户方法</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721183932390.png" alt="在这里插入图片描述"></p><h3 id="2-5-服务器主线程任务"><a href="#2-5-服务器主线程任务" class="headerlink" title="2.5 服务器主线程任务"></a>2.5 服务器主线程任务</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721184510239.png" alt="在这里插入图片描述"></p><h3 id="2-6-服务器处理线程任务"><a href="#2-6-服务器处理线程任务" class="headerlink" title="2.6 服务器处理线程任务"></a>2.6 服务器处理线程任务</h3><ul><li>实现Runnable接口，之后执行的时候将其传入到线程池中执行。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/2020072118470527.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="3-聊天室客户端要点"><a href="#3-聊天室客户端要点" class="headerlink" title="3. 聊天室客户端要点"></a>3. 聊天室客户端要点</h2><h3 id="3-1-向服务端发送消息，让服务器转发给其他人"><a href="#3-1-向服务端发送消息，让服务器转发给其他人" class="headerlink" title="3.1 向服务端发送消息，让服务器转发给其他人"></a>3.1 向服务端发送消息，让服务器转发给其他人</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185036367.png" alt="在这里插入图片描述"></p><h3 id="3-2-接收服务端的消息"><a href="#3-2-接收服务端的消息" class="headerlink" title="3.2 接收服务端的消息"></a>3.2 接收服务端的消息</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185104298.png" alt="在这里插入图片描述"></p><h3 id="3-3-主线程任务"><a href="#3-3-主线程任务" class="headerlink" title="3.3 主线程任务"></a>3.3 主线程任务</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185243618.png" alt="在这里插入图片描述"></p><h3 id="3-4-处理线程任务"><a href="#3-4-处理线程任务" class="headerlink" title="3.4 处理线程任务"></a>3.4 处理线程任务</h3><ul><li>实现Runnable接口，创建线程时启动<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185400861.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4. 测试结果"></a>4. 测试结果</h2><p><strong>服务器端信息</strong><br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/2020072118562745.png" alt="在这里插入图片描述"></p><hr><h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><h3 id="5-1-服务器"><a href="#5-1-服务器" class="headerlink" title="5.1 服务器"></a>5.1 服务器</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">package Server;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ChatServer {
    private int DEFAULT_PORT = 8888;
    private final String QUIT = "quit";

    private ServerSocket serverSocket;
    //存储已经连接的客户们
    private Map<integer , writer> connectedClients;
    private ExecutorService executorService;

    public ChatServer() {
        this.connectedClients = new HashMap<>();
        this.executorService = Executors.newFixedThreadPool(10);
    }

    //添加客户端
    public synchronized void addClient(Socket socket) throws IOException {
        if(socket != null){
            int key = socket.getPort();
            Writer value = new BufferedWriter(
                    new OutputStreamWriter(socket.getOutputStream())
            );
            connectedClients.put(key,value);
            System.out.println("客户" + key + "：已经连接");
        }
    }

    //移除客户端
    public synchronized void removeClient(Socket socket) throws IOException {
        if(socket != null){
            int port = socket.getPort();
            if(connectedClients.containsKey(port)){
                //移除用户的时候要进行关闭
                connectedClients.get(port).close();
                connectedClients.remove(port);
                System.out.println("客户端" + port + "：已经断开连接");
            }
        }
    }

    //将消息转发给其他用户
    public synchronized void forwardMessage(Socket socket,String fwdMsg) throws IOException {
        for(Integer port : connectedClients.keySet()){
            //不转发给自己
            if(!port.equals(socket.getPort())){
                Writer writer = connectedClients.get(port);
                writer.write(fwdMsg);
                writer.flush();
            }
        }
    }

    //检查是否退出
    public boolean readyToQuit(String msg){
        return QUIT.equals(msg);
    }

    public void close(){
        if(serverSocket != null){
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    //启动
    public void start(){
        try {
            //绑定监听端口
            serverSocket = new ServerSocket(DEFAULT_PORT);
            System.out.println("聊天室服务器已经成功启动！");

            while (true){
                Socket socket = serverSocket.accept();

                //为每个socket创建一条单独的线程进行处理
                //new Thread(new ChatHandler(socket,this)).start();
                executorService.execute(new ChatHandler(socket,this));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            close();
        }
    }

    public static void main(String[] args) {
        ChatServer chatServer = new ChatServer();
        chatServer.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></integer></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">package Server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;

public class ChatHandler implements Runnable {

    private Socket socket;
    private ChatServer chatServer;

    public ChatHandler(Socket socket, ChatServer chatServer) {
        this.socket = socket;
        this.chatServer = chatServer;
    }

    @Override
    public void run() {
        try {
            //添加对象
            chatServer.addClient(socket);

            //读取用户发送的信息
            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(socket.getInputStream())
            );
            String msg = null;
            //必须要读取到换行符
            while ((msg = reader.readLine()) != null){
                String fwdMsg ="客户端" + socket.getPort() + "：" + msg + "\n";
                chatServer.forwardMessage(socket,fwdMsg);
                System.out.print(fwdMsg);

                //检查是否退出
                if(chatServer.readyToQuit(msg)){
                    break;
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                chatServer.removeClient(socket);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-客户端"><a href="#5-2-客户端" class="headerlink" title="5.2 客户端"></a>5.2 客户端</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">package Client;

import Server.ChatServer;

import java.io.*;
import java.net.Socket;
import java.net.UnknownHostException;

public class ChatClient {
    private String DEFAULT_SERVER_HOST = "127.0.0.1";
    private int DEFAULT_PORT = 8888;
    private final String QUIT = "quit";

    private Socket socket;
    private BufferedReader reader;
    private BufferedWriter writer;

    //发送消息给服务器
    public void sendMsg(String msg) throws IOException {
        //输出流没有关闭的情况
        if(!socket.isOutputShutdown()){
            writer.write(msg + "\n");
            writer.flush();
        }
    }

    //接受消息从服务器
    public String receiveMsg() throws IOException {
        if(!socket.isInputShutdown()){
            return reader.readLine();
        }
        return null;
    }

    //检查是否退出
    public boolean readyToQuit(String msg){
        return QUIT.equals(msg);
    }

    //关闭
    public void close(){
        try {
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //启动开关
    public void start(){
        try {
            //创建socket
            socket = new Socket(DEFAULT_SERVER_HOST,DEFAULT_PORT);
            //创建io流
            writer = new BufferedWriter(
                    new OutputStreamWriter(socket.getOutputStream())
            );
            reader = new BufferedReader(
                    new InputStreamReader(socket.getInputStream())
            );

            //处理用户的输入的线程
            new Thread(new UserInputHandler(this)).start();

            //监听从服务器来的消息
            String msg = null;
            while ((msg = receiveMsg()) != null){
                System.out.println(msg);
            }
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            close();
        }
    }


    public static void main(String[] args) {
        ChatClient chatClient = new ChatClient();
        chatClient.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">package Client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class UserInputHandler implements Runnable{
    private ChatClient chatClient;

    public UserInputHandler(ChatClient chatClient) {
        this.chatClient = chatClient;
    }


    @Override
    public void run() {
        //等待用户输入信息
        BufferedReader reader = new BufferedReader(
                new InputStreamReader(System.in)
        );

        while (true){
            try {
                String msg = reader.readLine();
                //向服务器发送消息
                chatClient.sendMsg(msg);
                if(chatClient.readyToQuit(msg))
                    break;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></div><div class="share"><span>공유하기</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=https://kayleh.top/BIO阻塞模型/%20Kayleh%20BIO blocking model" target="_blank" rel="noopener" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/NIO%E6%A8%A1%E5%9E%8B/" title="NIO blocking model"><i class="fa fa-angle-double-left"></i>&nbsp;이전 포스트: NIO blocking model</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/I-O%E6%A8%A1%E5%9E%8B/" title="I/O model">다음 포스트: I/O model&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname="kayleh",disqus_identifier="BIO阻塞模型/",disqus_title="BIO blocking model",disqus_url="https://kayleh.top/BIO阻塞模型/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//kayleh.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/dao.js"></script><script src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/busuanzi/busuanzi.pure.mini.js"></script><script data-ad-client="ca-pub-7457165067653912" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></body></html>