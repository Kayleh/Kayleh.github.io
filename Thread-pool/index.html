<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Kayleh"><title>Thread Pool · Kayleh</title><meta name="description" content="异步执行的代码
1new Thread(r).start();
统一的工具类，定一个接口来实现。
123public interface Executor &amp;#123;    public void execute(Runnable r);&amp;#125;
123456// 新线程：直接创建一个新线程运"><meta name="keywords" content=""><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Kayleh</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">대문</a></li><li><a href="/archives">아카이브</a></li><li><a href="/categories">카테고리</a></li><li><a href="/tags">태그</a></li><li><a href="/google8102e2f35ce9e391.html"></a></li><li><a href="/mainfest.json"></a></li><li><a href="/ToDoList/index.html">ToDoList</a></li><li><a href="/categories/index.html">分类</a></li><li><a href="/friends/index.html">友人帐</a></li><li><a href="/link/index.html">友情链接</a></li><li><a href="/about/index.html">about</a></li><li class="soc"><a href="https://github.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://twitter.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter">&nbsp;</i></a><a href="https://www.instagram.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-instagram">&nbsp;</i></a><a href="https://kayleh.top/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Thread Pool</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-04-20</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/Thread-pool/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/Concurrency/" title="Concurrency" class="a-tag">Concurrency</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><p>异步执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure><p>统一的工具类，定一个接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新线程：直接创建一个新线程运行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>假如有 10000 个人都调用这个工具类提交任务，那就会创建 10000 个线程来执行，这肯定不合适吧！能不能控制一下线程的数量呢？</p></blockquote><p>可以把这个任务 r 丢到一个 tasks 队列中，然后只启动一个线程，就叫它 <strong>Worker</strong> 线程吧，不断从 tasks 队列中取任务，执行任务。这样无论调用者调用多少次，永远就只有一个 Worker 线程在运行，像这样。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.gif" alt="图片"></p><p>这个设计有了三个重大的意义：</p><p>\1. 控制了线程数量。</p><p>\2. 队列不但起到了缓冲的作用，还将任务的提交与执行解耦了。</p><p>\3. 最重要的一点是，解决了每次重复创建和销毁线程带来的系统开销。</p><blockquote><p>不过只有一个后台的工作线程 Worker 会不会少了点？还有如果这个 tasks 队列满了怎么办呢？</p></blockquote><p>Worker 线程的数量要增加，但是具体数量要让使用者决定，调用时传入，就叫核心线程数 <strong>corePoolSize</strong> 吧。</p><p>这样设计。</p><p>\1. 初始化线程池时，直接启动 corePoolSize 个工作线程 Worker 先跑着。</p><p>\2. 这些 Worker 就是死循环从队列里取任务然后执行。</p><p>\3. execute 方法仍然是直接把任务放到队列，但队列满了之后直接抛弃</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937229662.gif" alt="图片"></p><blockquote><p>初始化的时候，就创建了一堆 Worker 线程在那空跑着，假如此时并没有异步任务提交过来执行，这就有点浪费了。</p><p>队列一满，就直接把新任务丢弃了，这样有些粗暴，能不能让调用者自己决定该怎么处理呢？</p></blockquote><p>改进</p><p><strong>1. 按需创建Worker</strong>：刚初始化线程池时，不再立刻创建 corePoolSize 个工作线程，而是等待调用者不断提交任务的过程中，逐渐把工作线程 Worker 创建出来，等数量达到 corePoolSize 时就停止，把任务直接丢到队列里。那就必然要用一个属性记录已经创建出来的工作线程数量，就叫 <strong>workCount</strong> 吧。</p><p><strong>2. 加拒绝策略</strong>：实现上就是增加一个入参，类型是一个接口 <strong>RejectedExecutionHandler</strong>，由调用者决定实现类，以便在任务提交失败后执行 rejectedExecution 方法。</p><p><strong>3. 增加线程工厂</strong>：实现上就是增加一个入参，类型是一个接口 <strong>ThreadFactory</strong>，增加工作线程时不再直接 new 线程，而是调用这个由调用者传入的 ThreadFactory 实现类的 newThread 方法。</p><p>就像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937168495.gif" alt="图片"></p><blockquote><p>在这个场景里，弹性就是在任务提交比较频繁，和任务提交非常不频繁这两种情况下，你这个代码是否有问题？</p><p>这个线程池，当提交任务的量突增时，工作线程和队列都被占满了，就只能走拒绝策略，其实就是被丢弃掉</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937173510.gif" alt="图片"></p><p>调用方可以通过设置很大的核心线程数 corePoolSize 来解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937221389.gif" alt="图片"></p><blockquote><p>可以，但一般场景下 QPS 高峰期都很短，而为了这个很短暂的高峰，设置很大的核心线程数，简直太浪费资源了</p></blockquote><p>最大线程数 <strong>maximumPoolSize</strong>。当核心线程数和队列都满了时，新提交的任务仍然可以通过创建新的工作线程（叫它<strong>非核心线程</strong>），直到工作线程数达到 maximumPoolSize 为止，这样就可以缓解一时的高峰期了，而用户也不用设置过大的核心线程数。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.png" alt="图片"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937269134.gif" alt="图片"></p><p>\1. 开始的时候和上一版一样，当 workCount &lt; corePoolSize 时，通过创建新的 Worker 来执行任务。</p><p>\2. 当 workCount &gt;= corePoolSize 就停止创建新线程，把任务直接丢到队列里。</p><p>\3. 但当队列已满且仍然 workCount &lt; maximumPoolSize 时，不再直接走拒绝策略，而是创建非核心线程，直到 workCount = maximumPoolSize，再走拒绝策略。</p><p>这样 corePoolSize 就负责平时大多数情况所需要的工作线程数，而 maximumPoolSize 就负责在高峰期临时扩充工作线程数。</p><p>高峰时期的弹性搞定了，那自然就还要考虑低谷时期。当长时间没有任务提交时，核心线程与非核心线程都一直空跑着，浪费资源。我们可以给<strong>非核心线程</strong>设定一个超时时间 <strong>keepAliveTime</strong>，当这么长时间没能从队列里获取任务时，就不再等了，销毁线程。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937263714.gif" alt="图片"></p><p>这回线程池在 QPS 高峰时可以临时扩容，QPS 低谷时又可以及时回收线程（非核心线程）而不至于浪费资源，真的显得十分 Q 弹呢。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937301920.gif" alt="图片"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlashExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 省略一些参数校验</span></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些参数分别是</p><p><strong>int corePoolSize</strong>：核心线程数</p><p><strong>int maximumPoolSize</strong>：最大线程数</p><p><strong>long keepAliveTime</strong>：非核心线程的空闲时间</p><p><strong>TimeUnit unit</strong>：空闲时间的单位</p><p><strong>BlockingQueue workQueue</strong>：任务队列（线程安全的阻塞队列）</p><p><strong>ThreadFactory threadFactory</strong>：线程工厂</p><p><strong>RejectedExecutionHandler handler</strong>：拒绝策略</p><p>整个任务的提交流程是</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.webp" alt="图片"></p><p></p></div><div class="share"><span>공유하기</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=https://kayleh.top/Thread-pool/%20Kayleh%20Thread Pool" target="_blank" rel="noopener" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/note/" title="todoList"><i class="fa fa-angle-double-left"></i>&nbsp;이전 포스트: todoList</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/Implement-a-lock-based-on-ReentrantLock/" title="a Lock Based on ReentrantLock">다음 포스트: a Lock Based on ReentrantLock&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname="kayleh",disqus_identifier="Thread-pool/",disqus_title="Thread Pool",disqus_url="https://kayleh.top/Thread-pool/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//kayleh.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/dao.js"></script><script src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/busuanzi/busuanzi.pure.mini.js"></script><script data-ad-client="ca-pub-7457165067653912" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></body></html>