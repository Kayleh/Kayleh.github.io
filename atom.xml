<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kayleh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kayleh.top/"/>
  <updated>2020-12-15T17:26:36.247Z</updated>
  <id>https://kayleh.top/</id>
  
  <author>
    <name>Kayleh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Native方法?</title>
    <link href="https://kayleh.top/Native-method/"/>
    <id>https://kayleh.top/Native-method/</id>
    <published>2020-12-15T16:58:42.000Z</published>
    <updated>2020-12-15T17:26:36.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Native"><a href="#Native" class="headerlink" title="Native?"></a>Native?</h4><p>翻看Thread.start()源码,竟然出现了无方法体的方法??</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这里其实用到了关键字native</p><h4 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h4><blockquote><p>说明java的作用范围达不到了,回去调用底层C语言的库.</p></blockquote><p>使用native关键字会进入本地方法栈,调用本地方法接口JNI(Java Native Interface)</p><p>JNI的作用: 扩展Java的使用,融合不同的编程语言为Java所用</p><p>它在内存区域中专门开辟了一块标记区域: Native Method Stack,登记Native方法.</p><p>在最终执行的时候,加载本地方法库中的方法通过JNI</p><h4 id="本地方法的使用"><a href="#本地方法的使用" class="headerlink" title="本地方法的使用"></a>本地方法的使用</h4><p>少见.</p><blockquote><p>Java使用打印机,currentTimeMills( ),做外挂的Robot( )…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Native&quot;&gt;&lt;a href=&quot;#Native&quot; class=&quot;headerlink&quot; title=&quot;Native?&quot;&gt;&lt;/a&gt;Native?&lt;/h4&gt;&lt;p&gt;翻看Thread.start()源码,竟然出现了无方法体的方法??&lt;/p&gt;
&lt;figure class=
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://kayleh.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>沙箱安全机制</title>
    <link href="https://kayleh.top/Sandbox-security-mechanism/"/>
    <id>https://kayleh.top/Sandbox-security-mechanism/</id>
    <published>2020-12-15T16:58:23.000Z</published>
    <updated>2020-12-15T17:16:47.144Z</updated>
    
    <content type="html"><![CDATA[<ol><li><ul><li><h3 id="什么是沙箱？"><a href="#什么是沙箱？" class="headerlink" title="什么是沙箱？"></a>什么是沙箱？</h3><p> Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p> 所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p></li></ul></li></ol><pre><code> ### java中的安全模型：  在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图所示 ![JDK1.0安全模型](https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180111144130504-757642373.gif) 但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示 ![JDK1.1安全模型](https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180111144207051-1274870859.gif) 在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 ![JDK1.2安全模型](https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180111144239051-1741250711.gif) 当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示 ![最新的安全模型](https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180111144309176-1047557575.gif) 以上提到的都是基本的 Java 安全模型概念，在应用开发中还有一些关于安全的复杂用法，其中最常用到的 API 就是 doPrivileged。doPrivileged 方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。 ### 组成沙箱的基本组件： - 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 - 类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用 1. 它防止恶意代码去干涉善意的代码； 2. 它守护了被信任的类库边界； 3. 它将代码归入保护域，确定了代码可以进行哪些操作。      虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。      类装载器采用的机制是双亲委派模式。1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用； 2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 - 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 - 安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 - 安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：   1. 安全提供者   2. 消息摘要   3. 数字签名   4. 加密   5. 鉴别</code></pre><blockquote><p>说白了就是限制远程代码权限</p></blockquote><p>假如一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; b(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; a(); &#125;</span><br></pre></td></tr></table></figure><p>调用肯定会栈溢出,但是如果远程恶意修改栈空间就会导致内存溢出.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;什么是沙箱？&quot;&gt;&lt;a href=&quot;#什么是沙箱？&quot; class=&quot;headerlink&quot; title=&quot;什么是沙箱？&quot;&gt;&lt;/a&gt;什么是沙箱？&lt;/h3&gt;&lt;p&gt; Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://kayleh.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-类加载器和双亲委派机制</title>
    <link href="https://kayleh.top/JVM-classloader-and-parent-delegation-mechanism/"/>
    <id>https://kayleh.top/JVM-classloader-and-parent-delegation-mechanism/</id>
    <published>2020-12-14T13:28:57.000Z</published>
    <updated>2020-12-14T16:24:17.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h4 id="java的六种存储地址及解释"><a href="#java的六种存储地址及解释" class="headerlink" title="java的六种存储地址及解释"></a>java的六种存储地址及解释</h4><p>1） 寄存器(register)：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。</p><p>2） 堆栈(stack)：位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其中。<br>3）堆(heap)：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。<br>4）静态存储(static storage)：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。<br>5） 常量存储(constant storage)：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中。<br>6） 非RAM存储：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。</p><p>栈、堆、方法区存储的内容</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区:"></a>堆区:</h4><p>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。</p><h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h4><p>1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用<br>2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 </p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h4><p>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。<br>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 </p><div class="img-wrap"><div class="img-bg"><img class="img" src="/JVM-classloader-and-parent-delegation-mechanism/Blog\source\_posts\JVM-类加载器和双亲委派机制\20161101164523853" alt="img"/></div><span class="image-caption">img</span></div><h4 id="JVM在什么位置？"><a href="#JVM在什么位置？" class="headerlink" title="JVM在什么位置？"></a>JVM在什么位置？</h4><p>在操作系统之上。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/JVM-classloader-and-parent-delegation-mechanism/Blog\source\_posts\JVM-类加载器和双亲委派机制\JRE--JVM.png" alt="JRE--JVM" style="zoom: 33%;"/></div><span class="image-caption">JRE--JVM" style="zoom: 33%;</span></div><h4 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="/JVM-classloader-and-parent-delegation-mechanism/Blog\source\_posts\JVM-类加载器和双亲委派机制\JVM体系结构.png" alt="JVM体系结构"/></div><span class="image-caption">JVM体系结构</span></div><p>*栈用完系统会自动释放，不会有垃圾</p><ul><li><p><strong>栈、本地方法栈、程序计数器</strong>：百之百没有垃圾，不会有垃圾回收</p></li><li><p>JVM调优百分之99都是在调方法区和堆，而百分之99都是再调堆</p></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h4 id="类加载器的作用？"><a href="#类加载器的作用？" class="headerlink" title="类加载器的作用？"></a>类加载器的作用？</h4><blockquote><p>加载Class文件</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="/JVM-classloader-and-parent-delegation-mechanism/Blog\source\_posts\JVM-类加载器和双亲委派机制\1607958651140.png" alt="1607958651140" style="zoom: 80%;"/></div><span class="image-caption">1607958651140" style="zoom: 80%;</span></div><h4 id="加载器分为"><a href="#加载器分为" class="headerlink" title="加载器分为"></a>加载器分为</h4><ul><li>虚拟机自带的加载器</li><li>启动类（根）加载器</li><li>扩展类加载器</li><li>应用程序加载器</li></ul><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>java中类的加载有5个过程，加载、验证、准备、解析、初始化；</p><p>这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。</p><p>Class文件中的“类”从加载到JVM内存中，到卸载出内存过程有七个生命周期阶段。类加载机制包括了前五个阶段。</p><p>如下图所示：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/JVM-classloader-and-parent-delegation-mechanism/Blog\source\_posts\JVM-类加载器和双亲委派机制\20160504235346278.png" alt="img"/></div><span class="image-caption">img</span></div><p>其中，加载、验证、准备、初始化、卸载的<strong><em>\</em>开始顺序**</strong>是确定的，注意，只是按顺序开始，进行与结束的顺序并不一定。解析阶段可能在初始化之后开始。</p><p>另外，类加载无需等到程序中“首次使用”的时候才开始，JVM预先加载某些类也是被允许的。（<strong><em>\</em>类加载的时机**</strong>）</p><p>1、通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成等方式。</p><p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。这里只是转化了数据结构，并未合并数据。（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</p><p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。这个Class对象并没有规定是在Java堆内存中，它比较特殊，虽为对象，但存放在方法区中。</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><blockquote><p>升级处理交由最顶级处理 最顶级说我这没你们随便 在降级处理  </p></blockquote><p><strong>双亲委派模式</strong>是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，所以默认是父装载</p><blockquote><p>1.类加载器收到类加载的请求</p><p>2.将这个请求向上委托给父类加载器去完成,一直向上委托,直到启动类加载器</p><p>3.启动加载器检查是否能够加载当前这个类,能加载就结束,使用当前的加载器,否则,抛出异常,通知子加载器进行加载</p><p>4.重复步骤 3</p><p>Class Not Found</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;h4 id=&quot;java的六种存储地址及解释&quot;&gt;&lt;a href=&quot;#java的六种存储地址及解释&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://kayleh.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(10)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-10/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-10/</id>
    <published>2020-12-11T12:15:45.000Z</published>
    <updated>2020-12-13T15:01:57.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-库存预加载到Redis中是怎么实现的？"><a href="#1-库存预加载到Redis中是怎么实现的？" class="headerlink" title="1. 库存预加载到Redis中是怎么实现的？"></a>1. 库存预加载到Redis中是怎么实现的？</h2><p>我是通过实现<code>InitializingBean接口</code>，重写其中<code>afterPropertiesSet()方法</code>，实现的预加载</p><h3 id="1-1-之后主动添加秒杀商品的话，怎么添加？"><a href="#1-1-之后主动添加秒杀商品的话，怎么添加？" class="headerlink" title="1.1 之后主动添加秒杀商品的话，怎么添加？"></a>1.1 之后主动添加秒杀商品的话，怎么添加？</h3><p>通过后台管理进行添加，修改redis缓存和数据库中的值</p><hr><h2 id="2-在Redis中扣减库存的时候，是怎么保证线程安全，防止超卖的？"><a href="#2-在Redis中扣减库存的时候，是怎么保证线程安全，防止超卖的？" class="headerlink" title="2. 在Redis中扣减库存的时候，是怎么保证线程安全，防止超卖的？"></a>2. 在Redis中扣减库存的时候，是怎么保证线程安全，防止超卖的？</h2><p>redis中有一个<code>decr()</code>方法，它实现的是递减操作，而且能够<code>保证原子性</code></p><hr><h2 id="3-如果出现Redis缓存雪崩、穿透，怎么解决？"><a href="#3-如果出现Redis缓存雪崩、穿透，怎么解决？" class="headerlink" title="3. 如果出现Redis缓存雪崩、穿透，怎么解决？"></a>3. 如果出现Redis缓存雪崩、穿透，怎么解决？</h2><p>雪崩就是缓存中我存储的值全部都失效了，请求直接打到数据库上，请求过大，数据库扛不住。可以用设置这些热点数据永不失效，或者是设置一个随机的过期时间，这样来避免它同时失效。</p><p>缓存穿透是缓存和数据库中都没有的数据，如果有人利用这些数据高并发的访问的话，对数据库压力也很大。可以对数据比如它的id值进行一个校验，避免这些不存在的值对数据库进行访问或者是使用布隆过滤器，它的原理是通过高效的数据结构查询数据库中是否存在这个值，不存在的时候，就直接返回，存在的话才会访问到数据库。</p><hr><h2 id="4-限流防刷是怎么实现的？"><a href="#4-限流防刷是怎么实现的？" class="headerlink" title="4. 限流防刷是怎么实现的？"></a>4. 限流防刷是怎么实现的？</h2><p>限流防刷我是通过拦截器来实现的，我自定义了一个注解，它实现的功能就是标记在方法上，规定它单位时间内的访问次数，如果超过要求的话，就会被拦截。</p><p>拦截器我是继承的HandlerInterceptorAdapter，重写的是preHandle方法，在该方法中，将访问次数同步到Redis中，这个键值对是存在有效期的。最后还要把拦截器配置到项目中，继承WebMvcConfigurerAdapter，重写<code>addInterceptors()</code>方法</p><hr><h2 id="5-对于用户的恶意下单，他知道了你的URL地址，不停的刷，怎么办？"><a href="#5-对于用户的恶意下单，他知道了你的URL地址，不停的刷，怎么办？" class="headerlink" title="5. 对于用户的恶意下单，他知道了你的URL地址，不停的刷，怎么办？"></a>5. 对于用户的恶意下单，他知道了你的URL地址，不停的刷，怎么办？</h2><p>我是通过隐藏URL地址来避免这种问题的，当访问秒杀接口的时候，会先从后端生成一个随机的字符串，然后保存到redis中，并且拼接到URL地址上，这样再去访问秒杀的接口，通过RestFul风格的地址，获取其中的随机字符串，与redis中的进行比对，一致的话，才能继续向下访问</p><hr><h2 id="6-秒杀成功后是怎么同步到数据库中的？"><a href="#6-秒杀成功后是怎么同步到数据库中的？" class="headerlink" title="6. 秒杀成功后是怎么同步到数据库中的？"></a>6. 秒杀成功后是怎么同步到数据库中的？</h2><p>通过两步，一步是减少商品库存，第二步是创建秒杀订单。</p><h3 id="6-1-减库存成功，创建秒杀订单失败了怎么办？"><a href="#6-1-减库存成功，创建秒杀订单失败了怎么办？" class="headerlink" title="6.1 减库存成功，创建秒杀订单失败了怎么办？"></a>6.1 减库存成功，创建秒杀订单失败了怎么办？</h3><p>这两步过程在一个事务中执行，然后先减少库存，它有一个成功的标志，减少库存成功了，才去执行创建订单的操作</p><h3 id="6-2-Spring默认的事务隔离级别"><a href="#6-2-Spring默认的事务隔离级别" class="headerlink" title="6.2 Spring默认的事务隔离级别"></a>6.2 Spring默认的事务隔离级别</h3><p>默认情况下Spring使用的是数据库设置的默认隔离级别，应该是<code>可重复读</code></p><hr><h2 id="7-RabbitMQ怎么提高消息的高可用？"><a href="#7-RabbitMQ怎么提高消息的高可用？" class="headerlink" title="7. RabbitMQ怎么提高消息的高可用？"></a>7. RabbitMQ怎么提高消息的高可用？</h2><p>我在创建队列实例的时候，将其创建为可持久化的，它有一个durable属性设置为true，这样，RabbitMQ服务重启的情况下，也不会丢失消息。</p><hr><h2 id="8-说说volatile关键字儿"><a href="#8-说说volatile关键字儿" class="headerlink" title="8. 说说volatile关键字儿"></a>8. 说说volatile关键字儿</h2><p>它最重要的一点就是保证了变量的可见性。我想先说说JMM（java内存模型），每个线程有自己的工作内存，另外还存在一个主内存，线程从主内存中获取值存储在自己的工作内存中，当对变量进行修改，它不会立即将其同步到主内中，这个时候若有其他线程来从主内存中获取该变量的时候，就会发生脏读的现象，若被volatile标记的话，就能保证变量的可见性，当变量被修改的时候他就会将其立即同步到主内存中。</p><hr><h2 id="9-TCP和UDP的区别"><a href="#9-TCP和UDP的区别" class="headerlink" title="9. TCP和UDP的区别"></a>9. TCP和UDP的区别</h2><ol><li>TCP是需要通过三次握手建立连接的；UDP是无连接的</li><li>TCP提供的可靠性高；UDP的不保证可靠性，一般用于直播或者是语音通话</li><li>TCP是基于字节流的传输层协议，它比较慢；UDP比较快</li></ol><hr><h2 id="10-ArrayList"><a href="#10-ArrayList" class="headerlink" title="10. ArrayList"></a>10. ArrayList</h2><ul><li>底层是数组，查询快，增删慢</li><li>它的默认大小是10，添加值的时候会先对当前数组大小和总大小进行判断，若出现超过最大容量的话，就要进行扩容，扩容的大小是原来大小的1.5倍（右移运算符，右移1位），再将之前的数据复制到新的数组里边。</li></ul>]]></content>
    
    <summary type="html">
    
      项目总结
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(9)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-9/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-9/</id>
    <published>2020-12-09T12:14:45.000Z</published>
    <updated>2020-12-13T15:01:49.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-动态秒杀地址"><a href="#1-动态秒杀地址" class="headerlink" title="1. 动态秒杀地址"></a>1. 动态秒杀地址</h2><h3 id="1-1-前端的改变"><a href="#1-1-前端的改变" class="headerlink" title="1.1 前端的改变"></a>1.1 前端的改变</h3><p>之前我们实现秒杀的时候是直接跳转到秒杀接口，使得我们每次的秒杀地址都是一样的，这样具有安全隐患，所以，我们将其改为动态地址，通过在前端上写一个方法进行跳转，如下所示。</p><ul><li>它会先跳转到<code>/miaosha/path</code>，获取秒杀地址中的<code>path值</code>，将其存储在Redis中<img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200717200220865.png)</li><li>然后携带<code>path值</code>去访问真正的秒杀方法，在其中将<code>path</code>值与Redis中的值进行比较，一致才能继续秒杀<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200717200701223.png)</li></ul><h3 id="1-2-获取路径的Java代码"><a href="#1-2-获取路径的Java代码" class="headerlink" title="1.2 获取路径的Java代码"></a>1.2 获取路径的Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/path"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getMiaoshaPath</span><span class="params">(MiaoShaUser user,@RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId,</span></span><br><span class="line"><span class="function">                                         @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"verifyCode"</span>,defaultValue = <span class="string">"0"</span>)</span><span class="keyword">int</span> verifyCode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String path = miaoshaService.createMiaoshaPath(user,goodsId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><ul><li>先调用createMiaoshaPath()方法，在其中会创建一串随机值，并且存储到Redis中，具体方法如下，执行完之后将路径值返回到前端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createMiaoshaPath</span><span class="params">(MiaoShaUser user, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span> || goodsId &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String str = MD5Util.md5(UUIDUtil.getUUID());</span><br><span class="line">        redisService.set(MiaoshaKey.miaoshaPathPrefix,user.getId() + <span class="string">"_"</span> + goodsId,str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h3 id="1-3-执行秒杀接口的修改"><a href="#1-3-执行秒杀接口的修改" class="headerlink" title="1.3 执行秒杀接口的修改"></a>1.3 执行秒杀接口的修改</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200717212754253.png)</p><ul><li>路径上，我们采用了RestFul风格，通过@PathVariable注解获取其中的路径值，并与redis服务器中的值进行比较，一致才能向下一步继续执行</li></ul><hr><h2 id="2-添加验证码验证"><a href="#2-添加验证码验证" class="headerlink" title="2. 添加验证码验证"></a>2. 添加验证码验证</h2><p>我们在立即秒杀按钮处添加验证码，<code>防止机器人对我们的系统进行多次秒杀</code>，也可以使秒杀能够<code>错峰访问</code>，削减并发量，我们采用的是<code>ScriptEngine</code></p><h3 id="2-1-实现过程"><a href="#2-1-实现过程" class="headerlink" title="2.1 实现过程"></a>2.1 实现过程</h3><ol><li>首先，我们在路径获取中，添加了对验证码验证的步骤<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200717213516271.png)<br>在该方法中，实现的是将从前端获取的验证码与Redis存储的验证码进行验证，验证完成之后，就将它从Redis中移除，方法代码如下<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200717214223598.png)</li><li>在此之前，前端验证码会和后端有一个响应，每次刷新验证码都会将其的正确结果同步到服务器的Redis上<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200717214411513.png)</li></ol><hr><h2 id="3-接口限流防刷"><a href="#3-接口限流防刷" class="headerlink" title="3. 接口限流防刷"></a>3. 接口限流防刷</h2><ul><li>接口限流防刷的作用是在规定的时间内访问固定的次数。我们实现的思路是，在要限制防刷的方法上添加注解，通过拦截器进行限制访问次数</li></ul><h3 id="3-1-创建出这个注解"><a href="#3-1-创建出这个注解" class="headerlink" title="3.1 创建出这个注解"></a>3.1 创建出这个注解</h3><p>该注解中，包含了需要访问时间内的访问次数，以及判断是否需要登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">seconds</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needLogin</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；</li><li><code>@Target(ElementType.METHOD)</code>：表示注解修饰的是方法</li></ul><p>对我们想要限流的方法进行标记<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\2020071813164559.png)</p><h3 id="3-2-创建拦截器"><a href="#3-2-创建拦截器" class="headerlink" title="3.2 创建拦截器"></a>3.2 创建拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoShaUserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            MiaoShaUser user  = getUser(request,response);</span><br><span class="line">            UserContext.setUser(user);</span><br><span class="line">            HandlerMethod hm = (HandlerMethod) handler;</span><br><span class="line">            <span class="comment">//处理方法的对象，获取的是方法的注解</span></span><br><span class="line">            AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(accessLimit == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> seconds = accessLimit.seconds();</span><br><span class="line">            <span class="keyword">int</span> maxCount = accessLimit.maxCount();</span><br><span class="line">            <span class="keyword">boolean</span> needLogin = accessLimit.needLogin();</span><br><span class="line">            String key = request.getRequestURI();<span class="comment">//获取请求的地址</span></span><br><span class="line">            <span class="keyword">if</span> (needLogin) &#123;</span><br><span class="line">                <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//user为空，递交错误信息</span></span><br><span class="line">                    render(response, CodeMsg.SESSION_ERROR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                key += <span class="string">"_"</span> + user.getId();</span><br><span class="line">            &#125;</span><br><span class="line">            AccessKey accessKey = AccessKey.withExpireSecond(seconds);</span><br><span class="line">            Integer count = redisService.get(accessKey, key, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="keyword">null</span>)&#123;</span><br><span class="line">                redisService.set(accessKey,key,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &lt; maxCount)&#123;</span><br><span class="line">                redisService.incr(accessKey,key);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                render(response,CodeMsg.ACCESS_LIMIT_REACHED);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure><ul><li>继承<code>HandlerInterceptorAdapter</code>，重写<code>preHandle</code>方法</li><li>重要的UserContext<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200718134859274.png)<br>我们看一下具体的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用ThreadLocal来装user信息，调用它的set和get方法，向其中存储值</span></span><br><span class="line">    <span class="comment">//ThreadLocal是为当前线程存储值，所以，在多线程下，各个线程的user并不冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MiaoShaUser&gt; userHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(MiaoShaUser user)</span></span>&#123;</span><br><span class="line">        userHolder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MiaoShaUser <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p>其中ThreadLocal()源码如下<br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200718135610756.png)</p><h3 id="3-3-后序步骤解释"><a href="#3-3-后序步骤解释" class="headerlink" title="3.3 后序步骤解释"></a>3.3 后序步骤解释</h3><p><strong>方法后边比较简单啦</strong><br><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200718144817668.png)</p><h3 id="3-4-切莫忘记配置，不配置约等于不加拦截器"><a href="#3-4-切莫忘记配置，不配置约等于不加拦截器" class="headerlink" title="3.4 切莫忘记配置，不配置约等于不加拦截器"></a>3.4 切莫忘记配置，不配置约等于不加拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserArgumentResolver userArgumentResolver;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccessInterceptor accessInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class="line">        argumentResolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        InterceptorRegistration interceptorRegistration = registry.addInterceptor(accessInterceptor);</span><br><span class="line">        interceptorRegistration.addPathPatterns(<span class="string">"/miaosha/path"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure><p><img src="/Java-high-performance-and-high-concurrency-spike-system-9/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (8" alt="在这里插入图片描述">\20200718144110839.png)</p><p>在这个配置类中，我们重写的是addInterceptors方法，将拦截器注入进来，加到配置中，(指定要拦截的地址这一步可以省略掉了，因为我们使用的是注解标记，前边有一处写错，开始写的是没有注解的话，返回false，这样全局都被拦截了，应该写成true，这样才能放行），接下来就可以使用了！</p>]]></content>
    
    <summary type="html">
    
      安全优化,动态秒杀地址+数字公式验证码+接口限流防刷
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(8)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-8/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-8/</id>
    <published>2020-12-09T12:12:45.000Z</published>
    <updated>2020-12-13T14:43:40.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-秒杀接口优化思路"><a href="#1-秒杀接口优化思路" class="headerlink" title="1. 秒杀接口优化思路"></a>1. 秒杀接口优化思路</h2><blockquote><p>重点我们是要减少对数据库的访问</p></blockquote><ol><li>系统初始化时，将秒杀商品库存加载到Redis中</li><li>收到请求，在Redis中预减库存，库存不足时，直接返回秒杀失败</li><li>秒杀成功，将订单压入消息队列，返回前端消息“排队中”（像12306的买票）</li><li>消息出队，生成订单，减少库存</li><li>客户端在以上过程执行过程中，将一直轮询是否秒杀成功</li></ol><hr><h2 id="2-清晰框图解析"><a href="#2-清晰框图解析" class="headerlink" title="2. 清晰框图解析"></a>2. 清晰框图解析</h2><p><img src="/Java-high-performance-and-high-concurrency-spike-system-8/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (7" alt="在这里插入图片描述">\20200717154409401.png)</p><hr><h2 id="3-代码中我们如何实现"><a href="#3-代码中我们如何实现" class="headerlink" title="3. 代码中我们如何实现"></a>3. 代码中我们如何实现</h2><h3 id="3-1-库存预加载到Redis中"><a href="#3-1-库存预加载到Redis中" class="headerlink" title="3.1 库存预加载到Redis中"></a>3.1 库存预加载到Redis中</h3><p>这里我们是通过实现<code>InitialzingBean接口</code>，重写其中<code>afterProperties方法</code>达成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaController</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//系统启动的时候，就将数据存入Redis</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载所有秒杀商品</span></span><br><span class="line">        List&lt;GoodsVo&gt; goodsVos = goodsService.listGoodsVo();</span><br><span class="line">        <span class="keyword">if</span>(goodsVos == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//存入Redis中，各秒杀商品的数量</span></span><br><span class="line">        <span class="keyword">for</span> (GoodsVo good : goodsVos)&#123;</span><br><span class="line">            redisService.set(GoodsKey.miaoshaGoodsStockPrefix,<span class="string">""</span>+good.getId(),good.getStockCount());</span><br><span class="line">            map.put(good.getId(),<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><ol><li>我们先从数据库中将秒杀商品的信息读取出来，再一个一个加载到缓存中</li><li>注意一下其中有一个map，它添加了对应Id-false的键值对，它表示的是该商品没有被秒杀完，用于下文中，当商品秒杀完，阻止其对redis服务的访问（后文还会提到）</li></ol><h3 id="3-2-开始秒杀，预减库存"><a href="#3-2-开始秒杀，预减库存" class="headerlink" title="3.2 开始秒杀，预减库存"></a>3.2 开始秒杀，预减库存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//user不能为空，空了去登陆</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap内存标记，减少Redis访问时间</span></span><br><span class="line">        <span class="keyword">boolean</span> over = map.get(goodsId);</span><br><span class="line">        <span class="keyword">if</span>(over)</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收到请求，预减库存</span></span><br><span class="line">        Long count = redisService.decr(GoodsKey.miaoshaGoodsStockPrefix, <span class="string">""</span> + goodsId);</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            map.put(goodsId,<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><ol><li>首先用户不能为空</li><li>这里我们又看见了map，它写在了Redis服务前边，当商品秒杀完毕的时候，这样就能防止它再去访问Redis服务了</li><li>预减库存，库存小于0的时候就返回秒杀失败</li></ol><h3 id="3-3-加入消息队列中（Direct-Exchange）"><a href="#3-3-加入消息队列中（Direct-Exchange）" class="headerlink" title="3.3 加入消息队列中（Direct Exchange）"></a>3.3 加入消息队列中（Direct Exchange）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//判断是否已经秒杀过了</span></span><br><span class="line">        MiaoshaOrder miaoshaOrder = orderService.selectMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">        <span class="keyword">if</span>(miaoshaOrder != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入消息队列</span></span><br><span class="line">        MiaoshaMessage miaoshaMessage = <span class="keyword">new</span> MiaoshaMessage();</span><br><span class="line">        miaoshaMessage.setGoodsId(goodsId);</span><br><span class="line">        miaoshaMessage.setMiaoShaUser(user);</span><br><span class="line">        mqSender.sendMiaoshaMessage(miaoshaMessage);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><ol><li>在其之前我们有一个判断，判断该用户是不是重复秒杀，其实这一步是多余的，因为我们在数据库中已经建立了唯一索引，将userId和GoodsId绑定在了一起，不会生成重复的订单</li><li>自定义MiaoshaMessage类，创建对象，其中加入我们想要的user和goodsId信息，并将消息发出去</li></ol><h3 id="3-4-消息发送过程"><a href="#3-4-消息发送过程" class="headerlink" title="3.4 消息发送过程"></a>3.4 消息发送过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMiaoshaMessage</span><span class="params">(MiaoshaMessage miaoshaMessage)</span></span>&#123;</span><br><span class="line">        String msg = RedisService.beanToString(miaoshaMessage);</span><br><span class="line">        log.info(<span class="string">"miaosha send msg:"</span> + msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE,msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><ul><li>用SpringBoot框架提供的AmqpTemlplate实例来为我们的秒杀队列发送消息</li></ul><h3 id="3-5-消息出队处理"><a href="#3-5-消息出队处理" class="headerlink" title="3.5 消息出队处理"></a>3.5 消息出队处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQConfig.MIAOSHA_QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMiaoshaMsg</span><span class="params">(String miaoshaMessage)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"miaosha receive msg:"</span> + miaoshaMessage);</span><br><span class="line">        MiaoshaMessage msg = RedisService.stringToBean(miaoshaMessage, MiaoshaMessage<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> goodsId = msg.getGoodsId();</span><br><span class="line">        MiaoShaUser miaoShaUser = msg.getMiaoShaUser();</span><br><span class="line">        GoodsVo goodsVo = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断库存</span></span><br><span class="line">        <span class="keyword">int</span> stock = goodsVo.getStockCount();</span><br><span class="line">        <span class="keyword">if</span>(stock &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有库存而且没秒杀过，开始秒杀</span></span><br><span class="line">        miaoshaService.miaosha(miaoShaUser,goodsVo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><ul><li>判断库存是否还有，有的话，向下执行秒杀</li></ul><h4 id="3-5-1-秒杀方法"><a href="#3-5-1-秒杀方法" class="headerlink" title="3.5.1 秒杀方法"></a>3.5.1 秒杀方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">miaosha</span><span class="params">(MiaoShaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//库存减一</span></span><br><span class="line">        <span class="keyword">boolean</span> success = goodsService.reduceStock(goods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(success)</span><br><span class="line">            <span class="comment">//下订单</span></span><br><span class="line">            <span class="keyword">return</span> orderService.createOrder(user,goods);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            setGoodsOver(goods.getId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><ul><li>该方法我们用@Transactional注解标记，保证减库存和下订单都执行成功</li><li>注意其中有一个setGoodsOver()方法，它的作用是当该商品库存没有的时候，在redis中存一个标志，下面我们接着看</li></ul><h3 id="3-6-与前端进行交互的秒杀结果"><a href="#3-6-与前端进行交互的秒杀结果" class="headerlink" title="3.6 与前端进行交互的秒杀结果"></a>3.6 与前端进行交互的秒杀结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * orderId 成功</span></span><br><span class="line"><span class="comment">     * -1 秒杀失败</span></span><br><span class="line"><span class="comment">     * 0 继续轮询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> miaoShaUser</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> goodsId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/result"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Long&gt; <span class="title">miaoshaResult</span><span class="params">(MiaoShaUser miaoShaUser,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(miaoShaUser == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> result = miaoshaService.getMiaoshaResult(miaoShaUser.getId(),goodsId);</span><br><span class="line">        <span class="keyword">return</span> Result.success(result);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><ul><li>这里写了一个/resulet请求，前端会根据返回值，来判断秒杀的状态</li></ul><h4 id="3-6-1-getMiaoshaResult方法"><a href="#3-6-1-getMiaoshaResult方法" class="headerlink" title="3.6.1 getMiaoshaResult方法"></a>3.6.1 getMiaoshaResult方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMiaoshaResult</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        MiaoshaOrder order = orderService.selectMiaoshaOrderByUserIdGoodsId(userId, goodsId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(order != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//秒杀成功</span></span><br><span class="line">            <span class="keyword">return</span> order.getOrderId();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isOver = getGoodsOver(goodsId);</span><br><span class="line">            <span class="keyword">if</span>(isOver)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//继续轮询</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><ul><li>用户在秒杀该商品的过程中，在得到秒杀结果之前，会一直进行轮询，直到返回orderId或者-1来告知秒杀成功与失败</li><li>该方法中，从数据库中看看能不能查询到秒杀订单信息，有说明秒杀成功，返回订单号；失败了则获取redis中的是否秒杀完的标志，跟前边setGoodsOver()相对应，这里的getGoodsOver()便是对set的值进行获取，如果没有库存了则说明秒杀失败了，否则要继续轮询了（已经秒杀到，但是订单还没有创建完成）</li></ul>]]></content>
    
    <summary type="html">
    
      引入RabbitMQ后的秒杀优化
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(7)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-7/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-7/</id>
    <published>2020-12-08T12:17:45.000Z</published>
    <updated>2020-12-13T15:01:37.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-集成RabbitMQ"><a href="#1-集成RabbitMQ" class="headerlink" title="1. 集成RabbitMQ"></a>1. 集成RabbitMQ</h2><h3 id="1-1-添加依赖"><a href="#1-1-添加依赖" class="headerlink" title="1.1 添加依赖"></a>1.1 添加依赖</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716163301517.png)</p><h3 id="1-2-添加配置信息"><a href="#1-2-添加配置信息" class="headerlink" title="1.2 添加配置信息"></a>1.2 添加配置信息</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716163454589.png)</p><hr><h2 id="2-进行简单测试（Direct-Exchange）"><a href="#2-进行简单测试（Direct-Exchange）" class="headerlink" title="2. 进行简单测试（Direct Exchange）"></a>2. 进行简单测试（Direct Exchange）</h2><ul><li><strong>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue</strong></li></ul><h3 id="2-1-创建一个配置类"><a href="#2-1-创建一个配置类" class="headerlink" title="2.1 创建一个配置类"></a>2.1 创建一个配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_NAME,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-Bean注解"><a href="#2-1-1-Bean注解" class="headerlink" title="2.1.1 @Bean注解"></a>2.1.1 @Bean注解</h4><ul><li>@Bean注解就是要告诉<code>方法</code>，产生一个<code>Bean对象</code>，并将这个Bean由Spring容器管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Bean将放在IOC容器中。</li><li>SpringIOC容器管理一个或者多个Bean，这些Bean都需要在<code>@Configuration</code>注解下进行创建</li></ul><h3 id="2-2-创建消息的接受器"><a href="#2-2-创建消息的接受器" class="headerlink" title="2.2 创建消息的接受器"></a>2.2 创建消息的接受器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQConfig.QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive message:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h4 id="2-2-1-RabbitListener注解"><a href="#2-2-1-RabbitListener注解" class="headerlink" title="2.2.1 @RabbitListener注解"></a>2.2.1 @RabbitListener注解</h4><ul><li><code>@RabbitListener</code>，其中queues属性通过识别队列的名字来接受消息进行消费</li></ul><h3 id="2-3-创建消息的发送器"><a href="#2-3-创建消息的发送器" class="headerlink" title="2.3 创建消息的发送器"></a>2.3 创建消息的发送器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//AmqpTemplate接口定义了发送和接收消息的基本操作</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">        String msg = RedisService.beanToString(message);</span><br><span class="line">        log.info(<span class="string">"send message:"</span> + msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQConfig.QUEUE_NAME,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p>测试通过 ↓<br><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716165300289.png)</p><hr><h2 id="3-预先配置"><a href="#3-预先配置" class="headerlink" title="3. 预先配置"></a>3. 预先配置</h2><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716194032540.png)</p><hr><h2 id="4-Topic-Exchange"><a href="#4-Topic-Exchange" class="headerlink" title="4. Topic Exchange"></a>4. Topic Exchange</h2><ul><li><strong>任何发送到Topic Exchange的消息都会被转发到与routingKey匹配的队列上</strong></li></ul><h3 id="4-1-进行配置"><a href="#4-1-进行配置" class="headerlink" title="4.1 进行配置"></a>4.1 进行配置</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716194739570.png)</p><h3 id="4-2-编写消息发送者"><a href="#4-2-编写消息发送者" class="headerlink" title="4.2 编写消息发送者"></a>4.2 编写消息发送者</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716194916953.png)</p><h3 id="4-3-编写消息接收器"><a href="#4-3-编写消息接收器" class="headerlink" title="4.3 编写消息接收器"></a>4.3 编写消息接收器</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716195031442.png)</p><h3 id="4-4-测试结果"><a href="#4-4-测试结果" class="headerlink" title="4.4 测试结果"></a>4.4 测试结果</h3><ul><li>我们只绑定了队列1和队列2，根据消息发送者，会为队列1和队列2各发送一条消息，队列1和队列2各收到一条消息</li><li>测试内容<br><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\2020071619525022.png)</li><li>测试结果<br><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716195331704.png)</li></ul><hr><h2 id="5-Fanout-Exchange"><a href="#5-Fanout-Exchange" class="headerlink" title="5. Fanout Exchange"></a>5. Fanout Exchange</h2><ul><li><strong>任何发送到Fanout Exchange的消息都会被转发到与之绑定的队列上</strong></li></ul><h3 id="5-1-进行配置"><a href="#5-1-进行配置" class="headerlink" title="5.1 进行配置"></a>5.1 进行配置</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716195912138.png)</p><h3 id="5-2-编写消息发送者"><a href="#5-2-编写消息发送者" class="headerlink" title="5.2 编写消息发送者"></a>5.2 编写消息发送者</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\2020071620004565.png)</p><h3 id="5-3-编写消息接受器"><a href="#5-3-编写消息接受器" class="headerlink" title="5.3 编写消息接受器"></a>5.3 编写消息接受器</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716195031442-1607862601760.png)</p><h3 id="5-4-测试结果"><a href="#5-4-测试结果" class="headerlink" title="5.4 测试结果"></a>5.4 测试结果</h3><ul><li>根据条件，我们可以知道Fanout Exchange进行广播，每个队列都会收到消息</li><li>测试内容<img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716200231166.png)</li><li>测试结果<br><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\2020071620031624.png)</li></ul><hr><h2 id="6-Headers-Exchange"><a href="#6-Headers-Exchange" class="headerlink" title="6. Headers Exchange"></a>6. Headers Exchange</h2><ul><li><strong>任何发送到Headers Exchange的消息，都会和其中存储的条件进行匹配，有whereall和whereAny的区别（全部匹配/任何匹配）</strong></li></ul><h3 id="6-1-进行配置"><a href="#6-1-进行配置" class="headerlink" title="6.1 进行配置"></a>6.1 进行配置</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716193836266.png)</p><h3 id="6-2-编写消息发送者"><a href="#6-2-编写消息发送者" class="headerlink" title="6.2 编写消息发送者"></a>6.2 编写消息发送者</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716193713119.png)</p><h3 id="6-3-编写消息接收器"><a href="#6-3-编写消息接收器" class="headerlink" title="6.3 编写消息接收器"></a>6.3 编写消息接收器</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\20200716194217567.png)</p><h3 id="6-4-测试结果"><a href="#6-4-测试结果" class="headerlink" title="6.4 测试结果"></a>6.4 测试结果</h3><ul><li>根据匹配条件我们可以知道，只有3队列能接受到消息。</li><li>测试内容<img src="/Java-high-performance-and-high-concurrency-spike-system-7/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (6" alt="在这里插入图片描述">\2020071619431467.png)</li><li>测试结果</li></ul>]]></content>
    
    <summary type="html">
    
      Rabbit+接口优化
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(6)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-6/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-6/</id>
    <published>2020-12-08T12:14:45.000Z</published>
    <updated>2020-12-13T15:01:32.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-页面缓存优化"><a href="#1-页面缓存优化" class="headerlink" title="1. 页面缓存优化"></a>1. 页面缓存优化</h2><h3 id="1-1-未经优化之前的代码"><a href="#1-1-未经优化之前的代码" class="headerlink" title="1.1 未经优化之前的代码"></a>1.1 未经优化之前的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toList</span><span class="params">(Model model,MiaoShaUser user)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">        List&lt;GoodsVo&gt; goodsVos = goodsService.listGoodsVo();</span><br><span class="line">        model.addAttribute(<span class="string">"goodsList"</span>,goodsVos);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="1-2-优化产生的改变"><a href="#1-2-优化产生的改变" class="headerlink" title="1.2 优化产生的改变"></a>1.2 优化产生的改变</h3><p><img src="/Java-high-performance-and-high-concurrency-spike-system-6/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (5" alt="在这里插入图片描述">\20200714171300573.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/to_list"</span>,produces = <span class="string">"text/html"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toList</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model, MiaoShaUser user)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">    <span class="comment">//在有缓存的情况下，取出缓存</span></span><br><span class="line">    String html = redisService.get(GoodsKey.goodsKeyPrefix, <span class="string">""</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(! StringUtils.isEmpty(html)) <span class="keyword">return</span> html;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在没有缓存的时候，手动渲染，添加缓存</span></span><br><span class="line">    List&lt;GoodsVo&gt; goodsVos = goodsService.listGoodsVo();</span><br><span class="line">    model.addAttribute(<span class="string">"goodsList"</span>,goodsVos);</span><br><span class="line">    IWebContext ctx = <span class="keyword">new</span> WebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap());</span><br><span class="line">    html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">"goods_list"</span>,ctx);<span class="comment">//这里需要注入IContext</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(html))&#123;</span><br><span class="line">        redisService.set(GoodsKey.goodsKeyPrefix,<span class="string">""</span>,html);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">    <span class="comment">//return "goods_list";</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，我们应用缓存，一定要引入RedisService</li></ul><ol><li>@RequestMapping(value = “/to_list”,<code>produces = &quot;text/html&quot;</code>)produces标注了返回值的类型，必须与@ResponseBody搭配使用</li><li>手动渲染过程中，我们要注入<code>ThymeleafViewResolver</code>，这个是框架给我们准备好的Bean，利用它来渲染页面，其中第二个参数，需要注入<code>IContext</code></li><li>在<code>Spring5</code>版本中，<code>SpringWebContext</code>已经没有了，我们需要使用<code>WebContext</code>来代替。它剔除了之前对ApplicationContext 过多的依赖，现在thymeleaf渲染不再过多依赖spring容器</li><li>再者，我们对Redis缓存的时间设置了<code>60秒</code>的限制，超过60秒过期，这个时间不宜过长。在60秒内我们看到的网页一直一样是暂且可以接受的</li></ol><hr><h2 id="2-对象缓存与缓存更新"><a href="#2-对象缓存与缓存更新" class="headerlink" title="2. 对象缓存与缓存更新"></a>2. 对象缓存与缓存更新</h2><h3 id="2-1-对象缓存"><a href="#2-1-对象缓存" class="headerlink" title="2.1 对象缓存"></a>2.1 对象缓存</h3><p>对象缓存，我们之前已经做过了一个，就是在MiaoshaService中的<code>getByToken</code>方法，通过token值，从Redis中获取对象信息。<br>这次，我们实现一个getById()方法，即通过Id值，从Redis中获取user对象。（对象缓存<code>没有设置过期时间</code>，而且对象缓存是<code>粒度最小</code>的缓存）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> MiaoShaUser <span class="title">getById</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先从缓存中取</span></span><br><span class="line">        MiaoShaUser user = redisService.get(MiaoShaUserKey.idPrefix, <span class="string">""</span> + id, MiaoShaUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>) <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存中没有，从数据库中取，并且把它添加到缓存中</span></span><br><span class="line">        user = miaoShaUserDao.getById(id);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>) redisService.set(MiaoShaUserKey.idPrefix,<span class="string">""</span> + id,user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h3 id="2-2-缓存更新"><a href="#2-2-缓存更新" class="headerlink" title="2.2 缓存更新"></a>2.2 缓存更新</h3><p>我们模拟一个场景，我们要对密码进行修改，那么缓存也需要修改，现在先列出视频中给的方法，通过Id值取出用户，修改数据库，之后，对token-user缓存进行修改，id-user缓存进行删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updatePassword</span><span class="params">(<span class="keyword">long</span> id,String formPass,String token)</span></span>&#123;</span><br><span class="line">        <span class="comment">//取出user</span></span><br><span class="line">        MiaoShaUser user = getById(id);</span><br><span class="line">        <span class="comment">//没有这个用户</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.MOBILE_NOT_EXIST);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改密码，更新数据库</span></span><br><span class="line">        user.setPassword(MD5Util.formPassToDBPass(formPass,user.getSalt()));</span><br><span class="line">        miaoShaUserDao.update(user);</span><br><span class="line">        <span class="comment">//更新缓存,token-user缓存（登陆用的）这个不能删除，id-user缓存删除</span></span><br><span class="line">        redisService.set(MiaoShaUserKey.getTokenPrefix,token,user);</span><br><span class="line">        redisService.delete(MiaoShaUserKey.idPrefix,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><ul><li><strong>个人理解</strong>：我们上网时的多数场景，修改完密码之后都要我们进行重新登录，而且在我们这个项目中，登录的过程中会对token-user缓存进行重新添加，那么我们在修改密码的时候，可以直接将token-user和id-user全部都删除，而不需要对其中的缓存进行值的修改。</li></ul><hr><h2 id="3-页面静态化"><a href="#3-页面静态化" class="headerlink" title="3. 页面静态化"></a>3. 页面静态化</h2><h3 id="3-1-将商品详情页进行静态化处理（订单详情也做了静态化）"><a href="#3-1-将商品详情页进行静态化处理（订单详情也做了静态化）" class="headerlink" title="3.1 将商品详情页进行静态化处理（订单详情也做了静态化）"></a>3.1 将商品详情页进行静态化处理（订单详情也做了静态化）</h3><p>通常情况下，页面不采用第一种缓存的方式实现优化，而是通过静态化处理，比较常用的技术有Vue。通过静态化处理，我们将页面缓存在客户端浏览器中，不需要与服务器交互就能访问到页面。</p><p>以下，我们用JQuery实现。</p><h4 id="3-1-1-对后端代码进行处理"><a href="#3-1-1-对后端代码进行处理" class="headerlink" title="3.1.1 对后端代码进行处理"></a>3.1.1 对后端代码进行处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/detail/&#123;goodsId&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;GoodsDetailVo&gt; <span class="title">toDetail</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model, MiaoShaUser user, @PathVariable(<span class="string">"goodsId"</span>)</span> <span class="keyword">long</span> goodsId)</span>&#123;</span><br><span class="line"></span><br><span class="line">        GoodsVo goodsVo = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//秒杀开始、结束时间，当前时间</span></span><br><span class="line">        <span class="keyword">long</span> startDate = goodsVo.getStartDate().getTime();</span><br><span class="line">        <span class="keyword">long</span> endDate = goodsVo.getEndDate().getTime();</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//秒杀状态，0为没开始，1为正在进行，2为秒杀已经结束</span></span><br><span class="line">        <span class="keyword">int</span> miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//距离秒杀剩余的时间</span></span><br><span class="line">        <span class="keyword">int</span> remainSeconds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(now &lt; startDate)&#123;</span><br><span class="line">            <span class="comment">//秒杀没开始，进行倒计时</span></span><br><span class="line">            remainSeconds = (<span class="keyword">int</span>) (startDate - now) / <span class="number">1000</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(now &gt; endDate)&#123;</span><br><span class="line">            <span class="comment">//秒杀已经结束</span></span><br><span class="line">            miaoshaStatus = <span class="number">2</span>;</span><br><span class="line">            remainSeconds = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//秒杀进行时</span></span><br><span class="line">            remainSeconds = <span class="number">0</span>;</span><br><span class="line">            miaoshaStatus = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        GoodsDetailVo goodsDetailVo = <span class="keyword">new</span> GoodsDetailVo();</span><br><span class="line">        goodsDetailVo.setGoods(goodsVo);</span><br><span class="line">        goodsDetailVo.setUser(user);</span><br><span class="line">        goodsDetailVo.setMiaoshaStatus(miaoshaStatus);</span><br><span class="line">        goodsDetailVo.setRemainSeconds(remainSeconds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(goodsDetailVo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536</span></span><br></pre></td></tr></table></figure><ul><li>@RequestMapping中，去掉produces属性</li><li><code>去掉Model向前端传值的逻辑</code>，只留下业务处理过程，并将所需要的的值封装在<code>GoodsDetailVo</code>对象中</li><li><code>注意事项</code>在GoodsDetailVo中的属性字段要与前端所需要的字段名保持一致，如下所示，这样才能获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsDetailVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> miaoshaStatus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> remainSeconds;</span><br><span class="line">    <span class="keyword">private</span> GoodsVo goods;</span><br><span class="line">    <span class="keyword">private</span> MiaoShaUser user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>对应前端<br><img src="/Java-high-performance-and-high-concurrency-spike-system-6/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (5" alt="在这里插入图片描述">\20200714222548967.png)</p><h4 id="3-1-2-对前端跳转的修改"><a href="#3-1-2-对前端跳转的修改" class="headerlink" title="3.1.2 对前端跳转的修改"></a>3.1.2 对前端跳转的修改</h4><p>我们从商品列表页面跳转到商品详情页，修改为如下<br><img src="/Java-high-performance-and-high-concurrency-spike-system-6/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (5" alt="在这里插入图片描述">\20200714222755538.png)<br>注意其中<code>/goods_detail.htm</code>，它是放在static目录下的静态资源，为了防止视图解析器的跳转，将<code>html写为htm</code><br><img src="/Java-high-performance-and-high-concurrency-spike-system-6/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (5" alt="在这里插入图片描述">\20200714223101420.png)</p><h4 id="3-1-3-在application-properties中配置"><a href="#3-1-3-在application-properties中配置" class="headerlink" title="3.1.3 在application.properties中配置"></a>3.1.3 在application.properties中配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># static</span><br><span class="line">spring.resources.add-mappings=<span class="keyword">true</span></span><br><span class="line">spring.resources.cache.period= 3600 #缓存时间</span><br><span class="line">spring.resources.chain.cache=<span class="keyword">true</span> </span><br><span class="line">spring.resources.chain.enabled=<span class="keyword">true</span></span><br><span class="line">#spring.resources.chain.gzipped=true</span><br><span class="line">spring.resources.chain.html-application-cache=<span class="keyword">true</span></span><br><span class="line">spring.resources.<span class="keyword">static</span>-locations=classpath:/<span class="keyword">static</span>/</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h2 id="4-POST请求和GET请求的区别"><a href="#4-POST请求和GET请求的区别" class="headerlink" title="4. POST请求和GET请求的区别"></a>4. POST请求和GET请求的区别</h2><ul><li>GET：这个请求是幂等的，从服务端获取数据，反复获取不会对数据有影响。因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Etag，至少可以减少带宽消耗）</li><li>POST：该请求是不幂等的，它会在页面表单上提交数据，请求服务器的响应，往往会对数据进行修改</li></ul><h2 id="5-解决超卖问题"><a href="#5-解决超卖问题" class="headerlink" title="5. 解决超卖问题"></a>5. 解决超卖问题</h2><ol><li>当多个线程同时读取到同一个库存数量时，防止超卖，修改SQL语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加stock_count &gt; 0的条件</span></span><br><span class="line"><span class="keyword">update</span> miaosha_goods <span class="keyword">set</span> stock_count = stock_count - <span class="number">1</span> <span class="keyword">where</span> goods_id = <span class="comment">#&#123;goodsId&#125; and stock_count &gt; 0</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><ol><li>防止同一个用户秒杀多个，添加唯一索引，绑定user_id和goods_id，这样同一个用户对同一个商品的秒杀订单是唯一的</li></ol><p><img src="/Java-high-performance-and-high-concurrency-spike-system-6/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (5" alt="在这里插入图片描述">\20200715211412343.png)</p>]]></content>
    
    <summary type="html">
    
      页面缓存和对象缓存
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(5)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-5/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-5/</id>
    <published>2020-12-08T12:12:45.000Z</published>
    <updated>2020-12-13T14:43:26.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JMeter压力测试"><a href="#1-JMeter压力测试" class="headerlink" title="1. JMeter压力测试"></a>1. JMeter压力测试</h2><h3 id="1-1-测试过程"><a href="#1-1-测试过程" class="headerlink" title="1.1 测试过程"></a>1.1 测试过程</h3><ol><li>打开jmeter.bat<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713193736717.png)</li><li>设置HTTP默认请求<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713193845955.png)<br>编写协议和端口号<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713193919346.png)</li><li>编写测试HTTP请求<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713194035109.png)<br>因为我们已经写过<code>默认设置</code>，我们就可以不用编写协议和地址了，如下，只需编写<code>请求类型</code>和<code>地址</code>即可<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\2020071319414434.png)</li><li>添加聚合报告</li></ol><p>我们即可在报告中查看压测信息<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713194305250.png)</p><h3 id="1-2-Linux-top命令"><a href="#1-2-Linux-top命令" class="headerlink" title="1.2 Linux top命令"></a>1.2 Linux top命令</h3><ul><li>top：相当于Windows下的任务管理器，可以动态显示当前进程的状况</li></ul><hr><h2 id="2-自定义配置文件JMeter压测"><a href="#2-自定义配置文件JMeter压测" class="headerlink" title="2. 自定义配置文件JMeter压测"></a>2. 自定义配置文件JMeter压测</h2><h3 id="2-1-测试过程"><a href="#2-1-测试过程" class="headerlink" title="2.1 测试过程"></a>2.1 测试过程</h3><p>与上方基本一致，不过，要在测试的请求上，<code>添加CSV数据文件设置</code><br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713195835161.png)<br>读取我们自己编写的配置文件，并且标注变量名称，如此，即可开始压测。<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713195944979.png)<br>其中配置文件信息，用英文逗号隔开<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713201121978.png)</p><hr><h2 id="3-Redis压测"><a href="#3-Redis压测" class="headerlink" title="3. Redis压测"></a>3. Redis压测</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#100个并发连接，100000个请求</span></span><br><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000</span><br><span class="line"></span><br><span class="line"><span class="comment">#存取大小为100字节的数据包</span></span><br><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试set和lpush命令的QPS，其中-q为简化输出</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,lpush -q -n 1000000</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试单条命令的QPS</span></span><br><span class="line">redis-benchmark -n 100000 -q script load <span class="string">"redis.call('set','foo','bar')"</span></span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure><hr><h2 id="4-Linux环境下，命令行压测"><a href="#4-Linux环境下，命令行压测" class="headerlink" title="4. Linux环境下，命令行压测"></a>4. Linux环境下，命令行压测</h2><ol><li>在Windows目录下写好<code>jmx文件</code></li><li>命令行：<code>sh jmeter.sh -n -t xxx.jmx -l result.jtl</code></li><li>再将result.jtl<code>导入到jmeter中</code></li></ol><h3 id="4-1-打成jar包"><a href="#4-1-打成jar包" class="headerlink" title="4.1 打成jar包"></a>4.1 打成jar包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maven clean package</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>打开jar包，我们进入META-INF目录下，打开MANIFEST.MF文件，我们可以发现如下语句<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713211114969.png)<br>其中Main-Class为SpringBoot框架的启动类，在这个类中可以跟进看源码<br>Start-Class为我们自己编写的启动类</p><h3 id="4-2-上传到Linux服务器上"><a href="#4-2-上传到Linux服务器上" class="headerlink" title="4.2 上传到Linux服务器上"></a>4.2 上传到Linux服务器上</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行如下命令，之后即可根据如下地址访问</span></span><br><span class="line"><span class="comment">#http://182.92.xxx.xxx:8080/login</span></span><br><span class="line">java -jar miaosha.jar </span><br><span class="line">123</span><br></pre></td></tr></table></figure><h3 id="4-3-编写-jmx文件"><a href="#4-3-编写-jmx文件" class="headerlink" title="4.3 编写.jmx文件"></a>4.3 编写.jmx文件</h3><p>在Windows上用JMeter<code>编写.jmx脚本</code>，上传到服务器上，执行如下命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmeter.sh -n -t good_list.jmx -l result.jtl </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>之后，下载result.jtl到Windows本地，进行报告分析</p><hr><h2 id="5-SpringBoot-打war包"><a href="#5-SpringBoot-打war包" class="headerlink" title="5. SpringBoot 打war包"></a>5. SpringBoot 打war包</h2><ol><li>在pom.xml文件中，添加打包为war包的标签</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ol><li>添加tomcat provided编译时的依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><ol><li>在主类中，<code>实现SpringBootServletInitializer，重写configure()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MiaoshaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(MiaoshaApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><ol><li>将ROOT目录删除，并且把我们的war包修改为ROOT.war，放在webapps目录下，即可访问<br><img src="/Java-high-performance-and-high-concurrency-spike-system-5/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (4" alt="在这里插入图片描述">\20200713203204970.png)</li></ol><hr>]]></content>
    
    <summary type="html">
    
      JMeter压力测试
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(4)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-4/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-4/</id>
    <published>2020-12-07T12:13:45.000Z</published>
    <updated>2020-12-13T15:01:23.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实现联表查询的一个小技巧"><a href="#1-实现联表查询的一个小技巧" class="headerlink" title="1. 实现联表查询的一个小技巧"></a>1. 实现联表查询的一个小技巧</h2><p><img src="https://img-blog.csdnimg.cn/20200712214753389.png#pic_center" alt="在这里插入图片描述"><br>商品表和秒杀商品表是两个互相独立的表，其中的关联为<code>goods_id</code>，但是我要返回的对象，既想要商品表中的字段，又想要秒杀商品表中的字段，用下面这个方法，有点儿亮眼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsVo</span> <span class="keyword">extends</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Double miaoshaPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer stockCount;</span><br><span class="line">    <span class="keyword">private</span> Date startDate;</span><br><span class="line">    <span class="keyword">private</span> Date endDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>创建一个GoodsVo类，继承Goods类，再将<code>秒杀商品表中特有的字段</code>，添加进去即可</p><h3 id="1-1-左联表查询SQL语句"><a href="#1-1-左联表查询SQL语句" class="headerlink" title="1.1 左联表查询SQL语句"></a>1.1 左联表查询SQL语句</h3><ul><li>查询所有的商品</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    @<span class="keyword">Select</span>(<span class="string">"select g.*,mg.stock_count,mg.miaosha_price,mg.start_date,mg.end_date from miaosha_goods mg left join goods g on mg.goods_id = g.id"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;GoodsVo&gt; listGoodsVo();</span><br><span class="line">12</span><br></pre></td></tr></table></figure><ul><li>根据id获取商品</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    @<span class="keyword">Select</span>(<span class="string">"select g.*,mg.stock_count,mg.miaosha_price,mg.start_date,mg.end_date from miaosha_goods mg left join goods g on mg.goods_id = g.id where mg.goods_id = #&#123;goodId&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> GoodsVo getGoodsVoByGoodsId(@Param(<span class="string">"goodId"</span>)<span class="keyword">long</span> goodId);</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="1-2-Druid数据库连接池中url地址的写法"><a href="#1-2-Druid数据库连接池中url地址的写法" class="headerlink" title="1.2 Druid数据库连接池中url地址的写法"></a>1.2 Druid数据库连接池中url地址的写法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://xxx.xx.xxx.xxx:3306/miaosha?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;useTimezone=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li><code>serverTimezone=GMT%2B8</code>:时区为GMT%2B8</li></ul><hr><h2 id="2-商品详情页对RestFul风格的使用"><a href="#2-商品详情页对RestFul风格的使用" class="headerlink" title="2. 商品详情页对RestFul风格的使用"></a>2. 商品详情页对RestFul风格的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"to_detail/&#123;goodsId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toDetail</span><span class="params">(Model model, MiaoShaUser user, @PathVariable(<span class="string">"goodsId"</span>)</span> <span class="keyword">long</span> goodsId)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><ul><li><code>@RequestMapping</code>指定的映射URL，其中有用{}括起来的参数，在方法的形参处，用<code>@PathVariable</code>注解对其进行获取</li></ul><hr><h2 id="3-秒杀功能实现的逻辑"><a href="#3-秒杀功能实现的逻辑" class="headerlink" title="3. 秒杀功能实现的逻辑"></a>3. 秒杀功能实现的逻辑</h2><p><img src="/Java-high-performance-and-high-concurrency-spike-system-4/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本 (3" alt="在这里插入图片描述">\20200712231043251.png)</p><h3 id="3-1-减少库存的sql语句"><a href="#3-1-减少库存的sql语句" class="headerlink" title="3.1 减少库存的sql语句"></a>3.1 减少库存的sql语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    @<span class="keyword">Update</span>(<span class="string">"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;"</span>)</span><br><span class="line">    <span class="built_in">void</span> reduceStock(MiaoshaGoods miaoshaGoods);</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="3-2-创建订单的sql语句"><a href="#3-2-创建订单的sql语句" class="headerlink" title="3.2 创建订单的sql语句"></a>3.2 创建订单的sql语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @<span class="keyword">Insert</span>(<span class="string">"insert into order_info (user_id,goods_id,goods_name,goods_count,goods_price,order_channel,status,create_date)"</span> +</span><br><span class="line">            <span class="string">"values(#&#123;userId&#125;,#&#123;goodsId&#125;,#&#123;goodsName&#125;,#&#123;goodsCount&#125;,#&#123;goodsPrice&#125;,#&#123;orderChannel&#125;,#&#123;status&#125;,#&#123;createDate&#125;)"</span> )</span><br><span class="line">    @SelectKey(<span class="keyword">statement</span> = <span class="string">"select last_insert_id()"</span>,keyProperty = <span class="string">"id"</span>,resultType = long.class,<span class="keyword">before</span> = <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">insert</span>(OrderInfo orderInfo);</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h3 id="3-3-SelectKey-注解"><a href="#3-3-SelectKey-注解" class="headerlink" title="3.3 @SelectKey()注解"></a>3.3 @SelectKey()注解</h3><ul><li><code>需要前置注解</code>：@Insert 或 @InsertProvider 或 @Update 或 @UpdateProvider，否则无效。</li><li>statement：填入将会被执行的 SQL 字符串</li><li>keyProperty属性：填入将会被更新的参数对象的属性</li><li>before属性：填入 true 或 false 以指明 SQL 语句应被在插入语句的之前还是之后执行</li><li>resultType属性：填入 keyProperty 的 Java 类型</li></ul><h4 id="3-3-1-获取主键值的注意事项"><a href="#3-3-1-获取主键值的注意事项" class="headerlink" title="3.3.1 获取主键值的注意事项"></a>3.3.1 获取主键值的注意事项</h4><p>可能我们在执行完插入方法后，想如下这样通过获取返回值的方法来获取主键id值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> orderId = orderDao.insert(orderInfo)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>然而并不是这样，<code>因为执行插入sql语句返回值只有两种情况</code>，一种是插入成功返回1，另一种是插入失败，返回0，所以若这里出现一直获取到1值的问题，用如下方法解决</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderInfo.getId();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>因为，@SelectKey()会将值直接映射到实体类的属性上进行修改，要想获取主键值，只能这样获取，不能通过返回值获取</p>]]></content>
    
    <summary type="html">
    
      秒杀功能的实现
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(3)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-3/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-3/</id>
    <published>2020-12-07T12:12:45.000Z</published>
    <updated>2020-12-13T14:43:15.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实现分布式Session"><a href="#1-实现分布式Session" class="headerlink" title="1. 实现分布式Session"></a>1. 实现分布式Session</h2><h3 id="1-1-原理图解"><a href="#1-1-原理图解" class="headerlink" title="1.1 原理图解"></a>1.1 原理图解</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img-blog.csdnimg.cn/20200710172401826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MjI1ODg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li><strong>作用</strong>：用<code>Redis存储Session值</code>，在Redis中<code>通过token值来获取用户信息</code></li></ul><h3 id="1-2-每次登陆，将Session的过期时间进行修正"><a href="#1-2-每次登陆，将Session的过期时间进行修正" class="headerlink" title="1.2 每次登陆，将Session的过期时间进行修正"></a>1.2 每次登陆，将Session的过期时间进行修正</h3><ul><li>怎么说呢？我们的Session值固定过期时间为30min，要在每次登陆的时候，<code>以当前时间继续顺延30分钟</code></li><li>我们的<code>解决方法</code>就是，每次登陆时，重新再添加一次Cookie，则能够完成时间延长</li></ul><p>以下是<code>封装addCookie()</code>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(HttpServletResponse response, MiaoShaUser user, String token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首次登陆的时候，需要将Cookie存入Redis</span></span><br><span class="line">        redisService.set(MiaoShaUserKey.getTokenPrefix,token,user);</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(COOKIE_NAME_TOKEN, token);</span><br><span class="line">        cookie.setMaxAge(MiaoShaUserKey.getTokenPrefix.expireSeconds());</span><br><span class="line">        <span class="comment">//设置为根目录，则可以在整个应用范围内使用cookie</span></span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h3 id="1-3-Cookie有什么用？"><a href="#1-3-Cookie有什么用？" class="headerlink" title="1.3 Cookie有什么用？"></a>1.3 Cookie有什么用？</h3><p>在我们这个项目中，Cookie中存储的是token值。而这个token值是和用户信息是一一绑定的，将会存储在Redis中。我们从Cookie中获取到token，从而就可以获取到用户，下面简化代码的过程，便是对这一过程的演示。</p><h3 id="1-4-分布式Session的理解"><a href="#1-4-分布式Session的理解" class="headerlink" title="1.4 分布式Session的理解"></a>1.4 分布式Session的理解</h3><p>服务器中的原生session是无法满足需求的，因为用户的请求有可能随机落入到不同的服务器中，这样的结果将会导致用户的session丢失，传统做法中有解决方案，是进行session同步，将一个服务器上的session进行同步到另一个服务器上，在一个集群中无论你访问哪个服务器都可以共享，但是这种方法有个明显缺陷，就是性能问题，传输有时延问题，其次这样每台服务器的session重复拥有，这样其内存必然受到影响，如果只有几台服务器还好，如果是十台，二十台服务器呢？这种恐怖的场景会是什么样的体验呢，我就无法得知了。</p><p>那么我们应该如何有效的解决这样的问题呢，我们可以使用传说中的token来解决，简单明了的说就是用户每次登陆的时候生成一个类似sessionId的东西（也就是所谓的token，这将是全局的唯一标识，如UUID，作用类似于（sessionId）），将其写到cookie当中传送给客户端，客户端对数据库访问过程中不断上传这个token，而我们服务端拿到这个token就可以获取用户的信息，这个道理其实在很多地方是相通的，比如我们容器中实现原生session，也是将生成的id写入cookie当中。</p><hr><h2 id="2-解决注解获取参数造成的代码冗余"><a href="#2-解决注解获取参数造成的代码冗余" class="headerlink" title="2. 解决注解获取参数造成的代码冗余"></a>2. 解决注解获取参数造成的代码冗余</h2><p><strong>我们看一下，如下代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toList</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @CookieValue(value = MiaoShaUserService.COOKIE_NAME_TOKEN,required = <span class="keyword">false</span>)</span> String cookieToken,</span></span><br><span class="line"><span class="function">                         @<span class="title">RequestParam</span><span class="params">(value = MiaoShaUserService.COOKIE_NAME_TOKEN,required = <span class="keyword">false</span>)</span> String paramToken,</span></span><br><span class="line"><span class="function">                         )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;</span><br><span class="line">        MiaoShaUser user = miaoShaUserService.getByToken(response,token);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><ul><li><code>@CookieValue</code>：这个注解能够根据参数value在Cookie中获取值</li><li><code>@RequestParam</code>：该注解让我们在Request中能获取参数，解决的主要是，移动手机端不使用Cookie存值的问题</li></ul><p>我们在如上代码中，可以发现，注解标记获取参数，使得代码很厚重，若我们每次想从Cookie中获取token值时，都需要复现如上代码，所以我们要把它剖离出来</p><h3 id="2-1-WebMvcConfigurerAdapter"><a href="#2-1-WebMvcConfigurerAdapter" class="headerlink" title="2.1 WebMvcConfigurerAdapter"></a>2.1 WebMvcConfigurerAdapter</h3><p>在这个项目中，我们采用的是继承<code>WebMvcConfigurerAdapter</code>，重写其中<code>addArgumentResolvers()方法</code>，该方法实现的是<code>参数解析的功能</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserArgumentResolver userArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class="line">        argumentResolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-该方法在Spring5-0之后就过时了"><a href="#2-1-1-该方法在Spring5-0之后就过时了" class="headerlink" title="2.1.1 该方法在Spring5.0之后就过时了"></a>2.1.1 该方法在Spring5.0之后就过时了</h4><ul><li><strong>现用方式</strong></li></ul><ol><li>实现WebMvcConfigurer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><ol><li>继承WebMVCConfigurationSupport</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h3 id="2-2-在argumentResolvers中添加我们的参数解析逻辑"><a href="#2-2-在argumentResolvers中添加我们的参数解析逻辑" class="headerlink" title="2.2 在argumentResolvers中添加我们的参数解析逻辑"></a>2.2 在argumentResolvers中添加我们的参数解析逻辑</h3><ul><li>首先，我们应该搞清楚，我们想要的参数是什么？回看代码冗余的问题，最终我们想获取的是<code>MiaoShaUser</code>，这下我们进行代码的编写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoShaUserService miaoShaUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个方法判断参数类型是否支持</span></span><br><span class="line">        Class&lt;?&gt; clazz = methodParameter.getParameterType();</span><br><span class="line">        <span class="keyword">return</span> clazz == MiaoShaUser<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//这个方法实现对参数的处理</span></span><br><span class="line">        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String paramToken = request.getParameter(miaoShaUserService.COOKIE_NAME_TOKEN);</span><br><span class="line">        String cookieToken = getCookieValue(request, miaoShaUserService.COOKIE_NAME_TOKEN);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(paramToken) &amp;&amp; StringUtils.isEmpty(cookieToken))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> miaoShaUserService.getByToken(response,token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request,String cookieName)</span></span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(cookieName))&#123;</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure><ul><li>实现<code>HandlerMethodArgumentResolver接口</code>，必须重写其中的两个方法，<code>supportsParameter()</code>和<code>resolveArgument()</code></li><li>前者是对我们要进行解析的<code>参数类型</code>进行判断，符合才执行后者</li><li>后者是我们对<code>参数的处理逻辑</code>，两种情况，一是从request中获取token值，二是从cookie中拿取token值，根据token值来获取到对应的user</li></ul><p>以上就将我们需要的参数的处理逻辑实现了，在Mvc配置中，用<code>argumentResolvers.add(userArgumentResolver)</code>方法进行添加即可，这样我们再想获取user的时候就简单多了，如下</p><h3 id="2-3-如此清爽的代码"><a href="#2-3-如此清爽的代码" class="headerlink" title="2.3 如此清爽的代码"></a>2.3 如此清爽的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toList</span><span class="params">(Model model,MiaoShaUser user)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>省去了@CookieValue和@RequestParam注解的冗余，而且我们对user的获取也方便多了</p>]]></content>
    
    <summary type="html">
    
      实现分布式Session
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统(2)</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-2/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system-2/</id>
    <published>2020-12-06T12:13:45.000Z</published>
    <updated>2020-12-13T15:01:17.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-登录过程中，密码两次MD5加密"><a href="#1-登录过程中，密码两次MD5加密" class="headerlink" title="1. 登录过程中，密码两次MD5加密"></a>1. 登录过程中，密码两次MD5加密</h2><h3 id="1-1-为啥用两次MD5哇？"><a href="#1-1-为啥用两次MD5哇？" class="headerlink" title="1.1 为啥用两次MD5哇？"></a>1.1 为啥用两次MD5哇？</h3><ol><li>第一次MD5，是针对<code>传输安全</code>做的MD5加密，因为<code>http是明文传递</code>，如果不进行加密的话，密码就直接被劫持了。<br>(Password1 = MD5(inputPassword,固定的salt值)，salt为字符串)</li><li>第二次MD5，是针对<code>数据库安全</code>做的MD5加密，保证数据库的防盗安全。若不进行二次加密，MD5值经数据库获取，可直接被MD5转换器直接转换为用户密码，不安全。<br>(Password2 = MD5(Password1,随机的salt值))</li></ol><hr><h2 id="2-构建数据库表"><a href="#2-构建数据库表" class="headerlink" title="2. 构建数据库表"></a>2. 构建数据库表</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="/Java-high-performance-and-high-concurrency-spike-system-2/Blog\source\_posts\Java高性能高并发秒杀系统 - 副本\20200709182209155.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-1-几个需要注意的点"><a href="#2-1-几个需要注意的点" class="headerlink" title="2.1 几个需要注意的点"></a>2.1 几个需要注意的点</h3><ul><li>字符集采用的是<code>utf8mb4</code>(most bytes 4)。简单来说，utf8mb4是<code>utf8的超集</code>，能够用<code>4个字节</code>存储更多的字符。标准UTF-8字符集编码可以用1~4个字节取编码21位字符，但是在<code>MySQL中，utf8最多使用3个字节</code>，像一些表情emoji和不常用的字符如“墅”需要用4个字节才能表示出来。用utf8mb4能解决以上问题。</li><li>数据库中存储了<code>&quot;动态&quot;salt值</code></li></ul><hr><h2 id="3-针对MD5加密功能，封装了专用工具类"><a href="#3-针对MD5加密功能，封装了专用工具类" class="headerlink" title="3. 针对MD5加密功能，封装了专用工具类"></a>3. 针对MD5加密功能，封装了专用工具类</h2><p>以下MD5包的Maven依赖了解以下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><h3 id="3-1-工具类代码"><a href="#3-1-工具类代码" class="headerlink" title="3.1 工具类代码"></a>3.1 工具类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态的salt，用于第一次MD5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String salt = <span class="string">"1a2b3c4d"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String src)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用DigestUtils，实现md5处理</span></span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次MD5处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputPass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">inputPassToFormPass</span><span class="params">(String inputPass)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里没加“”出现了问题？？？</span></span><br><span class="line">        String pass =<span class="string">""</span> + salt.charAt(<span class="number">1</span>) + salt.charAt(<span class="number">7</span>) + inputPass</span><br><span class="line">                + salt.charAt(<span class="number">3</span>) + salt.charAt(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//System.out.println(pass);</span></span><br><span class="line">        <span class="keyword">return</span> md5(pass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure><ul><li>我在第一次处理加密时，拼接<code>字符</code>时没有添加<code>&quot;&quot;</code>，出现了登录验证失败的问题</li></ul><hr><h2 id="4-加入JSR参数校验"><a href="#4-加入JSR参数校验" class="headerlink" title="4. 加入JSR参数校验"></a>4. 加入JSR参数校验</h2><h3 id="4-1-JSR参数校验"><a href="#4-1-JSR参数校验" class="headerlink" title="4.1 JSR参数校验"></a>4.1 JSR参数校验</h3><ul><li>我们看如下，代码，在登录处理过程中，我们要用<code>代码</code>实现对前端传过来的id和password进行校验（我们这里是验证<code>非空</code>），引入JSR参数校验之后，能够将这些代码省去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/do_login"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title">doLogin</span><span class="params">(LoginVo loginVo)</span></span>&#123;</span><br><span class="line">        log.info(loginVo.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        String mobile = loginVo.getMobile();</span><br><span class="line">        String password = loginVo.getPassword();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(password))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.PASSWORD_EMPTY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(! ValidatorUtil.isMobile(mobile))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.MOBILE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CodeMsg msg = miaoShaUserService.login(loginVo);</span><br><span class="line">        <span class="keyword">if</span>(msg.getCode() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure><ul><li>进行JSR参数校验升级</li></ul><p>我们先看一下导入的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>我们在doLogin()方法上，加上JSR验证，<code>@Valid</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;CodeMsg&gt; <span class="title">doLogin</span><span class="params">(@Valid LoginVo loginVo)</span></span></span><br><span class="line"><span class="function">1</span></span><br></pre></td></tr></table></figure><p>被标注的参数，我们进入它的实现类中，对其中的字段进行约束，如下（<code>@NotNull</code>，<code>@Length</code>，<code>@IsMobile</code>，其中@IsMobile是我们自定义的注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IsMobile</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h3 id="4-2-IsMobile自定义注解"><a href="#4-2-IsMobile自定义注解" class="headerlink" title="4.2 @IsMobile自定义注解"></a>4.2 @IsMobile自定义注解</h3><p>我们看一下它的代码（这个注解的写法，根据已有注解@NotNull，仿写而来），它实现的是对手机号码的验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(</span><br><span class="line">        validatedBy = &#123;IsMobileValidator<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">IsMobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下三条语句，足矣</span></span><br><span class="line"><span class="comment">//我们在其中添加错误信息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "手机号码格式错误"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><ul><li><code>@Target</code>：表示的是能够标注的范围</li><li><code>@Constraint</code>：这个注解帮助我们处理逻辑，其中有<code>IsMobileValidator.class</code>是真正处理逻辑的类，我们看看它的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(required)&#123;</span><br><span class="line">            <span class="comment">//在必须有值的情况下</span></span><br><span class="line">            <span class="keyword">return</span> ValidatorUtil.isMobile(s);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在不要求有值的情况下</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(s))&#123;</span><br><span class="line">                <span class="comment">//空值是允许的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//有值就给它判断判断</span></span><br><span class="line">                <span class="keyword">return</span> ValidatorUtil.isMobile(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        required = constraintAnnotation.required();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><ul><li>先看类的声明部分，public class IsMobileValidator implements <code>ConstraintValidator</code>，它有两个泛型，第一个是<code>自定义的注解类</code>，第二个是要<code>验证的参数类型</code>，另外实现该接口的逻辑类，<code>被spring管理成bean</code>，可以在需要的地方进行装配</li><li>其中有一个<code>initialize</code>，初始化方法，它调用的是我们自定义注解中写的<code>required()</code>方法，默认需要有值</li><li>另一个方法<code>isValid</code>，则对逻辑进行验证，true验证通过，false验证失败</li></ul><hr><h2 id="5-全局异常处理器"><a href="#5-全局异常处理器" class="headerlink" title="5. 全局异常处理器"></a>5. 全局异常处理器</h2><h3 id="5-1-我们为什么要引入全局异常处理器？"><a href="#5-1-我们为什么要引入全局异常处理器？" class="headerlink" title="5.1 我们为什么要引入全局异常处理器？"></a>5.1 我们为什么要引入全局异常处理器？</h3><ul><li>一边想，一边看一下下面这个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> CodeMsg <span class="title">login</span><span class="params">(LoginVo loginVo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loginVo == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> CodeMsg.SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String mobile = loginVo.getMobile();</span><br><span class="line">        String password = loginVo.getPassword();</span><br><span class="line">        <span class="comment">//判断手机号是否存在</span></span><br><span class="line">        MiaoShaUser user = getById(Long.parseLong(mobile));</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> CodeMsg.MOBILE_NOT_EXIST;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证密码</span></span><br><span class="line">        String DBPass = user.getPassword();</span><br><span class="line">        <span class="comment">//这里对前端来的密码第二次MD5处理</span></span><br><span class="line">        String formPassToDBPass = MD5Util.formPassToDBPass(password, user.getSalt());</span><br><span class="line">        <span class="keyword">if</span>(!formPassToDBPass.equals(DBPass))&#123;</span><br><span class="line">            <span class="keyword">return</span> CodeMsg.PASSWORD_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CodeMsg.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>它的返回值是CodeMsg，而在业务中，方法对应的返回值应该是<code>确切的</code>，我们登陆，返回应该为 true 或 false，所以，我们要对这里进行优化</p><h3 id="5-2-优化"><a href="#5-2-优化" class="headerlink" title="5.2 优化"></a>5.2 优化</h3><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(LoginVo loginVo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loginVo == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String mobile = loginVo.getMobile();</span><br><span class="line">        String password = loginVo.getPassword();</span><br><span class="line">        <span class="comment">//判断手机号是否存在</span></span><br><span class="line">        MiaoShaUser user = getById(Long.parseLong(mobile));</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.MOBILE_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证密码</span></span><br><span class="line">        String DBPass = user.getPassword();</span><br><span class="line">        <span class="comment">//这里对前端来的密码第二次MD5处理</span></span><br><span class="line">        String formPassToDBPass = MD5Util.formPassToDBPass(password, user.getSalt());</span><br><span class="line">        <span class="keyword">if</span>(!formPassToDBPass.equals(DBPass))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.PASSWORD_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>我们可以发现，对应的参数验证，并没有返回值，而是直接<code>抛出异常</code>，而且我们也将<code>返回值进行了修改</code>，执行到方法的最后，能够返回ture</p><h3 id="5-3-全局异常"><a href="#5-3-全局异常" class="headerlink" title="5.3 全局异常"></a>5.3 全局异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CodeMsg codeMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlobalException</span><span class="params">(CodeMsg codeMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.codeMsg = codeMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodeMsg <span class="title">getCodeMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> codeMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><ul><li>全局异常就比较简单了，它<code>继承了RuntimeException类</code>，其中包含我们需要返回的信息CodeMsg的字段</li></ul><h3 id="5-4-全局异常处理器"><a href="#5-4-全局异常处理器" class="headerlink" title="5.4 全局异常处理器"></a>5.4 全局异常处理器</h3><p>这个处理器可就值得说一说了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span>&lt;<span class="title">String</span>&gt; <span class="title">exceptionHandler</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>,<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> GlobalException)&#123;</span><br><span class="line">            GlobalException ge = (GlobalException) e;</span><br><span class="line"></span><br><span class="line">            CodeMsg codeMsg = ge.getCodeMsg();</span><br><span class="line">            <span class="keyword">return</span> Result.error(codeMsg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BindException)&#123;</span><br><span class="line">            <span class="comment">//获取错误列表，拿取其中的第一个</span></span><br><span class="line">            BindException be = (BindException) e;</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = be.getAllErrors();</span><br><span class="line">            ObjectError error = allErrors.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            String message = error.getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.BIND_ERROR.fillArgs(message));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure><ul><li><code>@ControllerAdvice</code>：它是增强的Controller，能够实现<code>全局异常处理</code>和全局数据绑定</li><li>配合<code>@ExceptionHandler(value = Exception.class)</code>，它能够实现对所有异常的接受，而在方法中，对不同的异常进行处理</li></ul><hr><h2 id="6-关注一下参数替换的方法"><a href="#6-关注一下参数替换的方法" class="headerlink" title="6. 关注一下参数替换的方法"></a>6. 关注一下参数替换的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CodeMsg BIND_ERROR = <span class="keyword">new</span> CodeMsg(<span class="number">500101</span>,<span class="string">"参数校验异常：%s"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodeMsg <span class="title">fillArgs</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = <span class="keyword">this</span>.code;</span><br><span class="line">        String message = String.format(<span class="keyword">this</span>.msg, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CodeMsg(code,message);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul><li>其中<code>String.format()</code>能够根据传入的字符串格式，比如”参数校验异常：%s”，其中<code>%s</code>，能被第二个传入的参数进行替换，从而形成<code>动态的字符串</code></li></ul>]]></content>
    
    <summary type="html">
    
      MD5加密和全局异常处理器
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能高并发秒杀系统</title>
    <link href="https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system/"/>
    <id>https://kayleh.top/Java-high-performance-and-high-concurrency-spike-system/</id>
    <published>2020-12-06T12:12:45.000Z</published>
    <updated>2020-12-13T14:43:01.788Z</updated>
    
    <content type="html"><![CDATA[<h6 id="CSDN方-圆"><a href="#CSDN方-圆" class="headerlink" title="@CSDN方 圆"></a><em>@CSDN方 圆</em></h6><h2 id="1-集成Mybatis"><a href="#1-集成Mybatis" class="headerlink" title="1. 集成Mybatis"></a>1. 集成Mybatis</h2><blockquote><p>我觉得在集成Mybatis时问题并不大</p></blockquote><h3 id="1-1-新接触的不用xml文件写Mapper文件"><a href="#1-1-新接触的不用xml文件写Mapper文件" class="headerlink" title="1.1 新接触的不用xml文件写Mapper文件"></a>1.1 新接触的不用xml文件写Mapper文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">selectById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (id,name) values (#&#123;id&#125;,#&#123;name&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解<code>@Mapper</code>，标记该类是一个Mapper</li><li>通常之前做练习写数据库的CRUD都是在xml文件中进行的，这次采用的是在对应的方法上标注注解的形式，<code>@Select</code> <code>@Insert</code></li></ul><h3 id="1-2-事务的测试"><a href="#1-2-事务的测试" class="headerlink" title="1.2 事务的测试"></a>1.2 事务的测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"222"</span>);</span><br><span class="line">        userMapper.insertUser(user1);</span><br><span class="line"></span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"333"</span>);</span><br><span class="line">        userMapper.insertUser(user2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在UserService中，创建了一个方法，用来测试事务，用<code>@Transactional</code>标记</li></ul><h3 id="1-3-自定义一个Result类，用于返回结果使用"><a href="#1-3-自定义一个Result类，用于返回结果使用" class="headerlink" title="1.3 自定义一个Result类，用于返回结果使用"></a>1.3 自定义一个Result类，用于返回结果使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;T&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">error</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;T&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> code,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(CodeMsg codeMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(codeMsg != <span class="keyword">null</span>)&#123;</span><br><span class="line">            msg = codeMsg.getMsg();</span><br><span class="line">            code = codeMsg.getCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它包含了三个字段，<code>code用来保存状态码</code>，<code>msg状态信息</code>，<code>data是返回的对象</code>（泛型）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看<code>类声明的语句</code>，其中使用了泛型，这表示返回对象时，我们对其类型是“已知”的，不必强转，增加了灵活性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;T&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中的方法语句，在<code>返回值中标记了泛型</code>，需要我们在函数定义的中在返回值前加上<code>标识泛型</code>，可以把它想象成正常的返回值，像String等等，只不过用T来表示罢了</p><p>不过，在调用这个方法的时候用两种方法</p><ol><li>直接调用 <code>Result.success(&quot;Success&quot;)</code>;</li><li>标记泛型调用，<code>Result.success(&quot;Success&quot;)</code>;</li></ol><p>两种使用方法的结果都是一样的，不过第二种更能<code>突出它是泛型方法的使用</code>，推荐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>最后这个实在简单，在构造方法参数中使用泛型，传什么类型就自动为什么类型。</p><ul><li>最后总结一下这个Result的功能<br>1.在成功和失败的时候用于结果返回表示<br>2.另外它引入CodeMsg类，在CodeMsg类中，我们自定义了一些状态码和状态信息，用起来也比较方便</li></ul><p>下面是CodeMsg类的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeMsg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用错误码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CodeMsg SUCCESS = <span class="keyword">new</span> CodeMsg(<span class="number">0</span>,<span class="string">"success"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/jpfss/p/9928747.html" target="_blank" rel="noopener">Java泛型详解：和Class的使用。泛型类，泛型方法的详细使用实例</a></p><hr><h2 id="2-集成Redis"><a href="#2-集成Redis" class="headerlink" title="2. 集成Redis"></a>2. 集成Redis</h2><h3 id="2-1-与服务器的Redis建立连接"><a href="#2-1-与服务器的Redis建立连接" class="headerlink" title="2.1 与服务器的Redis建立连接"></a>2.1 与服务器的Redis建立连接</h3><p>我们的最终目的是要创建出<code>JedisPool</code>，用来创建出Jedis与服务器中Redis进行交互</p><p>首先，需要在配置文件<code>application.properties中写好配置信息</code>，比如主机地址、端口号、最大连接数等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis.host=182.xxx.xxx.xxx</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.timeout=3</span><br><span class="line">redis.poolMaxTotal=10</span><br><span class="line">redis.poolMaxIdle=10</span><br><span class="line">redis.poolMaxWait=3</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p>写好配置文件，我们要对其进行读取，创建读取配置信息的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//读取配置文件的注解,指定前缀，读以redis打头的</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> poolMaxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> poolMaxIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> poolMaxWait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><ul><li>注意注解<code>@ConfigurationProperties(prefix = &quot;redis&quot;)</code>，用来读取前缀是redis的配置信息，字段与要读取的信息一致</li></ul><p>接下来就是要创建<code>JedisPool</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisConfig redisConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPool <span class="title">jedisPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class="line">        jedisPoolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class="line">        jedisPoolConfig.setEvictorShutdownTimeoutMillis(redisConfig.getTimeout() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisPool(jedisPoolConfig,</span><br><span class="line">                redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout() * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><p>RedisConfig，作为Bean自动装配进来，我们还要建立<code>JedisPoolConfig</code>来设置一些参数，供建立JedisPool时读取</p><p>以上，完成了与服务器Redis的建立连接过程</p><h3 id="2-2-Key前缀的必要"><a href="#2-2-Key前缀的必要" class="headerlink" title="2.2 Key前缀的必要"></a>2.2 Key前缀的必要</h3><p>毕竟我们这个是高并发的项目，那么多个人在对同一个key进行读取时，如果不对key值进行修饰，很容易发生数据损坏，所以，我们采用了<code>前缀修饰</code>，在设计模式中，是对<code>模板方法模式</code>的应用</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/Java-high-performance-and-high-concurrency-spike-system/Blog\source\_posts\Java高性能高并发秒杀系统\20200707171433298.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>先创建一个<code>接口</code>，其中有两个方法，获得失效时间和获取前缀</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyPrefix</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加失效时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取前缀</span></span><br><span class="line">    <span class="function">String <span class="title">getPrefix</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>随后，我们创建的是<code>抽象类</code>，它就像是一个<code>模板</code>，为其他实现该抽象类的子类，建立了一个模板（我在说什么？？？应该传达清楚了）<br>我们对接口中的方法进行全部重写，其中获取前缀时，前缀为类名，提供<code>两种构造函数</code>，一种为无失效时间的，另一种为有失效时间的</li></ul><blockquote><p>抽象类中构造方法的理解：其中的构造方法与普通类中的构造方法<code>长得一样</code>，不过它<code>不能用来构造自己</code>，因为它是抽象的，不能实例化，但是一旦子类实现了该抽象类，那么<code>子类便可以调用其抽象类的构造函数进行实例化</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePrefix</span> <span class="keyword">implements</span> <span class="title">KeyPrefix</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireSecond;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>,prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">(<span class="keyword">int</span> expireSecond,String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expireSecond = expireSecond;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expireSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取前缀，前面添加类名</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">":"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure><ul><li>最后，展现出抽象类的<code>实现类</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserKey</span> <span class="keyword">extends</span> <span class="title">BasePrefix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserKey</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UserKey的两种前缀形式，一种是根据id另一种根据name</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserKey getById = <span class="keyword">new</span> UserKey(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserKey getByName = <span class="keyword">new</span> UserKey(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>它的构造函数就是用的<code>抽象父类中的构造函数</code>，而且定义了两个静态字段，一种是根据Id来生成前缀，前缀格式会根据getPrefix()方法，表示为<code>类名+：+id</code></p><h3 id="2-3-简单看RedisService中的一个方法"><a href="#2-3-简单看RedisService中的一个方法" class="headerlink" title="2.3 简单看RedisService中的一个方法"></a>2.3 简单看RedisService中的一个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(KeyPrefix keyPrefix,String key,T value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取Jedis对象</span></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">            String str = beanToString(value);</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String realKey = keyPrefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">int</span> seconds = keyPrefix.expireSeconds();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(seconds &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                jedis.set(realKey,str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//设置超时时间</span></span><br><span class="line">                jedis.setex(realKey,seconds,str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure><ol><li>根据自动装配获取<code>JedisPool</code>，用Jedis连接池来拿出<code>Jedis</code>与Redis服务器建立连接。</li><li>set方法，我们需要将<code>value值转换为String类型</code>，让Redis能够识别</li><li>随后，为key<code>添加前缀</code>，生成realKey；获取其中的失效时间</li><li>根据失效时间来判断是否需要调用<code>setex()方法</code></li></ol><h3 id="2-4-beanToString与stringToBean方法"><a href="#2-4-beanToString与stringToBean方法" class="headerlink" title="2.4 beanToString与stringToBean方法"></a>2.4 beanToString与stringToBean方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//进行类型判断，这里用到了？通配符</span></span><br><span class="line">        Class&lt;?&gt; clazz = value.getClass();</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Integer<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Long<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (String)value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果是对象的话，用JSON的静态方法转String</span></span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String str,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span> || clazz == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Integer<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Integer.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Long<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Long.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) str;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//转化成对象的JSON静态方法</span></span><br><span class="line">            <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(str),clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><ul><li>注解<code>@SupressWarings(&quot;unchecked&quot;)</code>，镇压警告</li></ul>]]></content>
    
    <summary type="html">
    
      集成Mybatis和Redis的知识点
    
    </summary>
    
    
    
      <category term="project" scheme="https://kayleh.top/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>AIO模型</title>
    <link href="https://kayleh.top/AIO-blocking-model/"/>
    <id>https://kayleh.top/AIO-blocking-model/</id>
    <published>2020-12-05T03:57:07.000Z</published>
    <updated>2020-12-05T04:09:17.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-在系统层面分析IO模型"><a href="#1-在系统层面分析IO模型" class="headerlink" title="1. 在系统层面分析IO模型"></a>1. 在系统层面分析IO模型</h2><p>当我们从网络中或者其他进程中接收到数据时，这个数据会<code>先</code>被拷贝到<code>系统内核的缓冲区</code>，然后从内核的缓冲区中再复制到我们<code>应用程序对应的缓冲区</code>中，这样我们才能实现从应用程序中取得这个数据。</p><h3 id="1-1-BIO模型"><a href="#1-1-BIO模型" class="headerlink" title="1.1 BIO模型"></a>1.1 BIO模型</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723190512937.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>我们的应用程序会首先<code>调用特定的函数</code>，这样才能去访问我们的操作系统。拿我们的BIO聊天室来说，我们在服务器上，想看一下客户端从网络上传递过来的数据有没有准备好，那么它会去询问操作系统有没有收到新的数据，如果没有收到，它会<code>一直阻塞</code>在这里，直到收到消息，并且已经<code>从系统内核缓冲区中拷贝到应用程序的缓冲区</code>中，这样这个调用才能够成功返回。这就是阻塞式IO，我们在等待的过程中，什么都做不了。</li></ul><h3 id="1-2-NIO模型"><a href="#1-2-NIO模型" class="headerlink" title="1.2 NIO模型"></a>1.2 NIO模型</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723191219755.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>当我们的应用程序进行系统调用，询问数据有没有准备好，没有准备好的话，因为它是<code>非阻塞的</code>，所以<code>直接返回</code>；直到系统已经将内核缓冲区中的数据复制到应用程序的缓冲区中，这时我们再去询问数据有没有准备好的话，就能够获取到我们想要的数据了。但是它并不包括Selector监听模式，仅仅是NIO中的非阻塞式模型。</li></ul><h4 id="1-2-1-IO多路复用"><a href="#1-2-1-IO多路复用" class="headerlink" title="1.2.1 IO多路复用"></a>1.2.1 IO多路复用</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/202007231924362.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>这个模式对应的就是我们NIO聊天室中采用的模式，使用了Selector监听</li><li>首先我们的应用程序发起新的询问，是不是有可用的数据进行操作了，如果数据这时没有准备好，<code>并不会如上NIO直接返回</code>，而是说，我们要求内核<code>监听</code>我们这个IO通道，直到它有了数据可以供我们的程序进行操作了，再来通知我们，这个监听的过程，就像我们聊天室中的<code>select()方法</code>，它是<code>阻塞</code>的。直到数据已经在系统内核缓存区中准备好了，它会通知你一下，告诉你可以执行系统调用，将缓存区中的数据复制到应用程序缓存区中，这时我们才真正获取到了我们想要的数据</li><li>在这个时候，系统内核能够监听多个IO通道，跟我们的聊天室一样，它也监听了多个通道，只要其中任何一个IO通道有了新的状态更新，那么这个监听都会返回给我们应用程序说，其中的IO通道有一个或者多个出现了状态的变化，你要不要对其进行处理一下，我们便可以根据它返回的条件，进行特定的处理。（Selector可以翻译成为IO多路复用器）</li></ul><h3 id="1-3-AIO模型（异步IO）"><a href="#1-3-AIO模型（异步IO）" class="headerlink" title="1.3 AIO模型（异步IO）"></a>1.3 AIO模型（异步IO）</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723194710403.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>BIO和NIO都是同步IO模型，这里我们说说AIO（异步）模型</li><li>同步IO模型是当我们访问的这个数据无论有没有准备好，都会返回给你结果；当数据没有准备好的时候，我们没有能够获取数据，<code>如果我们再也不发起获取数据的请求，那么我们永远都不会再获取到这个数据</code>。异步IO就不同了，当你请求这个数据没有请求到，而<code>之后这个数据准备好了，它就会回去通知你</code>，可以来取这个数据了</li><li>我们来看一下这个流程：我们去请求数据，数据没有准备好，我们没有被阻塞，而是<code>直接返回</code>了。在应用程序层面，虽然我们没有再发起新的请求，但是在系统后台，会监听这个我们请求数据的状态，当我们需要的数据已经准备好了，并且已经存在于系统内核缓存区中了，系统后台还会将这个数据拷贝到我们的应用程序缓存区中，到这里，系统内核会<code>递交给我们一个信号</code>，告诉你，你之前想要的这个数据，已经准备好给你了，你可以进行使用了。</li><li>它的<code>异步</code>体现在：我们程序只对数据发起了一次请求，没有请求到，就直接返回了，而之后，当这个数据已经准备好的时候，系统回来通知我们，而不需要我们再次发起请求，就能获取到这个数据，这就体现了异步的特点。A就是asynchronous，也就是异步的意思</li></ul><hr><h2 id="2-异步调用机制"><a href="#2-异步调用机制" class="headerlink" title="2. 异步调用机制"></a>2. 异步调用机制</h2><h3 id="2-1-AIO中的异步操作"><a href="#2-1-AIO中的异步操作" class="headerlink" title="2.1 AIO中的异步操作"></a>2.1 AIO中的异步操作</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723205527982.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>客户端对应AsynchronousSocketChannel</li><li>服务端对应AsynchronousServerSocketChannel</li><li>建立连接为connect/accept</li><li>读操作为read</li><li>写操作为write</li></ul><h3 id="2-2-通过Future进行异步调用"><a href="#2-2-通过Future进行异步调用" class="headerlink" title="2.2 通过Future进行异步调用"></a>2.2 通过Future进行异步调用</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723210814302.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>注意其中Future的get()方法是阻塞式的</li></ul><h3 id="2-3-通过CompletionHandler（多用）"><a href="#2-3-通过CompletionHandler（多用）" class="headerlink" title="2.3 通过CompletionHandler（多用）"></a>2.3 通过CompletionHandler（多用）</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723210919682.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>在执行操作的时候，传入CompletionHandler参数</li></ul><hr><h2 id="3-实战（回音服务器）"><a href="#3-实战（回音服务器）" class="headerlink" title="3. 实战（回音服务器）"></a>3. 实战（回音服务器）</h2><h3 id="3-1-服务器端"><a href="#3-1-服务器端" class="headerlink" title="3.1 服务器端"></a>3.1 服务器端</h3><h4 id="3-1-1-字段"><a href="#3-1-1-字段" class="headerlink" title="3.1.1 字段"></a>3.1.1 字段</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723211230958.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="3-1-2-主方法"><a href="#3-1-2-主方法" class="headerlink" title="3.1.2 主方法"></a>3.1.2 主方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723211619641.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="3-1-3-AcceptHandler的实现"><a href="#3-1-3-AcceptHandler的实现" class="headerlink" title="3.1.3 AcceptHandler的实现"></a>3.1.3 AcceptHandler的实现</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723211813626.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="3-1-4-ClientHandler的实现"><a href="#3-1-4-ClientHandler的实现" class="headerlink" title="3.1.4 ClientHandler的实现"></a>3.1.4 ClientHandler的实现</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723213343220.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h3><h4 id="3-2-1-字段"><a href="#3-2-1-字段" class="headerlink" title="3.2.1 字段"></a>3.2.1 字段</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/2020072321343625.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="3-2-2-主方法"><a href="#3-2-2-主方法" class="headerlink" title="3.2.2 主方法"></a>3.2.2 主方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723213746283.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><hr><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><h3 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALHOST = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//绑定端口号,调用的open方法（无参），这个参数类型为AsynchronousChannelGroup，其中包含共享的系统资源，如线程池，</span></span><br><span class="line">            <span class="comment">//因为我们没有传入参数，会从默认的ProviderHolder中，提供一个我们需要的AsynchronousServerSocketChannel对象</span></span><br><span class="line">            <span class="comment">//Handler会在不同的线程中进行处理，如我们的AcceptHandler和ClientHandler，它就是动用的共享资源：线程，来执行</span></span><br><span class="line">            serverChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(LOCALHOST,DEFAULT_PORT));</span><br><span class="line">            System.out.println(<span class="string">"服务器启动成功，监听端口号："</span> + DEFAULT_PORT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//该accept方法为异步调用，没有需要返回的结果也会返回，即没有收到客户连接的请求时</span></span><br><span class="line">                <span class="comment">//就会返回结果了；但是我们要保证在有客户连接的时候，主线程还在运行，否则主线程返回</span></span><br><span class="line">                <span class="comment">//服务器就直接宕机了，我们采用下面的小技巧来避免这种情况</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//accept在系统层面完成的时候（系统帮助我们完成了这个IO处理），返回的结果会被AcceptHandler来处理，</span></span><br><span class="line">                <span class="comment">//成功时执行的completed方法，失败执行的是failed方法</span></span><br><span class="line">                <span class="comment">//附带对象无；AcceptHandler为实现接口CompletionHandler的类，处理accept请求</span></span><br><span class="line">                serverChannel.accept(<span class="keyword">null</span>,<span class="keyword">new</span> AcceptHandler());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用这个来避免while过于频繁，相当于将主线程阻塞，以保证建立连接时与客户端的响应</span></span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(serverChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序处理accept请求的时候，并不是在主线程中执行的，</span></span><br><span class="line"><span class="comment">     * 而是从AsynchronousChannelGroup中取出另一个线程来执行</span></span><br><span class="line"><span class="comment">     * CompletionHandler泛型为，第一个为返回的结果类型；第二个为附带的对象类型</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>,<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * completed 该方法对应的是，我们之前上方调用accept方法，正常返回了，那么会执行该方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> result 方法执行成功的返回值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> attachment 附带信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(serverChannel.isOpen())&#123;</span><br><span class="line">                <span class="comment">//确保服务器还在运行</span></span><br><span class="line">                <span class="comment">//服务器继续等待下一个客户端来请求，但是这里并不是产生过多的accept方法压栈</span></span><br><span class="line">                <span class="comment">//而造成的栈溢出问题，这在底层已经进行保护了</span></span><br><span class="line">                serverChannel.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理已连接客户端的读写操作</span></span><br><span class="line">            AsynchronousSocketChannel clientChannel = result;</span><br><span class="line">            <span class="keyword">if</span>(clientChannel != <span class="keyword">null</span> &amp;&amp; clientChannel.isOpen())&#123;</span><br><span class="line">                ClientHandler handler = <span class="keyword">new</span> ClientHandler(clientChannel);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                Map&lt;String,Object&gt; attachmentInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                attachmentInfo.put(<span class="string">"type"</span>,<span class="string">"read"</span>);</span><br><span class="line">                attachmentInfo.put(<span class="string">"buffer"</span>,buffer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//依靠ClientHandler异步处理，读写操作，将其回传给客户端</span></span><br><span class="line">                clientChannel.read(buffer,attachmentInfo,handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//失败时的调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">Map</span>&lt;<span class="title">String</span>,<span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientChannel = clientChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Map&lt;String, Object&gt; attachment)</span> </span>&#123;</span><br><span class="line">            String type = (String) attachment.get(<span class="string">"type"</span>);</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) attachment.get(<span class="string">"buffer"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"read"</span>.equals(type))&#123;</span><br><span class="line">                <span class="comment">//已经读取到了客户端传过来的消息，将其回音给客户端</span></span><br><span class="line">                buffer.flip();<span class="comment">//回音要读缓冲区</span></span><br><span class="line">                attachment.put(<span class="string">"type"</span>,<span class="string">"write"</span>);</span><br><span class="line">                clientChannel.write(buffer,attachment,<span class="keyword">this</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"write"</span>.equals(type))&#123;</span><br><span class="line">                <span class="comment">//将其回传给客户端后，等待客户端的新的信息</span></span><br><span class="line">                <span class="comment">//将这里将再次进行异步调用，读取客户端发来的信息存储在缓冲区中</span></span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                attachment.put(<span class="string">"type"</span>,<span class="string">"read"</span>);</span><br><span class="line">                attachment.put(<span class="string">"buffer"</span>,byteBuffer);</span><br><span class="line">                clientChannel.read(byteBuffer,attachment,<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Map&lt;String, Object&gt; attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String LOCALHOST = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    AsynchronousSocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientChannel = AsynchronousSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            Future&lt;Void&gt; connect = clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(LOCALHOST, DEFAULT_PORT));</span><br><span class="line">            connect.get();<span class="comment">//阻塞式调用，直到有结果才返回</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取用户的输入</span></span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                String input = in.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] inputBytes = input.getBytes();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(inputBytes);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向服务器发送消息</span></span><br><span class="line">                Future&lt;Integer&gt; write = clientChannel.write(buffer);</span><br><span class="line">                write.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//接收服务器传来的消息</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                Future&lt;Integer&gt; read = clientChannel.read(buffer);</span><br><span class="line">                read.get();</span><br><span class="line"></span><br><span class="line">                String s = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                System.out.println(s);</span><br><span class="line"></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(clientChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200723214442368.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="1-AIO模型分析"><a href="#1-AIO模型分析" class="headerlink" title="1. AIO模型分析"></a>1. AIO模型分析</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724200020715.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>AsynchronousServerSocket：它属于一个<code>AsynchronousChannelGroup</code>，这个通道组，其实是被多个异步通道共享的资源群组，这里边我们之前提到过，有一个非常重要的资源：<code>线程池</code>，系统会利用线程池中的线程，来处理一些handler请求。系统利用这个资源组还为我们做了很多的事情，包括它能在数据准备好的时候通知我们和利用handler做一些异步的操作。当我们在创建AsynchronousServerSocket时(open())，我们可以自定义一个通道组，当然我们不传参的时候，系统会默认给我们一个群组。</li></ul><hr><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724195923945.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>当客户端请求与服务器建立连接时，系统会异步的调用AcceptHandler来处理连接请求，成功建立连接后，会返回一个AsynchronousSocketChannel对象，<code>每个对象</code>还会有一个<code>ClientHandler</code>来处理读写请求，在请求处理的过程中，并不是在主线程中完成的，而是通道组利用线程池资源，在不同的线程中完成异步处理。</li></ul><hr><h2 id="2-聊天室分析"><a href="#2-聊天室分析" class="headerlink" title="2. 聊天室分析"></a>2. 聊天室分析</h2><h3 id="2-1-服务器端"><a href="#2-1-服务器端" class="headerlink" title="2.1 服务器端"></a>2.1 服务器端</h3><h4 id="2-1-1-字段"><a href="#2-1-1-字段" class="headerlink" title="2.1.1 字段"></a>2.1.1 字段</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/2020072420461170.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-2-主方法"><a href="#2-1-2-主方法" class="headerlink" title="2.1.2 主方法"></a>2.1.2 主方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724204906660.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-3-AcceptHandler"><a href="#2-1-3-AcceptHandler" class="headerlink" title="2.1.3 AcceptHandler"></a>2.1.3 AcceptHandler</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724205358130.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-4-ClientHandler（处理读写请求）"><a href="#2-1-4-ClientHandler（处理读写请求）" class="headerlink" title="2.1.4 ClientHandler（处理读写请求）"></a>2.1.4 ClientHandler（处理读写请求）</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724205908451.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-5-添加和删除用户"><a href="#2-1-5-添加和删除用户" class="headerlink" title="2.1.5 添加和删除用户"></a>2.1.5 添加和删除用户</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/2020072421010985.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-6-接收和转发方法"><a href="#2-1-6-接收和转发方法" class="headerlink" title="2.1.6 接收和转发方法"></a>2.1.6 接收和转发方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210243585.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><p>客户端中使用的Future来处理异步请求，非常简单</p><h4 id="2-2-1-主方法"><a href="#2-2-1-主方法" class="headerlink" title="2.2.1 主方法"></a>2.2.1 主方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210613293.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-2-2-发送消息"><a href="#2-2-2-发送消息" class="headerlink" title="2.2.2 发送消息"></a>2.2.2 发送消息</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210719163.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-2-3-用户的输入线程"><a href="#2-2-3-用户的输入线程" class="headerlink" title="2.2.3 用户的输入线程"></a>2.2.3 用户的输入线程</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210827857.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><hr><h2 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3. 测试结果"></a>3. 测试结果</h2><ul><li>服务器端显示<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200724210901364.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><h3 id="4-1-服务器端-1"><a href="#4-1-服务器端-1" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALHOST = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup asynchronousChannelGroup;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ClientHandler&gt; connectedClients;</span><br><span class="line">    <span class="keyword">private</span> Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        connectedClients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//自定义ChannelGroup</span></span><br><span class="line">            ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">            asynchronousChannelGroup = AsynchronousChannelGroup.withThreadPool(executorService);</span><br><span class="line"></span><br><span class="line">            serverChannel = AsynchronousServerSocketChannel.open(asynchronousChannelGroup);</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(LOCALHOST,port));</span><br><span class="line">            System.out.println(<span class="string">"服务器已经启动成功，随时等待客户端连接..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                serverChannel.accept(<span class="keyword">null</span>,<span class="keyword">new</span> AcceptHandler());</span><br><span class="line"></span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(serverChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>,<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel clientChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(serverChannel.isOpen())</span><br><span class="line">                serverChannel.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(clientChannel != <span class="keyword">null</span> &amp;&amp; clientChannel.isOpen())&#123;</span><br><span class="line">                ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler(clientChannel);</span><br><span class="line"></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">                addClient(clientHandler);</span><br><span class="line">                clientChannel.read(buffer,buffer,clientHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"连接失败："</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">ByteBuffer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientChannel = clientChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AsynchronousSocketChannel <span class="title">getClientChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> clientChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//buffer不为空的时候，这要执行的是read之后的回调方法</span></span><br><span class="line">                <span class="keyword">if</span>(result &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//客户端异常，将客户端从连接列表中移除</span></span><br><span class="line">                    removeClient(<span class="keyword">this</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    String fwdMsg = receive(buffer);</span><br><span class="line">                    System.out.println(getClientName(clientChannel) + fwdMsg);</span><br><span class="line">                    forwardMsg(clientChannel,fwdMsg);</span><br><span class="line">                    buffer.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(readyToQuit(fwdMsg))&#123;</span><br><span class="line">                        removeClient(<span class="keyword">this</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        clientChannel.read(buffer,buffer,<span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"读写操作失败："</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(ClientHandler clientHandler)</span> </span>&#123;</span><br><span class="line">        connectedClients.add(clientHandler);</span><br><span class="line">        System.out.println(getClientName(clientHandler.getClientChannel()) + <span class="string">"已经连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(ClientHandler clientHandler)</span> </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel clientChannel = clientHandler.getClientChannel();</span><br><span class="line">        connectedClients.remove(clientHandler);</span><br><span class="line">        System.out.println(getClientName(clientChannel) + <span class="string">"已经断开连接"</span>);</span><br><span class="line">        close(clientChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equals(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> String <span class="title">receive</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charset.decode(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forwardMsg</span><span class="params">(AsynchronousSocketChannel clientChannel,String fwdMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ClientHandler connectedHandler : connectedClients) &#123;</span><br><span class="line">            AsynchronousSocketChannel client = connectedHandler.getClientChannel();</span><br><span class="line">            <span class="keyword">if</span>(!client.equals(clientChannel))&#123;</span><br><span class="line">                <span class="comment">//注意这个try，catch是自己加的</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//将消息存入缓存区中</span></span><br><span class="line">                    ByteBuffer buffer = charset.encode(getClientName(client) + fwdMsg);</span><br><span class="line">                    <span class="comment">//写给每个客户端</span></span><br><span class="line">                    client.write(buffer,<span class="keyword">null</span>,connectedHandler);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress remoteAddress = (InetSocketAddress) clientChannel.getRemoteAddress();</span><br><span class="line">            port = remoteAddress.getPort();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"客户端["</span> + port + <span class="string">"]:"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatServer chatServer = <span class="keyword">new</span> ChatServer();</span><br><span class="line">        chatServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-客户端-1"><a href="#4-2-客户端-1" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALHOST = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line">    <span class="keyword">private</span> Charset charset = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(LOCALHOST,DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientChannel = AsynchronousSocketChannel.open();</span><br><span class="line">            Future&lt;Void&gt; connect = clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            connect.get();</span><br><span class="line">            System.out.println(<span class="string">"与服务已成功建立连接"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UserInputHandler(<span class="keyword">this</span>)).start();</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">            <span class="keyword">while</span> (clientChannel.isOpen())&#123;</span><br><span class="line">                Future&lt;Integer&gt; read = clientChannel.read(buffer);</span><br><span class="line">                <span class="keyword">int</span> result = read.get();</span><br><span class="line">                <span class="keyword">if</span>(result &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//这里是，当我们输入quit时，在服务器端会自动将我们移除</span></span><br><span class="line">                    <span class="comment">//所以这里关闭就好了</span></span><br><span class="line">                    close(clientChannel);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    String msg = String.valueOf(charset.decode(buffer));</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(clientChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ByteBuffer buffer = charset.encode(msg);</span><br><span class="line">            Future&lt;Integer&gt; write = clientChannel.write(buffer);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                write.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equals(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line">        chatClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChatClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInputHandler</span><span class="params">(ChatClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedReader consoleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String msg = consoleReader.readLine();</span><br><span class="line">                client.sendMsg(msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(client.readyToQuit(msg))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"成功退出聊天室"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1-三种模型的适用场景"><a href="#1-三种模型的适用场景" class="headerlink" title="1. 三种模型的适用场景"></a>1. 三种模型的适用场景</h2><ol><li>BIO：适用于连接数目少，而且服务器资源对于我们已知的连接来说，比较充足，开发简单</li><li>NIO：相对BIO来说，开发难度较高，但是客户连接数目比较高。值得我们注意的是，由于NIO是单一的线程轮询来处理数据，需要避免每个任务执行的时间过长，防止其他线程出现过长的等待</li><li>AIO：接受的连接数目多，相对于NIO来说，是异步出来，可以接受某个任务花费过长的时间，但是开发难度比较高，维护起来也不简单。</li></ol><ul><li>附：可以使用JDK文件夹下面的VisualVM来监控程序的使用情况<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/AIO%E6%A8%A1%E5%9E%8B/20200725151809156.png" alt="在这里插入图片描述"></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-在系统层面分析IO模型&quot;&gt;&lt;a href=&quot;#1-在系统层面分析IO模型&quot; class=&quot;headerlink&quot; title=&quot;1. 在系统层面分析IO模型&quot;&gt;&lt;/a&gt;1. 在系统层面分析IO模型&lt;/h2&gt;&lt;p&gt;当我们从网络中或者其他进程中接收到数据时，这个数
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>NIO模型</title>
    <link href="https://kayleh.top/NIO-blocking-model/"/>
    <id>https://kayleh.top/NIO-blocking-model/</id>
    <published>2020-12-05T03:33:46.000Z</published>
    <updated>2020-12-05T04:10:49.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-翻译翻译？什么叫NIO？"><a href="#1-1-翻译翻译？什么叫NIO？" class="headerlink" title="1.1 翻译翻译？什么叫NIO？"></a>1.1 翻译翻译？什么叫NIO？</h3><p>NIO：我认为翻译成<code>Non-Blocking</code>，更加的通俗直白，相比于BIO，也有一个对比，叫他非阻塞IO最好不过了</p><ul><li>它和BIO有以下的区别<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721215841190.png" alt="在这里插入图片描述"></li><li>Channel是<code>双向</code>的，即可以读又可以写，相比于Stream，它并不区分出输入流和输出流，而且Channel可以完成非阻塞的读写，也可以完成阻塞的读写</li></ul><h3 id="1-2-Buffer简介"><a href="#1-2-Buffer简介" class="headerlink" title="1.2 Buffer简介"></a>1.2 Buffer简介</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721220142379.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>Channel的读写是离不开Buffer的，Buffer实际上内存上一块用来读写的区域。</li></ul><h4 id="1-2-1-写模式"><a href="#1-2-1-写模式" class="headerlink" title="1.2.1 写模式"></a>1.2.1 写模式</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721220305715.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>其中三个指针我们要了解一下，<code>position</code>为当前指针位置，<code>limit</code>用于读模式，用它来标记可读的最大范围，<code>capacity</code>是最大的可写范围阈值</li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721220837981.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><p>当我们写数据写了四个格子时，我们执行<code>flip()</code>方法，即可转变为<code>读模式</code>，limit指针就直接变到了我们刚刚写数据的极限位置，position指针回到初始位置，这样我们就可以将数据读出来了<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721220618271.png" alt="在这里插入图片描述"></p><h4 id="1-2-2-读模式到写模式的两种切换"><a href="#1-2-2-读模式到写模式的两种切换" class="headerlink" title="1.2.2 读模式到写模式的两种切换"></a>1.2.2 读模式到写模式的两种切换</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721221126713.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ol><li>当我们将数据全部读完时，切换到写模式<br>调用<code>clear()</code>方法，它会使position指针回到初始位置，limit回到最远端，这样就可以重新开始数据了，虽然clear意为清除，但是其实它只是将指针的位置移动了，并没有将数据清除，而是会覆盖原来的位置<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721221133628.png" alt="在这里插入图片描述"></li><li>只读了部分数据，我想将未读的部分保留，而现在我又要开始先进行写模式的操作了，这样可以执行<code>compact()</code>方法<br>这个方法会<code>将没有读到的数据保存到初始位置</code>，而<code>position指针的位置将会移动到这些数据的后面位置</code>，从未读的数据后开始进行写数据<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721221448757.png" alt="在这里插入图片描述"><br>之后再读数据的时候，我们就能将上次没有读到的数据读出来了</li></ol><h3 id="1-3-Channel简介"><a href="#1-3-Channel简介" class="headerlink" title="1.3 Channel简介"></a>1.3 Channel简介</h3><p>Channel间的数据交换，都需要依赖Buffer<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721221615368.png" alt="在这里插入图片描述"></p><h4 id="1-3-1-几个重要的Channel"><a href="#1-3-1-几个重要的Channel" class="headerlink" title="1.3.1 几个重要的Channel"></a>1.3.1 几个重要的Channel</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200721221704507.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>FileChannel：用于文件传输</li><li>ServerSocketChannel和SocketChannel：用于网络编程的传输</li></ul><h2 id="2-文件拷贝实战"><a href="#2-文件拷贝实战" class="headerlink" title="2. 文件拷贝实战"></a>2. 文件拷贝实战</h2><ul><li>一个字节一个字节的拷贝实在是慢的不行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FileCopyRunner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source,File target)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用任何缓冲的留的拷贝</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileCopyRunner noBufferStreamCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">            InputStream fin = <span class="keyword">null</span>;</span><br><span class="line">            OutputStream fout = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">                fout = <span class="keyword">new</span> FileOutputStream(target);</span><br><span class="line">                <span class="keyword">int</span> result;</span><br><span class="line">                <span class="keyword">while</span>((result = fin.read()) != - <span class="number">1</span>)&#123;</span><br><span class="line">                    fout.write(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用缓冲区的流的拷贝</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileCopyRunner bufferStreamCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">            InputStream fin = <span class="keyword">null</span>;</span><br><span class="line">            OutputStream fout = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">                fout = <span class="keyword">new</span> FileOutputStream(target);</span><br><span class="line">                <span class="comment">//创建缓冲区</span></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> result;</span><br><span class="line">                <span class="keyword">while</span>((result = fin.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//result这里表示从中读出来的具体字节数</span></span><br><span class="line">                    <span class="comment">//虽然缓冲区中能缓存1024，但是我们读取的时候不一定就有这么多字节</span></span><br><span class="line">                    <span class="comment">//所以我们使用result做下面的参数</span></span><br><span class="line">                    fout.write(buffer,<span class="number">0</span>,result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用带有缓冲区的channel复制 nio</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileCopyRunner nioBufferCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">            FileChannel fin = <span class="keyword">null</span>;</span><br><span class="line">            FileChannel fout = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">                fout = <span class="keyword">new</span> FileOutputStream(target).getChannel();</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(fin.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    byteBuffer.flip();<span class="comment">//转变为读模式</span></span><br><span class="line">                    <span class="keyword">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class="line">                        fout.write(byteBuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byteBuffer.clear();<span class="comment">//转变为写模式</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用没有缓冲区的channel复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileCopyRunner nioTransferCopy = ((source, target) -&gt; &#123;</span><br><span class="line">        FileChannel fin = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel fout = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fin = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">            fout = <span class="keyword">new</span> FileOutputStream(target).getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> transferred = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">long</span> size = fin.size();</span><br><span class="line">            <span class="keyword">while</span>(transferred != size)&#123;</span><br><span class="line">                <span class="comment">//如果拷贝的大小没有达到源文件的大小就要一直拷贝</span></span><br><span class="line">                transferred += fin.transferTo(<span class="number">0</span>,size,fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(fin);</span><br><span class="line">            close(fout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File source = <span class="keyword">new</span> File(<span class="string">"J:\\StudySpace\\Java秒杀系统方案优化-高性能高并发实战\\project.zip"</span>);</span><br><span class="line">        File target = <span class="keyword">new</span> File(<span class="string">"J:\\StudySpace\\Java秒杀系统方案优化-高性能高并发实战\\p1.zip"</span>);</span><br><span class="line">        File target2 = <span class="keyword">new</span> File(<span class="string">"J:\\StudySpace\\Java秒杀系统方案优化-高性能高并发实战\\p2.zip"</span>);</span><br><span class="line">        File target3 = <span class="keyword">new</span> File(<span class="string">"J:\\StudySpace\\Java秒杀系统方案优化-高性能高并发实战\\p3.zip"</span>);</span><br><span class="line">        File target4 = <span class="keyword">new</span> File(<span class="string">"J:\\StudySpace\\Java秒杀系统方案优化-高性能高并发实战\\p4.zip"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; noBufferStreamCopy.copyFile(source,target)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; bufferStreamCopy.copyFile(source,target2)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; nioBufferCopy.copyFile(source,target3)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; nioTransferCopy.copyFile(source,target4)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Selector概述"><a href="#3-Selector概述" class="headerlink" title="3. Selector概述"></a>3. Selector概述</h2><ul><li>Channel需要在Selector上注册<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722145734223.png" alt="在这里插入图片描述"></li><li>注册的同时，要告诉Selector监听的状态<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722145833687.png" alt="在这里插入图片描述"></li><li>Channel对应的状态有：<code>CONNECT</code>：socketChannel已经与服务器建立连接的状态；<code>ACCEPT</code>：serverSocketChannel已经与客户端建立连接的状态；<code>READ</code>：可读状态；<code>WRITE</code>：可写状态<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722150046897.png" alt="在这里插入图片描述"></li><li>Channel在Selector上注册完成后，会返回一个SelectKey对象，其中有几个重要的方法：<code>interestOps</code>：查看注册的Channel绑定的状态；<code>readyOps</code>：查看哪些是可操作的状态；<code>channel</code>：返回channel对象；<code>selector</code>：返回selector对象；<code>attachment</code>：附加其他对象<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722150611349.png" alt="在这里插入图片描述"></li><li>调用Selector的select方法，返回它监听的事件的数量，可同时响应多个事件。不过它是阻塞式的调用，当监听的事件中没有可以用来响应请求的，则会被阻塞，直到有可用的channel能够响应该请求，才会返回<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722150651862.png" alt="在这里插入图片描述"></li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="1-NIO模型分析"><a href="#1-NIO模型分析" class="headerlink" title="1. NIO模型分析"></a>1. NIO模型分析</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/202007222229375.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>在服务器端创建一个<code>Selector</code>，将<code>ServerSocketChannel注册到Selector上</code>，被Selector监听的事件为<code>Accept</code></li></ul><hr><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722222907340.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>Client1请求与服务器建立连接，Selector接收到Accept事件，服务器端对其进行处理（handles），服务器与客户端连接成功</li></ul><hr><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722223243146.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>建立连接过程中，服务器通道（ServerSocketChannel）调用<code>accept方法</code>，获取到与客户端进行连接的通道（<code>SocketChannel</code>），也将其<code>注册到Selector</code>上，<code>监听READ事件</code>，这样，客户端向服务器发送消息，就能触发该READ事件进行响应，读取该消息。</li></ul><blockquote><p>Tips: 我们处理这个建立连接并接收从客户端传过来的消息，都是在<code>一个线程</code>内完成的。在bio中，则会为单个客户端单独开辟一个线程，用于处理消息，并且客户端在不发送消息的过程中，该线程一直是阻塞的。</p></blockquote><hr><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722223923471.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>同样，两个客户连接过来也是一个线程在起作用，将客户端2的SocketChannel注册到服务器的Selector，并监听READ事件，随时响应随时处理。即一个客户端有一个SocketChannel，两个客户端就有两个SocketChannel，这个就是我们使用nio编程模型来用一个selector对象在一个线程里边监听以及处理多个通道的io的操作</li></ul><hr><p>各个Channel是被配置为<code>非阻塞式</code>的（configureBlocking(false)），但是Selector本身调用的<code>select()方法</code>，它是<code>阻塞式</code>的，当监听在Selector上的事件都没有触发时，那么它就会被阻塞，直到有事件对其进行响应</p><h2 id="2-聊天室项目代码重点知识"><a href="#2-聊天室项目代码重点知识" class="headerlink" title="2. 聊天室项目代码重点知识"></a>2. 聊天室项目代码重点知识</h2><h3 id="2-1-服务器端"><a href="#2-1-服务器端" class="headerlink" title="2.1 服务器端"></a>2.1 服务器端</h3><h4 id="2-1-1-字段"><a href="#2-1-1-字段" class="headerlink" title="2.1.1 字段"></a>2.1.1 字段</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/2020072222584984.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-2-主方法"><a href="#2-1-2-主方法" class="headerlink" title="2.1.2 主方法"></a>2.1.2 主方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722230412178.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-3-处理方法"><a href="#2-1-3-处理方法" class="headerlink" title="2.1.3 处理方法"></a>2.1.3 处理方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722230845441.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-4-转发消息方法"><a href="#2-1-4-转发消息方法" class="headerlink" title="2.1.4 转发消息方法"></a>2.1.4 转发消息方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722233104941.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-1-5-接收消息方法"><a href="#2-1-5-接收消息方法" class="headerlink" title="2.1.5 接收消息方法"></a>2.1.5 接收消息方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722231319234.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><h4 id="2-2-1-字段"><a href="#2-2-1-字段" class="headerlink" title="2.2.1 字段"></a>2.2.1 字段</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722231507769.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-2-2-主方法"><a href="#2-2-2-主方法" class="headerlink" title="2.2.2 主方法"></a>2.2.2 主方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722231820775.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-2-3-处理方法"><a href="#2-2-3-处理方法" class="headerlink" title="2.2.3 处理方法"></a>2.2.3 处理方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/202007222330187.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-2-4-接收方法"><a href="#2-2-4-接收方法" class="headerlink" title="2.2.4 接收方法"></a>2.2.4 接收方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722233204365.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h4 id="2-2-5-发送方法"><a href="#2-2-5-发送方法" class="headerlink" title="2.2.5 发送方法"></a>2.2.5 发送方法</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722233310845.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><hr><h2 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3. 测试结果"></a>3. 测试结果</h2><ul><li>服务器端显示信息正确<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/NIO模型/20200722233342438.png" alt="在这里插入图片描述"></li></ul><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><h3 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer rBuffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer wBuffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equals(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建ServerSocketChannel通道</span></span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//设置非阻塞模式，默认情况也是阻塞调用的</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//绑定端口号</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">//创建selector</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//将accept事件注册到selector上</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">"服务器启动成功，监听端口号："</span> + port + <span class="string">"..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始进入监听模式</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//阻塞式调用</span></span><br><span class="line">                selector.select();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取所有的监听事件，</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">                    <span class="comment">//处理事件</span></span><br><span class="line">                    handles(selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将已经处理完成的事件进行清空</span></span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(selector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件 处理accept事件 和 read事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectionKey 与selector绑定的channel的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handles</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">            <span class="comment">//处理accept事件</span></span><br><span class="line">            <span class="comment">//先要获取ServerSocketChannel</span></span><br><span class="line">            ServerSocketChannel server =(ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 我觉得这样写也行 直接调用全局变量 SocketChannel socketChannel = serverSocketChannel.accept();</span></span><br><span class="line">            <span class="comment">//获取对应的客户端的通道</span></span><br><span class="line">            SocketChannel socketChannel = server.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将客户端通道绑定到selector上，监听read事件</span></span><br><span class="line">            socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(<span class="string">"客户端"</span> + socketChannel.socket().getPort() + <span class="string">":已经连接"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">            <span class="comment">//处理read事件</span></span><br><span class="line">            SocketChannel clientChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            String fwdMsg = receive(clientChannel);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fwdMsg.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//接不到消息了，那么就把这个通道给他移除了</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">//通知selector有注册的通道被移除了，更新状态</span></span><br><span class="line">                selector.wakeup();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//转发消息</span></span><br><span class="line">                forwardMessage(clientChannel,fwdMsg);</span><br><span class="line">                <span class="keyword">if</span>(readyToQuit(fwdMsg))&#123;</span><br><span class="line">                    selectionKey.cancel();</span><br><span class="line">                    selector.wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转发消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientChannel 客户端通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fwdMsg 转发的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardMessage</span><span class="params">(SocketChannel clientChannel, String fwdMsg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//keys方法区别于selectedKeys,这个方法返回的是接下来需要被处理的通道key</span></span><br><span class="line">        <span class="comment">//而keys则返回与selector绑定的所有通道key</span></span><br><span class="line">        <span class="comment">//跳过ServerSocketChannel和本身</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selector.keys()) &#123;</span><br><span class="line">            SelectableChannel channel = selectionKey.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel <span class="keyword">instanceof</span> ServerSocketChannel)</span><br><span class="line">                System.out.println(<span class="string">"客户端"</span> + clientChannel.socket().getPort() + <span class="string">"："</span> + fwdMsg);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; !channel.equals(clientChannel))&#123;</span><br><span class="line">                wBuffer.clear();</span><br><span class="line">                <span class="comment">//写入消息</span></span><br><span class="line">                wBuffer.put(charset.encode(<span class="string">"客户端"</span> + clientChannel.socket().getPort() + <span class="string">"："</span> + fwdMsg));</span><br><span class="line">                <span class="comment">//转换为读模式</span></span><br><span class="line">                wBuffer.flip();</span><br><span class="line">                <span class="comment">//有数据就一直读</span></span><br><span class="line">                <span class="keyword">while</span>(wBuffer.hasRemaining())</span><br><span class="line">                    ((SocketChannel)channel).write(wBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从客户通道上读取消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientChannel 客户通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">receive</span><span class="params">(SocketChannel clientChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将当前指针置于初始位置，覆盖已有的消息（清空消息）</span></span><br><span class="line">        rBuffer.clear();</span><br><span class="line">        <span class="comment">//不停的向缓存中写</span></span><br><span class="line">        <span class="keyword">while</span>(clientChannel.read(rBuffer) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//由写模式到读模式</span></span><br><span class="line">        rBuffer.flip();</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charset.decode(rBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatServer chatServer = <span class="keyword">new</span> ChatServer();</span><br><span class="line">        chatServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SERVER_HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SERVER_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel clientChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer rBuffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer wBuffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERVER_HOST,DEFAULT_SERVER_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equals(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(closeable != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建用户通道</span></span><br><span class="line">            clientChannel = SocketChannel.open();</span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//这一步千万不能忘了</span></span><br><span class="line">            <span class="comment">//创建selector，并且将用户通道的connect请求注册上去</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            <span class="comment">//尝试与服务器创建连接</span></span><br><span class="line">            clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(host,port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (selector.isOpen())&#123;</span><br><span class="line">                <span class="comment">//一直监听selector上注册的channel请求</span></span><br><span class="line">                selector.select();</span><br><span class="line"></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">                    <span class="comment">//响应请求</span></span><br><span class="line">                    handles(selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClosedSelectorException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(selector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handles</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//处理connect事件</span></span><br><span class="line">        <span class="keyword">if</span>(selectionKey.isConnectable())&#123;</span><br><span class="line">            <span class="comment">//如果能够与服务器响应了</span></span><br><span class="line">            SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel.isConnectionPending())&#123;</span><br><span class="line">                channel.finishConnect(); <span class="comment">//正式建立连接</span></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> UserInputHandler(<span class="keyword">this</span>)).start();</span><br><span class="line">            &#125;</span><br><span class="line">            channel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">            String msg = receive(clientChannel);</span><br><span class="line">            SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="keyword">if</span>(msg.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//服务端异常</span></span><br><span class="line">                close(selector);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//TODO 看看这里信息对不对</span></span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">receive</span><span class="params">(SocketChannel clientChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        rBuffer.clear();</span><br><span class="line">        <span class="comment">//一直读数据</span></span><br><span class="line">        <span class="keyword">while</span> (clientChannel.read(rBuffer) &gt; <span class="number">0</span>);</span><br><span class="line">        rBuffer.flip();</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charset.decode(rBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        wBuffer.clear();</span><br><span class="line">        wBuffer.put(charset.encode(msg));</span><br><span class="line">        wBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span>(wBuffer.hasRemaining())&#123;</span><br><span class="line">            clientChannel.write(wBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(QUIT.equals(msg))</span><br><span class="line">            close(selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line">        chatClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-客户端监听用户输入进程"><a href="#4-3-客户端监听用户输入进程" class="headerlink" title="4.3 客户端监听用户输入进程"></a>4.3 客户端监听用户输入进程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInputHandler</span><span class="params">(ChatClient chatClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待用户输入信息</span></span><br><span class="line">        BufferedReader consoleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String msg = consoleReader.readLine();</span><br><span class="line">                chatClient.send(msg);</span><br><span class="line">                <span class="keyword">if</span>(chatClient.readyToQuit(msg)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-翻译翻译？什么叫NIO？&quot;&gt;&lt;a href=&quot;#1-1-翻译翻译？什么叫NIO？&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>BIO阻塞模型</title>
    <link href="https://kayleh.top/BIO-blocking-model/"/>
    <id>https://kayleh.top/BIO-blocking-model/</id>
    <published>2020-12-03T17:46:43.000Z</published>
    <updated>2020-12-05T04:10:24.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-BIO阻塞模型"><a href="#1-BIO阻塞模型" class="headerlink" title="1. BIO阻塞模型"></a>1. BIO阻塞模型</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200720183138508.png" alt="在这里插入图片描述"><br>简述BIO模型中服务端与客户端的响应过程</p><ol><li>服务器<code>serverSocket</code>先要和<code>端口</code>进行<code>绑定</code></li><li>绑定完成后，执行<code>accept方法</code>，等待客户端的连接，这个方法是<code>阻塞式调用</code>，也就是说，要一直等待客户端的连接响应，不做其他事情，一直等，（被阻塞的还有InputStream.read()、OutputStream.write()，这两个也会一直等待客户端的响应）</li><li>客户端创建<code>Socket</code>对象，<code>绑定</code>服务器的<code>ip地址</code>与<code>端口号</code>，与服务器进行连接</li><li>服务器接收到客户端的连接请求，accept方法获取到<code>客户端的socket信息</code>，连接成功</li><li>服务器与客户端创建各自的<code>io流</code>，实现<code>全双工通信</code></li><li>之后便可以随时<code>结束连接</code></li></ol><hr><h2 id="2-简单实战演示"><a href="#2-简单实战演示" class="headerlink" title="2. 简单实战演示"></a>2. 简单实战演示</h2><h3 id="2-1-服务器"><a href="#2-1-服务器" class="headerlink" title="2.1 服务器"></a>2.1 服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">        <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//绑定端口号</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(DEFAULT_PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器已经启动，绑定端口号："</span> + DEFAULT_PORT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//等待客户端的连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">"客户端"</span> + socket.getPort() + <span class="string">":"</span> + <span class="string">"已经连接"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取io流</span></span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(socket.getInputStream())</span><br><span class="line">                );</span><br><span class="line">                BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                        <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//读取客户发送的信息</span></span><br><span class="line">                String msg = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"客户端"</span> + socket.getPort() + <span class="string">":"</span> + msg);</span><br><span class="line">                    <span class="comment">//回复消息</span></span><br><span class="line">                    writer.write( msg + <span class="string">" ok"</span> +<span class="string">"\n"</span>);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    System.out.println(<span class="string">"服务器："</span> + msg + <span class="string">" ok"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(msg.equals(QUIT))&#123;</span><br><span class="line">                        System.out.println(<span class="string">"客户端"</span> + socket.getPort() + <span class="string">":断开连接"</span> );</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                    System.out.println(<span class="string">"服务器Socket关闭"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SERVER_PORT = <span class="number">8888</span>;</span><br><span class="line">        <span class="keyword">final</span> String DEFAULT_ADDRESS = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建Socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(DEFAULT_ADDRESS,DEFAULT_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建io流</span></span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())</span><br><span class="line">            );</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream())</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待用户输入信息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                BufferedReader consoleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">                String msg = consoleReader.readLine();</span><br><span class="line">                <span class="comment">//向服务器发送消息</span></span><br><span class="line">                writer.write(msg + <span class="string">"\n"</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                System.out.println(<span class="string">"客户端"</span>+ <span class="string">":"</span> + msg);</span><br><span class="line">                String line = reader.readLine();</span><br><span class="line">                System.out.println(<span class="string">"服务器："</span> + line);</span><br><span class="line">                <span class="comment">//退出判断</span></span><br><span class="line">                <span class="keyword">if</span>(msg.equals(QUIT))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-响应结果"><a href="#2-3-响应结果" class="headerlink" title="2.3 响应结果"></a>2.3 响应结果</h3><ul><li><strong>客户端</strong><br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200720183847235.png" alt="在这里插入图片描述"></li><li><strong>服务器</strong><br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200720183859453.png" alt="在这里插入图片描述"></li></ul><h2 id="3-加深理解"><a href="#3-加深理解" class="headerlink" title="3. 加深理解"></a>3. 加深理解</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721182800674.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="1-概念图解"><a href="#1-概念图解" class="headerlink" title="1. 概念图解"></a>1. 概念图解</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721171646426.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>BIO模型：客户端每有一个请求，服务端都要有一个线程来单独处理这个请求，典型的<code>一请求一应答</code>，java 1.4版本之前</li><li>对于聊天室服务器，它有多个线程，其中一个为图上的<code>Acceptor线程</code>（ChatServer），它实现的就是对来自客户端的请求不断响应，创建分配处理线程；对应客户端的每一个请求，都有一个单独的处理线程</li><li>对于客户端来说，它有两个线程，其中一个线程与服务器<code>建立连接，并接收来自服务器的消息</code>；另一个线程则用来<code>处理用户的输入，并将消息发送到服务器</code></li></ul><h3 id="1-1-伪异步的优化"><a href="#1-1-伪异步的优化" class="headerlink" title="1.1 伪异步的优化"></a>1.1 伪异步的优化</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721172110567.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>使用线程池的原因是因为防止一大批用户的响应，造成服务器过载，实现线程的复用，减少不停的创建删除线程造成的资源郎芬，这样也实现了BIO的伪异步IO通信</li></ul><p><a href="https://www.cnblogs.com/haimishasha/p/10625026.html#autoid-1-0-0" target="_blank" rel="noopener">I/O模型系列之三：IO通信模型BIO NIO AIO</a></p><hr><h2 id="2-聊天服务器中的要点"><a href="#2-聊天服务器中的要点" class="headerlink" title="2. 聊天服务器中的要点"></a>2. 聊天服务器中的要点</h2><h3 id="2-1-字段"><a href="#2-1-字段" class="headerlink" title="2.1 字段"></a>2.1 字段</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721183219259.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-2-转发消息方法"><a href="#2-2-转发消息方法" class="headerlink" title="2.2 转发消息方法"></a>2.2 转发消息方法</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721184044934.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-3-添加客户方法"><a href="#2-3-添加客户方法" class="headerlink" title="2.3 添加客户方法"></a>2.3 添加客户方法</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/2020072118380045.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-4-移除客户方法"><a href="#2-4-移除客户方法" class="headerlink" title="2.4 移除客户方法"></a>2.4 移除客户方法</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721183932390.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-5-服务器主线程任务"><a href="#2-5-服务器主线程任务" class="headerlink" title="2.5 服务器主线程任务"></a>2.5 服务器主线程任务</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721184510239.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="2-6-服务器处理线程任务"><a href="#2-6-服务器处理线程任务" class="headerlink" title="2.6 服务器处理线程任务"></a>2.6 服务器处理线程任务</h3><ul><li>实现Runnable接口，之后执行的时候将其传入到线程池中执行。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/2020072118470527.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="3-聊天室客户端要点"><a href="#3-聊天室客户端要点" class="headerlink" title="3. 聊天室客户端要点"></a>3. 聊天室客户端要点</h2><h3 id="3-1-向服务端发送消息，让服务器转发给其他人"><a href="#3-1-向服务端发送消息，让服务器转发给其他人" class="headerlink" title="3.1 向服务端发送消息，让服务器转发给其他人"></a>3.1 向服务端发送消息，让服务器转发给其他人</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185036367.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="3-2-接收服务端的消息"><a href="#3-2-接收服务端的消息" class="headerlink" title="3.2 接收服务端的消息"></a>3.2 接收服务端的消息</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185104298.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="3-3-主线程任务"><a href="#3-3-主线程任务" class="headerlink" title="3.3 主线程任务"></a>3.3 主线程任务</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185243618.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="3-4-处理线程任务"><a href="#3-4-处理线程任务" class="headerlink" title="3.4 处理线程任务"></a>3.4 处理线程任务</h3><ul><li>实现Runnable接口，创建线程时启动<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/20200721185400861.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4. 测试结果"></a>4. 测试结果</h2><p><strong>服务器端信息</strong><br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/BIO阻塞模型/2020072118562745.png" alt="在这里插入图片描述"></p><hr><h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><h3 id="5-1-服务器"><a href="#5-1-服务器" class="headerlink" title="5.1 服务器"></a>5.1 服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">//存储已经连接的客户们</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Writer&gt; connectedClients;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectedClients = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> key = socket.getPort();</span><br><span class="line">            Writer value = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())</span><br><span class="line">            );</span><br><span class="line">            connectedClients.put(key,value);</span><br><span class="line">            System.out.println(<span class="string">"客户"</span> + key + <span class="string">"：已经连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> port = socket.getPort();</span><br><span class="line">            <span class="keyword">if</span>(connectedClients.containsKey(port))&#123;</span><br><span class="line">                <span class="comment">//移除用户的时候要进行关闭</span></span><br><span class="line">                connectedClients.get(port).close();</span><br><span class="line">                connectedClients.remove(port);</span><br><span class="line">                System.out.println(<span class="string">"客户端"</span> + port + <span class="string">"：已经断开连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息转发给其他用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forwardMessage</span><span class="params">(Socket socket,String fwdMsg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer port : connectedClients.keySet())&#123;</span><br><span class="line">            <span class="comment">//不转发给自己</span></span><br><span class="line">            <span class="keyword">if</span>(!port.equals(socket.getPort()))&#123;</span><br><span class="line">                Writer writer = connectedClients.get(port);</span><br><span class="line">                writer.write(fwdMsg);</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否退出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equals(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//绑定监听端口</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(DEFAULT_PORT);</span><br><span class="line">            System.out.println(<span class="string">"聊天室服务器已经成功启动！"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为每个socket创建一条单独的线程进行处理</span></span><br><span class="line">                <span class="comment">//new Thread(new ChatHandler(socket,this)).start();</span></span><br><span class="line">                executorService.execute(<span class="keyword">new</span> ChatHandler(socket,<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatServer chatServer = <span class="keyword">new</span> ChatServer();</span><br><span class="line">        chatServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> ChatServer chatServer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatHandler</span><span class="params">(Socket socket, ChatServer chatServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.chatServer = chatServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//添加对象</span></span><br><span class="line">            chatServer.addClient(socket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取用户发送的信息</span></span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream())</span><br><span class="line">            );</span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//必须要读取到换行符</span></span><br><span class="line">            <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                String fwdMsg =<span class="string">"客户端"</span> + socket.getPort() + <span class="string">"："</span> + msg + <span class="string">"\n"</span>;</span><br><span class="line">                chatServer.forwardMessage(socket,fwdMsg);</span><br><span class="line">                System.out.print(fwdMsg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//检查是否退出</span></span><br><span class="line">                <span class="keyword">if</span>(chatServer.readyToQuit(msg))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                chatServer.removeClient(socket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-客户端"><a href="#5-2-客户端" class="headerlink" title="5.2 客户端"></a>5.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Server.ChatServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String DEFAULT_SERVER_HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String QUIT = <span class="string">"quit"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息给服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//输出流没有关闭的情况</span></span><br><span class="line">        <span class="keyword">if</span>(!socket.isOutputShutdown())&#123;</span><br><span class="line">            writer.write(msg + <span class="string">"\n"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受消息从服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">receiveMsg</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!socket.isInputShutdown())&#123;</span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否退出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equals(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动开关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(DEFAULT_SERVER_HOST,DEFAULT_PORT);</span><br><span class="line">            <span class="comment">//创建io流</span></span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())</span><br><span class="line">            );</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream())</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理用户的输入的线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UserInputHandler(<span class="keyword">this</span>)).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听从服务器来的消息</span></span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((msg = receiveMsg()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line">        chatClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInputHandler</span><span class="params">(ChatClient chatClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待用户输入信息</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line">                <span class="comment">//向服务器发送消息</span></span><br><span class="line">                chatClient.sendMsg(msg);</span><br><span class="line">                <span class="keyword">if</span>(chatClient.readyToQuit(msg))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-BIO阻塞模型&quot;&gt;&lt;a href=&quot;#1-BIO阻塞模型&quot; class=&quot;headerlink&quot; title=&quot;1. BIO阻塞模型&quot;&gt;&lt;/a&gt;1. BIO阻塞模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ka
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>I/O模型</title>
    <link href="https://kayleh.top/IO-model/"/>
    <id>https://kayleh.top/IO-model/</id>
    <published>2020-12-03T17:44:24.000Z</published>
    <updated>2020-12-05T04:12:07.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-java-io下的字符流和字节流"><a href="#1-java-io下的字符流和字节流" class="headerlink" title="1. java.io下的字符流和字节流"></a>1. java.io下的字符流和字节流</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/2020072015491941.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="1-1-字符流"><a href="#1-1-字符流" class="headerlink" title="1.1 字符流"></a>1.1 字符流</h3><p>字符流更加的方便我们使用，一般字符都是由多个字节来形成的，若我们使用字节流传输，则还需要我们自己将其转换为字符，若我们直接使用字符流的话，这样就能直接读取与输出字符。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720154944172.png" alt="在这里插入图片描述"></p><ul><li><code>CharArrayReader</code>：是基础的字符输入流，能从字符数组中读取数据</li><li><code>StringReader</code>：从字符串输入流中读取数据</li><li>输出流同理</li></ul><h4 id="1-1-1-更高级的字符流"><a href="#1-1-1-更高级的字符流" class="headerlink" title="1.1.1 更高级的字符流"></a>1.1.1 更高级的字符流</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/2020072015514933.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li><code>BufferedReader</code>：附带缓存区的字符输入流，但是我们并不能直接实例化供我们使用，而是将我们已经创建的Reader字符流，传入进来，就像对它<code>升级</code>一样，多了更多的功能，比如该字符流就是提供了缓存区，这样加快了io的效率，不必重复读取原始数据源</li><li><code>FilterReader</code>：同样也是运用了<code>装饰模式</code>，它额外的功能能对字符流中的字符进行筛选等</li><li><code>InputStreamReader</code>：连接字节流与字符流的一个桥梁，将字节流转化为字符流，比较常用的就是FileReader</li></ul><h3 id="1-2-字节流"><a href="#1-2-字节流" class="headerlink" title="1.2 字节流"></a>1.2 字节流</h3><p>字节流则是对一个个字节进行读取<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720155921778.png" alt="在这里插入图片描述"></p><ul><li><code>ByteArrayInputStream</code>：字节数组输入流，从字节数组中获取数据</li><li><code>FileInputStream</code>：文件输入流，从文件中获取数据</li><li>输出流同理</li></ul><h4 id="1-2-1-更高级的字节流"><a href="#1-2-1-更高级的字节流" class="headerlink" title="1.2.1 更高级的字节流"></a>1.2.1 更高级的字节流</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720160513951.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li><code>BufferedInputStream</code>：附带缓存区的字节输入流，它同样也是与BufferedReader一个原理，也需要传入进本的InputStream进行升级</li><li><code>DataInputStream与DataOutputStream</code>：这俩就比较有意思了，相辅相成，与java内置的<code>基本数据类型</code>相关，能够将其中的字节，利用一些方法，比如toLong或toInt等方法直接转换为java的基本数据类型</li></ul><hr><h2 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2. 装饰器模式"></a>2. 装饰器模式</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720161404658.png" alt="在这里插入图片描述"><br>我们刚刚看到的，在字符流中BufferedReader、InputStreamReader和FilterReader，字节流中的BufferedInputStream、DataInputStreamReader与DataOutputStream都运用到了装饰器模式，因为它们本身不能进行实例化，都需要传入基本的Reader或InputStream来进行<code>升级</code>，这里便体现的是装饰器模式。</p><hr><h2 id="3-Socket"><a href="#3-Socket" class="headerlink" title="3. Socket"></a>3. Socket</h2><ul><li>我们可以将Socket认为是<code>网络传输的端点</code>，它也是一种<code>数据源</code>，将特定的ip地址与端口号与其进行绑定，这样它就能够实现通信的功能，如下图中，服务器中的socket绑定了对应的ip与端口号，与客户端间进行通信<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720162148571.png" alt="在这里插入图片描述"></li></ul><h3 id="3-1-通过Socket发送数据"><a href="#3-1-通过Socket发送数据" class="headerlink" title="3.1 通过Socket发送数据"></a>3.1 通过Socket发送数据</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720162300339.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ol><li>创建Socket，绑定特定的ip地址与端口号</li><li>将Socket与网卡驱动程序绑定</li><li>通过Socket我们就能够发送数据了</li><li>网卡驱动程序对Socket数据进行读取</li></ol><h3 id="3-2-通过Socket读取数据"><a href="#3-2-通过Socket读取数据" class="headerlink" title="3.2 通过Socket读取数据"></a>3.2 通过Socket读取数据</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720162657547.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>与发送数据类似，只不过是将这个过程反过来了</li></ul><ol><li>我们还是要先创建Socket</li><li>将Socket与网卡驱动程序进行绑定</li><li>Socket接收来自网卡驱动程序的数据</li><li>从Socket中读取数据</li></ol><hr><h2 id="4-同步异步与阻塞非阻塞的概念"><a href="#4-同步异步与阻塞非阻塞的概念" class="headerlink" title="4. 同步异步与阻塞非阻塞的概念"></a>4. 同步异步与阻塞非阻塞的概念</h2><p>它们有两两组合的四种不同的排列组合，同步与异步强调<code>通信机制</code>，通俗点儿说可以是关于反应者的概念；阻塞与非阻塞强调<code>调用状态</code>，我们可以将其理解为调用者或者请求发起者<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720162901659.png" alt="在这里插入图片描述"></p><h3 id="4-1-同步（女孩）"><a href="#4-1-同步（女孩）" class="headerlink" title="4.1 同步（女孩）"></a>4.1 同步（女孩）</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720163148736.png" alt="在这里插入图片描述"><br>男孩向女孩表白，<code>女孩</code>立即对该事件进行思考、反应，这就是同步通信机制</p><h3 id="4-2-异步（女孩）"><a href="#4-2-异步（女孩）" class="headerlink" title="4.2 异步（女孩）"></a>4.2 异步（女孩）</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/2020072016333178.png" alt="在这里插入图片描述"><br>异步通信机制就是，女孩<code>不会</code>对男孩的请求立即响应，而是女孩先去考虑考虑，有结果了呢，我发短信给你</p><h3 id="4-3-阻塞（男孩）"><a href="#4-3-阻塞（男孩）" class="headerlink" title="4.3 阻塞（男孩）"></a>4.3 阻塞（男孩）</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720163448654.png" alt="在这里插入图片描述"><br>男孩是个瓜皮，自动对女孩表白了以后，茶不思饭不想，一直等待着女孩的回应，<code>不做其他的事情</code></p><h3 id="4-4-非阻塞（男孩）"><a href="#4-4-非阻塞（男孩）" class="headerlink" title="4.4 非阻塞（男孩）"></a>4.4 非阻塞（男孩）</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/2020072016354228.png" alt="在这里插入图片描述"><br>这种男生就比较厉害了，能够协调好生活和爱情，和女孩表白后，不对结果困惑，而是<code>该干啥还去干啥</code>，这就是非阻塞调用</p><h3 id="4-5-四种排列组合"><a href="#4-5-四种排列组合" class="headerlink" title="4.5 四种排列组合"></a>4.5 四种排列组合</h3><ol><li>同步阻塞<br>男孩表白后，女孩立即进行思考给出反应，男孩在该过程中傻等，不干别的</li><li>异步阻塞<br>男孩表白后，女孩溜了，回家去想怎么回应了，不立即思考，男孩傻等，不干别的</li><li>同步非阻塞<br>男孩表白后，男孩干别的去了，不等你回复，而女孩立即陷入了沉思，想着反应结果</li><li>异步非阻塞<br>两个人都比较想得开，男孩表白完，干别的去了，女孩也不立即考虑这件事情，等啥时候考虑好了，再发消息给男孩</li></ol><p><a href="https://www.cnblogs.com/linkenpark/p/12376343.html" target="_blank" rel="noopener">同步阻塞、同步非阻塞、异步阻塞、异步非阻塞</a></p><hr><h2 id="5-网络通信中的线程池"><a href="#5-网络通信中的线程池" class="headerlink" title="5. 网络通信中的线程池"></a>5. 网络通信中的线程池</h2><p>我们在处理高并发请求的时候，若采用如下方法，将会造成很大的资源浪费<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720164448156.png" alt="在这里插入图片描述"></p><p>线程池的使用是为了避免这种情况，节省系统的资源</p><h3 id="5-1-java提供的线程池"><a href="#5-1-java提供的线程池" class="headerlink" title="5.1 java提供的线程池"></a>5.1 java提供的线程池</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720164855993.png" alt="在这里插入图片描述"><br>我们可以利用Runnable与Callable来创建任务，利用线程池中的线程去执行任务，最后获得结果</p><h3 id="5-2-java创建线程池的静态方法"><a href="#5-2-java创建线程池的静态方法" class="headerlink" title="5.2 java创建线程池的静态方法"></a>5.2 java创建线程池的静态方法</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/I-O模型/20200720165057685.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li><code>newSingleThreadExecutor</code>：这个线程池中只有一个线程，我们对这一个线程进行不断的复用</li><li><code>newFixedThreadPool</code>：固定线程数量的线程池，当超过线程容量的时候，要进行等待</li><li><code>newCachedThreadPool</code>：这个线程池对多出的任务，还会创建出新的线程去对其进行执行</li><li><code>newScheduledThreadPool</code>：能够实现定时处理任务的线程池</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-java-io下的字符流和字节流&quot;&gt;&lt;a href=&quot;#1-java-io下的字符流和字节流&quot; class=&quot;headerlink&quot; title=&quot;1. java.io下的字符流和字节流&quot;&gt;&lt;/a&gt;1. java.io下的字符流和字节流&lt;/h2&gt;&lt;div cl
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="https://kayleh.top/Java-network-programming/"/>
    <id>https://kayleh.top/Java-network-programming/</id>
    <published>2020-12-03T17:35:35.000Z</published>
    <updated>2020-12-05T04:11:23.162Z</updated>
    
    <content type="html"><![CDATA[<h6 id="来源CSDN：方圆"><a href="#来源CSDN：方圆" class="headerlink" title="@来源CSDN：方圆"></a>@来源CSDN：方圆</h6><h2 id="1-URL地址的构造和解析"><a href="#1-URL地址的构造和解析" class="headerlink" title="1. URL地址的构造和解析"></a>1. URL地址的构造和解析</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/Java网络编程/20200719222030510.png" alt="在这里插入图片描述"><br>我们看如上地址，一般情况下.root根域名的部分会被省略。而URL的解析过程就是从右向左进行解析，将地址转换为IP地址，进行访问。</p><h3 id="1-1-域名的层级"><a href="#1-1-域名的层级" class="headerlink" title="1.1 域名的层级"></a>1.1 域名的层级</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/Java网络编程/20200719222140239.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><h3 id="1-2-域名DNS查询的两种方式"><a href="#1-2-域名DNS查询的两种方式" class="headerlink" title="1.2 域名DNS查询的两种方式"></a>1.2 域名DNS查询的两种方式</h3><h4 id="1-2-1-递归查询"><a href="#1-2-1-递归查询" class="headerlink" title="1.2.1 递归查询"></a>1.2.1 递归查询</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/Java网络编程/20200719222304793.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>如图上所示，浏览器将请求发送给DNS客户端，客户端请求根域名服务器对域名进行解析，解析完成后，随后再访问顶级域名服务器，请求它对域名进行解析，以此类推，直至全部解析完毕，重新从三级域名服务器一层一层传递给DNS客户端，再发送给浏览器。</li></ul><h4 id="1-2-2-迭代查询"><a href="#1-2-2-迭代查询" class="headerlink" title="1.2.2 迭代查询"></a>1.2.2 迭代查询</h4><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/Java网络编程/2020071922260859.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>迭代查询是访问DNS客户端后，先访问根域名服务器，将根域名服务器中存储的该域名的内容全部发送给DNS客户端，如果无法实现域名解析的话，DNS客户端会再次请求顶级域名服务器，过程也同上，最终完成解析后，再将请求结果传递给浏览器。</li></ul><blockquote><p>Tip: 在对域名进行解析过一次后，就会产生它的缓存，存在DNS客户端中，当再次访问该域名时，就不会再去请求各个域名服务器了。对于根域名服务器，在全球是限量的，它已经被内置在DNS客户端中了，不必担心不知道根域名服务器地址的问题。</p></blockquote><hr><h2 id="2-网络协议的基础知识"><a href="#2-网络协议的基础知识" class="headerlink" title="2. 网络协议的基础知识"></a>2. 网络协议的基础知识</h2><h3 id="2-1-分层及协议"><a href="#2-1-分层及协议" class="headerlink" title="2.1 分层及协议"></a>2.1 分层及协议</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/Java网络编程/2020071922320757.png" alt="在这里插入图片描述"/></div><span class="image-caption">在这里插入图片描述</span></div><ul><li>应用层：规定应用程序的数据格式</li><li>传输层：端口之间的连接</li><li>网络层：主机之间的连接，能够实现具体的定位</li><li>链路层：网卡之间的连接，每个网卡都有自己的MAC地址，在网卡生产出来的时候就已经确定了；假如通过MAC地址传递数据，那么它会给所有子网络主机都发送一份数据，并在接收时将MAC地址进行核对，一致时才进行接受，不能实现准确的定位</li><li>实体层：解决的是计算机之间的连接，一般通过光缆进行连接</li></ul><h3 id="2-2-各层的数据包格式"><a href="#2-2-各层的数据包格式" class="headerlink" title="2.2 各层的数据包格式"></a>2.2 各层的数据包格式</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/IO/Java网络编程/20200719223925329.png" alt="在这里插入图片描述"><br>从应用层向下，每经过一层都会被添加上该层的标头，对于Ethernet标头，它的大小为18个字节，其余数据部分为1500字节，它的大小最大为1518字节，即每个帧的字节，当发送较大的文件时，就会发送多个帧的数据包，通过标头信息，在接收时能够将其组合，实现数据的正确发送。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;来源CSDN：方圆&quot;&gt;&lt;a href=&quot;#来源CSDN：方圆&quot; class=&quot;headerlink&quot; title=&quot;@来源CSDN：方圆&quot;&gt;&lt;/a&gt;@来源CSDN：方圆&lt;/h6&gt;&lt;h2 id=&quot;1-URL地址的构造和解析&quot;&gt;&lt;a href=&quot;#1-URL地址的构造
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu固定IP设置方法</title>
    <link href="https://kayleh.top/ubuntu-set-ip/"/>
    <id>https://kayleh.top/ubuntu-set-ip/</id>
    <published>2020-11-13T15:23:35.000Z</published>
    <updated>2020-12-03T17:18:32.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu固定IP设置方法"><a href="#ubuntu固定IP设置方法" class="headerlink" title="ubuntu固定IP设置方法"></a>ubuntu固定IP设置方法</h1><h2 id="确认你要修改的网卡号"><a href="#确认你要修改的网卡号" class="headerlink" title="确认你要修改的网卡号"></a>确认你要修改的网卡号</h2><p>先确认你要修改的网卡号，假设你的服务器有多张网卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ubuntu1804:~$ ip addr&#96;</span><br></pre></td></tr></table></figure><p>我的服务器配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;1: lo:  mtu 65536 qdisc noqueue state UNKNOWN &#96;&#96;group&#96; &#96;default&#96; &#96;qlen 1000&#96;&#96;link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&#96;&#96;inet 127.0.0.1&#x2F;8 scope host lo&#96;&#96;valid_lft forever preferred_lft forever&#96;&#96;inet6 ::1&#x2F;128 scope host&#96;&#96;valid_lft forever preferred_lft forever&#96;&#96;2: ens33:  mtu 1500 qdisc fq_codel state UP &#96;&#96;group&#96; &#96;default&#96; &#96;qlen 1000&#96;&#96;link&#x2F;ether 00:0c:29:f1:b5:e1 brd ff:ff:ff:ff:ff:ff&#96;&#96;inet 172.16.87.140&#x2F;24 brd 172.16.87.255 scope global dynamic ens33&#96;&#96;valid_lft 1500sec preferred_lft 1500sec&#96;&#96;inet6 fe80::20c:29ff:fef1:b5e1&#x2F;64 scope link&#96;&#96;valid_lft forever preferred_lft forever&#96;</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img2018.cnblogs.com/blog/1024482/201909/1024482-20190926195311926-778081344.png" alt="img"/></div><span class="image-caption">img</span></div><h2 id="3-默认的网卡配置文件"><a href="#3-默认的网卡配置文件" class="headerlink" title="3. 默认的网卡配置文件"></a>3. 默认的网卡配置文件</h2><p>默认情况下，网络使用DHCP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ubuntu1804:~$ cat &#x2F;etc&#x2F;netplan&#x2F;50-cloud-init.yaml&#96;&#96;配置文件内容如下&#96; &#96;network:&#96;&#96;  &#96;&#96;ethernets:&#96;&#96;    &#96;&#96;ens33:&#96;&#96;      &#96;&#96;dhcp4: yes&#96;&#96;      &#96;&#96;addresses: []&#96; &#96;  &#96;&#96;version: 2&#96;</span><br></pre></td></tr></table></figure><h2 id="4-设置静态IP"><a href="#4-设置静态IP" class="headerlink" title="4. 设置静态IP"></a>4. 设置静态IP</h2><p>需要把配置文件修改为以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ubuntu1804:~$ sudo vi &#x2F;etc&#x2F;netplan&#x2F;50-cloud-init.yaml&#96;</span><br></pre></td></tr></table></figure><p>假设IP地址修改为192.168.1.100，子网掩码24位即255.255.255.0，网关设置为192.168.1.1，DNS1：223.5.5.5，DNS2：223.6.6.6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;network:&#96;&#96;  &#96;&#96;ethernets:&#96;&#96;    &#96;&#96;ens33:&#96;&#96;      &#96;&#96;dhcp4: no&#96;&#96;      &#96;&#96;addresses: [192.168.1.100&#x2F;24]&#96;&#96;      &#96;&#96;optional: &#96;&#96;true&#96;&#96;      &#96;&#96;gateway4: 192.168.1.1&#96;&#96;      &#96;&#96;nameservers:&#96;&#96;          &#96;&#96;addresses: [223.5.5.5,223.6.6.6]&#96; &#96;  &#96;&#96;version: 2&#96;</span><br></pre></td></tr></table></figure><p>　　</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img2018.cnblogs.com/blog/1024482/201909/1024482-20190926195125025-1367860921.png" alt="img"/></div><span class="image-caption">img</span></div><h2 id="5-应用新配置"><a href="#5-应用新配置" class="headerlink" title="5. 应用新配置"></a>5. 应用新配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ubuntu1804:~$ sudo netplan apply&#96;</span><br></pre></td></tr></table></figure><p>使用<code>ip addr</code>检查新地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ubuntu1804:~$ ip addr&#96;</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img2018.cnblogs.com/blog/1024482/201909/1024482-20190926195452363-191570303.png" alt="img"/></div><span class="image-caption">img</span></div><h2 id="6-测试网络连通性"><a href="#6-测试网络连通性" class="headerlink" title="6. 测试网络连通性"></a>6. 测试网络连通性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu1804:~$ ping 192.168.1.100</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img2018.cnblogs.com/blog/1024482/201909/1024482-20190926195509927-312010988.png" alt="img"/></div><span class="image-caption">img</span></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu固定IP设置方法&quot;&gt;&lt;a href=&quot;#ubuntu固定IP设置方法&quot; class=&quot;headerlink&quot; title=&quot;ubuntu固定IP设置方法&quot;&gt;&lt;/a&gt;ubuntu固定IP设置方法&lt;/h1&gt;&lt;h2 id=&quot;确认你要修改的网卡号&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
      <category term="linux" scheme="https://kayleh.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>file input and output</title>
    <link href="https://kayleh.top/file-input-and-output/"/>
    <id>https://kayleh.top/file-input-and-output/</id>
    <published>2020-11-03T18:24:07.000Z</published>
    <updated>2020-11-03T16:23:03.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对文件的输入输出"><a href="#对文件的输入输出" class="headerlink" title="对文件的输入输出"></a>对文件的输入输出</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li><strong>程序文件</strong>。包括源程序文件，这种文件的内容是程序代码</li><li><strong>数据文件</strong>。供程序运行时读写的数据</li></ul><p>操作系统把各种设备都统一作为文件来处理。</p><p>文件一般指存储在外部介质上数据的集合。</p><h4 id="流-数据流"><a href="#流-数据流" class="headerlink" title="流(数据流)"></a>流(数据流)</h4><p>数据的输入输出.流表示了信息从源到目的地的流动.</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件路径+文件名主干+文件后缀</p><h4 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h4><ul><li><strong>ASCII文件</strong>,在存储前需要转换,<strong>文本文件</strong></li><li><strong>二进制文件</strong>,存储在内存的数据的映象,不需要加以转换输出到外存,称为<strong>映像文件</strong>.</li></ul><h4 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/1183448-20200229114252989-978233196.png" alt></p><p>ANSI C标准采用“缓冲文件系统”处理数据文件。</p><p>所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。</p><p>如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 </p><p>程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率 </p><h4 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h4><p>对于操作系统而言,关键的概念是”<strong>文件指针</strong>”.每个被使用的文件都在内存中开辟一段存储单元,用来存放文件的有关信息.这些信息是保存在一个结构体变量中的.该结构体类型变量是由系统定义的,取名为FILE.有几个文件就建立几个这样的结构体变量,分别存放各文件的有关信息.同时返回对应的FILE结构指针.</p><p>FILE结构体类型在stdio.h文件中定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  short level;            <span class="comment">//缓冲区”满”或”空”的程度//</span></span><br><span class="line">  <span class="keyword">unsigned</span> flags;         <span class="comment">//文件状态标志//</span></span><br><span class="line">  <span class="keyword">char</span> fd;               <span class="comment">//文件描述符//</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> hold;     <span class="comment">//如无缓冲区不读取字符//</span></span><br><span class="line">  short bsize;            <span class="comment">//缓冲区大小//</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>;   <span class="comment">//数据缓冲区的位置//</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *curp;    <span class="comment">//指针,当前指向//</span></span><br><span class="line">  <span class="keyword">unsigned</span> istemp;       <span class="comment">//临时文件,指示器//</span></span><br><span class="line">  short token;           <span class="comment">//用于有效性检查//</span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>定义一个指向文件型数据的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br></pre></td></tr></table></figure><p>可以使fp指向某一个文件的文件信息区(是一个结构体变量),通过该文件信息区中的信息就能够访问该文件.</p><p><strong>通过文件指针变量能够找到与它关联的文件</strong>,如果有n个文件,应设n个指针变量,分别指向n个FILE类型变量,以实现对n个文件的访问.</p><p>通常将这种指向文件信息区的指针变量简称为<strong>指向文件的指针变量</strong></p><blockquote><p>并不是指向外部介质上的数据文件的开头,而是指向内存中的文件信息区的开头.</p></blockquote><h2 id="打开与关闭文件"><a href="#打开与关闭文件" class="headerlink" title="打开与关闭文件"></a>打开与关闭文件</h2><p>“打开”指为文件建立相应的信息区(用来存放有关文件的信息)和文件缓存区(用来暂时存放输入输出的数据).</p><p>打开文件的同时,一般指定一个指针变量指向该文件,建立起指针变量与文件之间的联系.</p><h4 id="用fopen函数打开数据文件"><a href="#用fopen函数打开数据文件" class="headerlink" title="用fopen函数打开数据文件"></a>用fopen函数打开数据文件</h4><p>fopen(文件名,使用文件方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp=fopen(<span class="string">"a1"</span>,<span class="string">"r"</span>);</span><br></pre></td></tr></table></figure><p>实现失败返回NULL.</p><h4 id="使用文件方式"><a href="#使用文件方式" class="headerlink" title="使用文件方式."></a>使用文件方式.</h4><div class="table-container"><table><thead><tr><th>打开方式</th><th>含义</th><th>指定文件不存在时</th><th>指定文件存在时</th></tr></thead><tbody><tr><td>r</td><td>只读方式打开文本文件</td><td>出错</td><td>正常打开</td></tr><tr><td>w</td><td>只写方式打开文本文件</td><td>建立新文件</td><td>文件原有内容丢失</td></tr><tr><td>a</td><td>追加方式打开文本文件</td><td>建立新文件</td><td>在原有内容末尾追加</td></tr><tr><td>r+</td><td>读/写方式打开文本文件</td><td>出错</td><td>正常打开</td></tr><tr><td>w+</td><td>读/写方式创建新的文本文件</td><td>建立新文件</td><td>文件原有内容丢失</td></tr><tr><td>a+</td><td>读/追加方式建立新的文本文件</td><td>建立新文件</td><td>在原有内容末尾追加</td></tr><tr><td>rb</td><td>只读方式打开二进制文件</td><td>出错</td><td>正常打开</td></tr><tr><td>wb</td><td>只写方式打开二进制文件</td><td>建立新文件</td><td>文件原有内容丢失</td></tr><tr><td>ab</td><td>追加方式打开二进制文件</td><td>建立新文件</td><td>在原有内容末尾添加</td></tr><tr><td>rb+</td><td>读/写方式打开二进制文件</td><td>出错</td><td>正常打开</td></tr><tr><td>wb+</td><td>读/写方式创建新的二进制文件</td><td>建立新文件</td><td>文件原有内容丢失</td></tr><tr><td>ab+</td><td>读/追加方式创建新的二进制文件</td><td>建立新文件</td><td>在原有内容末尾追加</td></tr></tbody></table></div><blockquote><p>带b区别在于换行的处理</p></blockquote><h4 id="用fclose函数关闭数据文件"><a href="#用fclose函数关闭数据文件" class="headerlink" title="用fclose函数关闭数据文件"></a>用fclose函数关闭数据文件</h4><p>fclose(文件指针);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p>先把缓冲区中的数据输出到磁盘文件,然后才撤销文件信息区.</p><h2 id="顺序读写数据文件"><a href="#顺序读写数据文件" class="headerlink" title="顺序读写数据文件"></a>顺序读写数据文件</h2><h4 id="怎样向文件读写字符"><a href="#怎样向文件读写字符" class="headerlink" title="怎样向文件读写字符"></a>怎样向文件读写字符</h4><p>读写一个字符的函数.</p><div class="table-container"><table><thead><tr><th>函数名</th><th>调用形式</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>fgetc</td><td>fgetc(fp)</td><td>从fp指向的文件读入一个字符</td><td>读成功,带回所读的字符,失败了则返回文件结束标志EOF(即-1)</td></tr><tr><td>fputc</td><td>fputc(ch,fp)</td><td>把字符ch写到文件指针变量fp所指向的文件中</td><td>输出成功,返回值就是输出的字符,输出失败,则返回文件结束标志EOF(即-1)</td></tr></tbody></table></div><h5 id="从键盘输入一些字符-并逐个把它们送到磁盘上去-直到用户输入一个”-”为止"><a href="#从键盘输入一些字符-并逐个把它们送到磁盘上去-直到用户输入一个”-”为止" class="headerlink" title="从键盘输入一些字符,并逐个把它们送到磁盘上去,直到用户输入一个”#”为止."></a>从键盘输入一些字符,并逐个把它们送到磁盘上去,直到用户输入一个”#”为止.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch, filename[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入所用的文件名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, filename);</span><br><span class="line">    getchar();<span class="comment">//用来消化最后输入的回车符</span></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename, <span class="string">'w'</span>) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open file\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入一个准备存储到磁盘的字符串(以#结束):"</span>);</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(ch, fp);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">        ch = getchar(); <span class="comment">//再接收从键盘输入的一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>); <span class="comment">//向屏幕输出一个换行符s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将一个磁盘文件中的信息复制到另一个磁盘文件中"><a href="#将一个磁盘文件中的信息复制到另一个磁盘文件中" class="headerlink" title="将一个磁盘文件中的信息复制到另一个磁盘文件中"></a>将一个磁盘文件中的信息复制到另一个磁盘文件中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    <span class="keyword">char</span> ch, infile[<span class="number">10</span>], outfile[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入读入文件的名字:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, infile);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入输出文件的名字:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, outfile);</span><br><span class="line">    getchar(); <span class="comment">//用来消化最后输入的回车符</span></span><br><span class="line">    <span class="keyword">if</span> ((in = fopen(infile, <span class="string">'r'</span>) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open file\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((out = fopen(outfile, <span class="string">'w'</span>) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open file\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch = fgetc(in);</span><br><span class="line">    <span class="keyword">while</span> (!feof(in)) <span class="comment">//如未遇到输入文件的结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        fputc(ch, out);</span><br><span class="line">        <span class="built_in">putchar</span>(ch); <span class="comment">//显示在屏幕上</span></span><br><span class="line">        ch = fgetc(in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>); <span class="comment">//显示完全部字符后换行</span></span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在访问磁盘文件时,是逐个字符(字节)进行的,为了知道当前访问到第几个字节,系统用”文件读写位置标记”来表示当前所访问的位置.开始时指向第1个字节,每访问完一个字节,当前读写位置就指向下一个字节.为了知道对文件的读写是否完成,只需看文件读写位置是否移到文件的末尾.</p><blockquote><p>feof函数可以检测文件是否已被读取过.</p></blockquote><h4 id="怎样向文件读写一个字符串"><a href="#怎样向文件读写一个字符串" class="headerlink" title="怎样向文件读写一个字符串"></a>怎样向文件读写一个字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str,n,fp);</span><br></pre></td></tr></table></figure><p>作用是从fp所指向的文件中读入一个长度为n-1的字符串,并在最后加一个’\0’字符,然后把这n个字符存放到字符数组str中.</p><p><strong>读写一个字符串的函数</strong></p><div class="table-container"><table><thead><tr><th>函数名</th><th>调用形式</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>fgets</td><td>fgets(str,n,fp)</td><td>从fp指向的文件读入一个长度为(n-1)的字符串,存放到字符数组str中.</td><td>读成功,返回地址str,失败则返回NULL</td></tr><tr><td>fputs</td><td>fputs(str,fp)</td><td>把str所指向的字符串写到文件指针变量fp所指向的文件中</td><td>输出成功,返回0;否则返回非0值</td></tr></tbody></table></div><p><strong>fgets函数的原型为：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * str,<span class="keyword">int</span> n,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>作用是从文件读入一个字符串.调用时可以写成下面的形式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str,n,fp)</span><br></pre></td></tr></table></figure><p>n是要求得到的字符个数,但实际上只从fp所指向的文件中读入n-1字符,然后在最后加一个’\0’字符,这样得到的字符串共有n个字符,把它们放到字符数组str中.</p><p>如果在读完n-1个字符之前遇到换行符’\n’或文件结束符EOF,读入即结束,但将所遇到的换行符”\n”也作为一个字符读入.执行成功返回值为str数组首元素的地址,如果一开始就遇到文件尾或读数据出错,则为NULL.</p><p><strong>fputs函数的原型为：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fputs</span><span class="params">(<span class="keyword">char</span> * str,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>其作用是将str所指向的字符串输出到fp所指向的文件中.调用时可以写成下面的形式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">"China"</span>,fp);</span><br></pre></td></tr></table></figure><p>第一个参数可以是字符串常量,字符数组名或字符型指针.字符串末尾的’\0’不输出.输出成功,函数值为0,不成功则为EOF(-1).</p><h5 id="从键盘读入若干个字符串-对它们按字母大小的顺序排序-然后把排好序的字符串送到磁盘文件中保存"><a href="#从键盘读入若干个字符串-对它们按字母大小的顺序排序-然后把排好序的字符串送到磁盘文件中保存" class="headerlink" title="从键盘读入若干个字符串,对它们按字母大小的顺序排序,然后把排好序的字符串送到磁盘文件中保存."></a>从键盘读入若干个字符串,对它们按字母大小的顺序排序,然后把排好序的字符串送到磁盘文件中保存.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">10</span>], temp[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, k, n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter strings:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        gets(str[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) <span class="comment">//用选择法对字符串排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str[k], str[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                k = j;</span><br><span class="line">            <span class="keyword">if</span> (k != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(temp, str[i]);</span><br><span class="line">                <span class="built_in">strcpy</span>(str[i], str[k]);</span><br><span class="line">                <span class="built_in">strcpy</span>(str[k], temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"D:\\CC\\string.dat"</span>, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open file!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nThe new sequence:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(str[i], fp);</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"\n"</span>, fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用格式化的方式读写文本文件"><a href="#用格式化的方式读写文本文件" class="headerlink" title="用格式化的方式读写文本文件"></a>用格式化的方式读写文本文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(文件指针,格式化字符串,输出表列);</span><br><span class="line"><span class="built_in">fscanf</span>(文件指针,格式化字符串,输入表列);<span class="comment">//从磁盘文件上读入ASCII字符</span></span><br><span class="line">---</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"%d,%6.2f"</span>,i,f);</span><br></pre></td></tr></table></figure><p>因为在输入时要将文件中的ASCII码<strong>转换为二进制形式</strong>再保存在内存变量中,在输出时又要将内存中的二进制形式转换成字符,要花费更多的时间,因此,在内存与磁盘交换数据的情况下,最好不用fprintf和fscanf函数,而用fread和fwrite函数.</p><h4 id="用二进制方式向文件读写一组数据"><a href="#用二进制方式向文件读写一组数据" class="headerlink" title="用二进制方式向文件读写一组数据"></a>用二进制方式向文件读写一组数据</h4><p>允许用fread函数从文件读一个数据块,用fwrite函数向文件写一个数据块.在读写时以二进制形式进行的.在向磁盘写数据时,直接将内存中的一组数据<strong>原封不动,不加转换</strong>地复制到磁盘文件上,读入时也是将磁盘文件中若干字节的内容一批读入内存.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(<span class="built_in">buffer</span>,<span class="built_in">size</span>,count,fp);</span><br><span class="line">fwrite(<span class="built_in">buffer</span>,<span class="built_in">size</span>,count,fp);</span><br></pre></td></tr></table></figure><blockquote><p>buffer:</p><ul><li>fread:用来存放从文件读入的数据的存储区的地址</li><li>fwrite:把此地址开始的存储区中的数据向文件输出(指起始地址)</li></ul><p>size：要读的每个数据块的字节数<br>count：要读的数据块的个数<br>fp：文件指针</p></blockquote><p>如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(f,<span class="number">4</span>,<span class="number">10</span>,fp);</span><br><span class="line"><span class="comment">//f是一个float型数组名(代表数组首元素地址),从fp所指向的文件读入10个4个字节的数据,存储到数组f中</span></span><br></pre></td></tr></table></figure><p>fread或fwrite执行成功返回<strong>count</strong>(输入或输出数据项的个数).</p><h5 id="从键盘输入10个学生的有关数据-然后把它们转存到磁盘文件上"><a href="#从键盘输入10个学生的有关数据-然后把它们转存到磁盘文件上" class="headerlink" title="从键盘输入10个学生的有关数据,然后把它们转存到磁盘文件上."></a>从键盘输入10个学生的有关数据,然后把它们转存到磁盘文件上.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">15</span>];</span><br><span class="line">&#125; stu[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"D:\\CC\\string.dat"</span>, <span class="string">"wb"</span>)) == <span class="literal">NULL</span>)<span class="comment">//二进制文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open file!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        <span class="keyword">if</span> ((fwrite(&amp;stu[i], <span class="keyword">sizeof</span>(struct Student_type), <span class="number">1</span>, fp) != <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file write error!\n"</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter datas of student:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d %d %s"</span>, stu[i].name, &amp;stu[i].num, &amp;stu[i].age, stu[i].addr);</span><br><span class="line">    save();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h4><ul><li><p>数据的存储方式</p><p>​    文本方式: 数据以字符方式(ASCII代码)存储到文件中.如整数12,送到文件时占2个字节,而不是4个字节.以文本方式保存的数据便于阅读</p><p>​    二进制方式:数据按在内存的存储状态原封不动地复制到文件.如整数12,送到文件时和内存中一样占4个字节.</p></li><li><p>文件的分类</p><p>​    文本文件(ASCII文件):文件全部为ASCII字符</p><p>​    二进制文件:按二进制方式把在内存中的数据复制到文件的,称为二进制文件,即映像文件.</p></li><li><p>文件的打开方式</p><p>​    文本方式: 不带b的方式,读写文件时<strong>对换行符进行转换</strong></p><p>​    文本方式: 带b的方式,读写文件时<strong>对换行符不进行转换</strong></p></li><li><p>文件读写函数</p><p>​    文本读写函数:用来向文本文件读写字符数据的函数(如fgetc,fgets,fputc,fputs,fscanf,fprintf等)</p><p>​    二进制读写函数:用来向二进制文件读写二进制数据的函数(如getw,putw,fread,fwrite等)</p></li></ul><hr><h2 id="随机读写数据文件"><a href="#随机读写数据文件" class="headerlink" title="随机读写数据文件"></a>随机读写数据文件</h2><h3 id="文件位置标记及其定位"><a href="#文件位置标记及其定位" class="headerlink" title="文件位置标记及其定位"></a>文件位置标记及其定位</h3><h4 id="文件位置标记"><a href="#文件位置标记" class="headerlink" title="文件位置标记"></a>文件位置标记</h4><p>文件位置标记用来指示”接下来要读写的下一个字符的位置”</p><h4 id="文件位置标记的定位"><a href="#文件位置标记的定位" class="headerlink" title="文件位置标记的定位"></a>文件位置标记的定位</h4><p>:one: 用rewind函数使文件位置标记指向开头.同时feof函数的值会回复为0(假).</p><h5 id="有一个磁盘文件-内有一些信息-要求第1次将它的内容显示在屏幕上-第2次把它复制到另一文件上"><a href="#有一个磁盘文件-内有一些信息-要求第1次将它的内容显示在屏幕上-第2次把它复制到另一文件上" class="headerlink" title="有一个磁盘文件,内有一些信息.要求第1次将它的内容显示在屏幕上,第2次把它复制到另一文件上."></a>有一个磁盘文件,内有一些信息.要求第1次将它的内容显示在屏幕上,第2次把它复制到另一文件上.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp1, *fp2;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    fp1 = fopen(<span class="string">"file1.dat"</span>, <span class="string">"r"</span>); <span class="comment">//不含路径默认在源文件所在目录</span></span><br><span class="line">    fp2 = fopen(<span class="string">"file2.dat"</span>, <span class="string">"w"</span>);</span><br><span class="line">    ch = getc(fp1);</span><br><span class="line">    <span class="keyword">while</span> (!feof(fp1)) <span class="comment">//或者 while(ch!=EOF)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">        ch = getc(fp1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    rewind(fp1);</span><br><span class="line">    ch = getc(fp1);</span><br><span class="line">    <span class="keyword">while</span> (!feof(fp1))</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(ch, fp2);</span><br><span class="line">        ch = getc(fp1);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:two:用fseek函数改变文件位置标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(文件类型指针,位移量,起始点);</span><br></pre></td></tr></table></figure><p><strong>起始点:</strong></p><div class="table-container"><table><thead><tr><th>起始点</th><th>名字</th><th>用数字代表</th></tr></thead><tbody><tr><td>文件开始位置</td><td>SEEK_SET</td><td>0</td></tr><tr><td>文件当前位置</td><td>SEEK_CUR</td><td>1</td></tr><tr><td>文件末尾位置</td><td>SEEK_END</td><td>2</td></tr></tbody></table></div><p>位移量:以”起始点”为基点,应是long型数据(在数字的末尾加一个字母L,就表示是long型);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">100L</span>,<span class="number">0</span>);<span class="comment">//将文件位置标记先前移到离文件开头100个字节处.</span></span><br></pre></td></tr></table></figure><p>:three:用ftell函数测定文件位置标记的当前位置.</p><p>函数得到流式文件中文件位置标记的当前位置.调用函数时出错(如不存在fp指向的文件),返回值为-1L.</p><h4 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h4><h5 id="在磁盘文件上存有10个学生的数据-要求将第1-3-5-7-9个学生数据输入计算机-并在屏幕上显示出来"><a href="#在磁盘文件上存有10个学生的数据-要求将第1-3-5-7-9个学生数据输入计算机-并在屏幕上显示出来" class="headerlink" title="在磁盘文件上存有10个学生的数据.要求将第1,3,5,7,9个学生数据输入计算机,并在屏幕上显示出来."></a>在磁盘文件上存有10个学生的数据.要求将第1,3,5,7,9个学生数据输入计算机,并在屏幕上显示出来.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">15</span>];</span><br><span class="line">&#125; stu[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"D:\\CC\\string.dat"</span>, <span class="string">"wb"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open file!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fseek(fp, i * <span class="keyword">sizeof</span>(struct Student_type), <span class="number">0</span>);</span><br><span class="line">        fread(&amp;stu[i], <span class="keyword">sizeof</span>(struct Student_type), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-10s %4d %4d %-15s\n"</span>, stu[i].name, stu[i].num, stu[i].age, stu[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件读写的出错检测"><a href="#文件读写的出错检测" class="headerlink" title="文件读写的出错检测"></a>文件读写的出错检测</h2><p>检查输入输出函数调用时可能出现的错误.</p><p><strong>ferror函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ferror(fp);</span><br></pre></td></tr></table></figure><p>如果返回值为0,表示未出现错误.</p><p>如果返回一个非零值,表示出错.</p><blockquote><p>对同一个文件每一次调用输入输出函数,都会产生一个新的ferror函数值.因此在调用一个输入输出函数后立即检查ferror的值,否则信息会丢失.</p><p>在执行fopen函数时,ferror函数的初始值自动置为0.</p></blockquote><p><strong>clearerr函数</strong></p><p>使文件出错标记和文件结束标记置为0.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对文件的输入输出&quot;&gt;&lt;a href=&quot;#对文件的输入输出&quot; class=&quot;headerlink&quot; title=&quot;对文件的输入输出&quot;&gt;&lt;/a&gt;对文件的输入输出&lt;/h1&gt;&lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="C" scheme="https://kayleh.top/tags/C/"/>
    
  </entry>
  
</feed>
