<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kayleh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dqlcr5.coding-pages.com/"/>
  <updated>2020-07-14T05:46:09.133Z</updated>
  <id>http://dqlcr5.coding-pages.com/</id>
  
  <author>
    <name>Kayleh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>J2EE</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/J2EE/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/J2EE/</id>
    <published>2020-07-14T05:44:34.000Z</published>
    <updated>2020-07-14T05:46:09.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><a id="more"></a><h3 id="JAVA应用服务器都有那些？"><a href="#JAVA应用服务器都有那些？" class="headerlink" title="JAVA应用服务器都有那些？"></a>JAVA应用服务器都有那些？</h3><p>BEA WebLogic Server，</p><p>IBM WebSphere Application Server，</p><p>Oracle9i Application Server</p><p>jBoss，</p><p>Tomcat</p><h3 id="在什么情况下回使用assert？"><a href="#在什么情况下回使用assert？" class="headerlink" title="在什么情况下回使用assert？"></a>在什么情况下回使用assert？</h3><p>assertion (断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个 boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 </p><h3 id="1分钟之内只能处理1000个请求，你怎么实现，手撕代码"><a href="#1分钟之内只能处理1000个请求，你怎么实现，手撕代码" class="headerlink" title="1分钟之内只能处理1000个请求，你怎么实现，手撕代码?"></a>1分钟之内只能处理1000个请求，你怎么实现，手撕代码?</h3><p> 限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶 </p><h3 id="如何在链接里不输入项目名称的情况下启动项目？"><a href="#如何在链接里不输入项目名称的情况下启动项目？" class="headerlink" title="如何在链接里不输入项目名称的情况下启动项目？"></a>如何在链接里不输入项目名称的情况下启动项目？</h3><p> 可在taomcat配置虚拟目录。 </p><h3 id="说明一下JSP中的静态包含和动态包含的有哪些区别？"><a href="#说明一下JSP中的静态包含和动态包含的有哪些区别？" class="headerlink" title="说明一下JSP中的静态包含和动态包含的有哪些区别？"></a>说明一下JSP中的静态包含和动态包含的有哪些区别？</h3><p>静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作<a href="jsp:forward">jsp:forward</a>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的”contentType”属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。</p><p>例如：</p><p>&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file=”…” %&gt;</p><p>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page=”…”&gt;<br>&lt;jsp:param name=”…” value=”…” /&gt;<br> &lt;&gt; </p><h3 id="请说一下表达式语言（EL）的隐式对象以及该对象的作用"><a href="#请说一下表达式语言（EL）的隐式对象以及该对象的作用" class="headerlink" title="请说一下表达式语言（EL）的隐式对象以及该对象的作用"></a>请说一下表达式语言（EL）的隐式对象以及该对象的作用</h3><p>EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。 </p><h3 id="谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？"><a href="#谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？" class="headerlink" title="谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？"></a>谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？</h3><p>JSP有9个内置对象：<br>- request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>- response：封装服务器对客户端的响应；<br>- pageContext：通过该对象可以获取其他对象；<br>- session：封装用户会话的对象；<br>- application：封装服务器运行环境的对象；<br>- out：输出服务器响应的输出流对象；<br>- config：Web应用的配置对象；<br>- page：JSP页面本身（相当于Java程序中的this）；<br>- exception：封装页面抛出异常的对象。</p><p>如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。</p><h3 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然后在浏览器上就可打入主机？"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然后在浏览器上就可打入主机？" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？</h3><p>端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?<br>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。 </p><h3 id="请说明一下jsp有哪些动作-这些动作的作用又分别是什么"><a href="#请说明一下jsp有哪些动作-这些动作的作用又分别是什么" class="headerlink" title="请说明一下jsp有哪些动作? 这些动作的作用又分别是什么?"></a>请说明一下jsp有哪些动作? 这些动作的作用又分别是什么?</h3><p>JSP 共有以下6种基本动作</p><p>jsp:include：在页面被请求的时候引入一个文件。 </p><p>jsp:useBean：寻找或者实例化一个JavaBean。<br>jsp:setProperty：设置JavaBean的属性。</p><p>jsp:getProperty：输出某个JavaBean的属性。 </p><p>jsp:forward：把请求转到一个新的页面。</p><p>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</p><h3 id="详细说明一下Request对象的主要方法是什么？"><a href="#详细说明一下Request对象的主要方法是什么？" class="headerlink" title="详细说明一下Request对象的主要方法是什么？"></a>详细说明一下Request对象的主要方法是什么？</h3><p> setAttribute(String name,Object)：设置名字为name的request的参数值<br>getAttribute(String name)：返回由name指定的属性值<br>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的Body的长度<br>getHeader(String name)：获得HTTP协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例<br>getParameterValues(String name)：获得有name指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的IP地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性 </p><h3 id="请简要说明一下四种会话跟踪技术分别是什么？"><a href="#请简要说明一下四种会话跟踪技术分别是什么？" class="headerlink" title="请简要说明一下四种会话跟踪技术分别是什么？"></a>请简要说明一下四种会话跟踪技术分别是什么？</h3><p>会话作用域ServletsJSP 页面描述<br>page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于forward 指令和 include 动作的关系）session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。 </p><h3 id="请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？"><a href="#请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？" class="headerlink" title="请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？"></a>请简要说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？</h3><p>JSP 是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是”类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑 </p><h3 id="请说明一下JSP的内置对象以及该对象的使用方法。"><a href="#请说明一下JSP的内置对象以及该对象的使用方法。" class="headerlink" title="请说明一下JSP的内置对象以及该对象的使用方法。"></a>请说明一下JSP的内置对象以及该对象的使用方法。</h3><p> request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。<br>response表示HttpServletResponse对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）<br>out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。<br>pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。<br>session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息<br>applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息<br>config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。<br>page表示从该页面产生的一个servlet实例 </p><h3 id="请说明一下web-xml文件中可以配置哪些内容？"><a href="#请说明一下web-xml文件中可以配置哪些内容？" class="headerlink" title="请说明一下web.xml文件中可以配置哪些内容？"></a>请说明一下web.xml文件中可以配置哪些内容？</h3><p> web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：</p><p>①配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：<br><context-param><br><param-name>contextConfigLocation</param-name><br><param-value>classpath:applicationContext.xml</param-value><br></context-param></p><listener><listener-class>org.springframework.web.context.ContextLoaderListener</listener-class></listener><p>②配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：</p><filter><filter-name>openSessionInView</filter-name><filter-class>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter</filter-class></filter><filter-mapping><filter-name>openSessionInView</filter-name><url-pattern>/*</url-pattern></filter-mapping><p>③配置会话超时时间为10分钟：</p><session-config><session-timeout>10</session-timeout></session-config><p>④配置404和Exception的错误页面：<br><error-page><br><error-code>404</error-code><br><location>/error.jsp</location><br></error-page></p><error-page><exception-type>java.lang.Exception</exception-type><location>/error.jsp</location></error-page>⑤配置安全认证方式：<security-constraint><web-resource-collection><web-resource-name>ProtectedArea</web-resource-name><url-pattern>/admin/*</url-pattern><http-method>GET</http-method><http-method>POST</http-method></web-resource-collection><auth-constraint><role-name>admin</role-name></auth-constraint></security-constraint><login-config><auth-method>BASIC</auth-method></login-config><security-role><role-name>admin</role-name></security-role> <h3 id="谈谈你对Javaweb开发中的监听器的理解？"><a href="#谈谈你对Javaweb开发中的监听器的理解？" class="headerlink" title="谈谈你对Javaweb开发中的监听器的理解？"></a>谈谈你对Javaweb开发中的监听器的理解？</h3><p>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：<br>①ServletContextListener：对Servlet上下文的创建和销毁进行监听。<br>②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。<br>③HttpSessionListener：对Session的创建和销毁进行监听。</p><p>session的销毁有两种情况：1). session超时（可以在web.xml中通过<session-config>/<session-timeout>标签配置超时时间）；2). 通过调用session对象的invalidate()方法使session失效。<br>④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。<br>⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。<br>⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</session-timeout></session-config></p><h3 id="请问过滤器有哪些作用？以及过滤器的用法又是什么呢"><a href="#请问过滤器有哪些作用？以及过滤器的用法又是什么呢" class="headerlink" title="请问过滤器有哪些作用？以及过滤器的用法又是什么呢?"></a>请问过滤器有哪些作用？以及过滤器的用法又是什么呢?</h3><p>Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。</p><p>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。<br>和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。</p><h3 id="请问使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？"><a href="#请问使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？" class="headerlink" title="请问使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？"></a>请问使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？</h3><p> 可以通过重写Servlet接口的init(ServletConfig)方法并通过ServletConfig对象的getInitParameter()方法来获取Servlet的初始化参数。可以通过ServletConfig对象的getServletContext()方法获取ServletContext对象，并通过该对象的getInitParameter()方法来获取服务器上下文参数。当然，ServletContext对象也在处理用户请求的方法（如doGet()方法）中通过请求对象的getServletContext()方法来获得。 </p><h3 id="请问使用Servlet如何获取用户提交的查询参数以及表单数据？"><a href="#请问使用Servlet如何获取用户提交的查询参数以及表单数据？" class="headerlink" title="请问使用Servlet如何获取用户提交的查询参数以及表单数据？"></a>请问使用Servlet如何获取用户提交的查询参数以及表单数据？</h3><p>可以通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。 </p><h3 id="服务器收到用户提交的表单数据，请问调用了以下方法中的哪一个方法？第一个是Servlet中的doGet-方法，第二个Servlet中的是doPost-方法"><a href="#服务器收到用户提交的表单数据，请问调用了以下方法中的哪一个方法？第一个是Servlet中的doGet-方法，第二个Servlet中的是doPost-方法" class="headerlink" title="服务器收到用户提交的表单数据，请问调用了以下方法中的哪一个方法？第一个是Servlet中的doGet()方法，第二个Servlet中的是doPost()方法"></a>服务器收到用户提交的表单数据，请问调用了以下方法中的哪一个方法？第一个是Servlet中的doGet()方法，第二个Servlet中的是doPost()方法</h3><p>HTML的<form>元素有一个method属性，用来指定提交表单的方式，其值可以是get或post。我们自定义的Servlet一般情况下会重写doGet()或doPost()两个方法之一或全部，如果是GET请求就调用doGet()方法，如果是POST请求就调用doPost()方法，那为什么为什么这样呢？我们自定义的Servlet通常继承自HttpServlet，HttpServlet继承自GenericServlet并重写了其中的service()方法，这个方法是Servlet接口中定义的。HttpServlet重写的service()方法会先获取用户请求的方法，然后根据请求方法调用doGet()、doPost()、doPut()、doDelete()等方法，如果在自定义Servlet中重写了这些方法，那么显然会调用重写过的（自定义的）方法，这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java与模式》一书的第37章）。当然，自定义Servlet中也可以直接重写service()方法，那么不管是哪种方式的请求，都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。 </form></p><h3 id="请问如何在基于Java的Web项目中实现文件上传和下载？"><a href="#请问如何在基于Java的Web项目中实现文件上传和下载？" class="headerlink" title="请问如何在基于Java的Web项目中实现文件上传和下载？"></a>请问如何在基于Java的Web项目中实现文件上传和下载？</h3><p>在Sevlet 3 以前，Servlet API中没有支持上传功能的API，因此要实现上传功能需要引入第三方工具从POST请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们推荐使用Apache的commons-fileupload。<br>从Servlet 3开始，文件上传变得简单许多。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com.jackfrued.servlet;</span><br><span class="line"> <span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"> <span class="meta">@WebServlet</span>(<span class="string">"/UploadServlet"</span>)</span><br><span class="line"> <span class="meta">@MultipartConfig</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">             </span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">         <span class="comment">// 可以用request.getPart()方法获得名为photo的上传附件</span></span><br><span class="line">         <span class="comment">// 也可以用request.getParts()获得所有上传附件（多文件上传）</span></span><br><span class="line">         <span class="comment">// 然后通过循环分别处理每一个上传的文件</span></span><br><span class="line">         Part part = request.getPart(<span class="string">"photo"</span>);</span><br><span class="line">         <span class="keyword">if</span> (part != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">part.getSubmittedFileName().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径</span></span><br><span class="line">             String</span><br><span class="line">savePath = request.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">             <span class="comment">// Servlet</span></span><br><span class="line"><span class="number">3.1</span>规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名</span><br><span class="line">             <span class="comment">// 更好的做法是为上传的文件进行重命名（避免同名文件的相互覆盖）</span></span><br><span class="line">             </span><br><span class="line">part.write(savePath + <span class="string">"/"</span> + part.getSubmittedFileName());</span><br><span class="line">             </span><br><span class="line">request.setAttribute(<span class="string">"hint"</span>, <span class="string">"Upload Successfully!"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             request.setAttribute(<span class="string">"hint"</span>,</span><br><span class="line"><span class="string">"Upload failed!"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 跳转回到上传页面</span></span><br><span class="line">         </span><br><span class="line">request.getRequestDispatcher(<span class="string">"index.jsp"</span>).forward(request, response);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="说明一下Servlet-3中的异步处理指的是什么？"><a href="#说明一下Servlet-3中的异步处理指的是什么？" class="headerlink" title="说明一下Servlet 3中的异步处理指的是什么？"></a>说明一下Servlet 3中的异步处理指的是什么？</h3><p>在Servlet 3中引入了一项新的技术可以让Servlet异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么Servlet或Filter会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个Runnable对象交给Executor并立即返回即可。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span></span><br><span class="line">java.io.IOException;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.AsyncContext;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"> <span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> <span class="meta">@WebServlet</span>(urlPatterns = &#123;<span class="string">"/async"</span>&#125;, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">ServletException, IOException </span>&#123;</span><br><span class="line">         <span class="comment">// 开启Tomcat异步Servlet支持</span></span><br><span class="line">         </span><br><span class="line">req.setAttribute(<span class="string">"org.apache.catalina.ASYNC_SUPPORTED"</span>, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">final</span> AsyncContext ctx =</span><br><span class="line">req.startAsync();  <span class="comment">// 启动异步处理的上下文</span></span><br><span class="line">         <span class="comment">// ctx.setTimeout(30000);</span></span><br><span class="line">         ctx.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line">run() &#123;</span><br><span class="line">                 </span><br><span class="line"><span class="comment">// 在此处添加异步处理的代码</span></span><br><span class="line">                 </span><br><span class="line">ctx.complete();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="说说Servlet接口中有哪些方法？"><a href="#说说Servlet接口中有哪些方法？" class="headerlink" title="说说Servlet接口中有哪些方法？"></a>说说Servlet接口中有哪些方法？</h3><p>Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：<br>- void init(ServletConfig config) throws ServletException<br>- void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException<br>- void destory()<br>- java.lang.String getServletInfo()<br>- ServletConfig getServletConfig()<br>Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。</p><h3 id="阐述一下阐述Servlet和CGI的区别"><a href="#阐述一下阐述Servlet和CGI的区别" class="headerlink" title="阐述一下阐述Servlet和CGI的区别?"></a>阐述一下阐述Servlet和CGI的区别?</h3><p> Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。 </p><h3 id="在Servlet执行的过程中，一般实现哪几个方法？"><a href="#在Servlet执行的过程中，一般实现哪几个方法？" class="headerlink" title="在Servlet执行的过程中，一般实现哪几个方法？"></a>在Servlet执行的过程中，一般实现哪几个方法？</h3><p>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)</p><p>public void destroy()<br>init ()方法在servlet的生命周期中仅执行一次，在服务器装载servlet时执行。缺省的init()方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性装入GIF图像，初始化数据库连接等，缺省的inti()方法设置了servlet的初始化参数，并用它的ServeltConfig对象参数来启动配置，所以覆盖init()方法时，应调用super.init()以确保仍然执行这些任务。service ()方法是servlet的核心，在调用service()方法之前，应确保已完成init()方法。对于HttpServlet，每当客户请求一个HttpServlet对象，该对象的service()方法就要被调用，HttpServlet缺省的service()方法的服务功能就是调用与 HTTP请求的方法相应的do功能，doPost()和doGet()，所以对于HttpServlet，一般都是重写doPost()和doGet() 方法。destroy()方法在servlet的生命周期中也仅执行一次，即在服务器停止卸载servlet时执行，把servlet作为服务器进程的一部分关闭。缺省的destroy()方法通常是符合要求的，但也可以override，比如在卸载servlet时将统计数字保存在文件中，或是关闭数据库连接getServletConfig()方法返回一个servletConfig对象，该对象用来返回初始化参servletContext。servletContext接口提供有关servlet的环境信息。getServletInfo()方法提供有关servlet的信息，如作者，版本，版权。</p><h3 id="请说出Servlet的生命周期是什么样的？并且请分析一下Servlet和CGI的区别。"><a href="#请说出Servlet的生命周期是什么样的？并且请分析一下Servlet和CGI的区别。" class="headerlink" title="请说出Servlet的生命周期是什么样的？并且请分析一下Servlet和CGI的区别。"></a>请说出Servlet的生命周期是什么样的？并且请分析一下Servlet和CGI的区别。</h3><p> Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。<br>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 </p><h3 id="回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"><a href="#回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？" class="headerlink" title="回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"></a>回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？</h3><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><p>Servlet 通过调用 init () 方法进行初始化。</p><p>Servlet 调用 service() 方法来处理客户端的请求。</p><p>Servlet 通过调用 destroy() 方法终止（结束）。</p><p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p><p>Servlet单实例，减少了产生servlet的开销；</p><h3 id="简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？"><a href="#简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？" class="headerlink" title="简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？"></a>简要说明一下forward与redirect区别，并且说一下你知道的状态码都有哪些？以及redirect的状态码又是多少？</h3><p>1.从地址栏显示来说</p><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</p><p>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><p>2.从数据共享来说</p><p>forward:转发页面和转发到的页面可以共享request里面的数据.</p><p>redirect:不能共享数据.</p><p>3.从运用地方来说</p><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.</p><p>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.</p><p>4.从效率来说</p><p>forward:高.</p><p>redirect:低.</p><p>redirect的状态码是302</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-Web&quot;&gt;&lt;a href=&quot;#Java-Web&quot; class=&quot;headerlink&quot; title=&quot;Java Web&quot;&gt;&lt;/a&gt;Java Web&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>MVC</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/MVC/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/MVC/</id>
    <published>2020-07-14T05:43:03.000Z</published>
    <updated>2020-07-14T05:44:08.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><a id="more"></a><h3 id="请谈一下Spring-MVC的工作原理是怎样的？"><a href="#请谈一下Spring-MVC的工作原理是怎样的？" class="headerlink" title="请谈一下Spring MVC的工作原理是怎样的？"></a>请谈一下Spring MVC的工作原理是怎样的？</h3><p>①客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。<br>② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。<br>③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。<br>④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。<br>⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。<br>⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。<br>⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。<br>⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。 </p><h3 id="简述一下SpringMVC的运行机制？以及运行机制的流程是什么？"><a href="#简述一下SpringMVC的运行机制？以及运行机制的流程是什么？" class="headerlink" title="简述一下SpringMVC的运行机制？以及运行机制的流程是什么？"></a>简述一下SpringMVC的运行机制？以及运行机制的流程是什么？</h3><p>1、用户发送请求时会先从DispathcherServler的doService方法开始，在该方法中会将ApplicationContext、localeResolver、themeResolver等对象添加到request中，紧接着就是调用doDispatch方法。</p><p>2、进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是post并且contenttType是否为multipart/为前缀)即调用的是checkMultipart方法；如果是的将request包装成MultipartHttpServletRequest。</p><p>3、然后调用getHandler方法来匹配每个HandlerMapping对象，如果匹配成功会返回这个Handle的处理链HandlerExecutionChain对象，在获取该对象的内部其实也获取我们自定定义的拦截器，并执行了其中的方法。</p><p>4、执行拦截器的preHandle方法，如果返回false执行afterCompletion方法并理解返回</p><p>5、通过上述获取到了HandlerExecutionChain对象，通过该对象的getHandler()方法获得一个object通过HandlerAdapter进行封装得到HandlerAdapter对象。</p><p>6、该对象调用handle方法来执行Controller中的方法，该对象如果返回一个ModelAndView给DispatcherServlet。</p><p>7、DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View后DispatcherServlet使用这个View对ModelAndView中的模型数据进行视图渲染。</p><h3 id="说明一下springmvc和spring-boot区别是什么？"><a href="#说明一下springmvc和spring-boot区别是什么？" class="headerlink" title="说明一下springmvc和spring-boot区别是什么？"></a>说明一下springmvc和spring-boot区别是什么？</h3><p>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能。 </p><h3 id="说明一下Spring-MVC注解的优点是什么？"><a href="#说明一下Spring-MVC注解的优点是什么？" class="headerlink" title="说明一下Spring MVC注解的优点是什么？"></a>说明一下Spring MVC注解的优点是什么？</h3><p>1、XML配置起来有时候冗长，此时注解可能是更好的选择，如jpa的实体映射；注解在处理一些不变的元数据时有时候比XML方便的多，比如springmvc的数据绑定，如果用xml写的代码会多的多；</p><p>2、注解最大的好处就是简化了XML配置；其实大部分注解一定确定后很少会改变，所以在一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；</p><p>3、注解相对于XML的另一个好处是类型安全的，XML只能在运行期才能发现问题。</p><h3 id="请简单介绍一下你了解的Java领域中的Web-Service框架都有哪些？"><a href="#请简单介绍一下你了解的Java领域中的Web-Service框架都有哪些？" class="headerlink" title="请简单介绍一下你了解的Java领域中的Web Service框架都有哪些？"></a>请简单介绍一下你了解的Java领域中的Web Service框架都有哪些？</h3><p>Java领域的Web Service框架很多，包括Axis2（Axis的升级版本）、Jersey（RESTful的Web Service框架）、CXF（XFire的延续版本）、Hessian、Turmeric、JBoss SOA等，其中绝大多数都是开源框架。 </p><h3 id="简述一下Mybatis和Hibernate的区别是什么？"><a href="#简述一下Mybatis和Hibernate的区别是什么？" class="headerlink" title="简述一下Mybatis和Hibernate的区别是什么？"></a>简述一下Mybatis和Hibernate的区别是什么？</h3><p>1、简介</p><p>Hibernate：Hibernate是当前最流行的ORM框架之一，对JDBC提供了较为完整的封装。Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL的自动生成和执行。</p><p>Mybatis：Mybatis同样也是非常流行的ORM框架，主要着力点在于 POJO 与 SQL 之间的映射关系。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定 POJO 。相对Hibernate“O/R”而言，Mybatis 是一种“Sql Mapping”的ORM实现。</p><p>2、缓存机制对比</p><p>相同点</p><p>Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p><p>不同点</p><p>Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</p><p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p><p>两者比较</p><p>因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p><p>Mybatis：小巧、方便、高效、简单、直接、半自动化</p><p>Hibernate：强大、方便、高效、复杂、间接、全自动化</p><h3 id="请问EJB需要直接实现它的业务接口或者Home接口吗？请简述一下理由。"><a href="#请问EJB需要直接实现它的业务接口或者Home接口吗？请简述一下理由。" class="headerlink" title="请问EJB需要直接实现它的业务接口或者Home接口吗？请简述一下理由。"></a>请问EJB需要直接实现它的业务接口或者Home接口吗？请简述一下理由。</h3><p> 在EJB中则至少要包括10个class:<br>Bean类，特定App Server的Bean实现类Bean的remote接口，特定App Server的remote接口实现类，特定App Server的remote接口的实现类的stub类和skeleton类。<br>Bean的home接口，特定App Server的home接口实现类，特定App Server的home接口的实现类的stub类和skeleton类。<br>和RMI不同的是，EJB中这10个class真正需要用户写的只有3个，Bean类，remote接口，home接口，其它的7个究竟怎么生成，被打包在哪里，是否需要更多的类文件，否根据不同的App Server表现出较大的差异。<br>Weblogic：<br>home接口和remote接口的weblogic的实现类的stub类和skeleton类是在EJB被部署到weblogic的时候，由weblogic动态生成stub类和skeleton类的字节码，所以看不到这4个类文件。<br>对于一次客户端远程调用EJB，要经过两个远程对象的多次RMI循环。首先是通过JNDI查找Home接口，获得Home接口的实现类，这个过程其实相当复杂，首先是找到Home接口的Weblogic实现类，然后创建一个Home接口的Weblogic实现类的stub类的对象实例，将它序列化传送给客户端（注意stub类的实例是在第1次RMI循环中，由服务器动态发送给客户端的，因此不需要客户端保存Home接口的Weblogic实现类的stub 类），最后客户端获得该stub类的对象实例（普通的RMI需要在客户端保存stub类，而EJB不需要，因为服务器会把stub类的对象实例发送给客户端）。<br>客户端拿到服务器给它的Home接口的Weblogic实现类的stub类对象实例以后，调用stub类的create方法， (在代码上就是home.create()，但是后台要做很多事情),于是经过第2次RMI循环，在服务器端，Home接口的Weblogic实现类的 skeleton类收到stub类的调用信息后，由它再去调用Home接口的Weblogic实现类的create方法。<br>在服务端， Home接口的Weblogic实现类的create方法再去调用Bean类的Weblogic实现类的ejbCreate方法，在服务端创建或者分配一个EJB实例，然后将这个EJB实例的远程接口的Weblogic实现类的stub类对象实例序列化发送给客户端。 </p><h3 id="说明一下EJB的几种类型分别是什么？"><a href="#说明一下EJB的几种类型分别是什么？" class="headerlink" title="说明一下EJB的几种类型分别是什么？"></a>说明一下EJB的几种类型分别是什么？</h3><p>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean，会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种，<br>实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种。 </p><h3 id="简述一下EJB的激活机制是什么？"><a href="#简述一下EJB的激活机制是什么？" class="headerlink" title="简述一下EJB的激活机制是什么？"></a>简述一下EJB的激活机制是什么？</h3><p>以Stateful Session Bean 为例：其Cache大小决定了内存中可以同时存在的Bean实例的数量，根据MRU或NRU算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个EJB实例业务方法时，如果对应EJB Object发现自己没有绑定对应的Bean实例则从其去激活Bean存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的 ejbActive和ejbPassivate方法。 </p><h3 id="说一下EJB规范中EJB禁止的操作有哪些？"><a href="#说一下EJB规范中EJB禁止的操作有哪些？" class="headerlink" title="说一下EJB规范中EJB禁止的操作有哪些？"></a>说一下EJB规范中EJB禁止的操作有哪些？</h3><p>1.不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，</p><p>2.不能操作awt，</p><p>3.不能实现服务器功能，</p><p>4.不能对静态属生存取，</p><p>5.不能使用IO操作直接存取文件系统，</p><p>6.不能加载本地库.，</p><p>7.不能将this作为变量和返回，</p><p>8.不能循环调用。</p><h3 id="请简述一下EJB的角色以及对应的三个对象分别是什么？"><a href="#请简述一下EJB的角色以及对应的三个对象分别是什么？" class="headerlink" title="请简述一下EJB的角色以及对应的三个对象分别是什么？"></a>请简述一下EJB的角色以及对应的三个对象分别是什么？</h3><p> 一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性。这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）<br>三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类 </p><h3 id="EJB包括SessionBean和EntityBean，请说出他们的生命周期以及EJB是如何管理事务的？"><a href="#EJB包括SessionBean和EntityBean，请说出他们的生命周期以及EJB是如何管理事务的？" class="headerlink" title="EJB包括SessionBean和EntityBean，请说出他们的生命周期以及EJB是如何管理事务的？"></a>EJB包括SessionBean和EntityBean，请说出他们的生命周期以及EJB是如何管理事务的？</h3><p>SessionBean： Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个Stateful Session Bean 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful Session Bean 的方法时容器会把调用分派到与此客户机相关联的Bean实例。<br>EntityBean：Entity Beans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity beans就一直存活。而不是按照应用程序或者服务进程来说的。即使EJB容器崩溃了，Entity beans也是存活的。Entity Beans生命周期能够被容器或者Beans自己管理。<br>EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems的Transaction Service（JTS）、Java Transaction API（JTA），开发组（X/Open）的XA接口。 </p><h3 id="EJB与JAVA-BEAN的区别是什么？"><a href="#EJB与JAVA-BEAN的区别是什么？" class="headerlink" title="EJB与JAVA BEAN的区别是什么？"></a>EJB与JAVA BEAN的区别是什么？</h3><p> Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。EnterpriseJava Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理， EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 </p><h3 id="请问EJB是基于哪些技术实现的？并说明一下SessionBean和EntityBean的区别以及StatefulBean和StatelessBean的区别。"><a href="#请问EJB是基于哪些技术实现的？并说明一下SessionBean和EntityBean的区别以及StatefulBean和StatelessBean的区别。" class="headerlink" title="请问EJB是基于哪些技术实现的？并说明一下SessionBean和EntityBean的区别以及StatefulBean和StatelessBean的区别。"></a>请问EJB是基于哪些技术实现的？并说明一下SessionBean和EntityBean的区别以及StatefulBean和StatelessBean的区别。</h3><p>EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。<br>SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/Mybatis/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/Mybatis/</id>
    <published>2020-07-14T05:41:49.000Z</published>
    <updated>2020-07-14T05:42:44.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MYBATIS"><a href="#MYBATIS" class="headerlink" title="MYBATIS"></a>MYBATIS</h2><a id="more"></a><h3 id="请问MyBatis中的动态SQL是什么意思？"><a href="#请问MyBatis中的动态SQL是什么意思？" class="headerlink" title="请问MyBatis中的动态SQL是什么意思？"></a>请问MyBatis中的动态SQL是什么意思？</h3><p> 对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有：<br>- if<br>- choose / when / otherwise<br>- trim<br>- where<br>- set<br>- foreach </p><h3 id="说明一下MyBatis中命名空间（namespace）的作用是什么？"><a href="#说明一下MyBatis中命名空间（namespace）的作用是什么？" class="headerlink" title="说明一下MyBatis中命名空间（namespace）的作用是什么？"></a>说明一下MyBatis中命名空间（namespace）的作用是什么？</h3><p>在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。 </p><blockquote><p> 1、mybatis对JDBC做了哪些封装？</p><p> 2、mybatis如何映射？</p><p> 3、Mybatis接口绑定有几种实现方式,分别是怎么实现的?</p><p> 4、Mybatis中和${}的区别？</p><p> 5、myBatis 实现一对一有几种方式?具体怎么操作的？</p><p> 6、myBatis 实现一对多有几种方式?怎么操作的？</p><p> 7、myBatis 里面的动态Sql是怎么设定的?用什么语法?</p><p> 8、讲下 myBatis 的缓存？</p><p> 9、mybatis的执行流程？</p><p> 10、持久层框架为什么选择mybatis？ </p></blockquote><p> 2😁. mapper.xml文件中的namespace(全限名)来关联和接口的关系. 3😁. .两种方式: ①通过注解绑定,在接口的方法上添加<a href="https://www.nowcoder.com/profile/3598" target="_blank" rel="noopener">@select,@update,等注解,里面包含了sql语句.②通过xml文件里写sql绑定,这种方式要求指定xml文件里namespace的值为接口的全限定名.4😁.使用 ${}在编译期传入的参数会直接拼接成字符串,而则会生成占位符”?”,并且因为${}会直接拼接成字符串,会造成sql注入,而</a>传入的参数会生成占位符”?” ,可以有效的防止了sql注入. 7😁.动态sql通过if节点来实现,使用OGNL语法判断.完整的动态sql要配合where,trim节点,choose,when,otherwise标签来完成,一个choose中至少有一个when,0个or1个otherwise,如果when满足就执行, 全部不满住就执行otherwise. 8😁.mybatis分一级缓存和二级缓存;一级缓存默认开启,在对象中有个hashmap用于存储缓存数据,不同的sqlsessioin之间缓存数据互不影响.二级缓存时mapper映射级别的缓存,多个SqlSession去操作同一个mapper映射的sql语句,多个SqlSession可以公用二级缓存,二级缓存是跨SqlSession的. (二级缓存需要手动开启),一级缓存和二级缓存都是用作在短时间内重复查询而做的优化. !     我编不下去了.!🤣 </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MYBATIS&quot;&gt;&lt;a href=&quot;#MYBATIS&quot; class=&quot;headerlink&quot; title=&quot;MYBATIS&quot;&gt;&lt;/a&gt;MYBATIS&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/Spring/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/Spring/</id>
    <published>2020-07-14T05:40:15.000Z</published>
    <updated>2020-07-14T05:41:29.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPRING"><a href="#SPRING" class="headerlink" title="SPRING"></a>SPRING</h1><a id="more"></a><h3 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h3><p>- no：不进行自动装配，手动设置Bean的依赖关系。<br>- byName：根据Bean的名字进行自动装配。<br>- byType：根据Bean的类型进行自动装配。<br>- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。<br>- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</p><p>自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。</p><h3 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h3><p>在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。</p><p>设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p><p>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。</p><h3 id="什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>什么是IoC和DI？并且简要说明一下DI是如何实现的？</h3><p><strong>IoC</strong>叫<strong>控制反转</strong>，是Inversion of Control的缩写，<strong>DI</strong>（Dependency Injection）叫<strong>依赖注入</strong>，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p><p>一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。<br>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p><h3 id="Spring中BeanFactory和ApplicationContext的区别是什么？"><a href="#Spring中BeanFactory和ApplicationContext的区别是什么？" class="headerlink" title="Spring中BeanFactory和ApplicationContext的区别是什么？"></a>Spring中BeanFactory和ApplicationContext的区别是什么？</h3><p><strong>BeanFactory：</strong><br>BeanFactory是spring中比较原始，比较古老的Factory。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。</p><p><strong>ApplicationContext</strong><br>ApplicationContext是BeanFactory的子类，因为古老的BeanFactory无法满足不断更新的spring的需求，于是ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展：</p><p>&lt;1&gt;MessageSource, 提供国际化的消息访问<br>&lt;2&gt;资源访问（如URL和文件）<br>&lt;3&gt;事件传递<br>&lt;4&gt;Bean的自动装配<br>&lt;5&gt;各种不同应用层的Context实现</p><p><strong>区别</strong>：</p><blockquote><p>&lt;1&gt;如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。<br>&lt;2&gt;BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。<br>&lt;3&gt;没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能。</p></blockquote><h3 id="说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"><a href="#说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？" class="headerlink" title="说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"></a>说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？</h3><p>①IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</p><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>举个简单的例子，我们找女朋友常见的情况是，我们到处去看哪里有长得漂亮身材又好的女孩子，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><p>②实现IOC的步骤</p><p>定义用来描述bean的配置的Java类</p><p>解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术</p><p>遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可。</p><h3 id="简单说明一下依赖注入的方式有哪几种？以及这些方法如何使用？"><a href="#简单说明一下依赖注入的方式有哪几种？以及这些方法如何使用？" class="headerlink" title="简单说明一下依赖注入的方式有哪几种？以及这些方法如何使用？"></a>简单说明一下依赖注入的方式有哪几种？以及这些方法如何使用？</h3><p> 1、Set注入 2、构造器注入 3、接口注入 </p><h3 id="Controller和-RestController的区别是什么？"><a href="#Controller和-RestController的区别是什么？" class="headerlink" title="@Controller和@RestController的区别是什么？"></a>@Controller和@RestController的区别是什么？</h3><p> @RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用 </p><h3 id="谈一下autowired-和resource区别是什么？"><a href="#谈一下autowired-和resource区别是什么？" class="headerlink" title="谈一下autowired 和resource区别是什么？"></a>谈一下autowired 和resource区别是什么？</h3><p>1、共同点</p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p>2、不同点</p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><h3 id="介绍一下bean的生命周期"><a href="#介绍一下bean的生命周期" class="headerlink" title="介绍一下bean的生命周期"></a>介绍一下bean的生命周期</h3><p>Spring生命周期流程图：</p><p> <img src="/2020/07/14/Spring/10.png" alt="img"> </p><h3 id="简要说明一下IOC和AOP是什么？"><a href="#简要说明一下IOC和AOP是什么？" class="headerlink" title="简要说明一下IOC和AOP是什么？"></a>简要说明一下IOC和AOP是什么？</h3><p>依赖注入的三种方式：</p><p>（1）接口注入</p><p>（2）Construct注入</p><p>（3）Setter注入</p><p>控制反转（IoC）与依赖注入（DI）是同一个概念，引入IOC的目的：</p><p>（1）脱开、降低类之间的耦合；</p><p>（2）倡导面向接口编程、实施依赖倒换原则； </p><p>（3）提高系统可插入、可测试、可修改等特性。</p><p>具体做法：</p><p>（1）将bean之间的依赖关系尽可能地抓换为关联关系；</p><p>（2）将对具体类的关联尽可能地转换为对Java interface的关联，而不是与具体的服务对象相关联；</p><p>（3）Bean实例具体关联相关Java interface的哪个实现类的实例，在配置信息的元数据中描述；</p><p>（4）由IoC组件（或称容器）根据配置信息，实例化具体bean类、将bean之间的依赖关系注入进来。</p><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h3 id="Spring支持的事务管理类型有哪些？以及你在项目中会使用哪种方式？"><a href="#Spring支持的事务管理类型有哪些？以及你在项目中会使用哪种方式？" class="headerlink" title="Spring支持的事务管理类型有哪些？以及你在项目中会使用哪种方式？"></a>Spring支持的事务管理类型有哪些？以及你在项目中会使用哪种方式？</h3><p>Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p><p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p><p>这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。</p><h3 id="如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h3><p>a. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。<br>b. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。<br>c. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。</p><p>d. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。<br>e. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。<br>f. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</p><h3 id="AOP的原理是什么？"><a href="#AOP的原理是什么？" class="headerlink" title="AOP的原理是什么？"></a>AOP的原理是什么？</h3><p>AOP（Aspect Orient Programming），指面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常使用AspectJ的编译时增强实现AOP，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p><p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><h3 id="aop的应用场景有哪些？"><a href="#aop的应用场景有哪些？" class="headerlink" title="aop的应用场景有哪些？"></a>aop的应用场景有哪些？</h3><p>Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务。</p><h3 id="说明一下Spring框架为企业级开发带来的好处有哪些？"><a href="#说明一下Spring框架为企业级开发带来的好处有哪些？" class="headerlink" title="说明一下Spring框架为企业级开发带来的好处有哪些？"></a>说明一下Spring框架为企业级开发带来的好处有哪些？</h3><p>- 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。<br>- IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。<br>- AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。<br>- MVC：Spring的MVC框架为Web表示层提供了更好的解决方案。<br>- 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。<br>- 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。</p><h3 id="谈一下spring框架的优点都有哪些？"><a href="#谈一下spring框架的优点都有哪些？" class="headerlink" title="谈一下spring框架的优点都有哪些？"></a>谈一下spring框架的优点都有哪些？</h3><p>Spring是一个轻量级的DI和AOP容器框架，在项目的中的使用越来越广泛，它的优点主要有以下几点：</p><p>Spring是一个非侵入式框架，其目标是使应用程序代码对框架的依赖最小化，应用代码可以在没有Spring或者其他容器的情况运行。</p><p>Spring提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以使运行环境隔离开来。</p><p>Spring推动应用的设计风格向面向对象及面向接口编程转变，提高了代码的重用性和可测试性。</p><p>Spring改进了结构体系的选择，虽然作为应用平台，Spring可以帮助我们选择不同的技术实现，比如从Hibernate切换到其他的ORM工具，从Struts切换到Spring MVC,尽管我们通常不会这么做，但是我们在技术方案上选择使用Spring作为应用平台，Spring至少为我们提供了这种可能性的选择，从而降低了平台锁定风险。</p><h3 id="Struts拦截器和Spring-AOP有什么区别？"><a href="#Struts拦截器和Spring-AOP有什么区别？" class="headerlink" title="Struts拦截器和Spring AOP有什么区别？"></a>Struts拦截器和Spring AOP有什么区别？</h3><p>拦截器是AOP的一种实现，struts2 拦截器采用xwork2的interceptor！而spring的AOP基于IoC基础,其底层采用动态代理与CGLIB代理两种方式结合的实现方式。</p><h3 id="简单介绍一下spring？"><a href="#简单介绍一下spring？" class="headerlink" title="简单介绍一下spring？"></a>简单介绍一下spring？</h3><p>Spring是一个轻量级框架，可以一站式构建你的企业级应用。</p><p>Spring的模块大概分为6个。分别是：</p><p>1、Core Container（Spring的核心）【重要】</p><p>2、AOP（面向切面变成）【重要】</p><p>3、Messaging（消息发送的支持）</p><p>4、Data Access/Integration（数据访问和集成）</p><p>5、Web（主要是SpringWeb内容，包括MVC）【重要】</p><p>6、Test（Spring测试支持，包含JUint等测试单元的支持） 7、Instrumentation（设备支持，比如Tomcat的支持）</p><h3 id="请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"><a href="#请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？" class="headerlink" title="请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"></a>请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？</h3><p>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。</p><p>持久层设计的目标包括：<br>- 数据存储逻辑的分离，提供抽象化的数据访问接口。<br>- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。<br>- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。<br>- 数据抽象，提供更面向对象的数据操作。</p><p>持久层框架有：<br>- Hibernate<br>- MyBatis<br>- TopLink<br>- Guzz<br>- jOOQ<br>- Spring Data<br>- ActiveJDBC</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SPRING&quot;&gt;&lt;a href=&quot;#SPRING&quot; class=&quot;headerlink&quot; title=&quot;SPRING&quot;&gt;&lt;/a&gt;SPRING&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/IO/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/IO/</id>
    <published>2020-07-14T05:39:13.000Z</published>
    <updated>2020-07-14T05:39:45.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><a id="more"></a><h3 id="运行时异常与受检异常有什么区别？"><a href="#运行时异常与受检异常有什么区别？" class="headerlink" title="运行时异常与受检异常有什么区别？"></a>运行时异常与受检异常有什么区别？</h3><p> 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：</p><blockquote><p>- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）<br>- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br>- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）<br>- 优先使用标准的异常<br>- 每个方法抛出的异常都要有文档<br>- 保持异常的原子性<br>- 不要在catch中忽略掉捕获到的异常 </p></blockquote><h3 id="什么是java序列化？以及如何实现java序列化？"><a href="#什么是java序列化？以及如何实现java序列化？" class="headerlink" title="什么是java序列化？以及如何实现java序列化？"></a>什么是java序列化？以及如何实现java序列化？</h3><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。<br>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。 </p><h3 id="java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h3><p>字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。 </p><h3 id="说明一下Java中的异常处理机制的原理以及如何应用。"><a href="#说明一下Java中的异常处理机制的原理以及如何应用。" class="headerlink" title="说明一下Java中的异常处理机制的原理以及如何应用。"></a>说明一下Java中的异常处理机制的原理以及如何应用。</h3><p>当JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。 </p><h3 id="请问你平时最常见到的runtime-exception是什么？"><a href="#请问你平时最常见到的runtime-exception是什么？" class="headerlink" title="请问你平时最常见到的runtime exception是什么？"></a>请问你平时最常见到的runtime exception是什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ArithmeticException,</span><br><span class="line">ArrayStoreException,</span><br><span class="line">BufferOverflowException,</span><br><span class="line">BufferUnderflowException,</span><br><span class="line">CannotRedoException,</span><br><span class="line">CannotUndoException,</span><br><span class="line">ClassCastException,</span><br><span class="line">CMMException,</span><br><span class="line">ConcurrentModificationException,</span><br><span class="line">DOMException,</span><br><span class="line">EmptyStackException,</span><br><span class="line">IllegalArgumentException,</span><br><span class="line">IllegalMonitorStateException,</span><br><span class="line">IllegalPathStateException,</span><br><span class="line">IllegalStateException,</span><br><span class="line">ImagingOpException,</span><br><span class="line">IndexOutOfBoundsException,</span><br><span class="line">MissingResourceException,</span><br><span class="line">NegativeArraySizeException,</span><br><span class="line">NoSuchElementException,</span><br><span class="line">NullPointerException,</span><br><span class="line">ProfileDataException,</span><br><span class="line">ProviderException,</span><br><span class="line">RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException,</span><br><span class="line">UnsupportedOperationException</span><br></pre></td></tr></table></figure><h3 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别?"></a>error和exception有什么区别?</h3><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 </p><h3 id="运行时的异常与一般情况下出现的异常有什么相同点和不同点？"><a href="#运行时的异常与一般情况下出现的异常有什么相同点和不同点？" class="headerlink" title="运行时的异常与一般情况下出现的异常有什么相同点和不同点？"></a>运行时的异常与一般情况下出现的异常有什么相同点和不同点？</h3><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 </p><h3 id="如何打印日志？"><a href="#如何打印日志？" class="headerlink" title="如何打印日志？"></a>如何打印日志？</h3><p>cat /var/log/*.log</p><p>如果日志在更新，如何实时查看tail -f /var/log/messages</p><p>还可以使用watch -d -n 1 cat /var/log/messages</p><p>-d表示高亮不同的地方，-n表示多少秒刷新一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>GC</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/GC/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/GC/</id>
    <published>2020-07-14T05:38:14.000Z</published>
    <updated>2020-07-14T05:38:53.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><a id="more"></a><h3 id="简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"><a href="#简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？" class="headerlink" title="简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"></a>简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？</h3><p> 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。 </p><h3 id="在java中会存在内存泄漏吗？请简单描述一下。"><a href="#在java中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="在java中会存在内存泄漏吗？请简单描述一下。"></a>在java中会存在内存泄漏吗？请简单描述一下。</h3><p>Java中的确存在Java的内存泄漏, 并且事态可以变得相当严重</p><p>Java garbage collector自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的其他程序上下文的内存泄漏. 但是Java应用程序依旧会有相当的内存泄漏. 查找原因会十分困难.<br>有两类主要的Java内存泄漏:<br>* 不再需要的对象引用<br>* 未释放的系统资源<br><strong>非必要的对象引用</strong><br>Java代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java对象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如下问题:<br>* 在向数组添加对象以后遗漏了对于他们的处理<br>* 直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.<br>* 在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当中.<br>* 允许一个长久执行的线程所引用的对象. 设置引用为NULL也无济于事, 在线程退出和空闲之前, 对象不会被收集释放<br><strong>未释放的系统资源</strong><br>Java方法可以定位Java实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java常常通过JNI(Java Native Interface)调用C/C++子程序定位这些资源.</p><h3 id="说明一下垃圾回收的优点以及原理。"><a href="#说明一下垃圾回收的优点以及原理。" class="headerlink" title="说明一下垃圾回收的优点以及原理。"></a>说明一下垃圾回收的优点以及原理。</h3><p> Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 </p><h3 id="请问GC是什么-还有为什么要有GC"><a href="#请问GC是什么-还有为什么要有GC" class="headerlink" title="请问GC是什么? 还有为什么要有GC?"></a>请问GC是什么? 还有为什么要有GC?</h3><p> GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 </p><h3 id="简述一下GC算法"><a href="#简述一下GC算法" class="headerlink" title="简述一下GC算法"></a>简述一下GC算法</h3><p>①GC（GarbageCollection 垃圾收集），GC的对象是堆空间和永久区</p><p>②GC算法包含：引用计数法，标记清除，标记压缩，复制算法。</p><p>③引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。</p><p>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><h3 id="什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下"><a href="#什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下" class="headerlink" title="什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下"></a>什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下</h3><p> 可能是堆内存太小。 </p><h3 id="请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"><a href="#请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？" class="headerlink" title="请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"></a>请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？</h3><p> Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GC&quot;&gt;&lt;a href=&quot;#GC&quot; class=&quot;headerlink&quot; title=&quot;GC&quot;&gt;&lt;/a&gt;GC&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/JVM/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/JVM/</id>
    <published>2020-07-14T05:35:08.000Z</published>
    <updated>2020-07-14T05:37:52.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><a id="more"></a><h3 id="简单描述一下JVM加载class文件的原理是什么"><a href="#简单描述一下JVM加载class文件的原理是什么" class="headerlink" title="简单描述一下JVM加载class文件的原理是什么?"></a>简单描述一下JVM加载class文件的原理是什么?</h3><p>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种<br>（1）隐式装载，程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，<br>（2）显式装载，通过class.forname()等方法，显式加载需要的类 ,隐式加载与显式加载的区别：两者本质是一样的。</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h3 id="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 </p><h3 id="jvm最大内存限制多少？"><a href="#jvm最大内存限制多少？" class="headerlink" title="jvm最大内存限制多少？"></a>jvm最大内存限制多少？</h3><p>(1)堆内存分配</p><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小 于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC后调整堆的大小。</p><p>(2)非堆内存分配</p><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p><p>(3)VM最大内存</p><p>首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽 然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系 统下为2G-3G），而64bit以上的处理器就不会有限制了。</p><p> (3)下面是当前比较流行的几个不同公司不同版本JVM最大堆内存: </p><p> <img src="/2020/07/14/JVM/5.png" alt="img"> </p><h3 id="jvm是如何实现线程的？"><a href="#jvm是如何实现线程的？" class="headerlink" title="jvm是如何实现线程的？"></a>jvm是如何实现线程的？</h3><p>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件IO等)，又可以独立调度。线程是CPU调度的基本单位。</p><p>主流OS都提供线程实现。Java语言提供对线程操作的同一API，每个已经执行start()，且还未结束的java.lang.Thread类的实例，代表了一个线程。</p><p>Thread类的关键方法，都声明为Native。这意味着这个方法无法或没有使用平台无关的手段来实现，也可能是为了执行效率。</p><p>实现线程的方式</p><p>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持的线程。</p><p>内核来完成线程切换</p><p>内核通过调度器Scheduler调度线程，并将线程的任务映射到各个CPU上</p><p>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)</p><p>用户态和内核态切换消耗内核资源</p><p>使用用户线程实现</p><p>系统内核不能感知线程存在的实现</p><p>用户线程的建立、同步、销毁和调度完全在用户态中完成</p><p>所有线程操作需要用户程序自己处理，复杂度高</p><p>用户线程加轻量级进程混合实现</p><p>轻量级进程作为用户线程和内核线程之间的桥梁</p><h3 id="什么是JVM内存模型？"><a href="#什么是JVM内存模型？" class="headerlink" title="什么是JVM内存模型？"></a>什么是JVM内存模型？</h3><p>Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</p><p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：</p><p> <img src="/2020/07/14/JVM/6.png" alt="img"> </p><h3 id="在JAVA虚拟机中，哪些对象可作为ROOT对象？"><a href="#在JAVA虚拟机中，哪些对象可作为ROOT对象？" class="headerlink" title="在JAVA虚拟机中，哪些对象可作为ROOT对象？"></a>在JAVA虚拟机中，哪些对象可作为ROOT对象？</h3><p>虚拟机栈中的引用对象</p><p>方法区中类静态属性引用的对象</p><p>方法区中常量引用对象</p><p>本地方法栈中JNI引用对象</p><h3 id="GC中如何判断对象是否需要被回收？"><a href="#GC中如何判断对象是否需要被回收？" class="headerlink" title="GC中如何判断对象是否需要被回收？"></a>GC中如何判断对象是否需要被回收？</h3><p>即使在可达性分析算法中不可达的对象,也并非是“非回收不可”的,这时候它们暂时处于“等待”阶段,要真正宣告一个对象回收,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)</p><p>如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。</p><p>finalize()方法是对象逃脱回收的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中跳出回收——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。</p><h3 id="说明一下JAVA虚拟机的作用是什么"><a href="#说明一下JAVA虚拟机的作用是什么" class="headerlink" title="说明一下JAVA虚拟机的作用是什么?"></a>说明一下JAVA虚拟机的作用是什么?</h3><p>解释运行字节码程序消除平台相关性。</p><p>jvm将java字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，至少需要编译成不同的目标代码。而引入JVM后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p><p>假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？</p><p>绝大多数新创建的对象分配在Eden区。</p><p>在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。</p><p>在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。</p><p>一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。</p><p>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。</p><h3 id="说明一下eden区和survial区的含义以及工作原理？"><a href="#说明一下eden区和survial区的含义以及工作原理？" class="headerlink" title="说明一下eden区和survial区的含义以及工作原理？"></a>说明一下eden区和survial区的含义以及工作原理？</h3><p>目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成Eden 空间、 From Survivor 和 To Survivor 三块区域。</p><p>我们把Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；<br>2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p><h3 id="简单描述一下JVM分区都有哪些？"><a href="#简单描述一下JVM分区都有哪些？" class="headerlink" title="简单描述一下JVM分区都有哪些？"></a>简单描述一下JVM分区都有哪些？</h3><p> <img src="/2020/07/14/JVM/7.png" alt="img"> </p><p> java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。 </p><h3 id="简单描述一下类的加载过程"><a href="#简单描述一下类的加载过程" class="headerlink" title="简单描述一下类的加载过程"></a>简单描述一下类的加载过程</h3><p>如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。</p><p> <img src="/2020/07/14/JVM/8.png" alt="img"> </p><p><strong>加载</strong></p><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</p><p><strong>验证</strong></p><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>准备</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><p>public static int v = 8080;</p><p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<client>方法之中，这里我们后面会解释。</client></p><p>但是注意如果声明为：</p><p>public static final int v = 8080;</p><p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p><p>解析</p><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：</p><p>CONSTANT_Class_info</p><p>CONSTANT_Field_info</p><p>CONSTANT_Method_info</p><p>等类型的常量。</p><p>下面我们解释一下符号引用和直接引用的概念：</p><p>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p><p>初始化</p><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。</p><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></p><p>注意以下几种情况不会执行类初始化：</p><p>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</p><p>定义对象数组，不会触发该类的初始化。</p><p>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</p><p>通过类名获取Class对象，不会触发类的初始化。</p><p>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</p><p>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</p><p>类加载器</p><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：</p><p>启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</p><p>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</p><p>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。</p><p>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p><p> <img src="/2020/07/14/JVM/9.png" alt="img"> </p><p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。 </p><h3 id="简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算法？使用CMS怎样解决内存碎片的问题呢？"><a href="#简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算法？使用CMS怎样解决内存碎片的问题呢？" class="headerlink" title="简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算法？使用CMS怎样解决内存碎片的问题呢？"></a>简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算法？使用CMS怎样解决内存碎片的问题呢？</h3><p>垃圾回收算法</p><p>标记清除</p><p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。</p><p>复制算法</p><p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p><p>标记整理</p><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p><p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p><p>增量算法</p><p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><p>垃圾回收器</p><p>Serial收集器</p><p>Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。</p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p><p>通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。</p><p>ParNew收集器</p><p>ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。</p><p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>-UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。</p><p>Parallel Scavenge收集器</p><p>Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><p>-UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收</p><p>CMS收集器</p><p>CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤：</p><p>初始标记(initial mark)</p><p>并发标记(concurrent mark)</p><p>重新标记(remark)</p><p>并发清除(concurrent sweep)</p><p>注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。</p><p>G1收集器</p><p>G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><p>并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。</p><p>分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。</p><p>空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。</p><p>可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><p>CMS：采用标记清除算法</p><p>解决这个问题的办法就是可以让CMS在进行一定次数的Full GC（标记清除）的时候进行一次标记整理算法，CMS提供了以下参数来控制：</p><p>-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5</p><p>也就是CMS在进行5次Full GC（标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定的数量以内，甚至可以配置CMS在每次Full GC的时候都进行内存的整理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Reflection</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/Reflection/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/Reflection/</id>
    <published>2020-07-14T05:33:21.000Z</published>
    <updated>2020-07-14T05:33:44.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><h3 id="说明一下JAVA中反射的实现过程和作用分别是什么？"><a href="#说明一下JAVA中反射的实现过程和作用分别是什么？" class="headerlink" title="说明一下JAVA中反射的实现过程和作用分别是什么？"></a>说明一下JAVA中反射的实现过程和作用分别是什么？</h3><p>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：</p><p>Class：类的对象，</p><p>Constructor：类的构造方法，</p><p>Field：类中的属性对象，</p><p>Method：类中的方法对象。</p><p>作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reflection&quot;&gt;&lt;a href=&quot;#Reflection&quot; class=&quot;headerlink&quot; title=&quot;Reflection&quot;&gt;&lt;/a&gt;Reflection&lt;/h1&gt;&lt;h3 id=&quot;说明一下JAVA中反射的实现过程和作用分别是什么？&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>JDK</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/JDK/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/JDK/</id>
    <published>2020-07-14T05:32:29.000Z</published>
    <updated>2020-07-14T05:34:39.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><a id="more"></a><h3 id="请问JDK和JRE的区别是什么？"><a href="#请问JDK和JRE的区别是什么？" class="headerlink" title="请问JDK和JRE的区别是什么？"></a>请问JDK和JRE的区别是什么？</h3><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 </p><h3 id="Java中的LongAdder和AtomicLong有什么区别？"><a href="#Java中的LongAdder和AtomicLong有什么区别？" class="headerlink" title="Java中的LongAdder和AtomicLong有什么区别？"></a>Java中的LongAdder和AtomicLong有什么区别？</h3><p>JDK1.8引入了LongAdder类。CAS机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap的实现思想，应该可以想到对一种传统AtomicInteger等原子类的改进思路。虽然CAS操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将AtomicInteger的内部核心数据value分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据value被分离成多个单元cell，每个cell独自维护内部的值，当前对象的实际值由所有的cell累计合成，这样热点就进行了有效的分离，提高了并行度。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Lock</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/Lock/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/Lock/</id>
    <published>2020-07-14T05:31:29.000Z</published>
    <updated>2020-07-14T05:34:34.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h1><a id="more"></a><h3 id="简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？"><a href="#简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？" class="headerlink" title="简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？"></a>简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？</h3><p>主要相同点：Lock能完成synchronized所实现的所有功能<br>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 </p><h3 id="JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"><a href="#JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？" class="headerlink" title="JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"></a>JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：</p><p>指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><p>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下三种方法：</p><p>1.破坏请求和保持条件，进程必须等所有要请求的资源都空闲时才能申请资源，这种方法会使资源浪费严重(有些资源可能仅在运行初期或结束时才使用，甚至根本不使用). 允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源，比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比第一种方法好，会使资源利用率上升。</p><p>2.破坏不可抢占条件，这种方法代价大，实现复杂。</p><p>3.破坏循坏等待条件，对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</p><h3 id="请问什么是死锁-deadlock"><a href="#请问什么是死锁-deadlock" class="headerlink" title="请问什么是死锁(deadlock)?"></a>请问什么是死锁(deadlock)?</h3><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p><p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p><h3 id="说明一下锁和同步的区别。"><a href="#说明一下锁和同步的区别。" class="headerlink" title="说明一下锁和同步的区别。"></a>说明一下锁和同步的区别。</h3><p><strong>用法上的不同：</strong><br>synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。<br>synchronized是托管给JVM执行的12，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。<br><strong>性能上的不同：</strong><br>lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。<br>在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。<br><strong>锁机制不同：</strong><br>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁。 </p><h3 id="请说明一下synchronized的可重入怎么实现。"><a href="#请说明一下synchronized的可重入怎么实现。" class="headerlink" title="请说明一下synchronized的可重入怎么实现。"></a>请说明一下synchronized的可重入怎么实现。</h3><p> 每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。 </p><h3 id="请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"><a href="#请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。" class="headerlink" title="请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"></a>请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。</h3><p> 如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LOCK&quot;&gt;&lt;a href=&quot;#LOCK&quot; class=&quot;headerlink&quot; title=&quot;LOCK&quot;&gt;&lt;/a&gt;LOCK&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Thread</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/Thread/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/Thread/</id>
    <published>2020-07-14T05:30:23.000Z</published>
    <updated>2020-07-14T05:50:17.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="THREAD"><a href="#THREAD" class="headerlink" title="THREAD"></a>THREAD</h1><a id="more"></a><h3 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h3><p>通过合理的时间调度，避开共享资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证一个客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。 </p><h3 id="简要说明一下线程的基本状态以及状态之间的关系？"><a href="#简要说明一下线程的基本状态以及状态之间的关系？" class="headerlink" title="简要说明一下线程的基本状态以及状态之间的关系？"></a>简要说明一下线程的基本状态以及状态之间的关系？</h3><p>其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。 </p><h3 id="解释一下什么是线程池（thread-pool）？"><a href="#解释一下什么是线程池（thread-pool）？" class="headerlink" title="解释一下什么是线程池（thread pool）？"></a>解释一下什么是线程池（thread pool）？</h3><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：<br>- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br>- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。<br>- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br>- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。<br>- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 </p><h3 id="举例说明同步和异步"><a href="#举例说明同步和异步" class="headerlink" title="举例说明同步和异步"></a>举例说明同步和异步</h3><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 </p><h3 id="介绍一下线程同步和线程调度的相关方法。"><a href="#介绍一下线程同步和线程调度的相关方法。" class="headerlink" title="介绍一下线程同步和线程调度的相关方法。"></a>介绍一下线程同步和线程调度的相关方法。</h3><p> - wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；<br>- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；<br>- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。 </p><h3 id="请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h3><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><h3 id="请简述一下线程的sleep-方法和yield-方法有什么区别？"><a href="#请简述一下线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="请简述一下线程的sleep()方法和yield()方法有什么区别？"></a>请简述一下线程的sleep()方法和yield()方法有什么区别？</h3><p>①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p><p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p><p>② 线程执行sleep()方法后转入阻塞（blocked）状态，</p><p>而执行yield()方法后转入就绪（ready）状态；</p><h3 id="Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用，请说明原因？"><a href="#Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用，请说明原因？" class="headerlink" title="Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用，请说明原因？"></a>Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用，请说明原因？</h3><p>有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法，</p><p>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。</p><p>调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 </p><h3 id="多线程和同步有几种实现方法-并且这些实现方法具体内容都是什么"><a href="#多线程和同步有几种实现方法-并且这些实现方法具体内容都是什么" class="headerlink" title="多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么?"></a>多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么?</h3><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口同步的实现方面有两种，分别是synchronized,wait与notify。</p><h3 id="说出你所知道的线程同步的方法"><a href="#说出你所知道的线程同步的方法" class="headerlink" title="说出你所知道的线程同步的方法"></a>说出你所知道的线程同步的方法</h3><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 </p><h3 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h3><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。</p><h3 id="请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"><a href="#请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。" class="headerlink" title="请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。"></a>请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">ThreadTest1 tt=<span class="keyword">new</span> ThreadTest1();</span><br><span class="line">Inc inc=tt.<span class="keyword">new</span> Inc();</span><br><span class="line">Dec dec=tt.<span class="keyword">new</span> Dec();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(inc);</span><br><span class="line">t.start();</span><br><span class="line">t=<span class="keyword">new</span> Thread(dec);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">j++;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"-inc:"</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">j--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"-dec:"</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">inc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">dec();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"><a href="#说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？" class="headerlink" title="说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"></a>说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？</h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。<br>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 </p><h3 id="明一下sleep-和-wait-有什么区别？"><a href="#明一下sleep-和-wait-有什么区别？" class="headerlink" title="明一下sleep() 和 wait() 有什么区别？"></a>明一下sleep() 和 wait() 有什么区别？</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 </p><h3 id="请你说明一下在监视器-Monitor-内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？"><a href="#请你说明一下在监视器-Monitor-内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？" class="headerlink" title="请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？"></a>请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><h3 id="分析一下同步方法和同步代码块的区别是什么？"><a href="#分析一下同步方法和同步代码块的区别是什么？" class="headerlink" title="分析一下同步方法和同步代码块的区别是什么？"></a>分析一下同步方法和同步代码块的区别是什么？</h3><p>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法。 </p><h3 id="请详细描述一下线程从创建到死亡的几种状态都有哪些？"><a href="#请详细描述一下线程从创建到死亡的几种状态都有哪些？" class="headerlink" title="请详细描述一下线程从创建到死亡的几种状态都有哪些？"></a>请详细描述一下线程从创建到死亡的几种状态都有哪些？</h3><ol><li><strong>新建( new )</strong>：新创建了一个线程对象。</li><li><strong>可运行( runnable )</strong>：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li><li><strong>运行( running )</strong>：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li><li><strong>阻塞( block )</strong>：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</li><li><strong>死亡( dead )</strong>：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 </li></ol><h3 id="创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>有三种方式可以用来创建线程：<br>继承Thread类<br>实现Runnable接口<br>应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 </p><h3 id="解释一下Java多线程回调是什么意思？"><a href="#解释一下Java多线程回调是什么意思？" class="headerlink" title="解释一下Java多线程回调是什么意思？"></a>解释一下Java多线程回调是什么意思？</h3><p>所谓回调，就是客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便叫做回调方法。 </p><h3 id="列举一下启动线程有哪几种方式，之后再说明一下线程池的种类都有哪些？"><a href="#列举一下启动线程有哪几种方式，之后再说明一下线程池的种类都有哪些？" class="headerlink" title="列举一下启动线程有哪几种方式，之后再说明一下线程池的种类都有哪些？"></a>列举一下启动线程有哪几种方式，之后再说明一下线程池的种类都有哪些？</h3><p>①启动线程有如下三种方式：</p><p>一、继承Thread类创建线程类</p><p>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</p><p>（2）创建Thread子类的实例，即创建了线程对象。</p><p>（3）调用线程对象的start()方法来启动该线程。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">"  "</span>+i);</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"  : "</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">                <span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。</p><p>二、通过Runnable接口创建线程类</p><p>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p><p>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p><p>（3）调用线程对象的start()方法来启动该线程。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RunnableThreadTest rtt = <span class="keyword">new</span> RunnableThreadTest();</span><br><span class="line">                <span class="keyword">new</span> Thread(rtt,<span class="string">"新线程1"</span>).start();</span><br><span class="line">                <span class="keyword">new</span> Thread(rtt,<span class="string">"新线程2"</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、通过Callable和Future创建线程</p><p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p><p>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p><p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p><p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②线程池的种类有：</p><p>Java通过Executors提供四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。<br>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><h3 id="简要说明一下JAVA中cyclicbarrier和countdownlatch的区别分别是什么？"><a href="#简要说明一下JAVA中cyclicbarrier和countdownlatch的区别分别是什么？" class="headerlink" title="简要说明一下JAVA中cyclicbarrier和countdownlatch的区别分别是什么？"></a>简要说明一下JAVA中cyclicbarrier和countdownlatch的区别分别是什么？</h3><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p><p>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p><p>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p><p>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p><h3 id="说明一下线程池有什么优势？"><a href="#说明一下线程池有什么优势？" class="headerlink" title="说明一下线程池有什么优势？"></a>说明一下线程池有什么优势？</h3><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。</p><p>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p><h3 id="请回答一下Java中有几种线程池？并且详细描述一下线程池的实现过程"><a href="#请回答一下Java中有几种线程池？并且详细描述一下线程池的实现过程" class="headerlink" title="请回答一下Java中有几种线程池？并且详细描述一下线程池的实现过程"></a>请回答一下Java中有几种线程池？并且详细描述一下线程池的实现过程</h3><p> 1、newFixedThreadPool创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是：<br> 1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。<br>3、newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。<br>4、newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻) </p><h3 id="请说明一下Java中都有哪些方式可以启动一个线程？"><a href="#请说明一下Java中都有哪些方式可以启动一个线程？" class="headerlink" title="请说明一下Java中都有哪些方式可以启动一个线程？"></a>请说明一下Java中都有哪些方式可以启动一个线程？</h3><ol><li><p>继承自Thread类</p></li><li><p>实现Runnable接口</p></li><li><p>即实现Runnable接口，也继承Thread类，并重写run方法</p></li></ol><h3 id="请列举一下创建线程的方法，并简要说明一下在这些方法中哪个方法更好，原因是什么？"><a href="#请列举一下创建线程的方法，并简要说明一下在这些方法中哪个方法更好，原因是什么？" class="headerlink" title="请列举一下创建线程的方法，并简要说明一下在这些方法中哪个方法更好，原因是什么？"></a>请列举一下创建线程的方法，并简要说明一下在这些方法中哪个方法更好，原因是什么？</h3><p>需要从Java.lang.Thread类派生一个新的线程类，重载它的run()方法；</p><p>实现Runnalbe接口，重载Runnalbe接口中的run()方法。</p><p>实现Runnalbe接口更好，使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享.</p><h3 id="简短说明一下你对AQS的理解。"><a href="#简短说明一下你对AQS的理解。" class="headerlink" title="简短说明一下你对AQS的理解。"></a>简短说明一下你对AQS的理解。</h3><p> AQS其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：先进先出的队列、state状态<br>定义了内部类ConditionObject<br>拥有两种线程模式独占模式和共享模式。<br>在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是基于AQS来构建，一般我们叫AQS为同步器。 </p><h3 id="请简述一下线程池的运行流程，使用参数以及方法策略等"><a href="#请简述一下线程池的运行流程，使用参数以及方法策略等" class="headerlink" title="请简述一下线程池的运行流程，使用参数以及方法策略等"></a>请简述一下线程池的运行流程，使用参数以及方法策略等</h3><p>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。 </p><h3 id="线程，进程，然后线程创建有很大开销，怎么优化？"><a href="#线程，进程，然后线程创建有很大开销，怎么优化？" class="headerlink" title="线程，进程，然后线程创建有很大开销，怎么优化？"></a>线程，进程，然后线程创建有很大开销，怎么优化？</h3><p> 可以使用线程池。 </p><h3 id="什么是生产者消费者模式？"><a href="#什么是生产者消费者模式？" class="headerlink" title="什么是生产者消费者模式？"></a>什么是生产者消费者模式？</h3><p>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。</p><p>优点：支持并发、解耦。</p><p> <img src="/2020/07/14/Thread/308572_1537880635592_7142B8354CA8A352B2B805F997C71549.png" alt="img"> </p><h3 id="简述一下实现多线程同步的方法？"><a href="#简述一下实现多线程同步的方法？" class="headerlink" title="简述一下实现多线程同步的方法？"></a>简述一下实现多线程同步的方法？</h3><p>可以使用synchronized、lock、volatile和ThreadLocal来实现同步。 </p><h3 id="如何在线程安全的情况下实现一个计数器？"><a href="#如何在线程安全的情况下实现一个计数器？" class="headerlink" title="如何在线程安全的情况下实现一个计数器？"></a>如何在线程安全的情况下实现一个计数器？</h3><p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p><h3 id="多线程中的i-线程安全吗？请简述一下原因？"><a href="#多线程中的i-线程安全吗？请简述一下原因？" class="headerlink" title="多线程中的i++线程安全吗？请简述一下原因？"></a>多线程中的i++线程安全吗？请简述一下原因？</h3><p>不安全。i++不是原子性操作。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;THREAD&quot;&gt;&lt;a href=&quot;#THREAD&quot; class=&quot;headerlink&quot; title=&quot;THREAD&quot;&gt;&lt;/a&gt;THREAD&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Array</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/Array/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/Array/</id>
    <published>2020-07-14T05:29:08.000Z</published>
    <updated>2020-07-14T05:48:30.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><a id="more"></a><h3 id="List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set三个接口存取元素时，各有什么特点？"></a>List、Map、Set三个接口存取元素时，各有什么特点？</h3><p> List以特定索引来存取元素，可以有重复元素。</p><p>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</p><p>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</p><p>Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 </p><h3 id="阐述ArrayList、Vector、LinkedList的存储性能和特性"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性</h3><p> ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以<strong>索引数据快而插入数据慢</strong>，Vector中的方法由于<strong>添加了synchronized修饰</strong>，因此Vector是线程安全的容器，但性能上较ArrayList差，<strong>因此已经是Java中的遗留容器</strong>。</p><p>LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 </p><h3 id="判断List、Set、Map是否继承自Collection接口？"><a href="#判断List、Set、Map是否继承自Collection接口？" class="headerlink" title="判断List、Set、Map是否继承自Collection接口？"></a>判断List、Set、Map是否继承自Collection接口？</h3><p> List、Set 是，Map 不是。</p><p>Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素</p><p>（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 </p><h3 id="你所知道的常用集合类以及主要方法？"><a href="#你所知道的常用集合类以及主要方法？" class="headerlink" title="你所知道的常用集合类以及主要方法？"></a>你所知道的常用集合类以及主要方法？</h3><p>最常用的集合类是List 和 Map。</p><p>List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。</p><p>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p><h3 id="说明Collection-和-Collections的区别"><a href="#说明Collection-和-Collections的区别" class="headerlink" title="说明Collection 和 Collections的区别"></a>说明Collection 和 Collections的区别</h3><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 </p><h3 id="说明ArrayList-Vector-LinkedList的存储性能和特性是什么？"><a href="#说明ArrayList-Vector-LinkedList的存储性能和特性是什么？" class="headerlink" title="说明ArrayList,Vector,LinkedList的存储性能和特性是什么？"></a>说明ArrayList,Vector,LinkedList的存储性能和特性是什么？</h3><p> ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 </p><h3 id="ArrayList和LinkedList的区别？-链表和数组的优缺点"><a href="#ArrayList和LinkedList的区别？-链表和数组的优缺点" class="headerlink" title="ArrayList和LinkedList的区别？(链表和数组的优缺点)"></a>ArrayList和LinkedList的区别？(链表和数组的优缺点)</h3><p> ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 </p><h3 id="说明HashMap和Hashtable的区别？"><a href="#说明HashMap和Hashtable的区别？" class="headerlink" title="说明HashMap和Hashtable的区别？"></a>说明HashMap和Hashtable的区别？</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。 </p><h3 id="请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？"><a href="#请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？" class="headerlink" title="请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？"></a>请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h3 id="说说Iterator和ListIterator的区别？"><a href="#说说Iterator和ListIterator的区别？" class="headerlink" title="说说Iterator和ListIterator的区别？"></a>说说Iterator和ListIterator的区别？</h3><p>Iterator和ListIterator的区别是：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 </p><h3 id="请简单说明一下什么是迭代器？"><a href="#请简单说明一下什么是迭代器？" class="headerlink" title="请简单说明一下什么是迭代器？"></a>请简单说明一下什么是迭代器？</h3><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,<br>每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.<br>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.</p><p><img src="/2020/07/14/Array/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9.png" alt="img"> </p><h3 id="解释为什么集合类没有实现Cloneable和Serializable接口？"><a href="#解释为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="解释为什么集合类没有实现Cloneable和Serializable接口？"></a>解释为什么集合类没有实现Cloneable和Serializable接口？</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。<br><strong>实现Serializable序列化的作用</strong>：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。 </p><h3 id="Java集合类框架的基本接口有哪些？"><a href="#Java集合类框架的基本接口有哪些？" class="headerlink" title="Java集合类框架的基本接口有哪些？"></a>Java集合类框架的基本接口有哪些？</h3><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。 </p><h3 id="ConcurrentHashMap的原理？"><a href="#ConcurrentHashMap的原理？" class="headerlink" title="ConcurrentHashMap的原理？"></a>ConcurrentHashMap的原理？</h3><p> ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。</p><p>HashEntry 用来封装映射表的键 / 值对；</p><p>Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。</p><p>一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型</span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型</span></span><br><span class="line">  </span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图： </p><p> 插入三个节点后桶的结构示意图： </p><p> <img src="/2020/07/14/Array/308572_1537878284540_B6C31D01D41C9E1714958F9C56D01D8F.png" alt="img"> </p><p> 注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。 </p><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。 </p><h3 id="解释一下TreeMap"><a href="#解释一下TreeMap" class="headerlink" title="解释一下TreeMap?"></a>解释一下TreeMap?</h3><p>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。<br>TreeMap的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 </p><h3 id="请说明ArrayList是否会越界？"><a href="#请说明ArrayList是否会越界？" class="headerlink" title="请说明ArrayList是否会越界？"></a>请说明ArrayList是否会越界？</h3><p>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。 </p><h3 id="说明concurrenthashmap有什么优势以及1-7和1-8区别？"><a href="#说明concurrenthashmap有什么优势以及1-7和1-8区别？" class="headerlink" title="说明concurrenthashmap有什么优势以及1.7和1.8区别？"></a>说明concurrenthashmap有什么优势以及1.7和1.8区别？</h3><p>Concurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</p><p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p><h3 id="TreeMap的底层实现？"><a href="#TreeMap的底层实现？" class="headerlink" title="TreeMap的底层实现？"></a>TreeMap的底层实现？</h3><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p><p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：</p><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h3 id="说明ConcurrentHashMap锁加在了哪些地方？"><a href="#说明ConcurrentHashMap锁加在了哪些地方？" class="headerlink" title="说明ConcurrentHashMap锁加在了哪些地方？"></a>说明ConcurrentHashMap锁加在了哪些地方？</h3><p>加在每个Segment 上面。</p><h3 id="解释HashMap的容量为什么是2的n次幂？"><a href="#解释HashMap的容量为什么是2的n次幂？" class="headerlink" title="解释HashMap的容量为什么是2的n次幂？"></a>解释HashMap的容量为什么是2的n次幂？</h3><p>负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。 </p><h3 id="请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"><a href="#请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？" class="headerlink" title="请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"></a>请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？</h3><p>ArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。</p><h3 id="如果hashMap的key是一个自定义的类，怎么办？"><a href="#如果hashMap的key是一个自定义的类，怎么办？" class="headerlink" title="如果hashMap的key是一个自定义的类，怎么办？"></a>如果hashMap的key是一个自定义的类，怎么办？</h3><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p><h3 id="解释一下hashMap具体如何实现的？"><a href="#解释一下hashMap具体如何实现的？" class="headerlink" title="解释一下hashMap具体如何实现的？"></a>解释一下hashMap具体如何实现的？</h3><p> Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>J2SE</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/14/J2SE/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/14/J2SE/</id>
    <published>2020-07-14T05:27:19.000Z</published>
    <updated>2020-07-14T05:28:49.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-oriented"><a href="#Object-oriented" class="headerlink" title="Object-oriented"></a>Object-oriented</h1><a id="more"></a><h3 id="关于Synchronized和lock"><a href="#关于Synchronized和lock" class="headerlink" title="关于Synchronized和lock"></a>关于Synchronized和lock</h3><p><code>synchronized</code>是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。</p><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p> volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。 </p><h3 id="请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><a href="#请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？" class="headerlink" title="请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"></a>请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</h3><p> synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。<br>synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。 </p><h3 id="若对一个类不重写，它的equals-方法是如何比较的？"><a href="#若对一个类不重写，它的equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的equals()方法是如何比较的？"></a>若对一个类不重写，它的equals()方法是如何比较的？</h3><p> 比较是对象的地址。 </p><h3 id="请解释hashCode-和equals-方法有什么联系？"><a href="#请解释hashCode-和equals-方法有什么联系？" class="headerlink" title="请解释hashCode()和equals()方法有什么联系？"></a>请解释hashCode()和equals()方法有什么联系？</h3><p>Java对象的eqauls方法和hashCode方法是这样规定的：</p><p>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p><p>➁ 如果两个对象的hashCode相同，它们并不一定相同。</p><h3 id="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p> 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。<br>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 </p><h3 id="请说明Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#请说明Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h3><p> <strong>Java中的方法重载</strong>发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。</p><p>与此相对，<strong>方法覆盖</strong>是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 </p><h3 id="Query接口的list方法和iterate方法有什么区别？"><a href="#Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="Query接口的list方法和iterate方法有什么区别？"></a>Query接口的list方法和iterate方法有什么区别？</h3><p> ① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。<br>②  list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题 </p><h3 id="面向对象的”六原则一法则”。"><a href="#面向对象的”六原则一法则”。" class="headerlink" title="面向对象的”六原则一法则”。"></a>面向对象的”六原则一法则”。</h3><p> - <strong>单一职责原则：一个类只做它该做的事情</strong>。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- <strong>开闭原则</strong>：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- <strong>依赖倒转原则</strong>：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）<strong>里氏替换原则</strong>：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）<strong>- 接口隔离原则</strong>：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- <strong>合成聚合复用原则</strong>：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- <strong>迪米特法则</strong>：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。 </p><h3 id="如何通过反射获取和设置对象私有字段的值？"><a href="#如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="如何通过反射获取和设置对象私有字段的值？"></a>如何通过反射获取和设置对象私有字段的值？</h3><p> 可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。</p><p>下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">    Method m = str.getClass().getMethod(<span class="string">"toUpperCase"</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p> 方法的重载和重写都是实现多态的方式，</p><p>区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 </p><h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？</h3><p> 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：</p><p>(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</p><p>(2)如果两个对象的hashCode相同，它们并不一定相同。</p><p>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 </p><h3 id="请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"><a href="#请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？" class="headerlink" title="请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"></a>请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</h3><p> 一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性.内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。 </p><h3 id="请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><a href="#请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？" class="headerlink" title="请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？"></a>请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</h3><p> Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。</p><p>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。 </p><h3 id="请说明Java的接口和C-的虚类的相同和不同处"><a href="#请说明Java的接口和C-的虚类的相同和不同处" class="headerlink" title="请说明Java的接口和C++的虚类的相同和不同处"></a>请说明Java的接口和C++的虚类的相同和不同处</h3><p> 由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。 </p><h3 id="当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p> 是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 </p><h3 id="请你说说Static-Nested-Class-和-Inner-Class的不同"><a href="#请你说说Static-Nested-Class-和-Inner-Class的不同" class="headerlink" title="请你说说Static Nested Class 和 Inner Class的不同"></a>请你说说Static Nested Class 和 Inner Class的不同</h3><p> Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance).Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能Access Outer Class的动态成员(instance member).而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员, 这个概念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member),反过来就可以, 一个CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). </p><h3 id="请你讲讲abstract-class和interface有什么区别"><a href="#请你讲讲abstract-class和interface有什么区别" class="headerlink" title="请你讲讲abstract class和interface有什么区别?"></a>请你讲讲abstract class和interface有什么区别?</h3><p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p><p>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><h3 id="请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型"><a href="#请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?"></a>请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?</h3><p> 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 </p><h3 id="请说明一下final-finally-finalize的区别。"><a href="#请说明一下final-finally-finalize的区别。" class="headerlink" title="请说明一下final, finally, finalize的区别。"></a>请说明一下final, finally, finalize的区别。</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>finally是异常处理语句结构的一部分，表示总是执行。<br>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源<br>回收，例如关闭文件等。 </p><h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><p><strong>抽象：</strong><br>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只<br>是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。<br><strong>继承：</strong><br>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派<br>生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br><strong>封装：</strong><br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<br><strong>多态：</strong><br>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 </p><h3 id="请说明Comparable和Comparator接口的作用以及它们的区别。"><a href="#请说明Comparable和Comparator接口的作用以及它们的区别。" class="headerlink" title="请说明Comparable和Comparator接口的作用以及它们的区别。"></a>请说明Comparable和Comparator接口的作用以及它们的区别。</h3><p> Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 </p><h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><p> Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别 </p><h3 id="请说明Java是否支持多继承？"><a href="#请说明Java是否支持多继承？" class="headerlink" title="请说明Java是否支持多继承？"></a>请说明Java是否支持多继承？</h3><p> Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 </p><h3 id="如何通过反射创建对象？"><a href="#如何通过反射创建对象？" class="headerlink" title="如何通过反射创建对象？"></a>如何通过反射创建对象？</h3><ul><li>方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()</li><li>方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); </li></ul><h3 id="是否可以在static环境中访问非static变量？"><a href="#是否可以在static环境中访问非static变量？" class="headerlink" title="是否可以在static环境中访问非static变量？"></a>是否可以在static环境中访问非static变量？</h3><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 </p><h3 id="extends-和super-泛型限定符"><a href="#extends-和super-泛型限定符" class="headerlink" title="extends 和super 泛型限定符"></a>extends 和super 泛型限定符</h3><p>（1）泛型中上界和下界的定义</p><p>上界&lt;? extend Fruit&gt;</p><p>下界&lt;? super Apple&gt;</p><p>（2）上界和下界的特点</p><p>上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）</p><p>下界的list只能add，不能get</p><p> （3）示例代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上界</span></span><br><span class="line">    List&lt;? extends Fruit&gt; flistTop = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    flistTop.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//add Fruit对象会报错</span></span><br><span class="line">    <span class="comment">//flist.add(new Fruit());</span></span><br><span class="line">    Fruit fruit1 = flistTop.get(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//下界</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> Apple&gt; flistBottem = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    <span class="comment">//get Apple对象会报错</span></span><br><span class="line">    <span class="comment">//Apple apple = flistBottem.get(0);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）上界&lt;? extend Fruit&gt; ，表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。</p><p>下界&lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object 。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。</p><p>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。</p><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p> 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          List list = new ArrayList();</span></span><br><span class="line"><span class="comment">          list.add("qqyumidi");</span></span><br><span class="line"><span class="comment">          list.add("corn");</span></span><br><span class="line"><span class="comment">          list.add(100);</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">  </span><br><span class="line">         List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">         list.add(<span class="string">"qqyumidi"</span>);</span><br><span class="line">         list.add(<span class="string">"corn"</span>);</span><br><span class="line">         <span class="comment">//list.add(100);   // 1  提示编译错误</span></span><br><span class="line">  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">             String name = list.get(i); <span class="comment">// 2</span></span><br><span class="line">             System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<String>，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 </String></p><h3 id="静态变量存在什么位置"><a href="#静态变量存在什么位置" class="headerlink" title="静态变量存在什么位置"></a>静态变量存在什么位置</h3><p>方法区</p><h3 id="解释类加载机制，双亲委派模型，好处是什么？"><a href="#解释类加载机制，双亲委派模型，好处是什么？" class="headerlink" title="解释类加载机制，双亲委派模型，好处是什么？"></a>解释类加载机制，双亲委派模型，好处是什么？</h3><p>某个特定的类加载器在接到加载类的请求时， 首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 </p><p> 使用双亲委派模型的好处在于使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。 </p><blockquote><p>双亲委派机制的意义主要是保护一些基本类不受影响。<br>比如常用的 String类， 其全限定名是 java.lang.String， 只是 java.lang 这个包下的类在使用的时候，可以不用 import 而直接使用。<br>像这种基本类 按照双亲委派机制 都应该从 rt.jar 里去获取，而不应该从自定义加载器里去获取某个开发人员自己写的 java.lang.String, 毕竟开发人员自己写的 java.lang.String 可能有很多 bug, 通过这种方式，无论如何大家使用的都是 rt.jar 里的 java.lang.String 类了。 </p></blockquote><h3 id="请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？"><a href="#请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？" class="headerlink" title="请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？"></a>请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？</h3><p>StringBuffer线程安全，StringBuilder线程不安全，</p><p>底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。</p><h3 id="请说明String是否能能继承？"><a href="#请说明String是否能能继承？" class="headerlink" title="请说明String是否能能继承？"></a>请说明String是否能能继承？</h3><p> 不能，char数组用final修饰的。 </p><h3 id="说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h3><p> “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 </p><h3 id="请说明重载和重写的区别，相同参数不同返回值能重载吗？"><a href="#请说明重载和重写的区别，相同参数不同返回值能重载吗？" class="headerlink" title="请说明重载和重写的区别，相同参数不同返回值能重载吗？"></a>请说明重载和重写的区别，相同参数不同返回值能重载吗？</h3><p><strong>重载(Overloading)</strong></p><p>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。</p><p>重载Overloading是一个类中多态性的一种表现。</p><p>（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。</p><p>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</p><p>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</p><p><strong>重写（Overriding）</strong></p><p>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。</p><p>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。</p><p>方法重写又称方法覆盖。</p><p>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。</p><p>如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</p><p>（3）子类函数的访问修饰权限不能少于父类的。</p><h3 id="请列举你所知道的Object类的方法并简要说明。"><a href="#请列举你所知道的Object类的方法并简要说明。" class="headerlink" title="请列举你所知道的Object类的方法并简要说明。"></a>请列举你所知道的Object类的方法并简要说明。</h3><p>Object()默认构造方法。</p><p>clone() 创建并返回此对象的一个副本。</p><p>equals(Object obj) 指示某个其他对象是否与此对象“相等”。</p><p>finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><p>getClass()返回一个对象的运行时类。</p><p>hashCode()返回该对象的哈希码值。 </p><p>notify()唤醒在此对象监视器上等待的单个线程。</p><p>notifyAll()唤醒在此对象监视器上等待的所有线程。</p><p>toString()返回该对象的字符串表示。</p><p>wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p><p>wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</p><p>wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 </p><h3 id="类和对象的区别"><a href="#类和对象的区别" class="headerlink" title="类和对象的区别"></a>类和对象的区别</h3><p>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。</p><p>比如：“人”是一个类，而“教师”则是“人”的一个实例。</p><p>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。</p><h3 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h3><p>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p><h3 id="请讲讲Java有哪些特性，并举一个和多态有关的例子。"><a href="#请讲讲Java有哪些特性，并举一个和多态有关的例子。" class="headerlink" title="请讲讲Java有哪些特性，并举一个和多态有关的例子。"></a>请讲讲Java有哪些特性，并举一个和多态有关的例子。</h3><p> 封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） </p><h3 id="请你讲讲wait方法的底层原理"><a href="#请你讲讲wait方法的底层原理" class="headerlink" title="请你讲讲wait方法的底层原理"></a>请你讲讲wait方法的底层原理</h3><p>ObjectSynchronizer::wait方法通过object的对象中找到ObjectMonitor对象调用方法 void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)</p><p>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队列的末尾中然后在ObjectMonitor::exit释放锁，接着 thread_ParkEvent-&gt;park 也就是wait。</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Object-oriented&quot;&gt;&lt;a href=&quot;#Object-oriented&quot; class=&quot;headerlink&quot; title=&quot;Object-oriented&quot;&gt;&lt;/a&gt;Object-oriented&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Interview" scheme="http://dqlcr5.coding-pages.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/09/MYSQL/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/09/MYSQL/</id>
    <published>2020-07-09T09:54:25.000Z</published>
    <updated>2020-07-09T13:15:40.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL索引"><a href="#MYSQL索引" class="headerlink" title="MYSQL索引"></a>MYSQL索引</h1><a id="more"></a><blockquote><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p><p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p><p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p><p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p><p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p><p>建立索引会占用磁盘空间的索引文件。</p></blockquote><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p><h3 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure><h3 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p><h3 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure><h3 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line">    </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h3><p>有四种方式来添加数据表的索引：</p><ul><li><p><strong>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</strong></p><p> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</p></li><li><p><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> </p><p>这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p></li><li><p><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> </p><p>添加普通索引，索引值可出现多次。</p></li><li><p><strong>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):</strong></p><p>该语句指定了索引为 FULLTEXT ，用于全文索引。</p></li></ul><p>以下实例为在表中添加索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure><p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure><hr><h3 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h3><p>主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure><p>你也可以使用 ALTER 命令删除主键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p><hr><h3 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h3><p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p><p>尝试以下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G</span><br><span class="line">........</span><br></pre></td></tr></table></figure><h1 id="MySQL-临时表"><a href="#MySQL-临时表" class="headerlink" title="MySQL 临时表"></a>MySQL 临时表</h1><blockquote><p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p><p>MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。</p><p>如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (</span><br><span class="line">    -&gt; product_name VARCHAR(50) NOT NULL</span><br><span class="line">    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO SalesSummary</span><br><span class="line">    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (&#39;cucumber&#39;, 100.25, 90, 2);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM SalesSummary;</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">| product_name | total_sales | avg_unit_price | total_units_sold |</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">| cucumber     |      100.25 |          90.00 |                2 |</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当你使用 <strong>SHOW TABLES</strong>命令显示数据表列表时，你将无法看到 SalesSummary表。</p><p>如果你退出当前MySQL会话，再使用 <strong>SELECT</strong>命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p><h2 id="删除MySQL-临时表"><a href="#删除MySQL-临时表" class="headerlink" title="删除MySQL 临时表"></a>删除MySQL 临时表</h2><p>默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 <strong>DROP TABLE</strong> 命令来手动删除临时表。</p><p>以下是手动删除临时表的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (</span><br><span class="line">    -&gt; product_name VARCHAR(50) NOT NULL</span><br><span class="line">    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO SalesSummary</span><br><span class="line">    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (&#39;cucumber&#39;, 100.25, 90, 2);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM SalesSummary;</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">| product_name | total_sales | avg_unit_price | total_units_sold |</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">| cucumber     |      100.25 |          90.00 |                2 |</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; DROP TABLE SalesSummary;</span><br><span class="line">mysql&gt;  SELECT * FROM SalesSummary;</span><br><span class="line">ERROR 1146: Table &#39;RUNOOB.SalesSummary&#39; doesn&#39;t exist</span><br></pre></td></tr></table></figure><h2 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h2><p>如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用<strong>CREATE TABLE … SELECT</strong> 命令，是无法实现的。</p><p>本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下：</p><ul><li>使用 <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等。</li><li></li><li>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</li><li>如果你想复制表的内容，你就可以使用 <strong>INSERT INTO … SELECT</strong> 语句来实现。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>尝试以下实例来复制表 runoob_tbl 。</p><p><strong>步骤一：</strong></p><p>获取数据表的完整结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE runoob_tbl \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: runoob_tbl</span><br><span class="line">Create Table: CREATE TABLE &#96;runoob_tbl&#96; (</span><br><span class="line">  &#96;runoob_id&#96; int(11) NOT NULL auto_increment,</span><br><span class="line">  &#96;runoob_title&#96; varchar(100) NOT NULL default &#39;&#39;,</span><br><span class="line">  &#96;runoob_author&#96; varchar(40) NOT NULL default &#39;&#39;,</span><br><span class="line">  &#96;submission_date&#96; date default NULL,</span><br><span class="line">  PRIMARY KEY  (&#96;runoob_id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;AUTHOR_INDEX&#96; (&#96;runoob_author&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB </span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p><strong>步骤二：</strong></p><p>修改SQL语句的数据表名，并执行SQL语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE &#96;clone_tbl&#96; (</span><br><span class="line">  -&gt; &#96;runoob_id&#96; int(11) NOT NULL auto_increment,</span><br><span class="line">  -&gt; &#96;runoob_title&#96; varchar(100) NOT NULL default &#39;&#39;,</span><br><span class="line">  -&gt; &#96;runoob_author&#96; varchar(40) NOT NULL default &#39;&#39;,</span><br><span class="line">  -&gt; &#96;submission_date&#96; date default NULL,</span><br><span class="line">  -&gt; PRIMARY KEY  (&#96;runoob_id&#96;),</span><br><span class="line">  -&gt; UNIQUE KEY &#96;AUTHOR_INDEX&#96; (&#96;runoob_author&#96;)</span><br><span class="line">-&gt; ) ENGINE&#x3D;InnoDB;</span><br><span class="line">Query OK, 0 rows affected (1.80 sec)</span><br></pre></td></tr></table></figure><p><strong>步骤三：</strong></p><p>执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用 <strong>INSERT INTO… SELECT</strong> 语句来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO clone_tbl (runoob_id,</span><br><span class="line">    -&gt;                        runoob_title,</span><br><span class="line">    -&gt;                        runoob_author,</span><br><span class="line">    -&gt;                        submission_date)</span><br><span class="line">    -&gt; SELECT runoob_id,runoob_title,</span><br><span class="line">    -&gt;        runoob_author,submission_date</span><br><span class="line">    -&gt; FROM runoob_tbl;</span><br><span class="line">Query OK, 3 rows affected (0.07 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>执行以上步骤后，你将完整的复制表，包括表结构及表数据。</p><h3 id="另一种完整复制表的方法"><a href="#另一种完整复制表的方法" class="headerlink" title="另一种完整复制表的方法:"></a>另一种完整复制表的方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE targetTable LIKE sourceTable;</span><br><span class="line">INSERT INTO targetTable SELECT * FROM sourceTable;</span><br></pre></td></tr></table></figure><p>其他:</p><p>可以拷贝一个表中其中的一些字段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newadmin AS</span><br><span class="line">(</span><br><span class="line">    SELECT username, password FROM admin</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以将新建的表的字段改名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newadmin AS</span><br><span class="line">(  </span><br><span class="line">    SELECT id, username AS uname, password AS pass FROM admin</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以拷贝一部分数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newadmin AS</span><br><span class="line">(</span><br><span class="line">    SELECT * FROM admin WHERE LEFT(username,1) &#x3D; &#39;s&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以在创建表的同时定义表中的字段信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newadmin</span><br><span class="line">(</span><br><span class="line">    id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY</span><br><span class="line">)</span><br><span class="line">AS</span><br><span class="line">(</span><br><span class="line">    SELECT * FROM admin</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>区分下mysql复制表的两种方式。</strong></p><p><strong>第一、只复制表结构到新表</strong></p><p>create table 新表 select * from 旧表 where 1=2</p><p>或者</p><p>create table 新表 like 旧表 </p><p><strong>第二、复制表结构及数据到新表</strong></p><p>create table新表 select * from 旧表 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MYSQL索引&quot;&gt;&lt;a href=&quot;#MYSQL索引&quot; class=&quot;headerlink&quot; title=&quot;MYSQL索引&quot;&gt;&lt;/a&gt;MYSQL索引&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="sql" scheme="http://dqlcr5.coding-pages.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://dqlcr5.coding-pages.com/2020/07/02/Linux/"/>
    <id>http://dqlcr5.coding-pages.com/2020/07/02/Linux/</id>
    <published>2020-07-02T13:26:15.000Z</published>
    <updated>2020-07-07T02:51:16.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><a id="more"></a><p>下载中文支持</p><p><img src="/2020/07/02/Linux/1593837102375.png" alt="1593837102375"></p><p>网络连接的三种形式</p><p><strong>桥连接</strong>：Linux可以和其他系统通信，但是会造成IP冲突</p><p><strong>NAT</strong>：网络地址转换方式，Linux可以访问外网，不会造成IP冲突</p><p><strong>主机模式</strong>：你的Linux是一个独立的主机，不能访问外网</p><p>分区：</p><p>boot分区：200M</p><p>swap分区：交换分区，虚拟内存，没有挂载点，2048M</p><p>根分区/：使用全部剩余空间</p><p>安装VMTool复制到/opt下</p><p>tar -zxvf VM…… .tar.gz</p><p>解压,进去文件夹，执行 /vmware-install.pl</p><p>设置共享文件夹，在/mnt/hgfs下</p><p>Linux文件系统采用的是级层式的树状结构，最上层的是根目录“/”。</p><p>/bin 是Binary的缩写，这个目录存放着最经常使用的命令</p><p>/dev 管理设备</p><p>/etc管理配置文件</p><p>/home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 </p><p>/lib 系统开机需要</p><p>/media dvd相关</p><p>/mnt 挂载文件夹</p><p>/opt 安装的软件</p><p>/proc 内核</p><p>/root 系统管理员，超级权限者的用户主目录</p><p>/sbin Super user系统管理员使用的系统管理程序</p><p>/selinux 安全加强</p><p>/sys 系统</p><p>/tmp 临时文件</p><p>/usr 用户，安装的程序</p><p>/var 变量，日志</p><p><img src="/2020/07/02/Linux/clip_image004.png" alt="img">  </p><p><img src="/2020/07/02/Linux/clip_image0014.png" alt="img">  </p><h3 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h3><p>XShell</p><ul><li>需要Linux开启一个sshd服务22</li></ul><p>终端打开setup，打开系统服务，找到sshd，空格键打开服务。tab键退出。</p><p>该服务会监听22端口。</p><p><strong>ubuntu方法：</strong> </p><p>先试着开启SSH服务</p><p>在使用SSH之前，可以先检查SSH服务有没有开启。使用命令：sudo ps -e | grep ssh来查看，如果返回的结果是“xxxx? 00:00:00 sshd”,代表服务开启。那个四个x代表四位数字，每台机数字不一样的，如图：</p><p><img src="/2020/07/02/Linux/894368-20181110064124048-505138018.png" alt="img"></p><p>如果没有反应或者其他结果，再试着开启SSH服务。使用命令sudo /etc/init.d/ssh start来开启服务，如图：</p><p><img src="/2020/07/02/Linux/894368-20181110064515920-1613146923.png" alt="img"></p><p>如果是图中结果，说明没有安装SSH服务，此时需要安装 SSH服务，为了能提高安装成功率，建议先更新源：sudo apt-get update更新安装源，如图：</p><p><img src="/2020/07/02/Linux/894368-20181110065024263-2090018697.png" alt="img"></p><p>然后安装SSH服务，使用命令：sudo apt-get install openssh-server。如图：</p><p><img src="/2020/07/02/Linux/894368-20181110065349975-237913277.png" alt="img"></p><p>等待安装结束即可。然后再次查看服务有没有启动：sudo ps -e | grep ssh：</p><p> <img src="/2020/07/02/Linux/894368-20181110065558878-1157322075.png" alt="img"></p><p>有sshd那个东西，说明服务启动了，如果需要再次确认或者没有图中的结果，使用命令来启动:sudo /etc/init.d/ssh start:</p><p><img src="/2020/07/02/Linux/894368-20181110065759521-304903884.png" alt="img"></p><p>看到服务starting了，服务成功开启。另外，还有几条命令需要记住：</p><p>sudo service ssh status 查看服务状态：</p><p><img src="/2020/07/02/Linux/894368-20181110070229962-1792308008.png" alt="img"></p><p>sudo service ssh stop 关闭服务：</p><p>sudo service ssh restart 重启服务</p><p>Xshell新建会话，先查看linux的ip地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1593769665771.png" alt="1593769665771"></p><p>箭头指向的是ip地址。</p><p>填写到xshell</p><p><img src="/2020/07/02/Linux/1593769808715.png" alt="1593769808715"></p><p>Ubuntu需要配置sshd服务</p><p>输入Linux的用户名和密码。成功连接。</p><p>如果远程使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>服务器也会重启</p><h3 id="文件的上传下载XFTP"><a href="#文件的上传下载XFTP" class="headerlink" title="文件的上传下载XFTP"></a>文件的上传下载XFTP</h3><p>协议选择SFTP</p><p>端口号选择22</p><p><img src="/2020/07/02/Linux/1593782048647.png" alt="1593782048647"></p><p><strong>乱码解决</strong>：<img src="/2020/07/02/Linux/1593782224041.png" alt="1593782224041"></p><p>选择要传输的文件，右键传输就可以了。</p><h3 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h3><p> <img src="/2020/07/02/Linux/078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"> </p><h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><p>在正常模式下，我们可以使用快捷键。</p><p>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。</p><h4 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="插入模式/编辑模式"></a>插入模式/编辑模式</h4><p>在模式下，程序员可以输入内容。</p><p>按下 i, I 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可</p><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！</p><h4 id="各模式之间的互相转换"><a href="#各模式之间的互相转换" class="headerlink" title="各模式之间的互相转换"></a>各模式之间的互相转换</h4><p><img src="/2020/07/02/Linux/1593783036444.png" alt="1593783036444"></p><h4 id="快捷键的使用案例"><a href="#快捷键的使用案例" class="headerlink" title="快捷键的使用案例"></a>快捷键的使用案例</h4><p>1)  拷贝当前行   yy , 拷贝当前行向下的 5 行 5yy，并粘贴（p）。</p><p>2)  删除当前行  dd  , 删除当前行向下的 5 行 5dd</p><p>3)  在文件中查找某个单词  [命令行下  /关键字  ， 回车  查找  ,    输入 n 就是查找下一个 ],查询</p><p>hello.</p><p>4)  设置文件的行号，取消文件的行号.[命令行下  : set nu 和  :set nonu]</p><p>5)  编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg],注意这些都是在正常模式下执行的。</p><p>6)  在一个文件中输入  “hello” ,然后又撤销这个动作，再正常模式下输入 u</p><p>7)  编辑  /etc/profile 文件，并将光标移动到  第 20 行  shift+g</p><p>第一步：显示行号 :set nu </p><p>第二步：输入 20 这个数</p><p>第三步: 输入 shift+g</p><p> <img src="/2020/07/02/Linux/vi-vim-cheat-sheet-sch.gif" alt="img"> </p><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>shutdown</p><p>shutdown -h now : 表示立即关机</p><p>shutdown -h 1 : 表示 1 分钟后关机</p><p>shutdown -r now: 立即重启</p><p>halt</p><p>就是直接使用，效果等价于关机</p><p>reboot</p><p>就是重启系统。</p><p>sync：  把内存的数据同步到磁盘</p><h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><p>当我们关机或者重启时，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失。</p><h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><p>1)  登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份.</p><p>2)  在提示符下输入 logout 即可注销用户</p><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><p>1)logout 注销指令在图形运行级别无效，在 运行级别 3 下有效.</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>  <img src="/2020/07/02/Linux/clip_image003.gif" alt="img"></p><p><strong>说明</strong></p><p>Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号</p><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>useradd  [选项]  用户名</p><p>1)  当创建用户成功后，会自动的创建和用户同名的家目录</p><p>2)  也可以通过  useradd -d 指定目录   新的用户名，给新创建的用户指定家目录</p><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a><strong>设置密码</strong></h4><p>基本语法           </p><p>passwd  用户名</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><h5 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h5><p>userdel  用户名</p><p>1)       删除用户 xm，但是要保留家目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel xm</span><br></pre></td></tr></table></figure><p>2) 删除用户 xh 以及用户主目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel xh -r</span><br></pre></td></tr></table></figure><p><strong>在删除用户时，我们一般不会将家目录删除。</strong></p><h4 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h4><h5 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id  用户名</span><br><span class="line">uid=0(root) gid=0(root)  组=0(root)</span><br><span class="line"> |           |            |</span><br><span class="line"> V           V            V</span><br><span class="line">用户id号   所在组的id号    组名</span><br></pre></td></tr></table></figure><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root</p><p><strong>基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su–切换用户名</span><br><span class="line">//高权限用户向低权限用户不需要密码</span><br><span class="line">exit   //可以回到原来的用户</span><br></pre></td></tr></table></figure><p>1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p><p>2)当需要返回到原来用户时，使用 exit 指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami  &#x2F;&#x2F;查看当前用户</span><br></pre></td></tr></table></figure><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p><p><strong>增加组</strong></p><p>groupadd 组 名</p><p><strong>删除组</strong></p><p>groupdel 组 名</p><p><strong>增加用户时直接加上组</strong></p><p>useradd  -g 用户组 用户名</p><p><strong>修改用户的组</strong></p><p>usermod  -g 用户组 用户名</p><h4 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a><strong>用户和组的相关文件</strong></h4><p><strong>/etc/passwd 文件</strong></p><p>用户（user）的配置文件，记录用户的各种信息 </p><p>每行的含义：         </p><p>用户名 : 口令 : 用户标识号 : 组标识号 : 注释性描述 : 主目录 : 登录 Shell </p><p><strong>/etc/shadow 文件</strong></p><p>口令的配置文件<br>每行的含义：</p><p>登录名 : 加密口令 : 最后一次修改时间 : 最小时间间隔 : 最大时间间隔 : 警告时间 : 不活动时间 : 失效时间 : 标志</p><p><strong>/etc/group 文件</strong><br>组(group)的配置文件，记录 Linux 包含的组的信息每行含义：</p><p>组名:口令:组标识号:组内用户列表</p><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>运行级别说明：<br>0：关机<br>1：单用户【找回丢失密码】<br>2：多用户状态没有网络服务<br>3：多用户状态有网络服务<br>4：系统未使用保留给用户<br>5：图形界面<br>6：系统重启</p><p>常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件</p><p>/etc/inittab 的   <code>id:5:initdefault:</code>   这一行中的数字</p><p><img src="/2020/07/02/Linux/1593838451860.png" alt="1593838451860"></p><h4 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h4><p><img src="/2020/07/02/Linux/clip_image001.gif" alt="img"></p><p>init [012356]</p><p>int   3</p><p>init [012356]</p><h5 id="如何找回-root-密码"><a href="#如何找回-root-密码" class="headerlink" title="如何找回 root 密码"></a>如何找回 root 密码</h5><p>进入到 单用户模式，然后修改 root 密码。因为进入单用户模式，root 不需要密码就可以登录。</p><p>开机在引导期间使用enter进入页面，按e进入选择第二行的内核kenral再按e进入，输入1告诉内核进入单用户模式，再按回车回去上一级按b启动。</p><p>启动后使用passwd root就可以重置密码了。reboot重启。</p><h3 id="获得帮助信息"><a href="#获得帮助信息" class="headerlink" title="获得帮助信息"></a>获得帮助信息</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>man [命令或配置文件]（功能描述：获得帮助信息）</p><p>man  ls</p><h4 id="help-指令"><a href="#help-指令" class="headerlink" title="help 指令"></a>help 指令</h4><p>help 命令 （功能描述：获得 shell 内置命令的帮助信息）</p><p>help cd</p><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><h4 id="pwd-指令"><a href="#pwd-指令" class="headerlink" title="pwd 指令"></a>pwd 指令</h4><p>pwd   (功能描述：显示当前工作目录的绝对路径)</p><h4 id="ls-指令"><a href="#ls-指令" class="headerlink" title="ls 指令"></a>ls 指令</h4><p>ls [ 选 项] [目录或是文件]</p><h4 id="cd-指令"><a href="#cd-指令" class="headerlink" title="cd 指令"></a>cd 指令</h4><p>cd .当前目录(不变)</p><p>cd  [参数] (功能描述：切换到指定目录)</p><p>cd ~ 或者 cd ：回到自己的家目录</p><p>cd .. 回到当前目录的上一级目录</p><p>cd   /root  使用绝对路径切换到 root 目录</p><p>cd  ../../root    使用相对路径到/root 目录</p><h4 id="mkdir-指令"><a href="#mkdir-指令" class="headerlink" title="mkdir 指令"></a>mkdir 指令</h4><p>mkdir 指令用于创建目录(make directory)</p><p>mkdir  [选项]  要创建的目录</p><p>-p ：创建多级目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;aaa&#x2F;bbb&#x2F;ccc</span><br></pre></td></tr></table></figure><h4 id="rmdir-指令"><a href="#rmdir-指令" class="headerlink" title="rmdir 指令"></a>rmdir 指令</h4><p>rmdir 指令删除空目录</p><p>rmdir  [选项]  要删除的空目录</p><p><code>rmdir</code>删除的是空目录，如果目录下有内容时无法删除的。<br>提示：如果需要删除非空目录，需要使用<code>rm -rf</code>要删除的目录</p><h4 id="touch-指令"><a href="#touch-指令" class="headerlink" title="touch 指令"></a>touch 指令</h4><p>touch 指令创建空文件</p><p>touch 文件名称</p><h4 id="cp-指令"><a href="#cp-指令" class="headerlink" title="cp 指令[*]"></a>cp 指令[*]</h4><p>cp 指令拷贝文件到指定目录</p><p>cp [选项] source dest</p><p>-r ：递归复制整个文件夹</p><p>cp -r  源目录  目标目录</p><h4 id="rm-指令"><a href="#rm-指令" class="headerlink" title="rm 指令"></a>rm 指令</h4><p>rm 指令移除【删除】文件或目录</p><p>rm  [选项]  要删除的文件或目录</p><p>-r ：递归删除整个文件夹</p><p>-f ： 强制删除不提示</p><h4 id="mv-指令"><a href="#mv-指令" class="headerlink" title="mv 指令"></a>mv 指令</h4><p>mv 移动文件与目录或重命名</p><p>mv  oldNameFile newNameFile         (功能描述：重命名)</p><p> mv /temp/movefile /targetFolder     (功能描述：移动文件)</p><h4 id="cat-指令"><a href="#cat-指令" class="headerlink" title="cat 指令"></a>cat 指令</h4><p>cat 查看文件内容，是以只读的方式打开。</p><p>cat  [选项] 要查看的文件</p><p>-n ：显示行号</p><p>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上  管道命令 | more</p><p>cat 文件名 | more [分页浏览]</p><h4 id="more-指令"><a href="#more-指令" class="headerlink" title="more 指令"></a>more 指令</h4><p>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容</p><p>快捷键：</p><p><img src="/2020/07/02/Linux/1593843318484.png" alt="1593843318484"></p><h4 id="less-指令"><a href="#less-指令" class="headerlink" title="less 指令"></a>less 指令</h4><p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1593843382522.png" alt="1593843382522"></p><h4 id="gt-指令-和-gt-gt-指令"><a href="#gt-指令-和-gt-gt-指令" class="headerlink" title="&gt; 指令 和 &gt;&gt; 指令"></a>&gt; 指令 和 &gt;&gt; 指令</h4><p>&gt; 输出重定向 : 会将原来的文件的内容覆盖</p><p>&gt;&gt; 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt;文件    （功能描述：列表的内容写入文件 a.txt 中（覆盖写））</span><br><span class="line">ls -al &gt;&gt;文件（功能描述：列表的内容追加到文件 aa.txt 的末尾）</span><br><span class="line">cat 文件 1 &gt; 文件 2（功能描述：将文件 1 的内容覆盖到文件 2）</span><br><span class="line">cal &gt;&gt; &#x2F;home&#x2F;mycal将当前日历信息  追加到 &#x2F;home&#x2F;mycal 文件中 [提示 cal ]</span><br></pre></td></tr></table></figure><h4 id="echo-指令"><a href="#echo-指令" class="headerlink" title="echo 指令"></a>echo 指令</h4><p>echo 输出内容到控制台。</p><p>echo  [选项]  [输出内容]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH   使用 echo 指令输出环境变量,输出当前的环境路径。</span><br></pre></td></tr></table></figure><h4 id="head-指令"><a href="#head-指令" class="headerlink" title="head 指令"></a>head 指令</h4><p>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head  文件(功能描述：查看文件头 10 行内容)</span><br><span class="line">head -n 5 文件(功能描述：查看文件头 5 行内容，5 可以是任意行数)</span><br></pre></td></tr></table></figure><h4 id="tail-指令"><a href="#tail-指令" class="headerlink" title="tail 指令"></a>tail 指令</h4><p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail 文件（功能描述：查看文件后 10 行内容）</span><br><span class="line">tail -n 5 文件  （功能描述：查看文件后 5 行内容，5 可以是任意行数）</span><br><span class="line">tail -f文件（功能描述：实时追踪该文档的所有更新，工作经常使用）</span><br></pre></td></tr></table></figure><h4 id="ln-指令"><a href="#ln-指令" class="headerlink" title="ln 指令"></a>ln 指令</h4><p>软链接也叫符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）</span><br><span class="line">ln -s &#x2F;root linkToRoot在&#x2F;home 目录下创建一个软连接 linkToRoot，连接到 &#x2F;root 目录</span><br><span class="line">rm -rf  linkToRoot          删除软连接</span><br><span class="line">ln 硬链接 </span><br><span class="line">##软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名（filename）进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件），硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。</span><br></pre></td></tr></table></figure><p>当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。</p><h4 id="history-指令"><a href="#history-指令" class="headerlink" title="history 指令"></a>history 指令</h4><p>查看已经执行过历史命令,也可以执行历史指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history    （功能描述：查看已经执行过历史命令）</span><br><span class="line">history 10 显示最近使用过的 10 个指令。</span><br><span class="line">!10   执行编号为10的指令</span><br></pre></td></tr></table></figure><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date-指令-显示当前日期"><a href="#date-指令-显示当前日期" class="headerlink" title="date 指令-显示当前日期"></a>date 指令-显示当前日期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) date（功能描述：显示当前时间）</span><br><span class="line">2) date +%Y （功能描述：显示当前年份）</span><br><span class="line">3) date +%m（功能描述：显示当前月份）</span><br><span class="line">4) date +%d（功能描述：显示当前是哪一天）</span><br><span class="line">5) date &quot;+%Y-%m-%d %H:%M:%S&quot;（功能描述：显示年月日时分秒）</span><br></pre></td></tr></table></figure><h4 id="date-指令-设置日期"><a href="#date-指令-设置日期" class="headerlink" title="date 指令-设置日期"></a>date 指令-设置日期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date -s字符串时间</span><br><span class="line"></span><br><span class="line">设置系统当前时间 ， 比如设置成 2018-10-10 11:22:22</span><br><span class="line">date -s &quot;2018-10-10 11:22:22&quot;</span><br></pre></td></tr></table></figure><h4 id="查看日历指令"><a href="#查看日历指令" class="headerlink" title="查看日历指令"></a>查看日历指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal [选项]    （功能描述：不加选项，显示本月日历）</span><br><span class="line">cal</span><br><span class="line">cal 2021</span><br></pre></td></tr></table></figure><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find-指令"><a href="#find-指令" class="headerlink" title="find 指令"></a>find 指令</h4><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端  </p><p>find  [搜索范围]  [选项]</p><p><img src="/2020/07/02/Linux/1593844669367.png" alt="1593844669367"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">按文件名：根据名称查找&#x2F;home 目录下的 hello.txt 文件</span><br><span class="line">find &#x2F;home -name hello.txt</span><br><span class="line"></span><br><span class="line">按拥有者：查找&#x2F;opt 目录下，用户名称为 nobody 的文件</span><br><span class="line">find &#x2F;opt -user nobody</span><br><span class="line"></span><br><span class="line">查找整个 linux 系统下大于 20m 的文件（+n  大于-n 小于n 等于）</span><br><span class="line">find &#x2F; -size +20M</span><br><span class="line">find &#x2F; -size +20480K</span><br><span class="line"></span><br><span class="line">查询&#x2F; 目录下，所有 .txt 的文件</span><br><span class="line">find &#x2F; -name *.txt</span><br></pre></td></tr></table></figure><h4 id="locate-指令"><a href="#locate-指令" class="headerlink" title="locate 指令"></a>locate 指令</h4><p>locaate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updatedb </span><br><span class="line">locate 搜索文件</span><br></pre></td></tr></table></figure><p>由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</p><h4 id="grep-指令和-管道符号"><a href="#grep-指令和-管道符号" class="headerlink" title="grep 指令和 管道符号 |"></a>grep 指令和 管道符号 |</h4><p>grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 查找内容 源文件</span><br></pre></td></tr></table></figure><p> -n 显示匹配行及行号</p><p> -i 忽略字母大小写</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请在  hello.txt  文件中，查找&quot;yes&quot;所在行，并且显示行号</span><br><span class="line">cat hello.txt | grep -n yes</span><br></pre></td></tr></table></figure><h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip-gunzip-指令"><a href="#gzip-gunzip-指令" class="headerlink" title="gzip/gunzip 指令"></a>gzip/gunzip 指令</h4><p>gzip 用于压缩文件， gunzip 用于解压的</p><p>gzip 文件   （功能描述：压缩文件，只能将文件压缩为*.gz 文件）</p><p>gunzip 文 件.gz  （功能描述：解压缩文件命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gzip 压缩， 将 &#x2F;home 下的 hello.txt 文件进行压缩</span><br><span class="line">gzip  hello.txt</span><br><span class="line"></span><br><span class="line">gunzip 压缩， 将 &#x2F;home 下的 hello.txt.gz 文件进行解压缩</span><br><span class="line">gunzip  hello.txt.gz</span><br></pre></td></tr></table></figure><p>当我们使用 gzip 对文件进行压缩后，不会保留原来的文件。</p><h4 id="zip-unzip-指令"><a href="#zip-unzip-指令" class="headerlink" title="zip/unzip 指令"></a>zip/unzip 指令</h4><p>zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip[选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）</span><br><span class="line">unzip[选项] XXX.zip （功能描述：解压缩文件）</span><br></pre></td></tr></table></figure><p>zip  -r：递归压缩，即压缩目录</p><p>unzip   -d&lt;目录&gt; ：指定解压后文件的存放目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将 /home 下的 所有文件进行压缩成 mypackage.zip</span><br><span class="line">zip -r mypackage.zip /home/</span><br><span class="line"></span><br><span class="line">将 mypackge.zip 解压到 /opt/tmp 目录下</span><br><span class="line">unzip -d /opt/tmp/ mypackage.zip</span><br></pre></td></tr></table></figure><h4 id="tar-指令"><a href="#tar-指令" class="headerlink" title="tar 指令"></a>tar 指令</h4><p>tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar[选项]XXX.tar.gz打包的内容(功能描述：打包目录，压缩后的文件格式.tar.gz)</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1593845537786.png" alt="1593845537786"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">压缩多个文件，将  /home/a1.txt 和  /home/a2.txt 压缩成 a.tar.gz</span><br><span class="line">tar -zcvf a.tar.gz  a1.txt a2.txt</span><br><span class="line"></span><br><span class="line">将/home 的文件夹 压缩成 myhome.tar.gz</span><br><span class="line">tar -zcvf myhome.tar.gz /home/</span><br><span class="line"></span><br><span class="line">将  a.tar.gz解压到当前目录</span><br><span class="line">tar -zxvf a.tar.gz</span><br><span class="line"></span><br><span class="line">将 myhome.tar.gz解压到 /opt/ 目录下</span><br><span class="line"><span class="meta">#</span><span class="bash">指定解压到的那个目录，事先要存在才能成功，否则会报错。</span></span><br><span class="line">tar -zxvf myhome.tar.gz -C /opt/</span><br></pre></td></tr></table></figure><h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><h4 id="Linux-组基本介绍"><a href="#Linux-组基本介绍" class="headerlink" title="Linux 组基本介绍"></a>Linux 组基本介绍</h4><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</p><p>1)    所有者<br>2)    所在组<br>3)    其它组<br>4)    改变用户所在的组</p><p><img src="/2020/07/02/Linux/1593864434878.png" alt="1593864434878"></p><h4 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件/目录 所有者"></a>文件/目录 所有者</h4><p>一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。</p><h3 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h3><p>指令：ls  -ahl</p><p>创建一个组 police,再创建一个用户 tom,将 tom 放在 police 组 ,然后使用 tom 来创建一个文件 ok.txt</p><p><img src="/2020/07/02/Linux/1593864576338.png" alt="1593864576338"></p><p>所有者👆</p><h4 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h4><p>指令：chown 用户名 文件名</p><p>使用 root 创建一个文件 apple.txt ，然后将其所有者修改成 tom</p><p><img src="/2020/07/02/Linux/1593864639589.png" alt="1593864639589"></p><h4 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h4><p>groupadd 组 名</p><p>创建一个组, ,monster</p><p>创建一个用户  fox ，并放入到 monster 组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd monster</span><br><span class="line">useradd -g monster fox</span><br><span class="line">id fox &#x2F;&#x2F;查看</span><br></pre></td></tr></table></figure><h4 id="文件-目录-所在组"><a href="#文件-目录-所在组" class="headerlink" title="文件/目录 所在组"></a>文件/目录 所在组</h4><p>当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。</p><h4 id="查看文件-目录所在组"><a href="#查看文件-目录所在组" class="headerlink" title="查看文件/目录所在组"></a>查看文件/目录所在组</h4><p>ls –ahl </p><h4 id="修改文件所在的组"><a href="#修改文件所在的组" class="headerlink" title="修改文件所在的组"></a>修改文件所在的组</h4><p>chgrp 组名 文件名</p><p>使用 root 用户创建文件 orange.txt ,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到 police 组 。</p><p><img src="/2020/07/02/Linux/1593865387296.png" alt="1593865387296"></p><h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h4><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组.</p><h4 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用 root 的管理权限可以改变某个用户所在的组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod   –g    组名  用户名</span><br><span class="line">usermod –d  目录名 用户名  改变该用户</span><br></pre></td></tr></table></figure><p>创建一个土匪组（bandit）将 tom 这个用户从原来所在的 police 组，修改到 bandit(土匪) 组</p><p><img src="/2020/07/02/Linux/1593865717951.png" alt="1593865717951"></p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls  -l 中显示的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</span><br></pre></td></tr></table></figure><p>0-9 位说明</p><p>1)第 0 位确定文件类型(d, - , l , c , b)</p><p>2)第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。—User</p><p>3)第 4-6 位确定所属组（同用户组的）拥有该文件的权限，—Group</p><p>4)第 7-9 位确定其他用户拥有该文件的权限 —Other</p><p><img src="/2020/07/02/Linux/1593865847037.png" alt="1593865847037"></p><h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h4><p>1) [ r ]代表可读(read): 可以读取,查看</p><p>2)  [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p><p>3) [ x ]代表可执行(execute):可以被执行</p><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h4><p>1) [ r ]代表可读(read): 可以读取，ls 查看目录内容</p><p>2) [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录</p><p>3) [ x ]代表可执行(execute):可以进入该目录</p><h3 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h3><p>ls  -l 中显示的内容如下：</p><p>-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc</p><p>10 个字符确定不同用户能对文件干什么</p><p>第一个字符代表文件类型： 文件 (-),目录(d),链接(l)<br>其余字符每 3 个一组(rwx) 读(r) 写(w) 执行(x)<br>第一组 rwx : 文件拥有者的权限是读、写和执行<br>第二组 rw- :  与文件拥有者同一组的用户的权限是读、写但不能执行</p><p>第三组 r– :    不与文件拥有者同组的其他用户的权限是读不能写和执行</p><p>可用数字表示为: r=4,w=2,x=1  因此 rwx=4+2+1=7</p><table><thead><tr><th><strong>1</strong></th><th><strong>文件：硬连接数或    目录：子目录数</strong></th></tr></thead><tbody><tr><td><strong>root</strong></td><td><strong>用户</strong></td></tr><tr><td><strong>root</strong></td><td><strong>组</strong></td></tr><tr><td><strong>1213</strong></td><td><strong>文件大小(字节)，如果是文件夹，显示 4096 字节</strong></td></tr><tr><td><strong>Feb 2 09:39</strong></td><td><strong>最后修改日期</strong></td></tr><tr><td><strong>abc</strong></td><td><strong>文件名</strong></td></tr></tbody></table><p>​    </p><h4 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h4><p>通过 chmod 指令，可以修改文件或者目录的权限</p><h4 id="第一种方式：-、-、-变更权限"><a href="#第一种方式：-、-、-变更权限" class="headerlink" title="第一种方式：+ 、-、= 变更权限"></a>第一种方式：+ 、-、= 变更权限</h4><p>u:所有者  g:所有组  o:其他人  a:所有人(u、g、o 的总和)</p><p>1) chmod   u=rwx,g=rx,o=x   文件目录名</p><p>2) chmod   o+w    文件目录名</p><p>3) chmod   a-x    文件目录名</p><p>给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。<br><img src="/2020/07/02/Linux/1593866461439.png" alt="1593866461439"></p><p>给 abc 文件的所有者除去执行的权限，增加组写的权限</p><p><img src="/2020/07/02/Linux/1593866504885.png" alt="1593866504885"></p><p>给 abc 文件的所有用户添加读的权限  </p><p><img src="/2020/07/02/Linux/1593866558942.png" alt="1593866558942"></p><h4 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h4><p>规则：r=4 w=2 x=1,rwx=4+2+1=7 </p><p>chmod u=rwx,g=rx,o=x    文件目录名</p><p>相当于  chmod  751    文件目录名</p><p>将  /home/abc.txt    文件的权限修改成    rwxr-xr-x, 使用给数字的方式实现：</p><p>rwx = 4+2+1 = 7</p><p>r-x = 4+1=5</p><p>r-x = 4+1 =5</p><p>指令：chmod 755 /home/abc.txt</p><h4 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h4><p>chown  newowner  file                          改变文件的所有者</p><p>chown newowner:newgroup file     改变用户的所有者和所有组    </p><p>-R                       如果是目录 则使其下所有子文件或目录递归生效</p><p>请将 /home/abc .txt 文件的所有者修改成 tom</p><p><img src="/2020/07/02/Linux/1593866819855.png" alt="1593866819855"></p><p>请将 /home/kkk 目录下所有的文件和目录的所有者都修改成 tom</p><p>首选我们应该使用 root 操作。  </p><p><img src="/2020/07/02/Linux/1593866872283.png" alt="1593866872283"></p><h4 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组-chgrp"></a>修改文件所在组-chgrp</h4><p>chgrp newgroup file  改变文件的所有组</p><p>1)    请将 /home/abc .txt 文件的所在组修改成 bandit (土匪)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp bandit /home/abc.txt</span><br></pre></td></tr></table></figure><p>2)    请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp -R bandit &#x2F;home&#x2F;kkk</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1593866984875.png" alt="1593866984875"></p><h3 id="最佳实践-警察和土匪游戏"><a href="#最佳实践-警察和土匪游戏" class="headerlink" title="最佳实践-警察和土匪游戏"></a>最佳实践-警察和土匪游戏</h3><p>police警察     bandit土匪</p><p>jack, jerry: 警 察</p><p>xh, xq: 土 匪</p><p>(1)  创建组</p><p>bash&gt; groupadd police </p><p>bash&gt; groupadd bandit</p><p>(2)  创建用户 </p><p> <img src="/2020/07/02/Linux/1593867122713.png" alt="1593867122713"></p><p> <img src="/2020/07/02/Linux/1593867129607.png" alt="1593867129607"></p><p> (3)    jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限</p><p> <img src="/2020/07/02/Linux/1593867173773.png" alt="1593867173773"></p><p> (4)   jack 修改该文件，让其它组人可以读, 本组人可以读写</p><p> <img src="/2020/07/02/Linux/1593867219396.png" alt="1593867219396"></p><p> (5)   xh 投靠 警察，看看是否可以读写. </p><p>先用 root 修改 xh 的组 ：</p><p> <img src="/2020/07/02/Linux/1593867266232.png" alt="1593867266232"></p><p>使用 jack 给他的家目录 /home/jack 的所在组一个 rx 的权限</p><p> <img src="/2020/07/02/Linux/1593867293834.png" alt="1593867293834"></p><p>xh 需要重新注销在到 jack 目录就可以操作    jack 的文件  </p><p><img src="/2020/07/02/Linux/1593867344404.png" alt="1593867344404"></p><h2 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/2020/07/02/Linux/1593948751281.png" alt="1593948751281"></p><p><img src="/2020/07/02/Linux/1593948778770.png" alt="1593948778770"></p><p><strong>crontab  进行 定时任务的设置</strong>  </p><p><strong>任务调度</strong>：是指系统在某个时间执行的特定的命令或程序。</p><p>任务调度分类：</p><p>1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>2.个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。</p><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [选项]</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1593948881827.png" alt="1593948881827"></p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>设置任务调度文件：/etc/crontab</p><p>设置个人任务调度。执行 crontab –e 命令。  </p><p>接着输入任务到调度文件  </p><p>如：*/1 * * * * ls –l   /etc/ &gt; /tmp/to.txt</p><p>意思说每小时的每分钟执行 ls –l /etc/ &gt; /tmp/to.txt 命令</p><h4 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h4><p>1)  cron -e</p><p>2)  */ 1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt</p><p>3)  当保存退出后就程序。</p><p>4)  在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tmp/to.txt</p><h4 id="参数细节说明"><a href="#参数细节说明" class="headerlink" title="参数细节说明"></a>参数细节说明</h4><p><img src="/2020/07/02/Linux/1593949018840.png" alt="1593949018840"></p><p><img src="/2020/07/02/Linux/1593949051397.png" alt="1593949051397"></p><p><img src="/2020/07/02/Linux/1593949079188.png" alt="1593949079188"></p><h5 id="案例-1：每隔-1-分钟，就将当前的日期信息，追加到-tmp-mydate-文件中"><a href="#案例-1：每隔-1-分钟，就将当前的日期信息，追加到-tmp-mydate-文件中" class="headerlink" title="案例 1：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中"></a><strong>案例 1</strong>：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中</h5><p>1)  先编写一个文件 /home/mytask1.sh     </p><p>date &gt;&gt; /tmp/mydate</p><p>2)  给 mytask1.sh 一个可以执行权限</p><p>chmod 744 /home/mytask1.sh</p><p>3)  crontab -e</p><p>4)  */1 * * * *  /home/mytask1.sh</p><p>5)  成功</p><h5 id="案例-2：每隔-1-分钟，-将当前日期和日历都追加到-home-mycal-文件中"><a href="#案例-2：每隔-1-分钟，-将当前日期和日历都追加到-home-mycal-文件中" class="headerlink" title="案例 2：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal 文件中"></a><strong>案例 2</strong>：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal 文件中</h5><p>1)  先编写一个文件  </p><p>/home/mytask2.sh</p><p>date &gt;&gt; /tmp/mycal</p><p> cal &gt;&gt; /tmp/mycal</p><p>2)  给 mytask1.sh 一个可以执行权限</p><p>chmod 744 /home/mytask2.sh</p><p>3) crontab -e</p><p>4) */1 * * * *  /home/mytask2.sh</p><p>5)  成功</p><h5 id="案例-3-每天凌晨-2-00-将-mysql-数据库-testdb-，备份到文件中mydb-bak。"><a href="#案例-3-每天凌晨-2-00-将-mysql-数据库-testdb-，备份到文件中mydb-bak。" class="headerlink" title="案例 3:     每天凌晨 2:00 将 mysql 数据库 testdb ，备份到文件中mydb.bak。"></a><strong>案例 3:</strong>     每天凌晨 2:00 将 mysql 数据库 testdb ，备份到文件中mydb.bak。</h5><p>1)  先编写一个文件  /home/mytask3.sh</p><p>/usr/local/mysql/bin/mysqldump -u root -proot testdb &gt; /tmp/mydb.bak</p><p>2)  给 mytask3.sh 一个可以执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 &#x2F;home&#x2F;mytask3.sh</span><br></pre></td></tr></table></figure><p>3) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>4)    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * *  &#x2F;home&#x2F;mytask3.sh</span><br></pre></td></tr></table></figure><p>5)  成功</p><h4 id="crond-相关指令"><a href="#crond-相关指令" class="headerlink" title="crond 相关指令:"></a>crond 相关指令:</h4><p>1)  conrtab –r：终止任务调度。</p><p>2)  crontab –l：列出当前有那些任务调度</p><p>3)  service crond restart   [重启任务调度]</p><h2 id="Linux-磁盘分区、挂载"><a href="#Linux-磁盘分区、挂载" class="headerlink" title="Linux 磁盘分区、挂载"></a>Linux 磁盘分区、挂载</h2><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><h5 id="windows-下的磁盘分区"><a href="#windows-下的磁盘分区" class="headerlink" title="windows 下的磁盘分区"></a>windows 下的磁盘分区</h5><p><img src="/2020/07/02/Linux/1593951062587.png" alt="1593951062587"></p><h4 id="分区的方式："><a href="#分区的方式：" class="headerlink" title="分区的方式："></a>分区的方式：</h4><p>1) mbr 分区:</p><p>1.最多支持四个主分区</p><p>2.系统只能安装在主分区</p><p>3.扩展分区要占一个主分区</p><p>4.MBR 最大只支持 2TB，但拥有最好的兼容性</p><p>2) gtp 分区:</p><p>1.支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区）</p><p>2.最大支持 18EB 的大容量（1EB=1024 PB，1PB=1024 TB ）</p><p>3.windows7 64 位以后支持 </p><h4 id="windows-下的磁盘分区-1"><a href="#windows-下的磁盘分区-1" class="headerlink" title="windows 下的磁盘分区"></a>windows 下的磁盘分区</h4><p><img src="/2020/07/02/Linux/1593950528566.png" alt="1593950528566"></p><h3 id="Linux-分区"><a href="#Linux-分区" class="headerlink" title="Linux 分区"></a>Linux 分区</h3><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>1)Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。</p><p>2)Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p><img src="/2020/07/02/Linux/1593950575312.png" alt="1593950575312"></p><h4 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h4><p>1)Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘</p><p>2)对于 IDE 硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“</del>”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。  </p><p>3)对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样 . </p><h5 id="使用-lsblk-指令查看当前系统的分区情况"><a href="#使用-lsblk-指令查看当前系统的分区情况" class="headerlink" title="使用 lsblk 指令查看当前系统的分区情况"></a>使用 lsblk 指令查看当前系统的分区情况</h5><p><img src="/2020/07/02/Linux/1593950651437.png" alt="1593950651437"></p><p><img src="/2020/07/02/Linux/1593950681315.png" alt="1593950681315"></p><h4 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h4><p>需求是给我们的 Linux 系统增加一个新的硬盘，并且挂载到/home/newdisk</p><p><img src="/2020/07/02/Linux/1593950721662.png" alt="1593950721662"></p><h3 id="如何增加一块硬盘"><a href="#如何增加一块硬盘" class="headerlink" title="如何增加一块硬盘"></a>如何增加一块硬盘</h3><p>1)虚拟机添加硬盘</p><p>2)分区    fdisk         /dev/sdb </p><p>3)格式化 mkfs   -t    ext4    /dev/sdb1</p><p>4)挂载   先创建一个  /home/newdisk , 挂 载  mount     /dev/sdb1    /home/newdisk</p><p>5)设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 /home/newdisk) 。</p><p>vim   /etc/fstab</p><p>/dev/sdb1          /home/newdisk           ext4    defaults        0 0</p><h4 id="具体的操作步骤整理"><a href="#具体的操作步骤整理" class="headerlink" title="具体的操作步骤整理"></a>具体的操作步骤整理</h4><h5 id="虚拟机增加硬盘步骤-1"><a href="#虚拟机增加硬盘步骤-1" class="headerlink" title="虚拟机增加硬盘步骤 1"></a>虚拟机增加硬盘步骤 1</h5><p>在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！</p><p><img src="/2020/07/02/Linux/1593953351911.png" alt="1593953351911"></p><p><img src="/2020/07/02/Linux/1593953412730.png" alt="1593953412730"></p><p><img src="/2020/07/02/Linux/1593953444288.png" alt="1593953444288"></p><p><img src="/2020/07/02/Linux/1593953468858.png" alt="1593953468858"></p><p><img src="/2020/07/02/Linux/1593953495297.png" alt="1593953495297"></p><p>重启虚拟机reboot</p><p>重启后使用 lsblk -f </p><p>可以看见多了个sdb</p><h5 id="虚拟机增加硬盘步骤-2"><a href="#虚拟机增加硬盘步骤-2" class="headerlink" title="虚拟机增加硬盘步骤 2"></a>虚拟机增加硬盘步骤 2</h5><p>使用分区命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk  &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><p>开始对/sdb 分区</p><p>输入m可以看到帮助</p><p>m    显示命令列表</p><p>p    显示磁盘分区 同 fdisk –l</p><p>n    新增分区</p><p>d    删除分区</p><p>w    写入并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入n</span><br><span class="line"></span><br><span class="line">显示  e  extended</span><br><span class="line"> p  primary partition(1-4)</span><br><span class="line">选择p</span><br></pre></td></tr></table></figure><p>说明： 开始分区后输入 n，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出，若不保存退出输入 q。</p><p><img src="/2020/07/02/Linux/clip_image005.jpg" alt="img"></p><h5 id="虚拟机增加硬盘步骤-3"><a href="#虚拟机增加硬盘步骤-3" class="headerlink" title="虚拟机增加硬盘步骤 3"></a>虚拟机增加硬盘步骤 3</h5><p>格式化磁盘</p><p>分区命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4  &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure><p>其中 ext4 是分区类型</p><h5 id="虚拟机增加硬盘步骤-4"><a href="#虚拟机增加硬盘步骤-4" class="headerlink" title="虚拟机增加硬盘步骤 4"></a>虚拟机增加硬盘步骤 4</h5><p><strong>挂载</strong>: 将一个分区与一个目录联系起来，</p><p>•mount     设备名称  挂载目录</p><p>•例如：  mount   /dev/sdb1   /home/newdisk</p><p>•umount   设备名称  或者 挂载目录 </p><p>•例如：   umount   /dev/sdb1    或者   umount  /newdisk</p><h5 id="虚拟机增加硬盘步骤-5"><a href="#虚拟机增加硬盘步骤-5" class="headerlink" title="虚拟机增加硬盘步骤 5"></a>虚拟机增加硬盘步骤 5</h5><p>vim   /etc/fstab</p><p>在UUID上面一行插入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdb1     /home/newdisk     ext4  defaults  0 0</span><br></pre></td></tr></table></figure><p>这句话可以使开机后能自动挂载</p><p>使用命令mount -a立即生效</p><p> 永久挂载通过修改实现挂载添加完成后  执行 –即刻生效</p><p><img src="/2020/07/02/Linux/1593950964217.png" alt="1593950964217"></p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><h4 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1594016323677.png" alt="1594016323677"></p><h4 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h&#x2F;目录</span><br></pre></td></tr></table></figure><p>查询指定目录的磁盘占用情况，默认为当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-s 指定目录占用大小汇总</span><br><span class="line"></span><br><span class="line">-h 带计量单位</span><br><span class="line"></span><br><span class="line">-a 含文件</span><br><span class="line"></span><br><span class="line">--max-depth&#x3D;1  子目录深度</span><br><span class="line"></span><br><span class="line">-c 列出明细的同时，增加汇总值</span><br></pre></td></tr></table></figure><h4 id="查询-opt-目录的磁盘占用情况，深度为-1"><a href="#查询-opt-目录的磁盘占用情况，深度为-1" class="headerlink" title="查询 /opt 目录的磁盘占用情况，深度为 1"></a>查询 /opt 目录的磁盘占用情况，深度为 1</h4><p><img src="/2020/07/02/Linux/1594016421875.png" alt="1594016421875"></p><h4 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况-工作实用指令"></a>磁盘情况-工作实用指令</h4><p>1)    统计/home 文件夹下文件的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^-  表示以&quot;-&quot;打头的，表示文件</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1594016824199.png" alt="1594016824199"></p><p>2)    统计/home 文件夹下目录的个数</p><p><img src="/2020/07/02/Linux/1594016885378.png" alt="1594016885378"></p><p>3)统计计/home 文件夹下文件的个数，包括子文件夹里的</p><p><img src="/2020/07/02/Linux/1594016923222.png" alt="1594016923222"></p><p>4)    统计文件夹下目录的个数，包括子文件夹里的</p><p><img src="/2020/07/02/Linux/1594016946230.png" alt="1594016946230"></p><p>5)以树状显示目录结构  </p><p><img src="/2020/07/02/Linux/1594016968695.png" alt="1594016968695"></p><p><img src="/2020/07/02/Linux/1594017008507.png" alt="1594017008507"></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>Linux 网络配置原理图(含虚拟机)  </p><p>目前我们的网络配置采用的是 NAT。</p><p><img src="/2020/07/02/Linux/1594018740806.png" alt="1594018740806"></p><h4 id="查看网络-IP-和网关"><a href="#查看网络-IP-和网关" class="headerlink" title="查看网络 IP 和网关"></a>查看网络 IP 和网关</h4><p>查看虚拟网络编辑器  </p><p><img src="/2020/07/02/Linux/1594018794841.png" alt="1594018794841"></p><h4 id="修改-ip-地址-修改虚拟网络的-ip"><a href="#修改-ip-地址-修改虚拟网络的-ip" class="headerlink" title="修改 ip 地址(修改虚拟网络的 ip)"></a>修改 ip 地址(修改虚拟网络的 ip)</h4><p><img src="/2020/07/02/Linux/1594018819402.png" alt="1594018819402"></p><h4 id="查看网关"><a href="#查看网关" class="headerlink" title="查看网关"></a>查看网关</h4><p><img src="/2020/07/02/Linux/1594018857189.png" alt="1594018857189"></p><h4 id="查看-windows-环境的中-VMnet8-网络配置-ipconfig-指令"><a href="#查看-windows-环境的中-VMnet8-网络配置-ipconfig-指令" class="headerlink" title="查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令)"></a>查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令)</h4><p>1)  使用 ipconfig 查看</p><p>2)  界面查看</p><p><img src="/2020/07/02/Linux/1594018892385.png" alt="1594018892385"></p><h4 id="ping-测试主机之间网络连通"><a href="#ping-测试主机之间网络连通" class="headerlink" title="ping 测试主机之间网络连通"></a>ping 测试主机之间网络连通</h4><p>ping  目的主机 （功能描述：测试当前服务器是否可以连接目的主机）</p><p><strong>测试当前服务器是否可以连接百度</strong></p><p>[root@hadoop100 桌面]# ping <a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a></p><h4 id="linux-网络环境配置"><a href="#linux-网络环境配置" class="headerlink" title="linux 网络环境配置"></a>linux 网络环境配置</h4><p><strong>第一种方法(自动获取)</strong></p><p><img src="/2020/07/02/Linux/1594018974152.png" alt="1594018974152"></p><p>缺点: linux 启动后会自动获取 IP,缺点是每次自动获取的 ip 地址可能不一样。这个不适用于做服务器，因为我们的服务器的 ip 需要时固定的。  </p><p><strong>第二种方法(指定固定的 ip)</strong></p><p>直 接 修 改 配 置 文 件 来 指 定 IP, 并 可 以 连 接 到 外 网 ( 程 序 员 推 荐 ) ， 编 辑                                                                     vi      /etc/sysconfig/network-scripts/ifcfg-eth0</p><p>要求：将 ip 地址配置的静态的，ip 地址为 192.168.184.130</p><p><img src="/2020/07/02/Linux/1594019066944.png" alt="1594019066944"></p><p>修改后，一定要 重启服务</p><p>1)  service network restart</p><p>2)  reboot 重启系统</p><p><img src="/2020/07/02/Linux/1594019131820.png" alt="1594019131820"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h4 id="进程的基本介绍"><a href="#进程的基本介绍" class="headerlink" title="进程的基本介绍"></a>进程的基本介绍</h4><p> 1)在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号。</p><p>2)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如 www 服务器。</p><p>3)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p><p>4)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</p><h4 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h4><p>查看进行使用的指令是  ps ,一般来说使用的参数是 ps -aux</p><p><img src="/2020/07/02/Linux/1594038649910.png" alt="1594038649910"></p><p><img src="/2020/07/02/Linux/1594038680528.png" alt="1594038680528"></p><h4 id="ps-指令详解"><a href="#ps-指令详解" class="headerlink" title="ps 指令详解"></a>ps 指令详解</h4><p>1)指令：ps –aux|grep xxx ，比如我看看有没有 sshd 服务</p><p>指令说明</p><p>•  System V 展示风格</p><p>•  USER：用户名称</p><p>•  PID：进程号</p><p>•  %CPU：进程占用 CPU 的百分比</p><p>•  %MEM：进程占用物理内存的百分比</p><p>• VSZ：进程占用的虚拟内存大小（单位：KB）</p><p>• RSS：进程占用的物理内存大小（单位：KB）</p><p>• TT：终端名称,缩写 .</p><p>• STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</p><p>• STARTED：进程的启动时间</p><p>• TIME：CPU 时间，即进程使用 CPU 的总时间</p><p>• COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p><p><strong>要求：以全格式显示当前所有的进程，查看进程的父进程。</strong></p><p><img src="/2020/07/02/Linux/1594038857538.png" alt="1594038857538"></p><p><strong>•</strong>  ps -ef 是以全格式显示当前所有的进程</p><p><strong>•</strong>  -e 显示所有进程。-f 全格式。</p><p>​        <strong>•</strong>  ps -ef|grep xxx</p><p>​        <strong>•</strong> 是 BSD 风格</p><p>​        <strong>•</strong> UID：用户 ID</p><p>​        <strong>•</strong> PID：进程 ID</p><p>​        <strong>•</strong> PPID：父进程 ID</p><p>​        <strong>•</strong> C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</p><p>​        <strong>•</strong> STIME：进程启动的时间</p><p>​        <strong>•</strong> TTY：完整的终端名称</p><p>​        <strong>•</strong> TIME：CPU 时间</p><p>​        <strong>•</strong> CMD：启动进程所用的命令和参数</p><p>如果我们希望查看 sshd 进程的父进程号是多少，应该怎样查询 ？</p><p><img src="/2020/07/02/Linux/1594038908719.png" alt="1594038908719"></p><p>可以看到是1.</p><h4 id="终止进程-kill-和-killall"><a href="#终止进程-kill-和-killall" class="headerlink" title="终止进程 kill 和 killall"></a>终止进程 kill 和 killall</h4><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill  [选项] 进程号（功能描述：通过进程号杀死进程）</span><br><span class="line"></span><br><span class="line">killall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</span><br></pre></td></tr></table></figure><p><strong>选项:</strong></p><p>-9 :表示强迫进程立即停止</p><p><strong>踢掉某个非法登录用户</strong>  </p><p>xshell用jack登录</p><p><img src="/2020/07/02/Linux/1594039007134.png" alt="1594039007134"></p><p><strong>终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务</strong></p><p><img src="/2020/07/02/Linux/1594039036135.png" alt="1594039036135"></p><p><strong>终止多个 gedit 编辑器 【killall , 通过进程名称来终止进程】</strong>  </p><p><img src="/2020/07/02/Linux/1594039077859.png" alt="1594039077859"></p><p><strong>强制杀掉一个终端</strong>  </p><p><img src="/2020/07/02/Linux/1594039104006.png" alt="1594039104006"></p><h4 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树 pstree"></a>查看进程树 pstree</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] ,可以更加直观的来看进程信息</span><br></pre></td></tr></table></figure><p>-p :显示进程的 PID</p><p>-u :显示进程的所属用户</p><p><strong>树状的形式显示进程的 pid</strong>  </p><p><img src="/2020/07/02/Linux/1594039184688.png" alt="1594039184688"></p><p><strong>树状的形式进程的用户 id pstree -u 即可。</strong>  </p><h2 id="服务-Service-管理"><a href="#服务-Service-管理" class="headerlink" title="服务(Service)管理"></a>服务(Service)管理</h2><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。  </p><p>在 CentOS7.0 后 不再使用 service ,而是 systemctl</p><p><img src="/2020/07/02/Linux/1594039258444.png" alt="1594039258444"></p><h4 id="service-管理指令："><a href="#service-管理指令：" class="headerlink" title="service 管理指令："></a>service 管理指令：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service  服务名 [start | stop | restart | reload | status]</span><br></pre></td></tr></table></figure><p><strong>查看当前防火墙的状况，关闭防火墙和重启防火墙。</strong></p><p><img src="/2020/07/02/Linux/1594039305238.png" alt="1594039305238"></p><p><img src="/2020/07/02/Linux/1594039336933.png" alt="1594039336933"></p><p>CentOS用firewalld:   systemctl  status  firewalld</p><p>1) 关闭或者启用防火墙后，立即生效。[telnet 测试  某个端口即可]</p><p>在window下</p><p>telnet不是命令的，是因为没有telnet客户端</p><p><img src="/2020/07/02/Linux/1594039381169.png" alt="1594039381169"></p><p>2)这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。</p><p>如果希望设置某个服务自启动或关闭永久生效，要使用 chkconfig 指令</p><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名:"></a>查看服务名:</h4><p>方式 1：使用 setup -&gt; 系统服务 就可以看到。(空格选中，回车确认，tab切换)</p><p><img src="/2020/07/02/Linux/1594039460191.png" alt="1594039460191"></p><p>方式 2:     /etc/init.d/服务名称</p><p><img src="/2020/07/02/Linux/1594039571261.png" alt="1594039571261"></p><h4 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel):"></a>服务的运行级别(runlevel):</h4><p>查看或者修改默认级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi    &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure><p>Linux 系统有 7 种运行级别(runlevel)：常用的是级别 3 和 5</p><p>• 运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</p><p>• 运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆</p><p>• 运行级别 2：多用户状态(没有 NFS)，不支持网络</p><p>• 运行级别 3：完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式</p><p>• 运行级别 4：系统未使用，保留</p><p>• 运行级别 5：X11 控制台，登陆后进入图形 GUI 模式</p><p>• 运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</p><h4 id="开机的流程说明"><a href="#开机的流程说明" class="headerlink" title="开机的流程说明"></a>开机的流程说明</h4><p><img src="/2020/07/02/Linux/1594039668145.png" alt="1594039668145"></p><p>开机、BIOS自检、boot引导、init进程、判断运行级别、</p><h4 id="chkconfig-指令"><a href="#chkconfig-指令" class="headerlink" title="chkconfig 指令"></a>chkconfig 指令</h4><p>通过 chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看服务 chkconfig --list|grep xxx</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1594039757144.png" alt="1594039757144"></p><p>chkconfig   服务名   –list</p><p>chkconfig   –level  5   服务名   on/off</p><p><strong>将 sshd 服务在运行级别为 5 的情况下，不要自启动</strong>  </p><p><img src="/2020/07/02/Linux/1594039797350.png" alt="1594039797350"></p><p><strong>请显示当前系统所有服务的各个运行级别的运行状态</strong></p><p>bash&gt; chkconfig –list</p><p><strong>查看 sshd 服务的运行状态**</strong></p><p>bash&gt; service sshd status</p><p><strong>将 sshd 服务在运行级别 5 下设置为不自动启动，看看有什么效果？</strong></p><p>bash&gt; chkconfig –level 5 sshd off</p><p><strong>当运行级别为 5 时，关闭防火墙。</strong></p><p>bash&gt; chkconfig  –level 5  iptables off</p><p> <strong>在所有运行级别下，关闭防火墙</strong></p><p>bash&gt; chkconfig  iptables off</p><p><strong>在所有运行级别下，开启防火墙</strong></p><p>bash&gt; chkconfig  iptables  on</p><h4 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h4><blockquote><p>top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1594039987313.png" alt="1594039987313"></p><p><strong>监视特定用户</strong></p><p>top：输入此命令，按回车键，查看执行的进程。</p><p>u：然后输入“u”回车，再输入用户名，即可</p><p><img src="/2020/07/02/Linux/1594040023371.png" alt="1594040023371"></p><p><strong>终止指定的进程</strong></p><p>top：输入此命令，按回车键，查看执行的进程。</p><p>k：然后输入“k”回车，再输入要结束的进程 ID 号</p><p><img src="/2020/07/02/Linux/1594040063985.png" alt="1594040063985"></p><p><strong>指定系统状态更新的时间(每隔 10 秒自动更新， 默认是 3 秒)：</strong></p><p>bash&gt; top -d 10</p><h4 id="查看系统网络情况-netstat-重要"><a href="#查看系统网络情况-netstat-重要" class="headerlink" title="查看系统网络情况 netstat(重要)"></a>查看系统网络情况 netstat(重要)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat   [选项]</span><br><span class="line"></span><br><span class="line">netstat  -anp</span><br><span class="line"></span><br><span class="line">-an  按一定顺序排列输出</span><br><span class="line"></span><br><span class="line">-p  显示哪个进程在调用</span><br></pre></td></tr></table></figure><p>查看系统所有的网络服务</p><p><img src="/2020/07/02/Linux/1594040174174.png" alt="1594040174174"></p><p>查看服务名为 sshd 的服务的信息。</p><p><img src="/2020/07/02/Linux/1594040196413.png" alt="1594040196413"></p><h3 id="RPM-和-YUM"><a href="#RPM-和-YUM" class="headerlink" title="RPM   和 YUM"></a>RPM   和 YUM</h3><h4 id="rpm-包的管理"><a href="#rpm-包的管理" class="headerlink" title="rpm 包的管理"></a>rpm 包的管理</h4><blockquote><p>一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。</p><p>Linux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。</p></blockquote><h4 id="rpm-包的简单查询指令"><a href="#rpm-包的简单查询指令" class="headerlink" title="rpm 包的简单查询指令"></a>rpm 包的简单查询指令</h4><p>查询已安装的 rpm 列表 rpm  –qa|grep xx</p><p>请查询看一下，当前的 Linux 有没有安装 firefox .</p><p><img src="/2020/07/02/Linux/1594089056566.png" alt="1594089056566"></p><h3 id="rpm-包名基本格式："><a href="#rpm-包名基本格式：" class="headerlink" title="rpm 包名基本格式："></a>rpm 包名基本格式：</h3><p> 一个 rpm 包名：firefox-45.0.1-1.el6.centos.x86_64.rpm 名称:firefox</p><p>版本号：45.0.1-1</p><p>适用操作系统: el6.centos.x86_64</p><p>表示 centos6.x 的 64 位系统</p><p>如果是 i686i386 32 noarch </p><h4 id="rpm-包的其它查询指令："><a href="#rpm-包的其它查询指令：" class="headerlink" title="rpm 包的其它查询指令："></a>rpm 包的其它查询指令：</h4><p> rpm -qa :查询所安装的所有 rpm 软件包</p><p>rpm -qa | more [分页显示]  </p><p>rpm -qa | grep X [rpm -qa | grep firefox ]</p><p><img src="/2020/07/02/Linux/1594089139190.png" alt="1594089139190"></p><p>rpm -q 软件包名 :查询软件包是否安装</p><p>rpm -q firefox</p><p> rpm -qi 软件包名 ：查询软件包信息</p><p><img src="/2020/07/02/Linux/1594089158445.png" alt="1594089158445"></p><p>rpm -qi file  </p><p>rpm -ql 软件包名 :查询软件包中的文件</p><p>rpm -ql firefox</p><p><img src="/2020/07/02/Linux/1594089191772.png" alt="1594089191772"></p><p>rpm -qf 文件全路径名 查询文件所属的软件包</p><p>rpm -qf /etc/passwd </p><p>rpm -qf /root/install.log</p><p><img src="/2020/07/02/Linux/clip_image001.jpg" alt="img"></p><h4 id="卸载-rpm-包："><a href="#卸载-rpm-包：" class="headerlink" title="卸载 rpm 包："></a>卸载 rpm 包：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e RPM 包的名称</span><br></pre></td></tr></table></figure><p>删除 firefox  软件包 </p><p><img src="/2020/07/02/Linux/1594089294137.png" alt="1594089294137"></p><p>1)  如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：   $ rpm -e  foo</p><p>removing these packages would break dependencies:foo is needed by bar-1.0-1</p><p>2)  如果我们就是要删除 foo 这个 rpm 包，可以增加参数 –nodeps ,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行</p><p>如：$ rpm -e –nodeps foo</p><p>带上 –nodeps 就是强制删除。</p><h4 id="安装-rpm-包："><a href="#安装-rpm-包：" class="headerlink" title="安装 rpm 包："></a>安装 rpm 包：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh  RPM 包全路径名称</span><br></pre></td></tr></table></figure><p>i=install 安 装</p><p>v=verbose 提 示</p><p>h=hash  进度条</p><p>1) 演示安装 firefox 浏览器</p><p>步骤先找到 firefox 的安装 rpm 包,你需要挂载上我们安装 centos 的 iso 文件，然后到/media/下去找 rpm 找 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp firefox-45.0.1-1.el6.centos.x86_64.rpm &#x2F;opt&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/02/Linux/1594089388980.png" alt="1594089388980"></p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><blockquote><p> Yum 是一个 <a href="https://baike.baidu.com/item/Shell" target="_blank" rel="noopener">Shell </a>前端软件包管理器。基于 <a href="https://baike.baidu.com/item/RPM" target="_blank" rel="noopener">RPM </a>包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用 yum 的前提是可以联网。</p></blockquote><p><img src="/2020/07/02/Linux/1594089423920.png" alt="1594089423920"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询 yum 服务器是否有需要安装的软件</span><br><span class="line">yum list|grep xx 软件列表</span><br><span class="line">安装指定的 yum 包</span><br><span class="line">yum install xxx下载安装</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>使用 yum 的方式来安装 firefox</strong></p><p>先查看一下 firefox    rpm 在 yum 服务器有没有  </p><p><img src="/2020/07/02/Linux/1594089517271.png" alt="1594089517271"></p><p>1)  安装</p><p>yum install firefox</p><h2 id="搭建-JavaEE-环境"><a href="#搭建-JavaEE-环境" class="headerlink" title="搭建 JavaEE 环境"></a>搭建 JavaEE 环境</h2><p><img src="/2020/07/02/Linux/1594089578388.png" alt="1594089578388"></p><p><img src="/2020/07/02/Linux/1594089603193.png" alt="1594089603193"></p><h4 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h4><p>0)  先将软件通过 xftp5 上传到 /opt 下</p><p>1)  解压缩到 /opt</p><p>2)    配置环境变量的配置文件 vim    /etc/profile</p><p><img src="/2020/07/02/Linux/1594089685175.png" alt="1594089685175"></p><p>JAVA_HOME=/opt/jdk1.7.0_79 </p><p>PATH=/opt/jdk1.7.0_79/bin:$PATH </p><p>export JAVA_HOME PATH</p><p><strong>3)需要注销用户，环境变量才能生效</strong>  </p><p>如果是在 3 运行级别， logout</p><p>如果是在 5 运行级别，</p><p>4) 在任何目录下就可以使用 java 和 javac</p><p><img src="/2020/07/02/Linux/1594089893452.png" alt="1594089893452"></p><p>测试是否安装成功</p><p>​                <img src="/2020/07/02/Linux/clip_imag1e001.jpg" alt="img"><br>编写一个简单的 输出</p><p>Hello.java 输出”hello,world!”  </p><p><img src="/2020/07/02/Linux/1594089954309.png" alt="1594089954309"></p><h4 id="安装-tomcat"><a href="#安装-tomcat" class="headerlink" title="安装 tomcat"></a>安装 tomcat</h4><p>1)  解压缩到/opt</p><p><img src="/2020/07/02/Linux/1594089990057.png" alt="1594089990057"></p><p>2)启动 tomcat    ./startup.sh</p><p>先进入到 tomcat 的 bin 目录</p><p><img src="/2020/07/02/Linux/1594090017998.png" alt="1594090017998"></p><p><img src="/2020/07/02/Linux/1594090025822.png" alt="1594090025822"></p><p>使用 Linux 本地的浏览是可以访问到 tomcat</p><p>开放端口 8080 ,这样外网才能访问到 tomcat vim /etc/sysconfig/iptables</p><p> <img src="/2020/07/02/Linux/1594090060315.png" alt="1594090060315"></p><p>重启防火墙</p><p><img src="/2020/07/02/Linux/1594090082996.png" alt="1594090082996"></p><p>测试是否安装成功：</p><p>在 windows、Linux  下  访问 <a href="http://linuxip:8080" target="_blank" rel="noopener">http://linuxip:8080</a></p><p><img src="/2020/07/02/Linux/1594090112721.png" alt="1594090112721"></p><h4 id="Eclipse-的安装"><a href="#Eclipse-的安装" class="headerlink" title="Eclipse 的安装"></a>Eclipse 的安装</h4><p>1)  解压缩到/opt</p><p><img src="/2020/07/02/Linux/1594090161102.png" alt="1594090161102"></p><p>2)启动 eclipse，配置 jre 和 server</p><p>启动方法 1: 创建一个快捷方式</p><p>启动方式 2: 进入到  eclipse 解压后的文件夹，然后执行        ./eclipse    即可</p><p>3)编写 jsp 页面,并测试成功!</p><p><img src="/2020/07/02/Linux/1594090202684.png" alt="1594090202684"></p><h4 id="mysql-的安装和配置"><a href="#mysql-的安装和配置" class="headerlink" title="mysql 的安装和配置"></a>mysql 的安装和配置</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;虚拟机&quot;&gt;&lt;a href=&quot;#虚拟机&quot; class=&quot;headerlink&quot; title=&quot;虚拟机&quot;&gt;&lt;/a&gt;虚拟机&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://dqlcr5.coding-pages.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C prime plus</title>
    <link href="http://dqlcr5.coding-pages.com/2020/06/28/C-prime-plus/"/>
    <id>http://dqlcr5.coding-pages.com/2020/06/28/C-prime-plus/</id>
    <published>2020-06-28T09:33:01.000Z</published>
    <updated>2020-06-30T13:28:32.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h6 id="每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（-amp-）运算符访问的地址，它表示了在内存中的一个地址。"><a href="#每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（-amp-）运算符访问的地址，它表示了在内存中的一个地址。" class="headerlink" title="每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。"></a>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</h6><a id="more"></a><p>取地址&amp;</p><p>取值*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a变量的内存地址：%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b变量的内存地址：%p\n"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问数组b的地址其实就是数组第一个变量的数组</p><p> <strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure><p> 在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="keyword">char</span>   *ch;     <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure><p> 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。 </p><h4 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h4><p> 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Address of var variable: %p\n"</span>, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Address stored in ip variable: %p\n"</span>, ip );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of *ip variable: %d\n"</span>, *ip ); <span class="comment">//20</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h4><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"ptr 的地址是 %p\n"</span>, ptr  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure><h4 id="指针的算数运算"><a href="#指针的算数运算" class="headerlink" title="指针的算数运算"></a>指针的算数运算</h4><p>C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。</p><p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr++</span><br></pre></td></tr></table></figure><p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p><p>我们概括一下：</p><ul><li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li><li>指针的每一次递减，它都会指向前一个元素的存储单元。</li><li><strong>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度</strong>，比如 int 就是 4 个字节。</li></ul><h5 id="递增一个指针"><a href="#递增一个指针" class="headerlink" title="递增一个指针"></a>递增一个指针</h5><p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中的数组地址 */</span></span><br><span class="line">   ptr = var;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"存储地址：var[%d] = %x\n"</span>, i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"存储值：var[%d] = %d\n"</span>, i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 移动到下一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----</span><br><span class="line">存储地址：var[<span class="number">0</span>] = bf882b30</span><br><span class="line">存储值：var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">存储地址：of var[<span class="number">1</span>] = bf882b34</span><br><span class="line">存储值： var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">存储地址：of var[<span class="number">2</span>] = bf882b38</span><br><span class="line">存储值：var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure><h5 id="指针的比较"><a href="#指针的比较" class="headerlink" title="指针的比较"></a>指针的比较</h5><p>指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</p><p>下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &amp;var[MAX - 1]，则把变量指针进行递增：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中第一个元素的地址 */</span></span><br><span class="line">   ptr = var;</span><br><span class="line">   i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( ptr &lt;= &amp;var[MAX - <span class="number">1</span>] )</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Address of var[%d] = %p\n"</span>, i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Value of var[%d] = %d\n"</span>, i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 指向上一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line">Address of var[<span class="number">0</span>] = bfdbcb20</span><br><span class="line">Value of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">Address of var[<span class="number">1</span>] = bfdbcb24</span><br><span class="line">Value of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">Address of var[<span class="number">2</span>] = bfdbcb28</span><br><span class="line">Value of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>一个指向整数的指针数组的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr[MAX];</span><br></pre></td></tr></table></figure><p> 在这里，把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> i, *ptr[MAX];</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      ptr[i] = &amp;var[i]; <span class="comment">/* 赋值为整数的地址 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Value of var[%d] = %d\n"</span>, i, *ptr[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------</span><br><span class="line">Value of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">Value of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">Value of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure><p> 您也可以用一个指向字符的指针数组来存储一个字符串列表，如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">"Zara Ali"</span>,</span><br><span class="line">                   <span class="string">"Hina Ali"</span>,</span><br><span class="line">                   <span class="string">"Nuha Ali"</span>,</span><br><span class="line">                   <span class="string">"Sara Ali"</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Value of names[%d] = %s\n"</span>, i, names[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------</span><br><span class="line">Value of names[<span class="number">0</span>] = Zara Ali</span><br><span class="line">Value of names[<span class="number">1</span>] = Hina Ali</span><br><span class="line">Value of names[<span class="number">2</span>] = Nuha Ali</span><br><span class="line">Value of names[<span class="number">3</span>] = Sara Ali</span><br></pre></td></tr></table></figure><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p> 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    Pointer               Pointer Variable</span><br><span class="line"> _____________          _____________           _____________</span><br><span class="line">|  Address    | ------&gt;|  Address    |--------&gt;|    Value    |</span><br><span class="line">|_____________|        |_____________|         |_____________|</span><br></pre></td></tr></table></figure><p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **var;</span><br></pre></td></tr></table></figure><p> 当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var;</span><br><span class="line">   <span class="keyword">int</span>  *ptr;</span><br><span class="line">   <span class="keyword">int</span>  **pptr;</span><br><span class="line"></span><br><span class="line">   var = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 获取 var 的地址 */</span></span><br><span class="line">   ptr = &amp;var;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用运算符 &amp; 获取 ptr 的地址 */</span></span><br><span class="line">   pptr = &amp;ptr;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用 pptr 获取值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of var = %d\n"</span>, var );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value available at *ptr = %d\n"</span>, *ptr );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value available at **pptr = %d\n"</span>, **pptr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">Value of var = <span class="number">3000</span></span><br><span class="line">Value <span class="built_in">available</span> at *ptr = <span class="number">3000</span></span><br><span class="line">Value <span class="built_in">available</span> at **pptr = <span class="number">3000</span></span><br></pre></td></tr></table></figure><h4 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1[<span class="number">5</span>] ----------指针数组</span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">5</span>]---------数组指针</span><br></pre></td></tr></table></figure><p><strong>指针数组</strong>是一个数组，每个数组元素存放一个指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//指针数组，里面存的是指针</span></span><br><span class="line">    <span class="keyword">char</span> *p1[<span class="number">5</span>] = &#123;<span class="string">"wo"</span>,</span><br><span class="line">                   <span class="string">"jiao"</span>,</span><br><span class="line">                   <span class="string">"Kayleh"</span>,</span><br><span class="line">                   <span class="string">"!"</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="comment">// %s会取地址对应的值，char形是特列,通过字符串首地址输出字符串</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组指针</strong>是一个指针，它指向的是一个数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//&amp;temp表示取出整个数组的地址</span></span><br><span class="line">    <span class="comment">//temp表示数组的第一个元素的地址</span></span><br><span class="line">    <span class="keyword">int</span>(*p2)[<span class="number">5</span>] = &amp;temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="comment">//内部的*取得是数组的，外部的取得是数组元素的</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*p2 + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>数组名实际上是第一组一维数组的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[<span class="number">4</span>][<span class="number">5</span>]</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = <span class="built_in">array</span>[<span class="number">1</span>] = &amp;<span class="built_in">array</span>[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>)+<span class="number">3</span> == &amp;<span class="built_in">array</span>[<span class="number">1</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>结论</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="built_in">array</span>+i) == <span class="built_in">array</span>[i]</span><br><span class="line">*(*(<span class="built_in">array</span>+i)+j) == &amp;<span class="built_in">array</span>[i][j]</span><br><span class="line">*(*(*(<span class="built_in">array</span>+i)+j)+k) == &amp;<span class="built_in">array</span>[i][j][k]</span><br></pre></td></tr></table></figure><p>初始化二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int array[][3];&#x2F;&#x2F;前面的可不写</span><br></pre></td></tr></table></figure><p><strong>数组指针和二维数组</strong></p><h4 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h4><blockquote><p>void指针称为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> *pi = &amp;num;</span><br><span class="line">    <span class="keyword">char</span> *pc = <span class="string">"Kayleh"</span>;</span><br><span class="line">    <span class="keyword">void</span> *pv;</span><br><span class="line"></span><br><span class="line">    pv = pi;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pi:%p,pv:%p\n"</span>, pi, pv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pv:%d\n"</span>, *(<span class="keyword">int</span> *)pv); <span class="comment">//强制转换</span></span><br><span class="line"></span><br><span class="line">    pv = pc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pc:%p,pv:%p\n"</span>, pc, pv);</span><br><span class="line">    <span class="comment">//因为字符数组中每一个元素都相当于一个指针变量，就不需要在加*了，不用解引用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pv:%s\n"</span>, pv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NULL指针"><a href="#NULL指针" class="headerlink" title="NULL指针"></a>NULL指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p1;</span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p><p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p><p>函数指针变量的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; <span class="built_in">max</span>; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入三个数字:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大的数字是: %d\n"</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line">请输入三个数字:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">最大的数字是: <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="函数指针作为某个函数的参数"><a href="#函数指针作为某个函数的参数" class="headerlink" title="函数指针作为某个函数的参数"></a>函数指针作为某个函数的参数</h4><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><blockquote><p>以下是来自知乎作者常溪玲的解说：</p><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p><p>实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。</p><p>populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_array</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> arraySize, <span class="keyword">int</span> (*getNextValue)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextRandomValue</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">--------------------</span><br><span class="line"><span class="number">16807</span> <span class="number">282475249</span> <span class="number">1622650073</span> <span class="number">984943658</span> <span class="number">1144108930</span> <span class="number">470211272</span> <span class="number">101027544</span> <span class="number">1457850878</span> <span class="number">1458777923</span> <span class="number">2007237709</span></span><br></pre></td></tr></table></figure><h3 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C 传递指针给函数"></a>C 传递指针给函数</h3><p>C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。</p><p>下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSeconds</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *par)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Number of seconds: %ld\n"</span>, sec );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSeconds</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *par)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line">Number of seconds :<span class="number">1294450468</span></span><br></pre></td></tr></table></figure><p> 能接受指针作为参数的函数，也能接受数组作为参数，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 带有 5 个元素的整型数组  */</span></span><br><span class="line">   <span class="keyword">int</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">50</span>&#125;;</span><br><span class="line">   <span class="keyword">double</span> avg;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 传递一个指向数组的指针作为参数 */</span></span><br><span class="line">   avg = getAverage( balance, <span class="number">5</span> ) ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出返回值  */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Average value is: %f\n"</span>, avg );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>    i, sum = <span class="number">0</span>;      </span><br><span class="line">  <span class="keyword">double</span> avg;          </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  avg = (<span class="keyword">double</span>)sum / <span class="built_in">size</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line">Average value is: <span class="number">214.40000</span></span><br></pre></td></tr></table></figure><h3 id="C-从函数返回指针"><a href="#C-从函数返回指针" class="headerlink" title="C 从函数返回指针"></a>C 从函数返回指针</h3><p> C 允许您从函数返回指针。为了做到这点，您必须声明一个返回指针的函数，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p><p>现在，让我们来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要生成和返回随机数的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">getRandom</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span>  r[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 设置种子 */</span></span><br><span class="line">   srand( (<span class="keyword">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">   &#123;</span><br><span class="line">      r[i] = rand();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r[i] );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="keyword">int</span> *p;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"*(p + [%d]) : %d\n"</span>, i, *(p + i) );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------</span><br><span class="line"><span class="number">1523198053</span></span><br><span class="line"><span class="number">1187214107</span></span><br><span class="line"><span class="number">1108300978</span></span><br><span class="line"><span class="number">430494959</span></span><br><span class="line"><span class="number">1421301276</span></span><br><span class="line"><span class="number">930971084</span></span><br><span class="line"><span class="number">123250484</span></span><br><span class="line"><span class="number">106932140</span></span><br><span class="line"><span class="number">1604461820</span></span><br><span class="line"><span class="number">149169022</span></span><br><span class="line">*(p + [<span class="number">0</span>]) : <span class="number">1523198053</span></span><br><span class="line">*(p + [<span class="number">1</span>]) : <span class="number">1187214107</span></span><br><span class="line">*(p + [<span class="number">2</span>]) : <span class="number">1108300978</span></span><br><span class="line">*(p + [<span class="number">3</span>]) : <span class="number">430494959</span></span><br><span class="line">*(p + [<span class="number">4</span>]) : <span class="number">1421301276</span></span><br><span class="line">*(p + [<span class="number">5</span>]) : <span class="number">930971084</span></span><br><span class="line">*(p + [<span class="number">6</span>]) : <span class="number">123250484</span></span><br><span class="line">*(p + [<span class="number">7</span>]) : <span class="number">106932140</span></span><br><span class="line">*(p + [<span class="number">8</span>]) : <span class="number">1604461820</span></span><br><span class="line">*(p + [<span class="number">9</span>]) : <span class="number">149169022</span></span><br></pre></td></tr></table></figure><p>字符串</p><p>C 中有大量操作字符串的函数：</p><table><thead><tr><th align="left">函数</th><th align="left">目的</th></tr></thead><tbody><tr><td align="left"><strong>strcpy(s1, s2);</strong></td><td align="left">复制字符串 s2 到字符串 s1。</td></tr><tr><td align="left"><strong>strcat(s1, s2);</strong></td><td align="left">连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td align="left"><strong>strlen(s1);</strong></td><td align="left">返回字符串 s1 的长度。</td></tr><tr><td align="left"><strong>strcmp(s1, s2);</strong></td><td align="left">如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr><tr><td align="left"><strong>strchr(s1, ch);</strong></td><td align="left">返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td align="left"><strong>strstr(s1, s2);</strong></td><td align="left">返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h2 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C 结构体"></a>C 结构体</h2><p>C 数组允许定义可存储相同类型数据项的变量，<strong>结构</strong>是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p><p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p><ul><li>Title</li><li>Author</li><li>Subject</li><li>Book ID</li></ul><h4 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h4><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure><p><strong>tag</strong> 是结构体标签。</p><p><strong>member-list</strong> 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p><p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; book</span><br></pre></td></tr></table></figure><p> 在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。</p><p> 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此结构体的声明包含了指向自己类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h2&gt;&lt;h6 id=&quot;每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（-amp-）运算符访问的地址，它表示了在内存中的一个地址。&quot;&gt;&lt;a href=&quot;#每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（-amp-）运算符访问的地址，它表示了在内存中的一个地址。&quot; class=&quot;headerlink&quot; title=&quot;每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;amp;）运算符访问的地址，它表示了在内存中的一个地址。&quot;&gt;&lt;/a&gt;每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;amp;）运算符访问的地址，它表示了在内存中的一个地址。&lt;/h6&gt;
    
    </summary>
    
    
    
      <category term="C" scheme="http://dqlcr5.coding-pages.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://dqlcr5.coding-pages.com/2020/06/27/Redis/"/>
    <id>http://dqlcr5.coding-pages.com/2020/06/27/Redis/</id>
    <published>2020-06-27T09:30:29.000Z</published>
    <updated>2020-07-04T11:07:18.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><a id="more"></a><h3 id="在Linux下安装"><a href="#在Linux下安装" class="headerlink" title="在Linux下安装"></a>在Linux下安装</h3><p> <a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a> 官网下载，移动到<code>/opt</code> 目录下. 在终端使用命令解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf redis-XXXXXX.tar.gz</span></span><br></pre></td></tr></table></figure><p>进入解压后的目录,运行make指令(需要GCC编译器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd redis.XXX</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>进入默认安装的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p>在根目录创建一个文件夹/myredis，把安装目录下的redis.conf复制到/myredis，复制的目的是不影响出厂的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf &#x2F;myredis</span><br></pre></td></tr></table></figure><p>要把myredis的权限修改,否则会出现redis无法SHUTDOWN的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 &#x2F;myredis</span><br></pre></td></tr></table></figure><p>修改复制过来的conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure><p>修改为为yes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原来的：</span><br><span class="line">##########GENERAL###################</span><br><span class="line">XXX</span><br><span class="line">daemonzie no</span><br><span class="line"></span><br><span class="line">修改为:</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>检查有没有启动Redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|gref redis</span><br></pre></td></tr></table></figure><p>检查端口是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :6379</span><br></pre></td></tr></table></figure><p>结果是没有启动的</p><h5 id="启动方法："><a href="#启动方法：" class="headerlink" title="启动方法："></a>启动方法：</h5><p>在/usr/local/bin下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server &#x2F;myredis&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>默认端口是6379</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 6379</span><br></pre></td></tr></table></figure><p>检查是否连接成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PONG</span><br></pre></td></tr></table></figure><p>返回PONG表示成功</p><p>退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SHUTDOWN</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="KEY关键字"><a href="#KEY关键字" class="headerlink" title="KEY关键字"></a>KEY关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DBSIZE &#x2F;&#x2F;当前数据库的key的数量</span><br><span class="line">select db &#x2F;&#x2F;切换数据库</span><br><span class="line">Flushdb  &#x2F;&#x2F;清空当前库</span><br><span class="line">Flushall &#x2F;&#x2F;清空所有库</span><br><span class="line">key * 当前库所有的key</span><br><span class="line">exists key &#x2F;&#x2F;判断key是否存在，有返回1，无则0</span><br><span class="line">move key db &#x2F;&#x2F;移动到目标库，当前库的移除</span><br><span class="line">expire key 秒钟 &#x2F;&#x2F;给key设置过期时间，过期后查询到的是nid空值</span><br><span class="line">ttl key &#x2F;&#x2F;查看还有多久过期，-1表示永不过期，-2表示已过期</span><br><span class="line">type key &#x2F;&#x2F;查看key是什么类型</span><br></pre></td></tr></table></figure><h3 id="redis五种数据结构"><a href="#redis五种数据结构" class="headerlink" title="redis五种数据结构"></a>redis五种数据结构</h3><h5 id="String：字符串"><a href="#String：字符串" class="headerlink" title="String：字符串"></a>String：字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line">del key</span><br><span class="line">append key value &#x2F;&#x2F;在value后追加</span><br><span class="line">strlen &#x2F;&#x2F;String长度</span><br><span class="line">INCR&#x2F;DECR KEY&#x2F;&#x2F;一定要是数字，自增自减</span><br><span class="line">INCRBY&#x2F;DECRBY KEY 步长  &#x2F;&#x2F;多步递增递减</span><br><span class="line">getrange&#x2F;setrange key index index  &#x2F;&#x2F;根据索引取值设置值</span><br><span class="line">setex key 秒钟 value   &#x2F;&#x2F;设置值的时候设置过期时间</span><br><span class="line">setnx  &#x2F;&#x2F;set if not exist</span><br><span class="line">mset key1 value1 key2 value2 &#x2F;&#x2F; 设置多个值</span><br><span class="line">mget&#x2F;msetnx</span><br></pre></td></tr></table></figure><h5 id="List：列表"><a href="#List：列表" class="headerlink" title="List：列表"></a>List：列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list1 1 2 3 4 5 (类似栈)</span><br><span class="line">LRANGE list1 0 -1</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">lpop list1</span><br><span class="line">&quot;5&quot;</span><br><span class="line">rpop list1</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list2 1 2 3 4 5</span><br><span class="line">LRANGE list2 0 -1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">lpop list2</span><br><span class="line">&quot;1&quot;</span><br><span class="line">rpop list2</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lindex &#x2F;&#x2F;按照索引下标获得元素，（从上到下）</span><br><span class="line">llen  &#x2F;&#x2F;长度</span><br><span class="line">LREM KEY N Value  &#x2F;&#x2F;删除key数组中的N个Value</span><br><span class="line">LTRIM KEY 开始index 结束index &#x2F;&#x2F;截取指定范围的值后在赋值给key</span><br><span class="line">rpoplpush 源列表 目的列表  &#x2F;&#x2F;把源列表的最底的值移动到目的列表的最上面</span><br><span class="line">lset key index value &#x2F;&#x2F;根据数组下标设置成value</span><br><span class="line">linsert key before&#x2F;after 值1 值2  &#x2F;&#x2F;把值2的值插入到key数组值1的前面&#x2F;后面</span><br></pre></td></tr></table></figure><h5 id="Set：集合"><a href="#Set：集合" class="headerlink" title="Set：集合"></a>Set：集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sadd  key value1，value1，value2  &#x2F;&#x2F;只会进去不重复的值 </span><br><span class="line">smembers key value 0 -1 &#x2F;&#x2F;打印全部</span><br><span class="line">sismember key value &#x2F;&#x2F;判断value是否在key里</span><br><span class="line">scard  &#x2F;&#x2F;获取集合里面的元素</span><br><span class="line">srem key value &#x2F;&#x2F;删除集合中元素</span><br><span class="line">srandmember key &#x2F;&#x2F;随机出几个数</span><br><span class="line">spop key &#x2F;&#x2F;随机出栈</span><br><span class="line">smove key1 key2 在key1里某个值  &#x2F;&#x2F;将key1里的某个值赋给key2</span><br><span class="line">sdiff set1 set2  &#x2F;&#x2F;差集，set1里有的，set2没有的</span><br><span class="line">sinter set1 set2 &#x2F;&#x2F;交集，都有的</span><br><span class="line">sunion set1 set2 &#x2F;&#x2F;并集</span><br></pre></td></tr></table></figure><h5 id="Hash-：哈希"><a href="#Hash-：哈希" class="headerlink" title="Hash ：哈希"></a>Hash ：哈希</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value是一个键值对</span><br><span class="line">hset key &lt;key1,value1&gt;</span><br><span class="line">hget key key1</span><br><span class="line">hmset KEY1 keyA valueA KEY2 keyB valueB</span><br><span class="line">hmgetall  </span><br><span class="line">hdel KEY1 keyA</span><br><span class="line">HEXISTS KEY1 keyA &#x2F;&#x2F;判断是否存在</span><br><span class="line">hkeys&#x2F;kvals KEY1</span><br><span class="line">hincrby&#x2F;hincrbyfloat KEY1  keyA  步长&#x2F;浮点数    &#x2F;&#x2F;自增自减</span><br><span class="line">hsetnx</span><br></pre></td></tr></table></figure><h5 id="Zset（sorted-set）：有序集合"><a href="#Zset（sorted-set）：有序集合" class="headerlink" title="Zset（sorted set）：有序集合"></a>Zset（sorted set）：有序集合</h5><p>在set基础上，加一个score值</p><p>set是 k1 v1 v2 v3 </p><p>zset是 k1  score1  v1  score2  v2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zadd  key  k1  score1  v1  score2  v2</span><br><span class="line">zrange key 0 -1  &#x2F;&#x2F;只会打印value</span><br><span class="line">zrange key 0 -1 withscores  &#x2F;&#x2F;会打印v1，score，v2，score</span><br><span class="line">zrangebyscore key 开始score 结束score &#x2F;&#x2F;  &quot;（&quot; 表示不包含， a（ b  表示大于等于a，小于b </span><br><span class="line">zrangebyscore key 开始score 结束score withscore</span><br><span class="line">zrangebyscore key 开始score 结束score limit 开始下标步 多少步  </span><br><span class="line">zrem key score对应的value  &#x2F;&#x2F;删除元素</span><br><span class="line">zacard  key  &#x2F;&#x2F;统计key里value的个数</span><br><span class="line">zcount key score区间</span><br><span class="line">zrank key value  &#x2F;&#x2F;获取下标</span><br><span class="line">zrevrank  key value &#x2F;&#x2F;获取反转后的下标</span><br><span class="line">zrevrange key 0 -1&#x2F;&#x2F;反转集合</span><br><span class="line">zrevrangebyscore key 结束score 开始score   &#x2F;&#x2F;反转集合，index也要反转</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="Units"><a href="#Units" class="headerlink" title="Units"></a>Units</h4><p>1.配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</p><p>2.对大小写不敏感</p><p><img src="/2020/06/27/Redis/1.png" alt="1593308699248"></p><h4 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a>INCLUDES</h4><p>可以通过includes包含，redis.conf可以作为总闸,包含其他</p><p><img src="/2020/06/27/Redis/2.png" alt="1593308936736"></p><h4 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h4><p>daemonize 默认为no</p><p>pidfile 进程管道id文件</p><p>port 默认端口</p><p>tcp-backlog,backlog  511是一个连接队列,在高并发环境下你需要一个高backlog值来避免慢客户端连接问题</p><p>bind 端口及网卡的绑定</p><p>timeout 0 当系统空闲一段时间后中断</p><p>Tcp-keepalive 单位为秒,设置为0则不会进行Keepalive检测</p><p>loglevel notice 日志级别</p><p>logfile 日志文件</p><p>syslog-enabled 是否把日志输出到syslog中</p><p>syslog-ident 指定syslog里的日志标志</p><p>syslog-facility 指定syslog设备,值可以是USER或LOCAL0-LOCAL7</p><p>databases 默认有16个库</p><p><img src="/2020/06/27/Redis/3.png" alt="1593309132453"></p><h4 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a>SECURITY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config get requirepass</span><br><span class="line">config set requirepass &quot;123456&quot;   &#x2F;&#x2F;立即生效</span><br><span class="line">访问任何命令前使用 auth 123456</span><br></pre></td></tr></table></figure><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>maxclients 10000   允许10000人连接</p><p>maxmemory <bytes></bytes></p><p>maxmemory-policy  noexiction  缓存过期清洁策略 ,默认永不过期</p><ul><li>volatile-lru:使用LRU算法移除key,只对设置了过期时间的键</li><li>allkeys-lru:使用LRU算法移除key</li><li>volatile-random:在过期集合中移除随机的key,只对设置了过期时间的键</li><li>allkeys-random:移除随机的key</li><li>volatile-ttl:移除那些TTL值最小的key,即那些最近要过期的key</li><li>noexiction :不进行移除.针对写操作,只是返回错误信息</li></ul><p>LRU算法:最近最少使用的</p><p>Maxmemory-samples  设置样本数量,LRU算法和最小TTL算法都并非是精确的算法,而是估算值,所以你可以设置样本的大小,redis默认会检查这么多个key并选择其中LRU的那个;</p><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><ul><li><p>redis默认不是以守护进程的方式运行,可以通过该配置项修改,使用yes启动守护进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure></li><li><p>当Redis以守护进程方式运行时,Redis默认会把pid写入/var/run/redis.pid文件,可以通过pidfile指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid &#x2F;var&#x2F;run&#x2F;redis.pid</span><br></pre></td></tr></table></figure></li><li><p>指定redis监听端口,默认端口为6379</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure></li><li><p>绑定的主机地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blind 127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>当客户端闲置多长时间后关闭连接,如果指定为0,表示关闭该功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure></li><li><p>指定日志记录级别,Redis总共支持四个级别,debug、verbose、notice、warning，默认为verbose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel verbose</span><br></pre></td></tr></table></figure></li><li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile stdout</span><br></pre></td></tr></table></figure></li><li><p>设置数据库的数量，默认数据库为0，可以使用<dbid>命令在连接上指定数据库id</dbid></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure><ul><li>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">Redis默认配置文件中提供了三个条件:</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ul><li>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><ul><li>指定本地数据库文件名，默认为dump.rdb</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure><ul><li>指定本地数据库存放目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir .&#x2F;</span><br></pre></td></tr></table></figure><ul><li>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><ul><li>当master服务先设置了密码保护，slav服务连接master的密码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><ul><li>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</password></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure><ul><li>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max numbers of clients reached 错误信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 128</span><br></pre></td></tr></table></figure><ul><li>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把key存放内存，value会存放在swap区。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><ul><li>指定是否在每次更新操作后进行日志记录。Redis在默认情况下时异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件时按save条件来同步的，所以有的数据会在一段时间内只存在内存中。默认为no</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure><ul><li>指定更新日志文件名，默认为appendonly.aof</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure><ul><li>指定更新日志条件，共有3个可选值：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendfsync everysec</span><br><span class="line">no: 表示等操作系统进行数据缓存同步到磁盘（快）</span><br><span class="line">always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span><br><span class="line">everysec：表示每秒同步一次（折中，默认值）</span><br></pre></td></tr></table></figure><ul><li>指定是否启用虚拟内存机制，默认为no。VM机制将数据分页存放，有Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘换出到内存中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-enabled no</span><br></pre></td></tr></table></figure><ul><li>虚拟内存文件路径,默认值为/tmp/redis.swap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-swap-file &#x2F;tmp&#x2F;redis.swap</span><br></pre></td></tr></table></figure><ul><li>将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(Redis的索引数据 就是keys)，也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认为0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-max-memory 0</span><br></pre></td></tr></table></figure><ul><li>Redis swap文件分成了很多page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes;如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-page-size 32</span><br></pre></td></tr></table></figure><ul><li>设置swap文件中的page数量，由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的，在磁盘上每8个page将消耗1bytes的内存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-pages 134217728</span><br></pre></td></tr></table></figure><ul><li>设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure><ul><li>设置在向客户端应答时，是否把较小的包含并为一个包发送，默认为开启</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glueoutputbuf yes</span><br></pre></td></tr></table></figure><ul><li>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-zipmap-entries 64</span><br><span class="line">hash-max-zipmap-value 512</span><br></pre></td></tr></table></figure><ul><li>指定是否激活重置哈希，默认为开启</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure><ul><li>指定包含其他的配置文件，可以在同一主机上多个Redis实例之间同一份配置文件，而同时各个实例又拥有自己的特定配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inclue &#x2F;path&#x2F;to.local,conf</span><br></pre></td></tr></table></figure><h2 id="Redis持久化RDB"><a href="#Redis持久化RDB" class="headerlink" title="Redis持久化RDB"></a>Redis持久化RDB</h2><blockquote><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，即Snapshot快照，它恢复时是将快照文件直接读到内存里</p></blockquote><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件，替换上次持久化好的文件。</p><p>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方法要比AOF方式更加的高效。</p><p>RDB的缺点是最后一次持久化后的数据可能丢失。</p><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><blockquote><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）</p><p>数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p></blockquote><p>RDB保存的是dump.rdb文件,</p><p>先拷贝一份rdb，删除原rdb，再重命名为dump.rdb，即可恢复</p><h4 id="配置文件的位置"><a href="#配置文件的位置" class="headerlink" title="配置文件的位置"></a>配置文件的位置</h4><p>##########SNAPSHOT###########</p><p>save 秒钟 写操作次数</p><p>禁用 save “”</p><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p><p>rdbcompression yes</p><p>stop-writes-on-bgsave-error   yes</p><p>如果后台在save操作出现错误的时候，停止写入</p><p>如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制</p><p>rgbchecksum  yes    ##是否校验rdb文件</p><p>在存储快照后，还可以让Redis使用CRC算法来进行数据校验，但是这样做会增加大约10%的性能消耗，</p><p>如果希望获取到最大的性能提升，可以关闭此功能。</p><p><strong>触发RDB快照</strong></p><p>命令</p><p><code>save</code> 手动保存 <code>save</code>只管保存，其他不管，全部阻塞</p><p><code>bgsave</code> Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求，可以通过lastsave命令获得最后一次成功执行快照的时间</p><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。</p><p>config get dir获取目录</p><p>停止</p><p>动态所有停止RDB保存规则的方法：redis-cli config set save “”</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1.适合大规模的数据恢复</p><p>2.对数据完整性和一致性要求不高</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>1.在一定间隔时间做一次备份，所有如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</p><p>2.fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">内存中的      rdbSave     磁盘中的</span><br><span class="line">数据对象   ----------》    RDB文件</span><br><span class="line">            rdbload</span><br></pre></td></tr></table></figure><ul><li><p>RDB是一个非常紧凑的文件</p></li><li><p>RDB在保存文件时父进程唯一要做的就是fork出一个子进程来做，接下来的工作全部由子进程来做，</p><p>父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能</p></li><li><p>与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。</p></li></ul><ul><li>数据丢失风险大</li><li>RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能响应客户端的请求。</li></ul><h2 id="Redis持久化之AOF"><a href="#Redis持久化之AOF" class="headerlink" title="Redis持久化之AOF"></a>Redis持久化之AOF</h2><blockquote><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p></blockquote><p>AOF保存的是appendonly.aof文件</p><p>###########appendonly##########</p><p>恢复：删除dump.rdb，vim  appendonly.aof，删除末尾行的FLUSHALL，再次连接数据库即可访问。</p><p>两者可以共存，优先找aof，如果aof有修改为不能识别的字符，开启redis时会被拒绝。</p><p>这时，当前文件夹下有一个redis-check-aof，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br><span class="line">continue?[y&#x2F;N]:y</span><br></pre></td></tr></table></figure><p>命令会删除不符合语法规范的字段。</p><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用bgrewriteaof</p><p>重写原理：</p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set 语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p><p>触发机制：</p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p><p>auto-aof-rewrite-percentage 100  一倍</p><p>auto-aof-rewrite-min-size 64mb</p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>每秒同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整比较好</p><p>每修改同步：appendfsync  everysec  异步操作，每秒记录  如果一秒内宕机，有数据丢失。</p><p>不同步：appendfsync  no 从不同步</p><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><p>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢与rdb</p><p>aof运行效率要慢与rdb，每秒同步策略较好，不同步效率和rdb相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                             AOF                   网络协议格式</span><br><span class="line"> _________________   命令请求     ________________   的命令内容   ____________________</span><br><span class="line">|      客户端      | __________&gt; |     服务器      | __________&gt;|       AOF文件      |</span><br><span class="line">|_________________|             |________________|            |___________________|</span><br></pre></td></tr></table></figure><ul><li>aof文件时一个只进行追加的日志文件</li><li>Redis可以在AoF文件体积变得过大时，自动地在后台对AOF进行重写</li></ul><ul><li>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</li><li>根据所使用的fsync策略，AOF的速度可能会慢于RDB</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p>AOP持久化方式记录每次对服务器写的操作，当服务器重启的时候回重新执行这些命令来回复原始的数据，AOP命令以redis协议追加保存每次写的操作到文件末尾.</p></li><li><p>Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式.在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. </p></li><li><p>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件, 建议不要只使用AOF,因为RDB更适合于备份数据库(AOF在不断变化不好备份),</p><p>快速重启,而且不会有AOF可能存在的bug,留着作为一个万一的手段.</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞</p></blockquote><h4 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h4><p>一个队列中，一次性的、顺序性、排他性的执行一系列命令</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th><strong>DISCARD</strong></th><th><strong>取消事务，放弃执行事务块内的所有命令。</strong></th></tr></thead><tbody><tr><td><strong>EXEC</strong></td><td><strong>执行所有事务块内的命令。</strong></td></tr><tr><td><strong>MULTI</strong></td><td><strong>标记一个事务块的开始。</strong></td></tr><tr><td><strong>UNWATCH</strong></td><td><strong>取消 WATCH 命令对所有 key 的监视。</strong></td></tr><tr><td><strong>WATCH key [key …]</strong></td><td><strong>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong></td></tr></tbody></table><h5 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h5><p>MULTI 相当与 一个新的购物车，每输入一条命令返回QUEUED相当于加入购物车，EXEC执行命令相当于结账。</p><h5 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h5><p>在事务没有EXEC之前调用DISCARD</p><h5 id="全体连坐"><a href="#全体连坐" class="headerlink" title="全体连坐"></a>全体连坐</h5><p>如果有一个指令不能正常运行（编译出错），事务EXEC会报错</p><h5 id="冤头债主"><a href="#冤头债主" class="headerlink" title="冤头债主"></a>冤头债主</h5><p><strong>运行时出错的命令</strong>不会执行，而其他命令仍然会放行。</p><blockquote><p>Redis是否支持事务？ 是部分支持。</p></blockquote><h5 id="watch监控"><a href="#watch监控" class="headerlink" title="watch监控"></a>watch监控</h5><ul><li><p>悲观锁(Pessimistic Lock)</p><blockquote><p>我对这个事情的发展很悲观，每次去拿数据的时候都认为别人会修改，为了避免出事，把整张表锁了，</p><p>表锁，并发性最差，一致性最好。</p></blockquote></li><li><p><strong>乐观锁(Optimistic Lock)</strong></p><blockquote><p>我认为这个事没有人会去干，不会上锁，乐观锁在每条记录的后面加一个version版本号字段。</p><p>乐观锁策略：提交版本必须大于记录当前版本才能执行。</p></blockquote></li></ul><p>在调用MULTI之前，先调用  WATCH  + KEY</p><p><strong>UNWATCH取消所有key的监控</strong></p><p>有加塞篡改，监控了key，key被修改了，事务将被打断，调用UNWATCH再执行一次</p><h4 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h4><p>开启：以MULTI开始一个事务</p><p>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面。</p><p>执行：由EXEC命令触发事务</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>watch指令，类似乐观锁，事务提交时，如果key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会执行。</p><p>通过watch命令在事务执行之前监控了多个keys，倘若在watch之后有任何key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>单独的隔离操作：事务中的所有命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的请求所打断。</p><p>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个问题。</p><p>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p><h2 id="消息订阅发布"><a href="#消息订阅发布" class="headerlink" title="消息订阅发布"></a>消息订阅发布</h2><p>是什么？</p><blockquote><p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</p></blockquote><p>下图展示了频道channel1，以及订阅这个频道的三个客户端—client2和client5、client1之间的关系</p><p> <img src="/2020/06/27/Redis/pubsub1.png" alt="img"> </p><p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会发送给订阅它的三个客户端</p><p> <img src="/2020/06/27/Redis/pubsub2.png" alt="img"> </p><p>下表列出了 redis 发布订阅常用命令：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>PSUBSCRIBE pattern [pattern …]</strong></td><td align="left"><strong>订阅一个或多个符合给定模式的频道。</strong></td></tr><tr><td align="left"><strong>PUBSUB subcommand [argument [argument …]]</strong></td><td align="left"><strong>查看订阅与发布系统状态。</strong></td></tr><tr><td align="left"><strong>PUBLISH channel message</strong></td><td align="left"><strong>将信息发送到指定的频道。</strong></td></tr><tr><td align="left"><strong>PUNSUBSCRIBE [pattern [pattern …]]</strong></td><td align="left"><strong>退订所有给定模式的频道。</strong></td></tr><tr><td align="left"><strong>SUBSCRIBE channel[channel …]</strong></td><td align="left"><strong>订阅给定的一个或多个频道的信息。</strong></td></tr><tr><td align="left"><strong>UNSUBSCRIBE[channel [channel …]]</strong></td><td align="left"><strong>指退订给定的频道。</strong></td></tr></tbody></table><p>SUBSCRIBE   c1 c2 </p><p>PULISH c1 message</p><p>PSUBSCRIBE  new*  </p><p>PULISH  new4  message</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote><p>主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，Master以写为主，Slave以读为主。</p></blockquote><h5 id="在-myredis下："><a href="#在-myredis下：" class="headerlink" title="在/myredis下："></a>在/myredis下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf  redis6379.conf</span><br><span class="line">cp redis.conf  redis6380.conf</span><br><span class="line">cp redis.conf  redis6381.conf</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim redis6379.conf</span><br><span class="line">pidfile  &#x2F;var&#x2F;run&#x2F;redis.pid  -&gt;  &#x2F;var&#x2F;run&#x2F;redis6379.pid</span><br><span class="line">port 6379</span><br><span class="line">logfile &quot;&quot;  -&gt;   logfile &quot;6379.log&quot;</span><br><span class="line">备份</span><br><span class="line">dbfilename  dump.rdb   -&gt;    dump6379.rdb</span><br><span class="line"></span><br><span class="line">6380,6381 以此为例</span><br></pre></td></tr></table></figure><p>分别启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server &#x2F;myredis&#x2F;redis6379.conf</span><br><span class="line">redis-cli -p 6379</span><br></pre></td></tr></table></figure><p>检查是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|gref redis</span><br></pre></td></tr></table></figure><p>使用命令 info replication查看信息,他们的角色都是master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">role:master</span><br></pre></td></tr></table></figure><p>在主机（6379）下往数据库设值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">set k3 v3</span><br></pre></td></tr></table></figure><p>在从机（6380,6381）分别使用SLAVEOF命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF 127.0.0.1  6379</span><br></pre></td></tr></table></figure><p>这时再往主机6379设值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k4 v4</span><br></pre></td></tr></table></figure><p>从机可以获取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get k4</span><br><span class="line">&quot;v4&quot;</span><br><span class="line">get k1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><p>再次使用命令 info replication查看信息</p><p>6379主机下多了两个奴隶：6380,6381</p><p>6780、6781的角色变成了奴隶。</p><ul><li><strong>如果从机尝试写入数据。会出错。因为Master以写为主，Slave以读为主</strong></li></ul><ul><li>如果主机SHUTDOWN死了，调用从机的 info replication</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_link_status: 由up变成了down</span><br></pre></td></tr></table></figure><p>从机在原地待命</p><ul><li>如果主机重新连接回来了，并设值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k7 v7</span><br></pre></td></tr></table></figure><p>从机依然可以获取k7的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get k7</span><br><span class="line">&quot;v7&quot;</span><br></pre></td></tr></table></figure><ul><li><p>如果从机退出并重新连接role角色会变成master，并且会丢失退出期间的数据,</p><p>调用SLAVEOF 127.0.0.1  6379就可以恢复连接并获取到原来丢失的值</p></li></ul><p>  <strong>每次与master断开之后，都需要重新连接，除非配置进redis.conf</strong></p><h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><blockquote><p>去中心化</p><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中的下一个的master，可以有效减轻master的写压力。</p></blockquote><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的</p><p>Slaveof 新主库IP 新主库端口</p><p>例如81是80的从机，80是79的从机，那么80是79的奴隶，80还是奴隶，81是80的奴隶。</p><h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>一主二仆里，主机挂了，从机使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF no one</span><br></pre></td></tr></table></figure><p>当前从机的角色就变成了主机，其他从机需要调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slaveof 新主库IP 新主库端口</span><br><span class="line">&#x2F;&#x2F;使当前数据库停止与其他数据库同步，转成组数据库。</span><br></pre></td></tr></table></figure><p>才能跟随新主机。</p><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul><li><p>Slave启动成功连接到master后会发送一个sync命令</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步</p></li><li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将会被自动执行。</p></li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><blockquote><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>在/myredis下面创建一个sentinel.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch sentinel.conf</span><br><span class="line">vim sentinel.conf</span><br></pre></td></tr></table></figure><p>修改为以下内容：</p><p><em>一组 sentinel.conf 可以监控多个Master</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 被监控数据库名字(自己起名字)  127.0.0.1  6379  1</span><br><span class="line"></span><br><span class="line">//数字1 表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</span><br></pre></td></tr></table></figure><p>启动redis：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure><p>主机断开之后，哨兵监控到了，就开始投票，如果两个从机一人一票，就会重新投票，</p><p>票数高的从机替换主机，其他从机都跟随这个新主机。</p><p>断开的主机回来之后变成了从机，并跟随新主机。</p><h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步带Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>测试联通</p><p>先启动</p><p>在/usr/local/bin下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server &#x2F;myredis&#x2F;redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 6379</span><br></pre></td></tr></table></figure><p>Java：</p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wizard</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/29 18:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wizard</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/29 18:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.set(<span class="string">"k1"</span>, <span class="string">"v2"</span>);</span><br><span class="line">        jedis.get(<span class="string">"k1"</span>);</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        multi.set(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line"><span class="comment">//        multi.exec();</span></span><br><span class="line">        multi.discard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wizard</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/29 20:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestTX test = <span class="keyword">new</span> TestTX();</span><br><span class="line">        <span class="keyword">boolean</span> b = test.transMethod();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">int</span> balance;<span class="comment">//可用余额</span></span><br><span class="line">        <span class="keyword">int</span> debt;<span class="comment">//欠额</span></span><br><span class="line">        <span class="keyword">int</span> amtToSubtract = <span class="number">10</span>;<span class="comment">//实刷额度</span></span><br><span class="line">        jedis.watch(<span class="string">"balance"</span>);</span><br><span class="line">        <span class="comment">//其他程序执行</span></span><br><span class="line">        <span class="comment">// Thread.sleep(3000);</span></span><br><span class="line">        <span class="comment">//jedis.set("balance", "5");</span></span><br><span class="line">        balance = Integer.parseInt(jedis.get(<span class="string">"balance"</span>));</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; amtToSubtract) &#123;</span><br><span class="line">            jedis.unwatch();</span><br><span class="line">            System.out.println(<span class="string">"modify"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主从</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wizard</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/29 20:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis_M = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        Jedis jedis_S = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6380</span>);</span><br><span class="line"></span><br><span class="line">        jedis_S.slaveof(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis_M.set(<span class="string">"class"</span>, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis_S.get(<span class="string">"class"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wizard</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/29 20:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtils<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">                    JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    jedisPoolConfig.setMaxActive();</span><br><span class="line">                    jedisPoolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxWaitMillis(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">                    jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JedisPoolConfig:</p><p><img src="/2020/06/27/Redis/1593434346091.png" alt="1593434346091"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="sql" scheme="http://dqlcr5.coding-pages.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://dqlcr5.coding-pages.com/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://dqlcr5.coding-pages.com/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-06-20T13:14:21.000Z</published>
    <updated>2020-07-01T05:21:45.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OS-Kernel的特征"><a href="#OS-Kernel的特征" class="headerlink" title="OS Kernel的特征"></a>OS Kernel的特征</h3><a id="more"></a><ul><li><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。 常考易混概念——并行：指两个或多个事件在同一时刻同时发生。</p><p>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观 上看是交替运行的。 操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</p><p><strong>注意</strong>： 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。</p><p>计算机系统中存在多个运行的程序，需要OS管理和调度</p></li><li><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p><strong>同时共享</strong></p><blockquote><p>系统中的某些资源，虽然可以提供给 多个进程使用，但一个时间段内只允 许一个进程访问该资源</p></blockquote><p><strong>互斥共享</strong></p><blockquote><p>系统中的某些资源，允许一个时间段 内由多个进程“同时”对它们进行访 问</p></blockquote><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）<br>生活实例：</p><p>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 </p><p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p><h5 id="共享和并发的关系："><a href="#共享和并发的关系：" class="headerlink" title="共享和并发的关系："></a>共享和并发的关系：</h5><p>并发性指计算机系统中同时存在着多个运行着的程序。</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>通过上述例子来看并发与共享的关系： 并发性与共享性是互为存在条件。</p></li><li><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务。虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上 对应物是用户感受到的。虚拟技术中的“时分复用 技术”。微观上处理机在 各个微小的时间段内交替 着为各个进程服务</p><p>虚拟技术分为空分复用技术（如虚拟存储器技术）和时分复用技术（如虚拟处理器）。</p><p>没有并发性，就没有虚拟性</p></li><li><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知。</p><p>但只要运行环境相同，OS需要保证程序运行的结果也要相同。</p><p>只有拥有并发性才有异步性。</p></li></ul><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><p>资源的管理者</p><ul><li><p>处理机管理</p><blockquote><p>处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度 </p></blockquote></li><li><p>存储器管理</p><blockquote><p> 内存分配，内存保护，地址映射，内存扩充 </p></blockquote></li><li><p>文件管理</p><blockquote><p>管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护 </p></blockquote></li><li><p>设备管理</p><blockquote><p> 管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用 </p></blockquote></li></ul><p>提供接口：程序接口（API）和用户接口（GUI）</p><p>联机命令接口实例 </p><blockquote><p>联机命令接口就是交互式命令接口(CMD)  用户命令一句，系统执行一句。</p></blockquote><p>脱机命令接口实例</p><blockquote><p>脱机命令接口实例，脱机命令接口也就是批处理命令接口   用户命令一堆，系统执行一堆。</p></blockquote><p>程序接口：</p><blockquote><p>可以在程序中进行系统调用(广义指令)来使用程序接口。普通用户不能直接使用程序接口，只能通过程 序代码间接使用。</p></blockquote><h3 id="BIOS关系："><a href="#BIOS关系：" class="headerlink" title="BIOS关系："></a>BIOS关系：</h3><p>DISK：存放OS</p><p>BIOS：基本I/O处理系统，最基本的功能是电源开启后检测外设，之后加载相应的软件来执行</p><p>Bootloader：加载OS，把OS从硬盘放到内存里，让CPU可以操作系统，</p><p><img src="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.png" alt="1592878521236"></p><p>从图可以看出，计算机里面有一部分空间（硬盘）已经给BIOS占用了，但是还有很多地方是空的，BIOS需要从一个特定的地址开始执行，以X86为例，固定的地址为0xf000:fff0. CS寄存器和IP寄存器一起可以形成一个内存地址，一开始加电，BIOS就从这个地址开始执行。执行一系列的工作：</p><ul><li><p>POST（加电自检）</p><p>寻找显卡和执行BIOS，检查设备是否可以正常工作。初始化的检擦。</p></li><li><p>BIOS是如何把bootloader放进去的：</p></li></ul><p><img src="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.png" alt></p><p>Bootloader一般是放在硬盘的第一个主引导扇区。第一个扇区是512个字节。把bootloader放到内存里，CPU的掌控权就在bootloader；</p><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><h5 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h5><ul><li>特权指令，如内存清零指令—-不允许用户程序使用</li><li>非特权指令，如普通的运算指令。</li></ul><h5 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h5><ul><li>用户态（目态）</li><li>核心态（管态）</li></ul><h5 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h5><ul><li>内核程序</li><li>应用程序</li></ul><h5 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h5><p>与硬件关联紧密的模块</p><ul><li>时钟管理</li><li>中断处理</li><li>原语</li></ul><p>其他：</p><ul><li>对系统资源进行管理的功能</li></ul><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><ul><li><p>大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态</p><p>优点：高性能</p><p>缺点：内核代码庞大。结构混乱，难以维护。</p></li><li><p>微内核：只把最基本的功能保留在内核、</p><p>优点：内核功能少，结构清晰，方便维护</p><p>缺点：需要频繁的在核心态和用户态之间切换，性能低</p></li></ul><p>1.特权指令只能在核心态下执行</p><p>2.内核程序只能在核心态下执行</p><p>3.核心态和用户态的切换</p><h3 id="操作系统与设备和程序交互。"><a href="#操作系统与设备和程序交互。" class="headerlink" title="操作系统与设备和程序交互。"></a>操作系统与设备和程序交互。</h3><h4 id="系统调用、异常、中断"><a href="#系统调用、异常、中断" class="headerlink" title="系统调用、异常、中断"></a>系统调用、异常、中断</h4><ul><li><p>系统调用（来源于应用程序）sys call</p></li><li><p>应用程序主动向操作系统发出服务请求。</p></li><li><p>异常（来源于不良的应用程序） exception</p></li><li><p>非法指令或者其他坏的处理状态（如：内存出错）</p></li><li><p>中断（来源与外设）interrupt</p><ul><li>来自不同硬件设备的计时器和网络中断。</li></ul></li></ul><p>为什么应用程序不直接使用外设而要经过操作系统？</p><ul><li>在计算机运行中，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>为了方便应用程序</li></ul><p>产生的源头：</p><ul><li>中断：外设</li><li>异常：应用程序意想不到的行为</li><li>系统调用：应用程序请求操作提供服务。</li></ul><p>处理时间：</p><ul><li>中断：异步，异步：当这个事件产生的时候，我们应用程序并不知道什么时候产生。</li><li>异常：同步，异常执行到某条特定的指令后一定会产生</li><li>系统调用：异步或同步，当系统调用发出请求的时候，返回的时间是异步的</li></ul><p>响应：</p><ul><li>中断：持续，对用户应用程序是透明的、</li><li>异常: 杀死或者重新执行意想不到的应用程序指令</li><li>系统调用：等待和持续</li></ul><h3 id="进程和线程以及它们的区别"><a href="#进程和线程以及它们的区别" class="headerlink" title="进程和线程以及它们的区别"></a><strong>进程和线程以及它们的区别</strong></h3><p>进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发（如：用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等，然后该进程被放入到进程的就绪队列，进程调度程序选中它，为它分配CPU及其他相关资源，该进程就被运行起来）；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；</p><p>在没有实现线程的操作系统中，进程既是资源分配的基本单位，又是调度的基本单位，它是系统中并发执行的单元。而在实现了线程的操作系统中，进程是资源分配的基本单位，但是线程是调度的基本单位，是系统中并发执行的单元。</p><p>引入线程主要有以下4个方面的优点：</p><p>1）易于调度。</p><p>2）提高并发性。通过线程可以方便有效地实现并发。</p><p>3）开销小。创建线程比创建进程要快，所需要的开销也更小。</p><p>4）有利于发挥多处理器的功能。通过创建多线程，每个线程都在一个处理器上运行，从而实现应用程序的并行，使每个处理器都得到充分的运行。</p><p>尽管线程和进程很相似，但两者也存在着很大的不同，区别如下：</p><ul><li><p>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存空间。 </p></li><li><p>属于一个进程的所有线程共享该进程的所有资源，包括打开的文件，创建的Socket等。不同的进程互相独立。</p></li><li><p>线程又被称为轻量级进程。进程有进程控制块，线程有线程控制块。但线程控制块比进程控制块小得多。线程间切换代价小，进程间切换代价大。</p></li><li><p>进程是程序的一次执行，线程可以理解为程序中一段程序片段的执行。</p></li></ul><h3 id="进程间的通信的几种方式"><a href="#进程间的通信的几种方式" class="headerlink" title="进程间的通信的几种方式"></a>进程间的通信的几种方式</h3><p><strong>管道（pipe）及命名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p><p><strong>信号（signal）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p><p><strong>消息队列</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p><strong>共享内存</strong>：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p><p><strong>信号量</strong>：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p><p><strong>套接字</strong>：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p><h4 id="线程的实现方式-用户线程与内核线程的区别"><a href="#线程的实现方式-用户线程与内核线程的区别" class="headerlink" title="线程的实现方式(用户线程与内核线程的区别)"></a>线程的实现方式(用户线程与内核线程的区别)</h4><p>根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程。</p><p>内核线程建立和销毁都是由操作系统负责、通过系统调用完成的，操作系统在调度时，参考各进程内的线程运行情况做出调度决定，如果一个进程中没有就绪态的线程，那么这个进程也不会被调度占用CPU。</p><p>和内核线程相对应的是用户线程，用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。用户线程多见于一些历史悠久的操作系统，例如Unix操作系统，不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为“线程包”，用户线程是不能被操作系统所感知的。</p><h5 id="引入用户线程，具体而言，有以下四个方面的优势："><a href="#引入用户线程，具体而言，有以下四个方面的优势：" class="headerlink" title="引入用户线程，具体而言，有以下四个方面的优势："></a>引入用户线程，具体而言，有以下四个方面的优势：</h5><p>（1）可以在不支持线程的操作系统中实现。</p><p>（2）创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</p><p>（3）允许每个进程定制自己的调度算法，线程管理比较灵活。</p><p>（4）线程能够利用的表空间和堆栈空间比内核级线程多。</p><h5 id="用户线程的缺点主要有以下两点："><a href="#用户线程的缺点主要有以下两点：" class="headerlink" title="用户线程的缺点主要有以下两点："></a>用户线程的缺点主要有以下两点：</h5><p>（1）同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。</p><p>（2）页面失效也会产生类似的问题。</p><p>内核线程的优缺点刚好跟用户线程相反。实际上，操作系统可以使用混合的方式来实现线程。</p><h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><p>就绪状态：当进程已经分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行；</p><p>运行状态：当进程已获得处理机，其程序正在处理机上执行；</p><p>阻塞状态： 正在执行的进程，由于某个事件发生而无法执行时，便放弃处理机而处于阻塞状态；引起进程阻塞状态的事件可以有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件（信号）。</p><p><img src="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.jpg" alt></p><h4 id="注意区别"><a href="#注意区别" class="headerlink" title="注意区别"></a>注意区别</h4><p><strong>就绪状态和等待状态</strong>：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</p><p><strong>就绪状态 -&gt; 运行状态</strong>：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</p><p><strong>运行状态 -&gt; 就绪状态</strong>：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p><strong>运行状态 -&gt; 阻塞状态</strong>：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p><p><strong>阻塞状态 -&gt; 就绪状态</strong>：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p><h3 id="用户态和核心态的区别。"><a href="#用户态和核心态的区别。" class="headerlink" title="用户态和核心态的区别。"></a>用户态和核心态的区别。</h3><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p><p>用户态切换到内核态的3种方式：系统调用、异常、外围设备中断。</p><h3 id="什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="什么是缓冲区溢出？有什么危害？其原因是什么？"></a>什么是缓冲区溢出？有什么危害？其原因是什么？</h3><p>缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。</p><p>造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>　　所谓死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ul><li><p>互斥条件：一个资源每次只能被一个进程使用；若其他进程申请使用该资源，必须等到该资源被释放为止；</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</p></li><li><p>不可剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺；</p></li><li><p>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系；</p></li></ul><h4 id="死锁的解除与预防"><a href="#死锁的解除与预防" class="headerlink" title="死锁的解除与预防"></a>死锁的解除与预防</h4><p>1 <strong>死锁预防</strong><br>死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：</p><ul><li><p>注意：互斥条件无法破坏</p></li><li><p>打破请求与保持条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。</p></li><li><p>打破不可剥夺条件：允许进程强剥夺使用其他进程占有的资源，从而破坏不可剥夺条件。也就是说，一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。</p></li><li><p>打破循环等待条件：实行资源有序分配策略，破坏环路条件。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。</p></li></ul><p>2<strong>死锁避免的基本思想</strong><br>死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。</p><p><strong>银行家算法</strong>：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中所有进程都能完成，所以可避免死锁的发生。</p><h3 id="内存管理有哪几种方式-块式、页式、段式、段页式"><a href="#内存管理有哪几种方式-块式、页式、段式、段页式" class="headerlink" title="内存管理有哪几种方式(块式、页式、段式、段页式)."></a>内存管理有哪几种方式(块式、页式、段式、段页式).</h3><pre><code>内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理。块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。</code></pre><h3 id="分页和分段有什么区别（内存管理）？"><a href="#分页和分段有什么区别（内存管理）？" class="headerlink" title="分页和分段有什么区别（内存管理）？"></a><strong>分页和分段有什么区别（内存管理）？</strong></h3><p>​        段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p><p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分配。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p><p>两者的不同点：</p><ul><li><p>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p></li><li><p>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</p></li><li><p>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</p></li><li><p>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p></li><li><p>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a><strong>页面置换算法</strong></h3><p><strong>最佳置换算法OPT</strong>：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</p><p><strong>先进先出置换算法FIFO</strong>：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。</p><p><strong>最近最久未使用算法LRU</strong>：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。</p><p><strong>时钟算法clock(也被称为是最近未使用算法NRU)</strong>：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p><p><strong>改进型Clock算法：</strong>在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</p><p><strong>LFU最少使用算法LFU：</strong>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</p><h3 id="操作系统中进程调度策略"><a href="#操作系统中进程调度策略" class="headerlink" title="操作系统中进程调度策略"></a>操作系统中进程调度策略</h3><ul><li><p>先来先服务调度算法FCFS：队列实现，非抢占，先请求CPU的进程先分配到CPU，可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度，对于长作业比较有利；</p></li><li><p>最短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行，平均等待时间最短，但难以知道下一个CPU区间长度；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</p></li><li><p>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；</p></li><li><p>时间片轮转调度算法(可抢占的)：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p></li><li><p>高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间；</p></li><li><p>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p></li><li><p>多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p></li></ul><h3 id="进程同步有哪几种机制"><a href="#进程同步有哪几种机制" class="headerlink" title="进程同步有哪几种机制"></a><strong>进程同步有哪几种机制</strong></h3><p>　　原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><strong>虚拟内存</strong></h3><h4 id="内存的发展历程"><a href="#内存的发展历程" class="headerlink" title="内存的发展历程"></a>内存的发展历程</h4><p>　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —&gt; 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程)<br>）—&gt; 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —&gt; 不连续内存分配（分段，分页，段页式，虚拟内存）</p><h4 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图所示。<br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><p>　 <img src="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/70.png" alt="img"> 　　　　　　　　     　　　　　</p><p>由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p><h4 id="虚拟内存的应用与优点"><a href="#虚拟内存的应用与优点" class="headerlink" title="虚拟内存的应用与优点"></a>虚拟内存的应用与优点</h4><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p><p>在内存中可以保留多个进程，系统并发度提高</p><p>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</p><h3 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h3><p>颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。</p><p>内存颠簸的解决策略包括：</p><p>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</p><p>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</p><p>否则，还剩下两个办法：终止该进程或增加物理内存容量。</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>时间上的局部性：最近被访问的页在不久的将来还会被访问；</p><p> 空间上的局部性：内存中被访问的页周围的页也很可能被访问。</p><h2 id="Linux中常用到的命令"><a href="#Linux中常用到的命令" class="headerlink" title="Linux中常用到的命令"></a>Linux中常用到的命令</h2><p>显示文件目录命令ls        如ls<br>改变当前目录命令cd        如cd /home<br>建立子目录mkdir           如mkdir xiong<br>删除子目录命令rmdir       如rmdir /mnt/cdrom<br>删除文件命令rm            如rm /ucdos.bat<br>文件复制命令cp            如cp /ucdos /fox<br>获取帮助信息命令man      如man ls<br>显示文件的内容less        如less mwm.lx</p><p>Linux文件属性有哪些？（共十位）<br>-rw-r–r–那个是权限符号，总共是- — — —这几个位。</p><p>第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录（directory）；l表示链接文件（link）；</p><p>第一个三个连续的短横是用户权限位（User）</p><p>第二个三个连续短横是组权限位（Group）</p><p>第三个三个连续短横是其他权限位（Other）。<br>每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。</p><p>如果每个权限位都有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。<br>权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：<br>一个文件aaa具有完全空的权限- — — —。<br>chmod u+rw aaa（给用户权限位设置（增加）读写权限，其权限表示为：- rw- — —）<br>chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）<br>chmod ugo+rw aaa（给用户、组、其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）<br>如果aaa具有满权限- rwx rwx rwx。<br>chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）<br>如果要给aaa赋予制定权限- rwx r-x r-x，命令为：<br>chmod u=rwx，go=rx aaa</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OS-Kernel的特征&quot;&gt;&lt;a href=&quot;#OS-Kernel的特征&quot; class=&quot;headerlink&quot; title=&quot;OS Kernel的特征&quot;&gt;&lt;/a&gt;OS Kernel的特征&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Operating Systems" scheme="http://dqlcr5.coding-pages.com/tags/Operating-Systems/"/>
    
  </entry>
  
  <entry>
    <title>编码算法</title>
    <link href="http://dqlcr5.coding-pages.com/2020/06/19/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    <id>http://dqlcr5.coding-pages.com/2020/06/19/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-19T00:53:22.000Z</published>
    <updated>2020-06-19T01:08:34.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h2><a id="more"></a><hr><p>要学习编码算法，先来看一看什么是编码。</p><p>ASCII码就是一种编码，字母<code>A</code>的编码是十六进制的<code>0x41</code>，字母<code>B</code>是<code>0x42</code>，以此类推：</p><table><thead><tr><th align="left">字母</th><th align="left">ASCII编码</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">0x41</td></tr><tr><td align="left">B</td><td align="left">0x42</td></tr><tr><td align="left">C</td><td align="left">0x43</td></tr><tr><td align="left">D</td><td align="left">0x44</td></tr><tr><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>因为ASCII编码最多只能有127个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code>0x4e2d</code>，使用UTF-8则需要3个字节编码：</p><table><thead><tr><th align="left">汉字</th><th align="left">Unicode编码</th><th align="left">UTF-8编码</th></tr></thead><tbody><tr><td align="left">中</td><td align="left">0x4e2d</td><td align="left">0xe4b8ad</td></tr><tr><td align="left">文</td><td align="left">0x6587</td><td align="left">0xe69687</td></tr><tr><td align="left">编</td><td align="left">0x7f16</td><td align="left">0xe7bc96</td></tr><tr><td align="left">码</td><td align="left">0x7801</td><td align="left">0xe7a081</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p><p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p><p><a href="https://www.baidu.com/s?wd=中文" target="_blank" rel="noopener">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p><ul><li>如果字符是<code>A</code><del><code>Z</code>，<code>a</code></del><code>z</code>，<code>0</code>~<code>9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li><li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li></ul><p>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码总是大写。</p><p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String encoded = URLEncoder.encode(<span class="string">"中文!"</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果是<code>%E4%B8%AD%E6%96%87%21</code>，<code>中</code>的URL编码是<code>%E4%B8%AD</code>，<code>文</code>的URL编码是<code>%E6%96%87</code>，<code>!</code>虽然是ASCII字符，也要对其编码为<code>%21</code>。</p><p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p><p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的<code>URLDecoder</code>就可以解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String decoded = URLDecoder.decode(<span class="string">"%E4%B8%AD%E6%96%87%21"</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为<code>%</code>前缀表示的文本，编码后的文本仅包含<code>A</code><del><code>Z</code>，<code>a</code></del><code>z</code>，<code>0</code>~<code>9</code>，<code>-</code>，<code>_</code>，<code>.</code>，<code>*</code>和<code>%</code>，便于浏览器和服务器处理。</p><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>URL编码是对字符进行编码，表示成<code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。</p><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code><del><code>Z</code>、<code>a</code></del><code>z</code>、<code>0</code>~<code>9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p><p>举个例子：3个byte数据分别是<code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到<code>39</code>、<code>0b</code>、<code>22</code>和<code>2d</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │      b8       │      ad       │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0b     │    22     │    2d     │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure><p>因为6位整数的范围总是<code>0</code><del><code>63</code>，所以，能用64个字符表示：字符<code>A</code></del><code>Z</code>对应索引<code>0</code><del><code>25</code>，字符<code>a</code></del><code>z</code>对应索引<code>26</code><del><code>51</code>，字符<code>0</code></del><code>9</code>对应索引<code>52</code>~<code>61</code>，最后两个索引<code>62</code>、<code>63</code>分别用字符<code>+</code>和<code>/</code>表示。</p><p>在Java中，二进制数据就是<code>byte[]</code>数组。Java标准库提供了<code>Base64</code>来对<code>byte[]</code>数组进行编解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编码后得到<code>5Lit</code>4个字符。要对<code>Base64</code>解码，仍然用<code>Base64</code>这个类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(<span class="string">"5Lit"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的童鞋会问：如果输入的<code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code>0x00</code>，编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p><p>实际上，因为编码后的长度加上<code>=</code>总是4的倍数，所以即使不加<code>=</code>也可以计算出原始输入的<code>byte[]</code>。Base64编码的时候可以用<code>withoutPadding()</code>去掉<code>=</code>，解码出来的结果是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span>, <span class="number">0x21</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        System.out.println(b64encoded2);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(b64encoded2);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为标准的Base64编码会出现<code>+</code>、<code>/</code>和<code>=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code>+</code>变成<code>-</code>，<code>/</code>变成<code>_</code>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getUrlEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getUrlDecoder().decode(b64encoded);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p><p>和URL编码一样，Base64编码是一种编码算法，不是加密算法。</p><p>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>URL编码和Base64编码都是编码算法，它们不是加密算法；</p><p>URL编码的目的是把任意文本数据编码为%前缀表示的文本，便于浏览器和服务器处理；</p><p>Base64编码的目的是把任意二进制数据编码为文本，但编码后数据量会增加1/3。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编码算法&quot;&gt;&lt;a href=&quot;#编码算法&quot; class=&quot;headerlink&quot; title=&quot;编码算法&quot;&gt;&lt;/a&gt;编码算法&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="dataAlgorithm" scheme="http://dqlcr5.coding-pages.com/tags/dataAlgorithm/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法</title>
    <link href="http://dqlcr5.coding-pages.com/2020/06/17/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://dqlcr5.coding-pages.com/2020/06/17/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-17T10:03:58.000Z</published>
    <updated>2020-06-17T11:03:45.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><blockquote><p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 </p><a id="more"></a></blockquote><p>哈希算法最重要的特点就是：</p><ul><li>相同的输入一定得到相同的输出；</li><li>不同的输入大概率得到不同的输出。</li></ul><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><p>Java字符串的<code>hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节<code>int</code>整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;.hashCode(); &#x2F;&#x2F; 0x5e918d2</span><br><span class="line">&quot;hello, java&quot;.hashCode(); &#x2F;&#x2F; 0x7a9d88e8</span><br><span class="line">&quot;hello, bob&quot;.hashCode(); &#x2F;&#x2F; 0xa0dbae2f</span><br></pre></td></tr></table></figure><p>两个相同的字符串永远会计算出相同的<code>hashCode</code>，否则基于<code>hashCode</code>定位的<code>HashMap</code>就无法正常工作。这也是为什么当我们自定义一个class时，覆写<code>equals()</code>方法时我们必须正确覆写<code>hashCode()</code>方法。</p><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;AaAaAa&quot;.hashCode(); &#x2F;&#x2F; 0x7460e8c0</span><br><span class="line">&quot;BBAaBB&quot;.hashCode(); &#x2F;&#x2F; 0x7460e8c0</span><br></pre></td></tr></table></figure><p>有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，<code>String</code>的<code>hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p><ul><li>碰撞概率低；</li><li>不能猜测输出。</li></ul><p>不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashA(&quot;java001&quot;) &#x3D; &quot;123456&quot;</span><br><span class="line">hashA(&quot;java002&quot;) &#x3D; &quot;123457&quot;</span><br><span class="line">hashA(&quot;java003&quot;) &#x3D; &quot;123458&quot;</span><br></pre></td></tr></table></figure><p>那么很容易从输出<code>123459</code>反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashB(&quot;java001&quot;) &#x3D; &quot;123456&quot;</span><br><span class="line">hashB(&quot;java002&quot;) &#x3D; &quot;580271&quot;</span><br><span class="line">hashB(&quot;java003&quot;) &#x3D; ???</span><br></pre></td></tr></table></figure><p>常用的哈希算法有：</p><table><thead><tr><th align="left">算法</th><th align="left">输出长度（位）</th><th align="left">输出长度（字节）</th></tr></thead><tbody><tr><td align="left">MD5</td><td align="left">128 bits</td><td align="left">16 bytes</td></tr><tr><td align="left">SHA-1</td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left">RipeMD-160</td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left">SHA-256</td><td align="left">256 bits</td><td align="left">32 bytes</td></tr><tr><td align="left">SHA-512</td><td align="left">512 bits</td><td align="left">64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p><p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        md.update(<span class="string">"World"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>MessageDigest</code>时，我们首先根据哈希算法获取一个<code>MessageDigest</code>实例，然后，反复调用<code>update(byte[])</code>输入数据。当输入结束后，调用<code>digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p><p>运行上述代码，可以得到输入<code>HelloWorld</code>的MD5是<code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p><h3 id="哈希算法的用途"><a href="#哈希算法的用途" class="headerlink" title="哈希算法的用途"></a>哈希算法的用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>我们在网站上下载软件的时候，经常看到下载页显示的哈希：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1305351978745921/l" alt="file-md5"></p><p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p><ul><li>数据库管理员能够看到用户明文口令；</li><li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li></ul><p>不存储用户的原始口令，那么如何对用户进行认证？</p><p>方法是存储用户口令的哈希，例如，MD5。</p><p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p><p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p><table><thead><tr><th align="left">username</th><th align="left">password</th></tr></thead><tbody><tr><td align="left">bob</td><td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td align="left">alice</td><td align="left">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td align="left">tim</td><td align="left">bed128365216c019988915ed3add75fb</td></tr></tbody></table><p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p><p>使用哈希口令时，还要注意防止彩虹表攻击。</p><p>什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。</p><p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p><table><thead><tr><th align="left">常用口令</th><th align="left">MD5</th></tr></thead><tbody><tr><td align="left">hello123</td><td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td align="left">12345678</td><td align="left">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td align="left">passw0rd</td><td align="left">bed128365216c019988915ed3add75fb</td></tr><tr><td align="left">19700101</td><td align="left">570da6d5277a646f6552b8832012f5dc</td></tr><tr><td align="left">…</td><td align="left">…</td></tr><tr><td align="left">20201231</td><td align="left">6879c0ae9117b50074ce0a0d4c843060</td></tr></tbody></table><p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p><p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p><p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p><p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p><p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p><p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digest &#x3D; md5(salt+inputPassword)</span><br></pre></td></tr></table></figure><p>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th align="left">username</th><th align="left">salt</th><th align="left">password</th></tr></thead><tbody><tr><td align="left">bob</td><td align="left">H1r0a</td><td align="left">a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td align="left">alice</td><td align="left">7$p2w</td><td align="left">e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td align="left">tim</td><td align="left">z5Sk9</td><td align="left">1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p><h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p><p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code>&quot;SHA-1&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        md.update(<span class="string">"World"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 类似的，计算SHA-256，我们需要传入名称<code>&quot;SHA-256&quot;</code>，计算SHA-512，我们需要传入名称<code>&quot;SHA-512&quot;</code>。Java标准库支持的所有哈希算法可以在<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms" target="_blank" rel="noopener">这里</a>查到。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 &lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="dataAlgorithm" scheme="http://dqlcr5.coding-pages.com/tags/dataAlgorithm/"/>
    
  </entry>
  
</feed>
