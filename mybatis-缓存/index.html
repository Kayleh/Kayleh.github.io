<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Kayleh"><title>mybatis-cache · Kayleh</title><meta name="description" content="mybatis-缓存什么是缓存？缓存就是存储数据的一个地方（称作：Cache），当程序要读取数据时，会首先从缓存中获取，有则直接返回，否则从其他存储设备中获取，缓存最重要的一点就是从其内部获取数据的速度是非常快的，通过缓存可以加快数据的访问速度。比如我们从db中获取数据，中间需要经过网络传输耗时，d"><meta name="keywords" content=""><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Kayleh</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/google8102e2f35ce9e391.html"></a></li><li><a href="/mainfest.json"></a></li><li><a href="/categories/categories.html"></a></li><li><a href="/about/index.html">about</a></li><li><a href="/link/index.html">友人帐</a></li><li class="soc"><a href="https://github.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://twitter.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter">&nbsp;</i></a><a href="https://www.instagram.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-instagram">&nbsp;</i></a><a href="https://kayleh.top/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>mybatis-cache</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-05-29</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/mybatis-%E7%BC%93%E5%AD%98/#comments">Comments</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/frame/" title="frame" class="a-tag">frame</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h1 id="mybatis-缓存"><a href="#mybatis-缓存" class="headerlink" title="mybatis-缓存"></a>mybatis-缓存</h1><h4 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h4><p>缓存就是存储数据的一个地方（称作：Cache），当程序要读取数据时，会首先从缓存中获取，有则直接返回，否则从其他存储设备中获取，缓存最重要的一点就是从其内部获取数据的速度是非常快的，通过缓存可以加快数据的访问速度。比如我们从db中获取数据，中间需要经过网络传输耗时，db server从磁盘读取数据耗时等，如果这些数据直接放在jvm对应的内存中，访问是不是会快很多。</p><h4 id="mybatis中的缓存"><a href="#mybatis中的缓存" class="headerlink" title="mybatis中的缓存"></a>mybatis中的缓存</h4><p>mybatis中分为一级缓存和二级缓存。</p><p>一级缓存是SqlSession级别的缓存，在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据，不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</p><p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>一级缓存是SqlSession级别的缓存，每个SqlSession都有自己单独的一级缓存，多个SqlSession之间的一级缓存是相互隔离的，互不影响，mybatis中一级缓存是默认自动开启的。</p><p>一级缓存工作原理：在同一个SqlSession中去多次去执行同样的查询，每次执行的时候会先到一级缓存中查找，如果缓存中有就直接返回，如果一级缓存中没有相关数据，mybatis就会去db中进行查找，然后将查找到的数据放入一级缓存中，第二次执行同样的查询的时候，会发现缓存中已经存在了，会直接返回。一级缓存的存储介质是内存，是用一个HashMap来存储数据的，所以访问速度是非常快的。</p><h4 id="一级缓存案例"><a href="#一级缓存案例" class="headerlink" title="一级缓存案例"></a>一级缓存案例</h4><p>案例sql脚本</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">use 'test';
create table user(
    id int auto_increment primary key comment '用户id',
    name varchar(50) not null default '' comment '用户名',
    password varchar(50) not null default '' comment '用户密码'
) comment '用户表';
inseret into test values (1,'xiaoe',admin),(2,'xiaoa',admin)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是查询用户信息，返回一个list</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><select id="getList" resulttype="com.kayleh.bean.User">
        select id,name,password from test
        <where>
            <if test="id!=null">
                and id = #{id}
            </if>
            <if test="name!=null and name.toString()!=''">
                and name = #{name}
            </if>
            <if test="password!=null">
                and password = #{password}
            </if>
        </where>
</select>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的mapper接口方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java"> List<user> getList(Map<string , object> paramMap);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></string></user></code></pre><p>测试用例</p><p>上面的代码在同一个SqlSession中去执行了2次获取用户列表信息，2次查询结果分别放在userModelList1和userModelList2，最终代码中也会判断这两个集合是否相等，下面我们运行一下看看会访问几次db。</p><p>从输出中可以看出看到，sql只输出了一次，说明第一次会访问数据库，第二次直接从缓存中获取的，最后输出了一个true，也说明两次返回结果是同一个对象，第二次直接从缓存中获取数据的，加快了查询的速度。</p><h4 id="清空一级缓存的3种方式"><a href="#清空一级缓存的3种方式" class="headerlink" title="清空一级缓存的3种方式"></a>清空一级缓存的3种方式</h4><p>同一个SqlSession中查询同样的数据，mybatis默认会从一级缓存中获取，如果缓存中没有，才会访问db，那么如果我们希望不走缓存而是直接去访问数据库，又该如何操作呢？</p><p>让一级缓存失效有3种方式：</p><ul><li><p>SqlSession中执行增、删、改操作，此时sqlsession会自动清理其内部的一级缓存</p></li><li><p>调用SqlSession中的clearCache方法清理其内部的一级缓存</p></li><li><p>设置Mapper xml中select元素的flushCache属性值为true，那么执行查询的时候会先清空一级缓存中的所有数据，然后去db中获取数据</p></li></ul><p>上面方式任何一种都会让当前SqlSession中的以及缓存失效，进而去db中获取数据。</p><h4 id="一级缓存使用总结"><a href="#一级缓存使用总结" class="headerlink" title="一级缓存使用总结"></a>一级缓存使用总结</h4><p>一级缓存是SqlSession级别的，每个人SqlSession有自己的一级缓存，不同的SqlSession之间一级缓存是相互隔离的</p><p>mybatis中一级缓存默认是自动开启的</p><p>当在同一个SqlSession中执行同样的查询的时候，会先从一级缓存中查找，如果找到了直接返回，如果没有找到会去访问db，然后将db返回的数据丢到一级缓存中，下次查询的时候直接从缓存中获取</p><p>一级缓存清空的3种方式（1：SqlSession中执行增删改会使一级缓存失效；2：调用SqlSession.clearCache方法会使一级缓存失效；3：Mapper xml中的select元素的flushCache属性置为true，那么执行这个查询会使一级缓存失效）</p><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><h4 id="二级缓存的使用"><a href="#二级缓存的使用" class="headerlink" title="二级缓存的使用"></a>二级缓存的使用</h4><p>一级缓存使用上存在局限性，必须要在同一个SqlSession中执行同样的查询，一级缓存才能提升查询速度，如果想在不同的SqlSession之间使用缓存来加快查询速度，此时我们需要用到二级缓存了。</p><p>二级缓存是mapper级别的缓存，每个mapper xml有个namespace，二级缓存和namespace绑定的，每个namespace关联一个二级缓存，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p><p>二级缓存<strong>默认是没有开启</strong>的，需要我们在mybatis全局配置文件中进行开启：</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><settings>
    
    <setting name="cacheEnabled" value="true">
</settings>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面配置好了以后，还需要在对应的mapper xml加上下面配置，表示这个mapper中的查询开启二级缓存：</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><mapper namespace="com.kayleh.mapper.UserMapper">

<cache></cache>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></mapper></code></pre><p>配置就这么简单。</p><h4 id="一二级缓存共存时查询原理"><a href="#一二级缓存共存时查询原理" class="headerlink" title="一二级缓存共存时查询原理"></a>一二级缓存共存时查询原理</h4><p>一二级缓存如果都开启的情况下，数据查询过程如下：</p><p>当发起一个查询的时候，mybatis会先访问这个namespace对应的二级缓存，如果二级缓存中有数据则直接返回，否则继续向下</p><p>查询一级缓存中是否有对应的数据，如果有则直接返回，否则继续向下</p><p>访问db获取需要的数据，然后放在当前SqlSession对应的二级缓存中，并且在本地内存中的另外一个地方存储一份（这个地方我们就叫TransactionalCache）</p><p>当SqlSession关闭的时候，也就是调用SqlSession的close方法的时候，此时会将TransactionalCache中的数据放到二级缓存中，并且会清空当前SqlSession一级缓存中的数据。</p><h4 id="二级缓存案例"><a href="#二级缓存案例" class="headerlink" title="二级缓存案例"></a>二级缓存案例</h4><p>mybatis全局配置文件开启二级缓存配置</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><settings>
    
    <setting name="cacheEnabled" value="true">
</settings>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>mapper xml中使用cache元素开启二级缓存</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><cache>

<select id="getList" resulttype="com.kayleh.bean.User">
        select id,name,password from test
        <where>
            <if test="id!=null">
                and id = #{id}
            </if>
            <if test="name!=null and name.toString()!=''">
                and name = #{name}
            </if>
            <if test="password!=null">
                and password = #{password}
            </if>
        </where>
</select>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>for执行了2次查询，每次查询都是<strong>新的SqlSession</strong>。</p><p>清空或者跳过二级缓存的3种方式</p><p>当二级缓存开启的时候，在某个mapper xml中添加cache元素之后，这个mapper xml中所有的查询都默认开启了二级缓存，那么我们如何清空或者跳过二级缓存呢？3种方式如下：</p><p>对应的mapper中执行增删改查会清空二级缓存中数据</p><p>select元素的flushCache属性置为true，会先清空二级缓存中的数据，然后再去db中查询数据，然后将数据再放到二级缓存中</p><p>select元素的useCache属性置为true，可以使这个查询跳过二级缓存，然后去查询数据</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一二级缓存访问顺序：一二级缓存都存在的情况下，会先访问二级缓存，然后再访问一级缓存，最后才会访问db，这个顺序大家理解一下</p><p>将mapper xml中select元素的flushCache属性置为false，最终会清除一级缓存所有数据，同时会清除这个select所在的namespace对应的二级缓存中所有的数据</p><p>将mapper xml中select元素的useCache置为false，会使这个查询跳过二级缓存</p><p>总体上来说使用缓存可以提升查询效率，这块知识掌握了，大家可以根据业务自行选择</p><p></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=https://kayleh.top/mybatis-缓存/%20Kayleh%20mybatis-cache" target="_blank" rel="noopener" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/head-first-netty/" title="Head First Netty">Next post: Head First Netty&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname="kayleh",disqus_identifier="mybatis-缓存/",disqus_title="mybatis-cache",disqus_url="https://kayleh.top/mybatis-缓存/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//kayleh.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/dao.js"></script><script src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/busuanzi/busuanzi.pure.mini.js"></script><script data-ad-client="ca-pub-7457165067653912" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script src="/live2d-widget/autoload.js"></script></body></html>