<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Kayleh"><title>Kayleh</title><meta name="description" content="Dreamaker"><meta name="keywords" content=""><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Kayleh</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/" class="current">대문</a></li><li><a href="/archives">아카이브</a></li><li><a href="/categories">카테고리</a></li><li><a href="/tags">태그</a></li><li><a href="/google8102e2f35ce9e391.html"></a></li><li><a href="/mainfest.json"></a></li><li><a href="/link/index.html">友人帐</a></li><li><a href="/about/index.html">about</a></li><li class="soc"><a href="https://github.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://twitter.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter">&nbsp;</i></a><a href="https://www.instagram.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-instagram">&nbsp;</i></a><a href="https://kayleh.top/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-container"><p class="post-title"><a href="/AIO%E6%A8%A1%E5%9E%8B/">AIO blocking model</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-12-05</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/AIO%E6%A8%A1%E5%9E%8B/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/network/" title="network" class="a-tag">network</a><span>&nbsp;</span></span></p><p class="post-abstract">AIO模型1. 在系统层面分析IO模型当我们从网络中或者其他进程中接收到数据时，这个数据会先被拷贝到系统内核的缓冲区，然后从内核的缓冲区中再复制到我们应用程序对应的缓冲区中，这样我们才能实现从应用程序中取得这个数据。 1.1 BIO模型 我们的应用程序会首先调用特定的函数，这样才能去访问我们的操作系统。拿我们的...</p></div><div class="post-container"><p class="post-title"><a href="/NIO%E6%A8%A1%E5%9E%8B/">NIO blocking model</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-12-05</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/NIO%E6%A8%A1%E5%9E%8B/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/network/" title="network" class="a-tag">network</a><span>&nbsp;</span></span></p><p class="post-abstract">NIO模型1. 概述1.1 翻译翻译？什么叫NIO？NIO：我认为翻译成Non-Blocking，更加的通俗直白，相比于BIO，也有一个对比，叫他非阻塞IO最好不过了 它和BIO有以下的区别 Channel是双向的，即可以读又可以写，相比于Stream，它并不区分出输入流和输出流，而且Channel可以完成非阻...</p></div><div class="post-container"><p class="post-title"><a href="/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B/">BIO blocking model</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-12-03</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/network/" title="network" class="a-tag">network</a><span>&nbsp;</span></span></p><p class="post-abstract">BIO阻塞模型1. BIO阻塞模型简述BIO模型中服务端与客户端的响应过程 服务器serverSocket先要和端口进行绑定 绑定完成后，执行accept方法，等待客户端的连接，这个方法是阻塞式调用，也就是说，要一直等待客户端的连接响应，不做其他事情，一直等，（被阻塞的还有InputStream.read()、...</p></div><div class="post-container"><p class="post-title"><a href="/I-O%E6%A8%A1%E5%9E%8B/">I/O model</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-12-03</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/I-O%E6%A8%A1%E5%9E%8B/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/network/" title="network" class="a-tag">network</a><span>&nbsp;</span></span></p><p class="post-abstract">I/O模型1. java.io下的字符流和字节流 1.1 字符流字符流更加的方便我们使用，一般字符都是由多个字节来形成的，若我们使用字节流传输，则还需要我们自己将其转换为字符，若我们直接使用字符流的话，这样就能直接读取与输出字符。 CharArrayReader：是基础的字符输入流，能从字符数组中读取数据 St...</p></div><div class="post-container"><p class="post-title"><a href="/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Java network programming</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-12-03</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/network/" title="network" class="a-tag">network</a><span>&nbsp;</span></span></p><p class="post-abstract">@来源CSDN：方圆1. URL地址的构造和解析我们看如上地址，一般情况下.root根域名的部分会被省略。而URL的解析过程就是从右向左进行解析，将地址转换为IP地址，进行访问。 1.1 域名的层级 1.2 域名DNS查询的两种方式1.2.1 递归查询 如图上所示，浏览器将请求发送给DNS客户端，客户端请求根域...</p></div><div class="post-container"><p class="post-title"><a href="/ubuntu%E5%9B%BA%E5%AE%9AIP%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/">ubuntu fixed IP setting method</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-11-13</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/ubuntu%E5%9B%BA%E5%AE%9AIP%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/linux/" title="linux" class="a-tag">linux</a><span>&nbsp;</span></span></p><p class="post-abstract">ubuntu固定IP设置方法确认你要修改的网卡号先确认你要修改的网卡号，假设你的服务器有多张网卡： 我的服务器配置如下： 3. 默认的网卡配置文件默认情况下，网络使用DHCP 4. 设置静态IP需要把配置文件修改为以下内容： 假设IP地址修改为192.168.1.100，子网掩码24位即255.255....</p></div><div class="post-container"><p class="post-title"><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(10)/">Java高性能高并发秒杀系统(10)</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-11-11</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(10)/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/project/" title="project" class="a-tag">project</a><span>&nbsp;</span></span></p><p class="post-abstract">1. 库存预加载到Redis中是怎么实现的？我是通过实现InitializingBean接口，重写其中afterPropertiesSet()方法，实现的预加载 1.1 之后主动添加秒杀商品的话，怎么添加？通过后台管理进行添加，修改redis缓存和数据库中的值 2. 在Redis中扣减库存的时候，是怎么保证线程...</p></div><div class="post-container"><p class="post-title"><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(8)/">Java高性能高并发秒杀系统(9)</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-11-09</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(8)/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/project/" title="project" class="a-tag">project</a><span>&nbsp;</span></span></p><p class="post-abstract">1. 动态秒杀地址1.1 前端的改变之前我们实现秒杀的时候是直接跳转到秒杀接口，使得我们每次的秒杀地址都是一样的，这样具有安全隐患，所以，我们将其改为动态地址，通过在前端上写一个方法进行跳转，如下所示。 它会先跳转到/miaosha/path，获取秒杀地址中的path值，将其存储在Redis中 然后携带path...</p></div><div class="post-container"><p class="post-title"><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(7)/">Java高性能高并发秒杀系统(8)</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-11-09</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(7)/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/project/" title="project" class="a-tag">project</a><span>&nbsp;</span></span></p><p class="post-abstract">1. 秒杀接口优化思路 重点我们是要减少对数据库的访问 系统初始化时，将秒杀商品库存加载到Redis中 收到请求，在Redis中预减库存，库存不足时，直接返回秒杀失败 秒杀成功，将订单压入消息队列，返回前端消息“排队中”（像12306的买票） 消息出队，生成订单，减少库存 客户端在以上过程执行过程中，将一直轮...</p></div><div class="post-container"><p class="post-title"><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(6)/">Java高性能高并发秒杀系统(7)</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-11-08</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/Java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC%20(6)/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/project/" title="project" class="a-tag">project</a><span>&nbsp;</span></span></p><p class="post-abstract">1. 集成RabbitMQ1.1 添加依赖 1.2 添加配置信息 2. 进行简单测试（Direct Exchange） 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue 2.1 创建一个配置类 2.1.1 @Bean注解 @Bean注解就是要告诉方法，产生一个Be...</p></div><div class="pagination no-margin-bottom"><p class="clearfix"></p><p>총 5 페이지 / 19 &nbsp;</p><p><span class="pre pagbuttons"><i class="fa fa-angle-double-left"></i>&nbsp;<a role="navigation" href="/page/4/">이전</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/page/6/">다음</a>&nbsp;<i class="fa fa-angle-double-right"></i></span></p><p></p></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/dao.js"></script><script src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/busuanzi/busuanzi.pure.mini.js"></script><script data-ad-client="ca-pub-7457165067653912" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></body></html>