[{"title":"C prime plus","url":"/2020/06/28/C-prime-plus/","content":"\n## 指针\n\n###### 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。\n\n<!--more-->\n\n取地址&\n\n取值*\n\n```C\n#include <stdio.h>\nint main()\n{\n    int a;\n    char b[10];\n    printf(\"a变量的内存地址：%p\\n\", &a);\n    printf(\"b变量的内存地址：%p\\n\", &b);\n    return 0;\n}\n```\n\n访问数组b的地址其实就是数组第一个变量的数组\n\n **指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： \n\n```c\ntype *var-name;\n```\n\n 在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： \n\n```c\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;     /* 一个字符型的指针 */\n```\n\n 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。 \n\n#### 指针的使用\n\n 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： \n\n```c\n#include <stdio.h>\n \nint main ()\n{\n   int  var = 20;   /* 实际变量的声明 */\n   int  *ip;        /* 指针变量的声明 */\n \n   ip = &var;  /* 在指针变量中存储 var 的地址 */\n \n   printf(\"Address of var variable: %p\\n\", &var  );\n \n   /* 在指针变量中存储的地址 */\n   printf(\"Address stored in ip variable: %p\\n\", ip );\n \n   /* 使用指针访问值 */\n   printf(\"Value of *ip variable: %d\\n\", *ip ); //20\n \n   return 0;\n}\n```\n\n#### C 中的 NULL 指针\n\n在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。\n\nNULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：\n\n```c\n#include <stdio.h>\n \nint main ()\n{\n   int  *ptr = NULL;\n \n   printf(\"ptr 的地址是 %p\\n\", ptr  );\n \n   return 0;\n}\n```\n\n在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。\n\n如需检查一个空指针，您可以使用 if 语句，如下所示：\n\n```c\nif(ptr)     /* 如果 p 非空，则完成 */\nif(!ptr)    /* 如果 p 为空，则完成 */\n```\n\n#### 指针的算数运算\n\nC 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。\n\n假设 **ptr** 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：\n\n```c\nptr++\n```\n\n在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。\n\n我们概括一下：\n\n- 指针的每一次递增，它其实会指向下一个元素的存储单元。\n- 指针的每一次递减，它都会指向前一个元素的存储单元。\n- **指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度**，比如 int 就是 4 个字节。\n\n##### 递增一个指针\n\n我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：\n\n```c\n#include <stdio.h>\n \nconst int MAX = 3;\n \nint main ()\n{\n   int  var[] = {10, 100, 200};\n   int  i, *ptr;\n \n   /* 指针中的数组地址 */\n   ptr = var;\n   for ( i = 0; i < MAX; i++)\n   {\n \n      printf(\"存储地址：var[%d] = %x\\n\", i, ptr );\n      printf(\"存储值：var[%d] = %d\\n\", i, *ptr );\n \n      /* 移动到下一个位置 */\n      ptr++;\n   }\n   return 0;\n}\n----\n存储地址：var[0] = bf882b30\n存储值：var[0] = 10\n存储地址：of var[1] = bf882b34\n存储值： var[1] = 100\n存储地址：of var[2] = bf882b38\n存储值：var[2] = 200\n```\n\n##### 指针的比较\n\n指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。\n\n下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]，则把变量指针进行递增：\n\n```c\n#include <stdio.h>\n \nconst int MAX = 3;\n \nint main ()\n{\n   int  var[] = {10, 100, 200};\n   int  i, *ptr;\n \n   /* 指针中第一个元素的地址 */\n   ptr = var;\n   i = 0;\n   while ( ptr <= &var[MAX - 1] )\n   {\n \n      printf(\"Address of var[%d] = %p\\n\", i, ptr );\n      printf(\"Value of var[%d] = %d\\n\", i, *ptr );\n \n      /* 指向上一个位置 */\n      ptr++;\n      i++;\n   }\n   return 0;\n}\n----------------\nAddress of var[0] = bfdbcb20\nValue of var[0] = 10\nAddress of var[1] = bfdbcb24\nValue of var[1] = 100\nAddress of var[2] = bfdbcb28\nValue of var[2] = 200\n```\n\n#### 指针数组\n\n一个指向整数的指针数组的声明：\n\n```c\nint *ptr[MAX];\n```\n\n 在这里，把 **ptr** 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示： \n\n```c\n#include <stdio.h>\n \nconst int MAX = 3;\n \nint main ()\n{\n   int  var[] = {10, 100, 200};\n   int i, *ptr[MAX];\n \n   for ( i = 0; i < MAX; i++)\n   {\n      ptr[i] = &var[i]; /* 赋值为整数的地址 */\n   }\n   for ( i = 0; i < MAX; i++)\n   {\n      printf(\"Value of var[%d] = %d\\n\", i, *ptr[i] );\n   }\n   return 0;\n}\n------\nValue of var[0] = 10\nValue of var[1] = 100\nValue of var[2] = 200\n```\n\n 您也可以用一个指向字符的指针数组来存储一个字符串列表，如下： \n\n```c\n#include <stdio.h>\n \nconst int MAX = 4;\n \nint main ()\n{\n   const char *names[] = {\n                   \"Zara Ali\",\n                   \"Hina Ali\",\n                   \"Nuha Ali\",\n                   \"Sara Ali\",\n   };\n   int i = 0;\n \n   for ( i = 0; i < MAX; i++)\n   {\n      printf(\"Value of names[%d] = %s\\n\", i, names[i] );\n   }\n   return 0;\n}\n------\nValue of names[0] = Zara Ali\nValue of names[1] = Hina Ali\nValue of names[2] = Nuha Ali\nValue of names[3] = Sara Ali\n```\n\n#### 指向指针的指针\n\n 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 \n\n```\n              Pointer               Pointer \t\t\t\tVariable\n           _____________          _____________           _____________\n          |  Address    | ------>|  Address    |-------->|    Value    |\n          |_____________|        |_____________|         |_____________|\n```\n\n一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：\n\n```c\nint **var;\n```\n\n 当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示： \n\n```c\n#include <stdio.h>\n \nint main ()\n{\n   int  var;\n   int  *ptr;\n   int  **pptr;\n\n   var = 3000;\n\n   /* 获取 var 的地址 */\n   ptr = &var;\n\n   /* 使用运算符 & 获取 ptr 的地址 */\n   pptr = &ptr;\n\n   /* 使用 pptr 获取值 */\n   printf(\"Value of var = %d\\n\", var );\n   printf(\"Value available at *ptr = %d\\n\", *ptr );\n   printf(\"Value available at **pptr = %d\\n\", **pptr);\n\n   return 0;\n}\n-------------------\nValue of var = 3000\nValue available at *ptr = 3000\nValue available at **pptr = 3000\n```\n\n#### 指针数组和数组指针\n\n```c\nint *p1[5] ----------指针数组\nint (*p2)[5]---------数组指针\n```\n\n**指针数组**是一个数组，每个数组元素存放一个指针变量。\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    //指针数组，里面存的是指针\n    char *p1[5] = {\"wo\",\n                   \"jiao\",\n                   \"Kayleh\",\n                   \"!\"};\n    int i;\n    for (i = 0; i < 5; i++)\n    {\n        /* code */\n        // %s会取地址对应的值，char形是特列,通过字符串首地址输出字符串\n        printf(\"%s\\n\", p1[i]);\n    }\n}\n```\n\n**数组指针**是一个指针，它指向的是一个数组\n\n```c\n#include <stdio.h>\nint main()\n{\n    int temp[5] = {1, 2, 3, 4, 5};\n    //&temp表示取出整个数组的地址\n    //temp表示数组的第一个元素的地址\n    int(*p2)[5] = &temp;\n    int i;\n    for (i = 0; i < 5; i++)\n    {\n        /* code */\n        //内部的*取得是数组的，外部的取得是数组元素的\n        printf(\"%d\\n\", *(*p2 + i));\n    }\n    return 0;\n}\n```\n\n#### 二维数组\n\n数组名实际上是第一组一维数组的指针。\n\n```c\narray[4][5]\n*(array+1) = array[1] = &array[1][0]\n\n*(array+1)+3 == &array[1][3]\n```\n\n结论\n\n```c\n*(array+i) == array[i]\n*(*(array+i)+j) == &array[i][j]\n*(*(*(array+i)+j)+k) == &array[i][j][k]\n```\n\n初始化二维数组\n\n```\nint array[][3];//前面的可不写\n```\n\n**数组指针和二维数组**\n\n#### void指针\n\n> void指针称为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int num = 1024;\n    int *pi = &num;\n    char *pc = \"Kayleh\";\n    void *pv;\n\n    pv = pi;\n    printf(\"pi:%p,pv:%p\\n\", pi, pv);\n    printf(\"pv:%d\\n\", *(int *)pv); //强制转换\n\n    pv = pc;\n    printf(\"pc:%p,pv:%p\\n\", pc, pv);\n    //因为字符数组中每一个元素都相当于一个指针变量，就不需要在加*了，不用解引用\n    printf(\"pv:%s\\n\", pv);\n\n    return 0;\n}\n```\n\n\n\n#### NULL指针\n\n```c\n#define NULL ((void *)0)\n```\n\n```c\n#include <stdio.h>\nint main()\n{\n    int *p1;\n    int *p2 = NULL;\n\n    printf(\"%d\\n\", *p1);\n    printf(\"%d\\n\", *p2);\n    return 0;\n}\n```\n\n\n\n","tags":["C"]},{"title":"Redis","url":"/2020/06/27/Redis/","content":"\n# Redis\n\n<!--more-->\n\n### 在Linux下安装\n\n https://redis.io/ 官网下载，移动到`/opt` 目录下. 在终端使用命令解压\n\n```shell\n$ tar -zxvf redis-XXXXXX.tar.gz\n```\n\n进入解压后的目录,运行make指令(需要GCC编译器)\n\n```\n$ cd redis.XXX\n$ make\n$ make install\n```\n\n进入默认安装的目录\n\n```\n$ cd usr/local/bin\n```\n\n在根目录创建一个文件夹/myredis，把安装目录下的redis.conf复制到/myredis，复制的目的是不影响出厂的设置\n\n```\ncp redis.conf /myredis\n```\n\n要把myredis的权限修改,否则会出现redis无法SHUTDOWN的问题\n\n```\nsudo chmod 777 /myredis\n```\n\n修改复制过来的conf\n\n```\nvim redis.conf\n```\n\n修改为为yes\n\n```\n原来的：\n##########GENERAL###################\nXXX\ndaemonzie no\n\n修改为:\ndaemonize yes\n```\n\n检查有没有启动Redis\n\n```\n$ ps -ef|gref redis\n```\n\n检查端口是否启动\n\n```\nlsof -i :6379\n```\n\n结果是没有启动的\n\n##### 启动方法：\n\n在/usr/local/bin下：\n\n```\n$ redis-server /myredis/redis.conf\n```\n\n默认端口是6379\n\n```\n$ redis-cli -p 6379\n```\n\n检查是否连接成功\n\n```\n127.0.0.1:6379> ping\n```\n\n```\nPONG\n```\n\n返回PONG表示成功\n\n退出：\n\n```\n127.0.0.1:6379> SHUTDOWN\nexit\n```\n\n### KEY关键字\n\n```\nDBSIZE //当前数据库的key的数量\nselect db //切换数据库\nFlushdb  //清空当前库\nFlushall //清空所有库\nkey * 当前库所有的key\nexists key //判断key是否存在，有返回1，无则0\nmove key db //移动到目标库，当前库的移除\nexpire key 秒钟 //给key设置过期时间，过期后查询到的是nid空值\nttl key //查看还有多久过期，-1表示永不过期，-2表示已过期\ntype key //查看key是什么类型\n```\n\n### redis五种数据结构\n\n##### String：字符串\n\n```\nset key value\nget key\ndel key\nappend key value //在value后追加\nstrlen //String长度\nINCR/DECR KEY//一定要是数字，自增自减\nINCRBY/DECRBY KEY 步长  //多步递增递减\ngetrange/setrange key index index  //根据索引取值设置值\nsetex key 秒钟 value   //设置值的时候设置过期时间\nsetnx  //set if not exist\nmset key1 value1 key2 value2 // 设置多个值\nmget/msetnx\n\n```\n\n##### List：列表\n\n```\nLPUSH list1 1 2 3 4 5 (类似栈)\nLRANGE list1 0 -1\n5\n4\n3\n2\n1\nlpop list1\n\"5\"\nrpop list1\n\"1\"\n```\n\n```\nRPUSH list2 1 2 3 4 5\nLRANGE list2 0 -1\n1\n2\n3\n4\n5\nlpop list2\n\"1\"\nrpop list2\n\"5\"\n```\n\n```\nlindex //按照索引下标获得元素，（从上到下）\nllen  //长度\nLREM KEY N Value  //删除key数组中的N个Value\nLTRIM KEY 开始index 结束index //截取指定范围的值后在赋值给key\nrpoplpush 源列表 目的列表  //把源列表的最底的值移动到目的列表的最上面\nlset key index value //根据数组下标设置成value\nlinsert key before/after 值1 值2  //把值2的值插入到key数组值1的前面/后面\n```\n\n##### Set：集合\n\n```\nsadd  key value1，value1，value2  //只会进去不重复的值 \nsmembers key value 0 -1 //打印全部\nsismember key value //判断value是否在key里\nscard  //获取集合里面的元素\nsrem key value //删除集合中元素\nsrandmember key //随机出几个数\nspop key //随机出栈\nsmove key1 key2 在key1里某个值  //将key1里的某个值赋给key2\nsdiff set1 set2  //差集，set1里有的，set2没有的\nsinter set1 set2 //交集，都有的\nsunion set1 set2 //并集\n```\n\n##### Hash ：哈希\n\n```\nvalue是一个键值对\nhset key <key1,value1>\nhget key key1\nhmset KEY1 keyA valueA KEY2 keyB valueB\nhmgetall  \nhdel KEY1 keyA\nHEXISTS KEY1 keyA //判断是否存在\nhkeys/kvals KEY1\nhincrby/hincrbyfloat KEY1  keyA  步长/浮点数    //自增自减\nhsetnx\n```\n\n##### Zset（sorted set）：有序集合\n\n在set基础上，加一个score值\n\nset是 k1 v1 v2 v3 \n\nzset是 k1  score1  v1  score2  v2\n\n```\nzadd  key  k1  score1  v1  score2  v2\nzrange key 0 -1  //只会打印value\nzrange key 0 -1 withscores  //会打印v1，score，v2，score\nzrangebyscore key 开始score 结束score //  \"（\" 表示不包含， a（ b  表示大于等于a，小于b \nzrangebyscore key 开始score 结束score withscore\nzrangebyscore key 开始score 结束score limit 开始下标步 多少步  \nzrem key score对应的value  //删除元素\nzacard  key  //统计key里value的个数\nzcount key score区间\nzrank key value  //获取下标\nzrevrank  key value //获取反转后的下标\nzrevrange key 0 -1//反转集合\nzrevrangebyscore key 结束score 开始score   //反转集合，index也要反转\n\n```\n\n### 配置文件\n\n#### Units\n\n1.配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit\n\n2.对大小写不敏感\n\n![1593308699248](1.png)\n\n#### INCLUDES\n\n可以通过includes包含，redis.conf可以作为总闸,包含其他\n\n![1593308936736](2.png)\n\n#### GENERAL\n\ndaemonize 默认为no\n\npidfile 进程管道id文件\n\nport 默认端口\n\ntcp-backlog,backlog  511是一个连接队列,在高并发环境下你需要一个高backlog值来避免慢客户端连接问题\n\nbind 端口及网卡的绑定\n\ntimeout 0 当系统空闲一段时间后中断\n\nTcp-keepalive 单位为秒,设置为0则不会进行Keepalive检测\n\nloglevel notice 日志级别\n\nlogfile 日志文件\n\nsyslog-enabled 是否把日志输出到syslog中\n\nsyslog-ident 指定syslog里的日志标志\n\nsyslog-facility 指定syslog设备,值可以是USER或LOCAL0-LOCAL7\n\ndatabases 默认有16个库\n\n![1593309132453](3.png)\n\n#### SECURITY\n\n```\nconfig get requirepass\nconfig set requirepass \"123456\"   //立即生效\n访问任何命令前使用 auth 123456\n```\n\n#### LIMIT\n\nmaxclients 10000   允许10000人连接\n\nmaxmemory <bytes>\n\nmaxmemory-policy  noexiction  缓存过期清洁策略 ,默认永不过期\n\n- volatile-lru:使用LRU算法移除key,只对设置了过期时间的键\n- allkeys-lru:使用LRU算法移除key\n- volatile-random:在过期集合中移除随机的key,只对设置了过期时间的键\n- allkeys-random:移除随机的key\n- volatile-ttl:移除那些TTL值最小的key,即那些最近要过期的key\n- noexiction :不进行移除.针对写操作,只是返回错误信息\n\nLRU算法:最近最少使用的\n\nMaxmemory-samples  设置样本数量,LRU算法和最小TTL算法都并非是精确的算法,而是估算值,所以你可以设置样本的大小,redis默认会检查这么多个key并选择其中LRU的那个;\n\n#### 常用配置\n\n- redis默认不是以守护进程的方式运行,可以通过该配置项修改,使用yes启动守护进程\n\n  ```\n  daemonize no\n  ```\n\n- 当Redis以守护进程方式运行时,Redis默认会把pid写入/var/run/redis.pid文件,可以通过pidfile指定\n```\npid /var/run/redis.pid\n```\n- 指定redis监听端口,默认端口为6379\n```\nport 6379\n```\n- 绑定的主机地址\n```\nblind 127.0.0.1\n```\n- 当客户端闲置多长时间后关闭连接,如果指定为0,表示关闭该功能\n```\ntimeout 300\n```\n- 指定日志记录级别,Redis总共支持四个级别,debug、verbose、notice、warning，默认为verbose\n```\nloglevel verbose\n```\n- 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n```\nlogfile stdout\n```\n\n- 设置数据库的数量，默认数据库为0，可以使用<dbid>命令在连接上指定数据库id\n\n```\ndatabases 16\n```\n\n- 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\n```\nsave <seconds> <changes>\nRedis默认配置文件中提供了三个条件:\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n- 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n\n```\nrdbcompression yes\n```\n\n- 指定本地数据库文件名，默认为dump.rdb\n\n```\ndbfilename dump.rdb\n```\n\n- 指定本地数据库存放目录\n\n```\ndir ./\n```\n\n- 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n\n```\nslaveof <masterip> <masterport>\n```\n\n- 当master服务先设置了密码保护，slav服务连接master的密码\n\n```\nmasterauth <master-password>\n```\n\n- 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n\n```\nrequirepass foobared\n```\n\n- 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max numbers of clients reached 错误信息\n\n```\nmaxclients 128\n```\n\n- 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把key存放内存，value会存放在swap区。\n\n```\nmaxmemory <bytes>\n```\n\n- 指定是否在每次更新操作后进行日志记录。Redis在默认情况下时异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件时按save条件来同步的，所以有的数据会在一段时间内只存在内存中。默认为no\n\n```\nappendonly no\n```\n\n- 指定更新日志文件名，默认为appendonly.aof\n\n```\nappendfilename appendonly.aof\n```\n\n- 指定更新日志条件，共有3个可选值：\n\n```\nappendfsync everysec\nno: 表示等操作系统进行数据缓存同步到磁盘（快）\nalways：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）\neverysec：表示每秒同步一次（折中，默认值）\n```\n\n- 指定是否启用虚拟内存机制，默认为no。VM机制将数据分页存放，有Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘换出到内存中\n\n```\nvm-enabled no\n```\n\n- 虚拟内存文件路径,默认值为/tmp/redis.swap\n\n```\nvm-swap-file /tmp/redis.swap\n```\n\n- 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(Redis的索引数据 就是keys)，也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认为0\n\n```\nvm-max-memory 0\n```\n\n- Redis swap文件分成了很多page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes;如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值\n\n```\nvm-page-size 32\n```\n\n- 设置swap文件中的page数量，由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的，在磁盘上每8个page将消耗1bytes的内存\n\n```\nvm-pages 134217728\n```\n\n- 设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n\n```\nvm-max-threads 4\n```\n\n- 设置在向客户端应答时，是否把较小的包含并为一个包发送，默认为开启\n\n```\nglueoutputbuf yes\n```\n\n- 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n```\nhash-max-zipmap-entries 64\nhash-max-zipmap-value 512\n```\n\n- 指定是否激活重置哈希，默认为开启\n\n```\nactiverehashing yes\n```\n\n- 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n\n```\ninclue /path/to.local,conf\n```\n\n## Redis持久化RDB\n\n>在指定的时间间隔内将内存中的数据集快照写入磁盘，即Snapshot快照，它恢复时是将快照文件直接读到内存里\n\n#### 是什么？\n\nRedis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件，替换上次持久化好的文件。\n\n整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。\n\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方法要比AOF方式更加的高效。\n\nRDB的缺点是最后一次持久化后的数据可能丢失。\n\n#### Fork\n\n> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）\n>\n> 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\n\n\nRDB保存的是dump.rdb文件,\n\n先拷贝一份rdb，删除原rdb，再重命名为dump.rdb，即可恢复\n\n#### 配置文件的位置\n\n##########SNAPSHOT###########\n\nsave 秒钟 写操作次数\n\n禁用 save “”\n\n\n\nstop-writes-on-bgsave-error   yes\n\n如果后台在save操作出现错误的时候，停止写入\n\n如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制\n\nrgbchecksum  yes\n\n在存储快照后，\n\n\n\n命令\n\nsave 手动保存\n\nbgsave Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求，可以通过lastsave命令获得最后一次成功执行快照的时间\n\n执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。\n\nconfig get dir获取目录\n\n停止\n\n动态所有停止RDB保存规则的方法：redis-cli config set save “”\n\n### 优势\n\n1.适合大规模的数据恢复\n\n2.对数据完整性和一致性要求不高\n\n### 劣势\n\n1.在一定间隔时间做一次备份，所有如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n\n2.fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n\n#### 总结\n\n```\n\n\n内存中的      rdbSave     磁盘中的\n数据对象   ----------》    RDB文件\n            rdbload                \n\n\n```\n\n- RDB是一个非常紧凑的文件\n\n- RDB在保存文件时父进程唯一要做的就是fork出一个子进程来做，接下来的工作全部由子进程来做，\n\n  父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能\n\n- 与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。\n\n\n\n- 数据丢失风险大\n- RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能响应客户端的请求。\n\n## Redis持久化之AOF\n\n> 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n\nAOF保存的是appendonly.aof文件\n\n###########appendonly##########\n\n恢复：删除dump.rdb，vim  appendonly.aof，删除末尾行的FLUSHALL，再次连接数据库即可访问。\n\n两者可以共存，优先找aof，如果aof有修改为不能识别的字符，开启redis时会被拒绝。\n\n这时，当前文件夹下有一个redis-check-aof，使用命令：\n\n```\nredis-check-aof --fix appendonly.aof\ncontinue?[y/N]:y\n```\n\n命令会删除不符合语法规范的字段。\n\n### rewrite\n\nAOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用bgrewriteaof\n\n重写原理：\n\nAOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set 语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。\n\n触发机制：\n\nRedis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。\n\nauto-aof-rewrite-percentage 100  一倍\n\nauto-aof-rewrite-min-size 64mb\n\n#### 优势\n\n每秒同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整比较好\n\n每修改同步：appendfsync  everysec  异步操作，每秒记录  如果一秒内宕机，有数据丢失。\n\n不同步：appendfsync  no 从不同步\n\n#### 劣势\n\n相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢与rdb\n\naof运行效率要慢与rdb，每秒同步策略较好，不同步效率和rdb相同\n\n```\n                              AOF                   网络协议格式\n  _________________   命令请求     ________________   的命令内容   ____________________\n |      客户端      | __________> |     服务器      | __________>|       AOF文件      |\n |_________________|             |________________|            |___________________|\n```\n\n- aof文件时一个只进行追加的日志文件\n- Redis可以在AoF文件体积变得过大时，自动地在后台对AOF进行重写\n\n\n\n- 对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积\n- 根据所使用的fsync策略，AOF的速度可能会慢于RDB\n\n#### 总结\n\n- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储\n\n- AOP持久化方式记录每次对服务器写的操作，当服务器重启的时候回重新执行这些命令来回复原始的数据，AOP命令以redis协议追加保存每次写的操作到文件末尾.\n\n- Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大\n\n- 只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式.\n\n- 同时开启两种持久化方式.在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. \n\n- RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件, 建议不要只使用AOF,因为RDB更适合于备份数据库(AOF在不断变化不好备份),\n\n  快速重启,而且不会有AOF可能存在的bug,留着作为一个万一的手段.\n\n## 事务\n\n> 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞\n\n#### 能做什么？\n\n一个队列中，一次性的、顺序性、排他性的执行一系列命令\n\n#### 常用命令\n\n| **DISCARD**              | **取消事务，放弃执行事务块内的所有命令。**                   |\n| ------------------------ | ------------------------------------------------------------ |\n| **EXEC**                 | **执行所有事务块内的命令。**                                 |\n| **MULTI**                | **标记一个事务块的开始。**                                   |\n| **UNWATCH**              | **取消 WATCH 命令对所有 key 的监视。**                       |\n| **WATCH key [key ...\\]** | **监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。** |\n\n##### 正常执行\n\nMULTI 相当与 一个新的购物车，每输入一条命令返回QUEUED相当于加入购物车，EXEC执行命令相当于结账。\n\n##### 放弃事务\n\n在事务没有EXEC之前调用DISCARD\n\n##### 全体连坐\n\n如果有一个指令不能正常运行（编译出错），事务EXEC会报错\n\n##### 冤头债主\n\n**运行时出错的命令**不会执行，而其他命令仍然会放行。\n\n> Redis是否支持事务？ 是部分支持。\n\n##### watch监控\n\n- 悲观锁(Pessimistic Lock)\n\n  > 我对这个事情的发展很悲观，每次去拿数据的时候都认为别人会修改，为了避免出事，把整张表锁了，\n  >\n  > 表锁，并发性最差，一致性最好。\n\n- **乐观锁(Optimistic Lock)**\n\n  > 我认为这个事没有人会去干，不会上锁，乐观锁在每条记录的后面加一个version版本号字段。\n  >\n  > 乐观锁策略：提交版本必须大于记录当前版本才能执行。\n\n在调用MULTI之前，先调用  WATCH  + KEY\n\n**UNWATCH取消所有key的监控**\n\n有加塞篡改，监控了key，key被修改了，事务将被打断，调用UNWATCH再执行一次\n\n#### 阶段\n\n开启：以MULTI开始一个事务\n\n入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面。\n\n执行：由EXEC命令触发事务\n\n#### 总结\n\nwatch指令，类似乐观锁，事务提交时，如果key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会执行。\n\n通过watch命令在事务执行之前监控了多个keys，倘若在watch之后有任何key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。\n\n#### 特性：\n\n单独的隔离操作：事务中的所有命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的请求所打断。\n\n没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个问题。\n\n不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。\n\n## 消息订阅发布\n\n是什么？\n\n> 进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息\n\n下图展示了频道channel1，以及订阅这个频道的三个客户端---client2和client5、client1之间的关系\n\n ![img](pubsub1.png) \n\n当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会发送给订阅它的三个客户端\n\n ![img](pubsub2.png) \n\n\n\n下表列出了 redis 发布订阅常用命令：\n\n| **命令**                                         | **描述**                               |\n| :----------------------------------------------- | :------------------------------------- |\n| **PSUBSCRIBE pattern [pattern ...\\]**            | **订阅一个或多个符合给定模式的频道。** |\n| **PUBSUB subcommand [argument [argument ...\\]]** | **查看订阅与发布系统状态。**           |\n| **PUBLISH channel message**                      | **将信息发送到指定的频道。**           |\n| **PUNSUBSCRIBE [pattern [pattern ...\\]]**        | **退订所有给定模式的频道。**           |\n| **SUBSCRIBE channel[channel ...\\]**              | **订阅给定的一个或多个频道的信息。**   |\n| **UNSUBSCRIBE[channel [channel ...\\]]**          | **指退订给定的频道。**                 |\n\nSUBSCRIBE   c1 c2 \n\nPULISH c1 message\n\nPSUBSCRIBE  new*  \n\nPULISH  new4  message\n\n## 主从复制\n\n> 主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，Master以写为主，Slave以读为主。\n\n##### 在/myredis下：\n\n```\ncp redis.conf  redis6379.conf\ncp redis.conf  redis6380.conf\ncp redis.conf  redis6381.conf\n```\n\n修改配置文件\n\n```\nvim redis6379.conf\npidfile  /var/run/redis.pid  ->  /var/run/redis6379.pid\nport 6379\nlogfile \"\"  ->   logfile \"6379.log\"\n备份\ndbfilename  dump.rdb   ->    dump6379.rdb\n\n6380,6381 以此为例\n```\n\n分别启动\n\n```\nredis-server /myredis/redis6379.conf\nredis-cli -p 6379\n```\n\n检查是否启动\n\n```\nps -ef|gref redis\n```\n\n使用命令 info replication查看信息,他们的角色都是master\n\n```\nrole:master\n```\n\n在主机（6379）下往数据库设值\n\n```\nset k1 v1\nset k2 v2\nset k3 v3\n```\n\n在从机（6380,6381）分别使用SLAVEOF命令\n\n```\nSLAVEOF 127.0.0.1  6379\n```\n\n这时再往主机6379设值\n\n```\nset k4 v4\n```\n\n从机可以获取值\n\n```redis\nget k4\n\"v4\"\nget k1\n\"v1\"\n```\n\n再次使用命令 info replication查看信息\n\n6379主机下多了两个奴隶：6380,6381\n\n6780、6781的角色变成了奴隶。\n\n\n\n- **如果从机尝试写入数据。会出错。因为Master以写为主，Slave以读为主**\n\n\n\n- 如果主机SHUTDOWN死了，调用从机的 info replication\n\n```\nmaster_link_status: 由up变成了down\n```\n\n从机在原地待命\n\n\n\n- 如果主机重新连接回来了，并设值\n\n```\nset k7 v7\n```\n\n从机依然可以获取k7的值\n\n```\nget k7\n\"v7\"\n```\n\n- 如果从机退出并重新连接role角色会变成master，并且会丢失退出期间的数据,\n\n  调用SLAVEOF 127.0.0.1  6379就可以恢复连接并获取到原来丢失的值\n\n  \n\n  **每次与master断开之后，都需要重新连接，除非配置进redis.conf**\n\n  \n\n#### 薪火相传\n\n> 去中心化\n>\n> 上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中的下一个的master，可以有效减轻master的写压力。\n\n中途变更转向：会清除之前的数据，重新建立拷贝最新的\n\nSlaveof 新主库IP 新主库端口\n\n\n\n例如81是80的从机，80是79的从机，那么80是79的奴隶，80还是奴隶，81是80的奴隶。\n\n#### 反客为主\n\n一主二仆里，主机挂了，从机使用命令：\n\n```\nSLAVEOF no one\n```\n\n当前从机的角色就变成了主机，其他从机需要调用：\n\n```\nSlaveof 新主库IP 新主库端口\n//使当前数据库停止与其他数据库同步，转成组数据库。\n```\n\n才能跟随新主机。\n\n### 复制原理\n\n- Slave启动成功连接到master后会发送一个sync命令\n\n- Master接到命令启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步\n\n- 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n- 增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步\n\n  但是只要是重新连接master，一次完全同步（全量复制）将会被自动执行。\n\n### 哨兵模式\n\n> 反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库\n\n#### 启动\n\n在/myredis下面创建一个sentinel.conf文件\n\n```shell\ntouch sentinel.conf\nvim sentinel.conf\n```\n\n修改为以下内容：\n\n*一组 sentinel.conf 可以监控多个Master*\n\n```shell\nsentinel monitor 被监控数据库名字(自己起名字)  127.0.0.1  6379  1\n\n//数字1 表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机\n```\n\n启动redis：\n\n```\nredis-sentinel  /myredis/sentinel.conf \n```\n\n主机断开之后，哨兵监控到了，就开始投票，如果两个从机一人一票，就会重新投票，\n\n票数高的从机替换主机，其他从机都跟随这个新主机。\n\n断开的主机回来之后变成了从机，并跟随新主机。\n\n### 复制的缺点\n\n由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步带Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n\n### Jedis\n\n测试联通\n\n先启动\n\n在/usr/local/bin下：\n\n```\n$ redis-server /myredis/redis.conf\n```\n\n```\n$ redis-cli -p 6379\n```\n\nJava：\n\n依赖：\n\n```xml\n<dependencies>\n        <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 -->\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n            <version>2.8.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>3.3.0</version>\n        </dependency>\n    </dependencies>\n```\n\n\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 18:33\n */\npublic class TestPing {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        System.out.println(jedis.ping());\n    }\n}\n------\nPONG\n```\n\nAPI\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 18:33\n */\npublic class TestAPI {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.set(\"k1\", \"v2\");\n        jedis.get(\"k1\");\n        Set<String> keys = jedis.keys(\"*\");\n        //事务\n        Transaction multi = jedis.multi();\n        multi.set(\"k2\", \"v2\");\n//        multi.exec();\n        multi.discard();\n    }\n}\n```\n\n事务\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 20:04\n */\npublic class TestTX {\n    public static void main(String[] args) throws InterruptedException {\n        TestTX test = new TestTX();\n        boolean b = test.transMethod();\n        System.out.println(b);\n    }\n\n    public boolean transMethod() throws InterruptedException {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        int balance;//可用余额\n        int debt;//欠额\n        int amtToSubtract = 10;//实刷额度\n        jedis.watch(\"balance\");\n        //其他程序执行\n        // Thread.sleep(3000);\n        //jedis.set(\"balance\", \"5\");\n        balance = Integer.parseInt(jedis.get(\"balance\"));\n        if (balance < amtToSubtract) {\n            jedis.unwatch();\n            System.out.println(\"modify\");\n            return false;\n        }\n        return true;\n    }\n}\n```\n\n主从\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 20:04\n */\npublic class TestMS {\n    public static void main(String[] args) {\n        Jedis jedis_M = new Jedis(\"127.0.0.1\", 6379);\n        Jedis jedis_S = new Jedis(\"127.0.0.1\", 6380);\n\n        jedis_S.slaveof(\"127.0.0.1\", 6379);\n        jedis_M.set(\"class\", \"1\");\n\n        System.out.println(jedis_S.get(\"class\"));\n    }\n}\n```\n\n池\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 20:29\n */\npublic class JedisPoolUtils {\n\n    private static volatile JedisPool jedisPool = null;\n\n    private JedisPoolUtils() {\n    }\n\n    public static JedisPool getJedisPoolInstance() {\n        if (null == jedisPool) {\n            synchronized (JedisPoolUtils.class) {\n                if (null == jedisPool) {\n                    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n                    jedisPoolConfig.setMaxActive();\n                    jedisPoolConfig.setMaxIdle(32);\n                    jedisPoolConfig.setMaxWaitMillis(100*1000);\n                    jedisPoolConfig.setTestOnBorrow(true);\n                    jedisPool = new JedisPool(\"127.0.0.1\", 6379);\n                }\n            }\n        }\n        return jedisPool;\n    }\n}\n```\n\nJedisPoolConfig:\n\n![1593434346091](1593434346091.png)\n\n### 缓存雪崩\n\n","tags":["sql"]},{"title":"操作系统","url":"/2020/06/20/操作系统/","content":"\n### OS Kernel的特征\n\n<!--more-->\n\n- 并发\n- 计算机系统中存在多个运行的程序，需要OS管理和调度\n- 共享\n\n  - \"同时\"访问\n\n  - 互斥共享\n- 虚拟\n  - 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务。\n- 异步\n  - 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知。\n  - 但只要运行环境相同，OS需要保证程序运行的结果也要相同。\n\n#### 关系：\n\nDISK：存放OS\n\nBIOS：基本I/O处理系统，最基本的功能是电源开启后检测外设，之后加载相应的软件来执行\n\nBootloader：加载OS，把OS从硬盘放到内存里，让CPU可以操作系统，\n\n![1592878521236](1.png)\n\n从图可以看出，计算机里面有一部分空间（硬盘）已经给BIOS占用了，但是还有很多地方是空的，BIOS需要从一个特定的地址开始执行，以X86为例，固定的地址为0xf000:fff0. CS寄存器和IP寄存器一起可以形成一个内存地址，一开始加电，BIOS就从这个地址开始执行。执行一系列的工作：\n\n- POST（加电自检）\n\n  寻找显卡和执行BIOS，检查设备是否可以正常工作。初始化的检擦。\n\n- BIOS是如何把bootloader放进去的：\n\n![](2.png)\n\nBootloader一般是放在硬盘的第一个主引导扇区。第一个扇区是512个字节。把bootloader放到内存里，CPU的掌控权就在bootloader；\n\n### 操作系统与设备和程序交互。\n\n#### 系统调用、异常、中断\n\n- 系统调用（来源于应用程序）sys call\n  \n- 应用程序主动向操作系统发出服务请求。\n  \n- 异常（来源于不良的应用程序） exception\n  \n- 非法指令或者其他坏的处理状态（如：内存出错）\n  \n- 中断（来源与外设）interrupt\n\n  - 来自不同硬件设备的计时器和网络中断。\n\n    \n\n为什么应用程序不直接使用外设而要经过操作系统？\n\n- 在计算机运行中，内核是被信任的第三方\n- 只有内核可以执行特权指令\n- 为了方便应用程序\n\n\n\n产生的源头：\n\n- 中断：外设\n- 异常：应用程序意想不到的行为\n- 系统调用：应用程序请求操作提供服务。\n\n\n\n处理时间：\n\n- 中断：异步，异步：当这个事件产生的时候，我们应用程序并不知道什么时候产生。\n- 异常：同步，异常执行到某条特定的指令后一定会产生\n- 系统调用：异步或同步，当系统调用发出请求的时候，返回的时间是异步的\n\n\n\n响应：\n\n- 中断：持续，对用户应用程序是透明的、\n- 异常: 杀死或者重新执行意想不到的应用程序指令\n- 系统调用：等待和持续\n\n","tags":["Operating Systems"]},{"title":"编码算法","url":"/2020/06/19/编码算法/","content":"\n## 编码算法\n\n<!--more-->\n\n------\n\n要学习编码算法，先来看一看什么是编码。\n\nASCII码就是一种编码，字母`A`的编码是十六进制的`0x41`，字母`B`是`0x42`，以此类推：\n\n| 字母 | ASCII编码 |\n| :--- | :-------- |\n| A    | 0x41      |\n| B    | 0x42      |\n| C    | 0x43      |\n| D    | 0x44      |\n| …    | …         |\n\n因为ASCII编码最多只能有127个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是`0x4e2d`，使用UTF-8则需要3个字节编码：\n\n| 汉字 | Unicode编码 | UTF-8编码 |\n| :--- | :---------- | :-------- |\n| 中   | 0x4e2d      | 0xe4b8ad  |\n| 文   | 0x6587      | 0xe69687  |\n| 编   | 0x7f16      | 0xe7bc96  |\n| 码   | 0x7801      | 0xe7a081  |\n| …    | …           | …         |\n\n因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。\n\n比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。\n\n### URL编码\n\nURL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：\n\n[https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87](https://www.baidu.com/s?wd=中文)\n\n之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：\n\n- 如果字符是`A`~`Z`，`a`~`z`，`0`~`9`以及`-`、`_`、`.`、`*`，则保持不变；\n- 如果是其他字符，先转换为UTF-8编码，然后对每个字节以`%XX`表示。\n\n例如：字符`中`的UTF-8编码是`0xe4b8ad`，因此，它的URL编码是`%E4%B8%AD`。URL编码总是大写。\n\nJava标准库提供了一个`URLEncoder`类来对任意字符串进行URL编码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String encoded = URLEncoder.encode(\"中文!\", StandardCharsets.UTF_8);\n        System.out.println(encoded);\n    }\n}\n\n```\n\n上述代码的运行结果是`%E4%B8%AD%E6%96%87%21`，`中`的URL编码是`%E4%B8%AD`，`文`的URL编码是`%E6%96%87`，`!`虽然是ASCII字符，也要对其编码为`%21`。\n\n和标准的URL编码稍有不同，URLEncoder把空格字符编码成`+`，而现在的URL编码标准要求空格被编码为`%20`，不过，服务器都可以处理这两种情况。\n\n如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的`URLDecoder`就可以解码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String decoded = URLDecoder.decode(\"%E4%B8%AD%E6%96%87%21\", StandardCharsets.UTF_8);\n        System.out.println(decoded);\n    }\n}\n\n```\n\n要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为`%`前缀表示的文本，编码后的文本仅包含`A`~`Z`，`a`~`z`，`0`~`9`，`-`，`_`，`.`，`*`和`%`，便于浏览器和服务器处理。\n\n### Base64编码\n\nURL编码是对字符进行编码，表示成`%xx`的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。\n\nBase64编码可以把任意长度的二进制数据变为纯文本，且只包含`A`~`Z`、`a`~`z`、`0`~`9`、`+`、`/`、`=`这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。\n\n举个例子：3个byte数据分别是`e4`、`b8`、`ad`，按6bit分组得到`39`、`0b`、`22`和`2d`：\n\n```ascii\n┌───────────────┬───────────────┬───────────────┐\n│      e4       │      b8       │      ad       │\n└───────────────┴───────────────┴───────────────┘\n┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐\n│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│\n└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘\n┌───────────┬───────────┬───────────┬───────────┐\n│    39     │    0b     │    22     │    2d     │\n└───────────┴───────────┴───────────┴───────────┘\n```\n\n因为6位整数的范围总是`0`~`63`，所以，能用64个字符表示：字符`A`~`Z`对应索引`0`~`25`，字符`a`~`z`对应索引`26`~`51`，字符`0`~`9`对应索引`52`~`61`，最后两个索引`62`、`63`分别用字符`+`和`/`表示。\n\n在Java中，二进制数据就是`byte[]`数组。Java标准库提供了`Base64`来对`byte[]`数组进行编解码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad };\n        String b64encoded = Base64.getEncoder().encodeToString(input);\n        System.out.println(b64encoded);\n    }\n}\n\n```\n\n 编码后得到`5Lit`4个字符。要对`Base64`解码，仍然用`Base64`这个类： \n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] output = Base64.getDecoder().decode(\"5Lit\");\n        System.out.println(Arrays.toString(output)); // [-28, -72, -83]\n    }\n}\n\n```\n\n有的童鞋会问：如果输入的`byte[]`数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个`0x00`，编码后，在结尾加一个`=`表示补充了1个`0x00`，加两个`=`表示补充了2个`0x00`，解码的时候，去掉末尾补充的一个或两个`0x00`即可。\n\n实际上，因为编码后的长度加上`=`总是4的倍数，所以即使不加`=`也可以计算出原始输入的`byte[]`。Base64编码的时候可以用`withoutPadding()`去掉`=`，解码出来的结果是一样的：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, 0x21 };\n        String b64encoded = Base64.getEncoder().encodeToString(input);\n        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);\n        System.out.println(b64encoded);\n        System.out.println(b64encoded2);\n        byte[] output = Base64.getDecoder().decode(b64encoded2);\n        System.out.println(Arrays.toString(output));\n    }\n}\n\n```\n\n 因为标准的Base64编码会出现`+`、`/`和`=`，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把`+`变成`-`，`/`变成`_`： \n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] input = new byte[] { 0x01, 0x02, 0x7f, 0x00 };\n        String b64encoded = Base64.getUrlEncoder().encodeToString(input);\n        System.out.println(b64encoded);\n        byte[] output = Base64.getUrlDecoder().decode(b64encoded);\n        System.out.println(Arrays.toString(output));\n    }\n}\n\n```\n\nBase64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。\n\nBase64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。\n\n和URL编码一样，Base64编码是一种编码算法，不是加密算法。\n\n如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。\n\n### 小结\n\nURL编码和Base64编码都是编码算法，它们不是加密算法；\n\nURL编码的目的是把任意文本数据编码为%前缀表示的文本，便于浏览器和服务器处理；\n\nBase64编码的目的是把任意二进制数据编码为文本，但编码后数据量会增加1/3。","tags":["dataAlgorithm"]},{"title":"哈希算法","url":"/2020/06/17/哈希算法/","content":"\n### 哈希算法\n\n> 哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 \n>\n><!--more-->\n\n哈希算法最重要的特点就是：\n\n- 相同的输入一定得到相同的输出；\n- 不同的输入大概率得到不同的输出。\n\n哈希算法的目的就是为了验证原始数据是否被篡改。\n\nJava字符串的`hashCode()`就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节`int`整数：\n\n```\n\"hello\".hashCode(); // 0x5e918d2\n\"hello, java\".hashCode(); // 0x7a9d88e8\n\"hello, bob\".hashCode(); // 0xa0dbae2f\n```\n\n两个相同的字符串永远会计算出相同的`hashCode`，否则基于`hashCode`定位的`HashMap`就无法正常工作。这也是为什么当我们自定义一个class时，覆写`equals()`方法时我们必须正确覆写`hashCode()`方法。\n\n### 哈希碰撞\n\n哈希碰撞是指，两个不同的输入得到了相同的输出：\n\n```\n\"AaAaAa\".hashCode(); // 0x7460e8c0\n\"BBAaBB\".hashCode(); // 0x7460e8c0\n```\n\n有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，`String`的`hashCode()`输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。\n\n碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：\n\n- 碰撞概率低；\n- 不能猜测输出。\n\n不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：\n\n```\nhashA(\"java001\") = \"123456\"\nhashA(\"java002\") = \"123457\"\nhashA(\"java003\") = \"123458\"\n```\n\n那么很容易从输出`123459`反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：\n\n```\nhashB(\"java001\") = \"123456\"\nhashB(\"java002\") = \"580271\"\nhashB(\"java003\") = ???\n```\n\n常用的哈希算法有：\n\n| 算法       | 输出长度（位） | 输出长度（字节） |\n| :--------- | :------------- | :--------------- |\n| MD5        | 128 bits       | 16 bytes         |\n| SHA-1      | 160 bits       | 20 bytes         |\n| RipeMD-160 | 160 bits       | 20 bytes         |\n| SHA-256    | 256 bits       | 32 bytes         |\n| SHA-512    | 512 bits       | 64 bytes         |\n\n根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。\n\nJava标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 创建一个MessageDigest实例:\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        // 反复调用update输入数据:\n        md.update(\"Hello\".getBytes(\"UTF-8\"));\n        md.update(\"World\".getBytes(\"UTF-8\"));\n        byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6\n        System.out.println(new BigInteger(1, result).toString(16));\n    }\n}\n```\n\n使用`MessageDigest`时，我们首先根据哈希算法获取一个`MessageDigest`实例，然后，反复调用`update(byte[])`输入数据。当输入结束后，调用`digest()`方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。\n\n运行上述代码，可以得到输入`HelloWorld`的MD5是`68e109f0f40ca72a15e05cc22786f8e6`。\n\n### 哈希算法的用途\n\n因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。\n\n我们在网站上下载软件的时候，经常看到下载页显示的哈希：\n\n![file-md5](https://www.liaoxuefeng.com/files/attachments/1305351978745921/l)\n\n如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。\n\n哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：\n\n- 数据库管理员能够看到用户明文口令；\n- 数据库数据一旦泄漏，黑客即可获取用户明文口令。\n\n不存储用户的原始口令，那么如何对用户进行认证？\n\n方法是存储用户口令的哈希，例如，MD5。\n\n在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。\n\n因此，数据库存储用户名和口令的表内容应该像下面这样：\n\n| username | password                         |\n| :------- | :------------------------------- |\n| bob      | f30aa7a662c728b7407c54ae6bfd27d1 |\n| alice    | 25d55ad283aa400af464c76d713c07ad |\n| tim      | bed128365216c019988915ed3add75fb |\n\n这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。\n\n使用哈希口令时，还要注意防止彩虹表攻击。\n\n什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。\n\n然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：\n\n| 常用口令 | MD5                              |\n| :------- | :------------------------------- |\n| hello123 | f30aa7a662c728b7407c54ae6bfd27d1 |\n| 12345678 | 25d55ad283aa400af464c76d713c07ad |\n| passw0rd | bed128365216c019988915ed3add75fb |\n| 19700101 | 570da6d5277a646f6552b8832012f5dc |\n| …        | …                                |\n| 20201231 | 6879c0ae9117b50074ce0a0d4c843060 |\n\n这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：\n\nbob的MD5：`f30aa7a662c728b7407c54ae6bfd27d1`，原始口令：`hello123`；\n\nalice的MD5：`25d55ad283aa400af464c76d713c07ad`，原始口令：`12345678`；\n\ntim的MD5：`bed128365216c019988915ed3add75fb`，原始口令：`passw0rd`。\n\n这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。\n\n即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：\n\n```\ndigest = md5(salt+inputPassword)\n```\n\n经过加盐处理的数据库表，内容如下：\n\n| username | salt  | password                         |\n| :------- | :---- | :------------------------------- |\n| bob      | H1r0a | a5022319ff4c56955e22a74abcc2c210 |\n| alice    | 7$p2w | e5de688c99e961ed6e560b972dab8b6a |\n| tim      | z5Sk9 | 1eee304b92dc0d105904e7ab58fd2f64 |\n\n加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。\n\n### SHA-1\n\nSHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。\n\n在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为`\"SHA-1\"`：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 创建一个MessageDigest实例:\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        // 反复调用update输入数据:\n        md.update(\"Hello\".getBytes(\"UTF-8\"));\n        md.update(\"World\".getBytes(\"UTF-8\"));\n        byte[] result = md.digest(); // 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2\n        System.out.println(new BigInteger(1, result).toString(16));\n    }\n}\n\n```\n\n 类似的，计算SHA-256，我们需要传入名称`\"SHA-256\"`，计算SHA-512，我们需要传入名称`\"SHA-512\"`。Java标准库支持的所有哈希算法可以在[这里](https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms)查到。 ","tags":["dataAlgorithm"]},{"title":"插值查找算法","url":"/2020/06/17/插值查找算法/","content":"\n### 插值查找算法\n\n<!--more-->\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/17 9:06\n */\npublic class insertSearch {\n    /**\n     * @param arr     数组\n     * @param left    左边的索引\n     * @param right   右边的索引\n     * @param findVal 要查找的值\n     * @return\n     */\n    public static int insertValue(int[] arr, int left, int right, int findVal) {\n        System.out.println(\"插值查找次数...\");\n\n        //注意：findVal<arr[0]和findVal>arr[arr.length-1]必须需要\n        //否则得到的mid可能越界\n        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {\n            return -1;\n        }\n\n        //求出mid,自适应\n        int mid = left + (right - left) * (findVal - arr[left] / arr[right] - arr[left]);\n        int midVal = arr[mid];\n        if (findVal > midVal) {\n            //应该向右递归\n            return insertValue(arr, mid + 1, right, findVal);\n        } else if (findVal < midVal) {\n            return insertValue(arr, left, mid - 1, findVal);\n        } else {\n            return mid;\n        }\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"二分查找算法","url":"/2020/06/17/二分查找算法/","content":"\n### 二分查找算法\n\n<!--more-->\n\n```java\n/**\n     * 二分查找算法\n     *\n     * @param arr    待查找的数组,arr是升序排序\n     * @param target 需要查找的数\n     * @return 返回对应的下标，-1表示没有\n     */\n    public static int binarySearch(int[] arr, int target) {\n\n        int left = 0;\n        int right = arr.length - 1;\n        while (left <= right) {\n            //说明可以继续查找\n            int mid = (left + right) / 2;\n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] > target) {\n                right = mid - 1;//需要向左边查找\n            } else {\n                left = mid + 1;//需要向右边查找\n            }\n        }\n        return -1;\n\n    }\n```\n\n","tags":["dataAlgorithm"]},{"title":"线性查找算法","url":"/2020/06/17/线性查找算法/","content":"\n### 线性查找算法\n\n<!--more-->\n\n>  有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称\n>\n> 【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值。\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/17 8:57\n */\npublic class OrderSearch {\n    public static void main(String[] args) {\n        int[] arr = {1, 8, 10, 89, 1000, 1234};\n        System.out.println(OrderFind(arr, 10));\n    }\n\n    public static int OrderFind(int[] arr, int value) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            if (arr[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"多线程","url":"/2020/06/15/多线程/","content":"\n## 多线程\n\n<!--more-->\n\n### 一个线程的生命周期\n\n线程是一个动态执行的过程，它也有一个从产生到死亡的过程。\n\n下图显示了一个线程完整的生命周期。\n\n![img](1.jpg)\n\n- 新建状态:\n\n  使用 **new** 关键字和 **Thread** 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 **start()** 这个线程。\n\n- 就绪状态:\n\n  当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n\n- 运行状态:\n\n  如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n\n- 阻塞状态:\n\n  如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：\n\n  - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。\n  - 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。\n  - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。\n\n- 死亡状态:\n\n  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n\n---\n\n### 线程的优先级\n\n每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。\n\nJava 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。\n\n默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。\n\n具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。\n\n---\n\n### 创建一个线程\n\nJava 提供了三种创建线程的方法：\n\n- 通过实现 Runnable 接口；\n- 通过继承 Thread 类本身；\n- 通过 Callable 和 Future 创建线程。\n\n---\n\n## 通过实现 Runnable 接口来创建线程\n\n创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。\n\n为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：\n\n```java\npublic void run()\n```\n\n你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。\n\n在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。\n\nThread 定义了几个构造方法，下面的这个是我们经常使用的：\n\n```java\nThread(Runnable threadOb,String threadName);\n```\n\n这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。\n\n新线程创建之后，你调用它的 start() 方法它才会运行。\n\n```java\nvoid start();\n```\n\n下面是一个创建线程并开始让它执行的实例：\n\n![img](1.png)\n\n编译以上程序运行结果如下：\n\n```shell\nCreating Thread-1\nStarting Thread-1\nCreating Thread-2\nStarting Thread-2\nRunning Thread-1\nThread: Thread-1, 4\nRunning Thread-2\nThread: Thread-2, 4\nThread: Thread-1, 3\nThread: Thread-2, 3\nThread: Thread-1, 2\nThread: Thread-2, 2\nThread: Thread-1, 1\nThread: Thread-2, 1\nThread Thread-1 exiting.\nThread Thread-2 exiting.\n```\n\n---\n\n## 通过继承Thread来创建线程\n\n创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。\n\n继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。\n\n该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。\n\n![](2.png)\n\n编译以上程序运行结果如下：\n\n```\nCreating Thread-1\nStarting Thread-1\nCreating Thread-2\nStarting Thread-2\nRunning Thread-1\nThread: Thread-1, 4\nRunning Thread-2\nThread: Thread-2, 4\nThread: Thread-1, 3\nThread: Thread-2, 3\nThread: Thread-1, 2\nThread: Thread-2, 2\nThread: Thread-1, 1\nThread: Thread-2, 1\nThread Thread-1 exiting.\nThread Thread-2 exiting.\n```\n\n---\n\n## Thread 方法\n\n下表列出了Thread类的一些重要方法：\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **public void start()** 使该线程开始执行；**Java** 虚拟机调用该线程的 run 方法。 |\n| 2        | **public void run()** 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 |\n| 3        | **public final void setName(String name)** 改变线程名称，使之与参数 name 相同。 |\n| 4        | **public final void setPriority(int priority)**  更改线程的优先级。 |\n| 5        | **public final void setDaemon(boolean on)** 将该线程标记为守护线程或用户线程。 |\n| 6        | **public final void join(long millisec)** 等待该线程终止的时间最长为 millis 毫秒。 |\n| 7        |            **public void interrupt()** 中断线程。            |\n| 8        | **public final boolean isAlive()** 测试线程是否处于活动状态。 |\n\n测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **public static void yield()** 暂停当前正在执行的线程对象，并执行其他线程。 |\n| 2        | **public static void sleep(long millisec)** 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 |\n| 3        | **public static boolean holdsLock(Object x)** 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 |\n| 4        | **public static Thread currentThread()** 返回对当前正在执行的线程对象的引用。 |\n| 5        | **public static void dumpStack()** 将当前线程的堆栈跟踪打印至标准错误流。 |\n\n### 实例\n\n如下的ThreadClassDemo 程序演示了Thread类的一些方法：\n\n![](3.png)\n\n![](4.png)\n\n![](5.png)\n\n运行结果如下，每一次运行的结果都不一样。\n\n```\nStarting hello thread...\nStarting goodbye thread...\nHello\nHello\nHello\nHello\nHello\nHello\nGoodbye\nGoodbye\nGoodbye\nGoodbye\nGoodbye\n.......\n```\n\n## 通过 Callable 和 Future 创建线程\n\n- 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。\n- 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。\n- 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n- 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。\n\n![](6.png)\n\n## 创建线程的三种方式的对比\n\n- 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。\n- 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。\n\n------\n\n## 多线程的使用\n\n有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。\n\n通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。\n\n请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！","tags":["Concurrency"]},{"title":"模板方法","url":"/2020/06/13/模板方法/","content":"\n#### 模板方法\n\n------\n\n> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n>\n> <!--more-->\n\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n## 介绍\n\n**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。\n\n**何时使用：**有一些通用的方法。\n\n**如何解决：**将这些通用算法抽象出来。\n\n**关键代码：**在抽象类实现，其他步骤在子类实现。\n\n**应用实例：** 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n\n**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n**注意事项：**为防止恶意操作，一般模板方法都加上 final 关键词。\n\n## 实现\n\n我们将创建一个定义操作的 *Game* 抽象类，其中，模板方法设置为 final，这样它就不会被重写。*Cricket* 和 *Football* 是扩展了 *Game* 的实体类，它们重写了抽象类的方法。\n\n*TemplatePatternDemo*，我们的演示类使用 *Game* 来演示模板模式的用法。\n\n![模板模式的 UML 图](1.jpg)\n\n### 步骤1\n\n创建一个抽象类，它的模板方法被设置为 final。\n\n*Game.java*\n\n```java\npublic abstract class Game {\n   abstract void initialize();\n   abstract void startPlay();\n   abstract void endPlay();\n \n   //模板\n   public final void play(){\n \n      //初始化游戏\n      initialize();\n \n      //开始游戏\n      startPlay();\n \n      //结束游戏\n      endPlay();\n   }\n}\n```\n\n### 步骤 2\n\n创建扩展了上述类的实体类。\n\n*Cricket.java*\n\n```java\npublic class Cricket extends Game {\n \n   @Override\n   void endPlay() {\n      System.out.println(\"Cricket Game Finished!\");\n   }\n \n   @Override\n   void initialize() {\n      System.out.println(\"Cricket Game Initialized! Start playing.\");\n   }\n \n   @Override\n   void startPlay() {\n      System.out.println(\"Cricket Game Started. Enjoy the game!\");\n   }\n}\n```\n\n*Football.java*\n\n```java\npublic class Football extends Game {\n \n   @Override\n   void endPlay() {\n      System.out.println(\"Football Game Finished!\");\n   }\n \n   @Override\n   void initialize() {\n      System.out.println(\"Football Game Initialized! Start playing.\");\n   }\n \n   @Override\n   void startPlay() {\n      System.out.println(\"Football Game Started. Enjoy the game!\");\n   }\n}\n```\n\n### 步骤 3\n\n使用 *Game* 的模板方法 play() 来演示游戏的定义方式。\n\n*TemplatePatternDemo.java*\n\n```java\npublic class TemplatePatternDemo {\n   public static void main(String[] args) {\n \n      Game game = new Cricket();\n      game.play();\n      System.out.println();\n      game = new Football();\n      game.play();      \n   }\n}\n```\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```\nCricket Game Initialized! Start playing.\nCricket Game Started. Enjoy the game!\nCricket Game Finished!\n\nFootball Game Initialized! Start playing.\nFootball Game Started. Enjoy the game!\nFootball Game Finished!\n```","tags":["DesignPatterns"]},{"title":"访问者模式","url":"/2020/06/13/访问者模式/","content":"\n#### 访问者\n\n------\n\n> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n>\n> <!--more-->\n\n# 访问者模式\n\n在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。\n\n## 介绍\n\n**意图：**主要将数据结构与数据操作分离。\n\n**主要解决：**稳定的数据结构和易变的操作耦合问题。\n\n**何时使用：**需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。\n\n**如何解决：**在被访问的类里面加一个对外提供接待访问者的接口。\n\n**关键代码：**在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。\n\n**应用实例：**您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。\n\n**优点：** 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。\n\n**缺点：** 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。\n\n**使用场景：** 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。\n\n**注意事项：**访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。\n\n## 实现\n\n我们将创建一个定义接受操作的 *ComputerPart* 接口。*Keyboard*、*Mouse*、*Monitor* 和 *Computer* 是实现了 *ComputerPart* 接口的实体类。我们将定义另一个接口 *ComputerPartVisitor*，它定义了访问者类的操作。*Computer* 使用实体访问者来执行相应的动作。\n\n*VisitorPatternDemo*，我们的演示类使用 *Computer*、*ComputerPartVisitor* 类来演示访问者模式的用法。\n\n![访问者模式的 UML 图](1.jpg)\n\n### 步骤 1\n\n定义一个表示元素的接口。\n\nComputerPart.java\n\n```java\npublic interface ComputerPart {\n   public void accept(ComputerPartVisitor computerPartVisitor);\n}\n```\n\n\n\n### 步骤 2\n\n创建扩展了上述类的实体类。\n\n*Keyboard.java*\n\n```java\npublic class Keyboard  implements ComputerPart {\n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n*Monitor.java*\n\n```java\npublic class Monitor  implements ComputerPart {\n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n*Mouse.java*\n\n```java\npublic class Mouse  implements ComputerPart {\n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n*Computer.java*\n\n```java\npublic class Computer implements ComputerPart {\n   \n   ComputerPart[] parts;\n \n   public Computer(){\n      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      \n   } \n \n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      for (int i = 0; i < parts.length; i++) {\n         parts[i].accept(computerPartVisitor);\n      }\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n\n\n### 步骤 3\n\n定义一个表示访问者的接口。\n\n*ComputerPartVisitor.java*\n\n```java\npublic interface ComputerPartVisitor {\n   public void visit(Computer computer);\n   public void visit(Mouse mouse);\n   public void visit(Keyboard keyboard);\n   public void visit(Monitor monitor);\n}\n```\n\n\n\n### 步骤 4\n\n创建实现了上述类的实体访问者。\n\n*ComputerPartDisplayVisitor.java*\n\n```java\npublic class ComputerPartDisplayVisitor implements ComputerPartVisitor {\n \n   @Override\n   public void visit(Computer computer) {\n      System.out.println(\"Displaying Computer.\");\n   }\n \n   @Override\n   public void visit(Mouse mouse) {\n      System.out.println(\"Displaying Mouse.\");\n   }\n \n   @Override\n   public void visit(Keyboard keyboard) {\n      System.out.println(\"Displaying Keyboard.\");\n   }\n \n   @Override\n   public void visit(Monitor monitor) {\n      System.out.println(\"Displaying Monitor.\");\n   }\n}\n```\n\n\n\n### 步骤 5\n\n使用 *ComputerPartDisplayVisitor* 来显示 *Computer* 的组成部分。\n\n*VisitorPatternDemo.java*\n\n```java\npublic class VisitorPatternDemo {\n   public static void main(String[] args) {\n \n      ComputerPart computer = new Computer();\n      computer.accept(new ComputerPartDisplayVisitor());\n   }\n}\n```\n\n\n\n### 步骤 6\n\n执行程序，输出结果：\n\n```\nDisplaying Mouse.\nDisplaying Keyboard.\nDisplaying Monitor.\nDisplaying Computer.\n```","tags":["DesignPatterns"]},{"title":"策略模式","url":"/2020/06/13/策略模式/","content":"\n#### 策略\n\n------\n\n> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\n>\n> <!--more-->\n\n**策略模式：Strategy**，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。\n\n策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过`Arrays.sort()`实现忽略大小写排序：\n\n```java\nimport java.util.Arrays; `\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        String[] array = { \"apple\", \"Pear\", \"Banana\", \"orange\" };\n        Arrays.sort(array, String::compareToIgnoreCase);\n        System.out.println(Arrays.toString(array));\n    }\n}\n```\n\n\n\n如果我们想忽略大小写排序，就传入`String::compareToIgnoreCase`，如果我们想倒序排序，就传入`(s1, s2) -> -s1.compareTo(s2)`，这个比较两个元素大小的算法就是策略。\n\n我们观察`Arrays.sort(T[] a, Comparator c)`这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的`Comparator`对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。\n\n因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。\n\n如果我们自己实现策略模式的排序，用冒泡法编写如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        String[] array = { \"apple\", \"Pear\", \"Banana\", \"orange\" };\n        sort(array, String::compareToIgnoreCase);\n        System.out.println(Arrays.toString(array));\n    }\n\n    static <T> void sort(T[] a, Comparator<? super T> c) {\n        for (int i = 0; i < a.length - 1; i++) {\n            for (int j = 0; j < a.length - 1 - i; j++) {\n                if (c.compare(a[j], a[j + 1]) > 0) { // 注意这里比较两个元素的大小依赖传入的策略\n                    T temp = a[j];\n                    a[j] = a[j + 1];\n                    a[j + 1] = temp;\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：\n\n```java\npublic interface DiscountStrategy {\n    // 计算折扣额度:\n    BigDecimal getDiscount(BigDecimal total);\n}\n```\n\n接下来，就是实现各种策略。普通用户策略如下：\n\n```java\npublic class UserDiscountStrategy implements DiscountStrategy {\n    public BigDecimal getDiscount(BigDecimal total) {\n        // 普通会员打九折:\n        return total.multiply(new BigDecimal(\"0.1\")).setScale(2, RoundingMode.DOWN);\n    }\n}\n```\n\n满减策略如下：\n\n```java\npublic class OverDiscountStrategy implements DiscountStrategy {\n    public BigDecimal getDiscount(BigDecimal total) {\n        // 满100减20优惠:\n        return total.compareTo(BigDecimal.valueOf(100)) >= 0 ? BigDecimal.valueOf(20) : BigDecimal.ZERO;\n    }\n}\n```\n\n最后，要应用策略，我们需要一个`DiscountContext`：\n\n```java\npublic class DiscountContext {\n    // 持有某个策略:\n    private DiscountStrategy strategy = new UserDiscountStrategy();\n\n    // 允许客户端设置新策略:\n    public void setStrategy(DiscountStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public BigDecimal calculatePrice(BigDecimal total) {\n        return total.subtract(this.strategy.getDiscount(total)).setScale(2);\n    }\n}\n```\n\n调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：\n\n```java\nDiscountContext ctx = new DiscountContext();\n\n// 默认使用普通会员折扣:\nBigDecimal pay1 = ctx.calculatePrice(BigDecimal.valueOf(105));\nSystem.out.println(pay1);\n\n// 使用满减折扣:\nctx.setStrategy(new OverDiscountStrategy());\nBigDecimal pay2 = ctx.calculatePrice(BigDecimal.valueOf(105));\nSystem.out.println(pay2);\n\n// 使用Prime会员折扣:\nctx.setStrategy(new PrimeDiscountStrategy());\nBigDecimal pay3 = ctx.calculatePrice(BigDecimal.valueOf(105));\nSystem.out.println(pay3);\n```\n\n上述完整的策略模式如下图所示：\n\n```ascii\n┌───────────────┐      ┌─────────────────┐\n│DiscountContext│─ ─ ─>│DiscountStrategy │\n└───────────────┘      └─────────────────┘\n                                ▲\n                                │ ┌─────────────────────┐\n                                ├─│UserDiscountStrategy │\n                                │ └─────────────────────┘\n                                │ ┌─────────────────────┐\n                                ├─│PrimeDiscountStrategy│\n                                │ └─────────────────────┘\n                                │ ┌─────────────────────┐\n                                └─│OverDiscountStrategy │\n                                  └─────────────────────┘\n```\n\n策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。","tags":["DesignPatterns"]},{"title":"状态模式","url":"/2020/06/13/状态模式/","content":"\n#### 状态\n\n------\n\n> 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n>\n> <!--more-->\n\n**状态模式（State）**经常用在带有状态的对象中。\n\n什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：\n\n- 离线状态（尚未登录）；\n- 正在登录状态；\n- 在线状态；\n- 忙状态（暂时离开）。\n\n如何表示状态？我们定义一个`enum`就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：\n\n```java\nif (state == ONLINE) {\n    // 闪烁图标\n} else if (state == BUSY) {\n    reply(\"现在忙，稍后回复\");\n} else if ...\n```\n\n状态模式的目的是为了把上述一大串`if...else...`的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。\n\n例如，我们设计一个聊天机器人，它有两个状态：\n\n- 未连线；\n- 已连线。\n\n对于未连线状态，我们收到消息也不回复：\n\n```java\npublic class DisconnectedState implements State {\n    public String init() {\n        return \"Bye!\";\n    }\n\n    public String reply(String input) {\n        return \"\";\n    }\n}\n```\n\n对于已连线状态，我们回应收到的消息：\n\n```java\npublic class ConnectedState implements State {\n    public String init() {\n        return \"Hello, I'm Bob.\";\n    }\n\n    public String reply(String input) {\n        if (input.endsWith(\"?\")) {\n            return \"Yes. \" + input.substring(0, input.length() - 1) + \"!\";\n        }\n        if (input.endsWith(\".\")) {\n            return input.substring(0, input.length() - 1) + \"!\";\n        }\n        return input.substring(0, input.length() - 1) + \"?\";\n    }\n}\n```\n\n状态模式的关键设计思想在于状态切换，我们引入一个`BotContext`完成状态切换：\n\n```java\npublic class BotContext {\n\tprivate State state = new DisconnectedState();\n\n\tpublic String chat(String input) {\n\t\tif (\"hello\".equalsIgnoreCase(input)) {\n            // 收到hello切换到在线状态:\n\t\t\tstate = new ConnectedState();\n\t\t\treturn state.init();\n\t\t} else if (\"bye\".equalsIgnoreCase(input)) {\n            /  收到bye切换到离线状态:\n\t\t\tstate = new DisconnectedState();\n\t\t\treturn state.init();\n\t\t}\n\t\treturn state.reply(input);\n\t}\n}\n```\n\n这样，一个价值千万的AI聊天机器人就诞生了：\n\n```java\nScanner scanner = new Scanner(System.in);\nBotContext bot = new BotContext();\nfor (;;) {\n    System.out.print(\"> \");\n    String input = scanner.nextLine();\n    String output = bot.chat(input);\n    System.out.println(output.isEmpty() ? \"(no reply)\" : \"< \" + output);\n}\n```\n\n试试效果：\n\n```java\n> hello\n< Hello, I'm Bob.\n> Nice to meet you.\n< Nice to meet you!\n> Today is cold?\n< Yes. Today is cold!\n> bye\n< Bye!\n```","tags":["DesignPatterns"]},{"title":"观察者模式","url":"/2020/06/13/观察者模式/","content":"\n#### 观察者\n\n------\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n>\n> <!--more-->\n\n观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。\n\n要理解观察者模式，我们还是看例子。\n\n假设一个电商网站，有多种`Product`（商品），同时，`Customer`（消费者）和`Admin`（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，`Store`（商场）可以这么写：\n\n```java\npublic class Store {\n    Customer customer;\n    Admin admin;\n\n    private Map<String, Product> products = new HashMap<>();\n\n    public void addNewProduct(String name, double price) {\n        Product p = new Product(name, price);\n        products.put(p.getName(), p);\n        // 通知用户:\n        customer.onPublished(p);\n        // 通知管理员:\n        admin.onPublished(p);\n    }\n\n    public void setProductPrice(String name, double price) {\n        Product p = products.get(name);\n        p.setPrice(price);\n        // 通知用户:\n        customer.onPriceChanged(p);\n        // 通知管理员:\n        admin.onPriceChanged(p);\n    }\n}\n```\n\n我们观察上述`Store`类的问题：它直接引用了`Customer`和`Admin`。先不考虑多个`Customer`或多个`Admin`的问题，上述`Store`类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，`Store`类就必须继续改动。\n\n因此，上述问题的本质是`Store`希望发送通知给那些关心`Product`的对象，但`Store`并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。\n\n要实现这一目标也很简单，`Store`不能直接引用`Customer`和`Admin`，相反，它引用一个`ProductObserver`接口，任何人想要观察`Store`，只要实现该接口，并且把自己注册到`Store`即可：\n\n```java\npublic class Store {\n    private List<ProductObserver> observers = new ArrayList<>();\n    private Map<String, Product> products = new HashMap<>();\n\n    // 注册观察者:\n    public void addObserver(ProductObserver observer) {\n        this.observers.add(observer);\n    }\n\n    // 取消注册:\n    public void removeObserver(ProductObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    public void addNewProduct(String name, double price) {\n        Product p = new Product(name, price);\n        products.put(p.getName(), p);\n        // 通知观察者:\n        observers.forEach(o -> o.onPublished(p));\n    }\n\n    public void setProductPrice(String name, double price) {\n        Product p = products.get(name);\n        p.setPrice(price);\n        // 通知观察者:\n        observers.forEach(o -> o.onPriceChanged(p));\n    }\n}\n```\n\n就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：\n\n```java\n// observer:\nAdmin a = new Admin();\nCustomer c = new Customer();\n// store:\nStore store = new Store();\n// 注册观察者:\nstore.addObserver(a);\nstore.addObserver(c);\n```\n\n甚至可以注册匿名观察者：\n\n```java\nstore.addObserver(new ProductObserver() {\n    public void onPublished(Product product) {\n        System.out.println(\"[Log] on product published: \" + product);\n    }\n\n    public void onPriceChanged(Product product) {\n        System.out.println(\"[Log] on product price changed: \" + product);\n    }\n});\n```\n\n用一张图画出观察者模式：\n\n```ascii\n┌─────────┐      ┌───────────────┐\n│  Store  │─ ─ ─>│ProductObserver│\n└─────────┘      └───────────────┘\n     │                   ▲\n                         │\n     │             ┌─────┴─────┐\n     ▼             │           │\n┌─────────┐   ┌─────────┐ ┌─────────┐\n│ Product │   │  Admin  │ │Customer │ ...\n└─────────┘   └─────────┘ └─────────┘\n```\n\n观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：\n\n```java\npublic interface ProductObservable { // 注意此处拼写是Observable不是Observer!\n    void addObserver(ProductObserver observer);\n    void removeObserver(ProductObserver observer);\n}\n```\n\n对应的实体被观察者就要实现该接口：\n\n```java\npublic class Store implements ProductObservable {\n    ...\n}\n```\n\n有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：\n\n```java\npublic interface ProductObserver {\n    void onEvent(ProductEvent event);\n}\n```\n\n让观察者自己从Event对象中读取通知类型和通知数据。\n\n广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：\n\n```ascii\n                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n                   Messaging System\n                 │                       │\n                   ┌──────────────────┐\n              ┌──┼>│Topic:newProduct  │──┼─┐    ┌─────────┐\n              │    └──────────────────┘    ├───>│ConsumerA│\n┌─────────┐   │  │ ┌──────────────────┐  │ │    └─────────┘\n│Producer │───┼───>│Topic:priceChanged│────┘\n└─────────┘   │  │ └──────────────────┘  │\n              │    ┌──────────────────┐         ┌─────────┐\n              └──┼>│Topic:soldOut     │──┼─────>│ConsumerB│\n                   └──────────────────┘         └─────────┘\n                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\n消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。\n\n使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。\n\n此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：\n\n```java\nobservers.forEach(o -> o.onPublished(p));\n```\n\n这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。\n\n思考：如何改成异步通知，使得所有观察者可以并发同时处理？\n\n有的童鞋可能发现Java标准库有个`java.util.Observable`类和一个`Observer`接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。","tags":["DesignPatterns"]},{"title":"备忘录模式","url":"/2020/06/13/备忘录模式/","content":"\n#### 备忘录模式\n\n------\n\n> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n>\n> <!--more-->\n\n**备忘录模式（Memento）**，主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。\n\n其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把`TextEditor`类的字符串存储到文件，打开就是恢复`TextEditor`类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。\n\n在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把`TextEditor`类的字符串复制一份存起来，这样就可以Undo或Redo。\n\n标准的备忘录模式有这么几种角色：\n\n- Memonto：存储的内部状态；\n- Originator：创建一个备忘录并设置其状态；\n- Caretaker：负责保存备忘录。\n\n实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似`TextEditor`的类，增加`getState()`和`setState()`就可以了。\n\n我们以一个文本编辑器`TextEditor`为例，它内部使用`StringBuilder`允许用户增删字符：\n\n```java\npublic class TextEditor {\n    private StringBuilder buffer = new StringBuilder();\n\n    public void add(char ch) {\n        buffer.append(ch);\n    }\n\n    public void add(String s) {\n        buffer.append(s);\n    }\n\n    public void delete() {\n        if (buffer.length() > 0) {\n            buffer.deleteCharAt(buffer.length() - 1);\n        }\n    }\n}\n```\n\n为了支持这个`TextEditor`能保存和恢复状态，我们增加`getState()`和`setState()`两个方法：\n\n```java\npublic class TextEditor {\n    ...\n\n    // 获取状态:\n    public String getState() {\n        return buffer.toString();\n    }\n\n    // 恢复状态:\n    public void setState(String state) {\n        this.buffer.delete(0, this.buffer.length());\n        this.buffer.append(state);\n    }\n}\n```\n\n对这个简单的文本编辑器，用一个`String`就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。","tags":["DesignPatterns"]},{"title":"中介者模式","url":"/2020/06/13/中介者模式/","content":"\n# 中介者模式\n\n>  中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。\n>\n> <!--more-->\n\n## 介绍\n\n**意图：**用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n**主要解决：**对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。\n\n**何时使用：**多个类相互耦合，形成了网状结构。\n\n**如何解决：**将上述网状结构分离为星型结构。\n\n**关键代码：**对象 Colleague 之间的通信封装到一个类中单独处理。\n\n**应用实例：** 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。\n\n**优点：** 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。\n\n**缺点：**中介者会庞大，变得复杂难以维护。\n\n**使用场景：** 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。\n\n**注意事项：**不应当在职责混乱的时候使用。\n\n## 实现\n\n我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 *ChatRoom* 和 *User*。*User* 对象使用 *ChatRoom* 方法来分享他们的消息。\n\n*MediatorPatternDemo*，我们的演示类使用 *User* 对象来显示他们之间的通信。\n\n![中介者模式的 UML 图](1.jpg)\n\n### 步骤 1\n\n创建中介类。\n\nChatRoom.java\n\n![img](2.png)\n\n### 步骤 2\n\n创建 user 类。\n\nUser.java\n\n![img](3.png)\n\n### 步骤 3\n\n使用 *User* 对象来显示他们之间的通信。\n\nMediatorPatternDemo.java\n\n![img](4.png)\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```c\nThu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!\nThu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!\n```","tags":["DesignPatterns"]},{"title":"迭代器模式","url":"/2020/06/13/迭代器模式/","content":"\n### 迭代器\n\n------\n\n> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n>\n> <!--more-->\n\n**迭代器模式（Iterator）**实际上在Java的集合类中已经广泛使用了。我们以`List`为例，要遍历`ArrayList`，即使我们知道它的内部存储了一个`Object[]`数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用`Iterator`遍历，那么，`ArrayList`和`LinkedList`都可以以一种统一的接口来遍历：\n\n```java\nList<String> list = ...\nfor (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n    String s = it.next();\n}\n```\n\n实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持`Iterator`的集合对象用`foreach`循环写出来：\n\n```java\nList<String> list = ...\nfor (String s : list) {\n\n}\n```\n\n然后由Java编译器完成Iterator模式的所有循环代码。\n\n虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：\n\n```java\npublic class ReverseArrayCollection<T> implements Iterable<T> {\n    // 以数组形式持有集合:\n    private T[] array;\n\n    public ReverseArrayCollection(T... objs) {\n        this.array = Arrays.copyOfRange(objs, 0, objs.length);\n    }\n\n    public Iterator<T> iterator() {\n        return ???;\n    }\n}\n```\n\n实现Iterator模式的关键是返回一个`Iterator`对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个`Iterator`：\n\n```java\npublic class ReverseArrayCollection<T> implements Iterable<T> {\n    private T[] array;\n\n    public ReverseArrayCollection(T... objs) {\n        this.array = Arrays.copyOfRange(objs, 0, objs.length);\n    }\n\n    public Iterator<T> iterator() {\n        return new ReverseIterator();\n    }\n\n    class ReverseIterator implements Iterator<T> {\n        // 索引位置:\n        int index;\n\n        public ReverseIterator() {\n            // 创建Iterator时,索引在数组末尾:\n            this.index = ReverseArrayCollection.this.array.length;\n        }\n\n        public boolean hasNext() {\n            // 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):\n            return index > 0;\n        }\n\n        public T next() {\n            // 将索引移动到下一个元素并返回(倒序往前移动):\n            index--;\n            return array[index];\n        }\n    }\n}\n```\n\n使用内部类的好处是内部类隐含地持有一个它所在对象的`this`引用，可以通过`ReverseArrayCollection.this`引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出`ConcurrentModificationException`，就需要更仔细地设计。","tags":["DesignPatterns"]},{"title":"解释器模式","url":"/2020/06/12/解释器模式/","content":"\n# 解释器模式\n\n> 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n\n<!--more-->\n\n## 介绍\n\n**意图：**给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n\n**主要解决：**对于一些固定文法构建一个解释句子的解释器。\n\n**何时使用：**如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n**如何解决：**构建语法树，定义终结符与非终结符。\n\n**关键代码：**构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。\n\n**应用实例：**编译器、运算表达式计算。\n\n**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。\n\n**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。\n\n**使用场景：** 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。\n\n**注意事项：**可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。\n\n## 实现\n\n我们将创建一个接口 *Expression* 和实现了 *Expression* 接口的实体类。定义作为上下文中主要解释器的 *TerminalExpression* 类。其他的类 *OrExpression*、*AndExpression* 用于创建组合式表达式。\n\n*InterpreterPatternDemo*，我们的演示类使用 *Expression* 类创建规则和演示表达式的解析。\n\n![解释器模式的 UML 图](6.jpg)\n\n### 步骤 1\n\n创建一个表达式接口。\n\n![img](1.png)\n\n### 步骤 2\n\n创建实现了上述接口的实体类。\n\n![img](2.png)\n\n![img](3.png)\n\n![img](4.png)\n\n### 步骤 3\n\n*InterpreterPatternDemo* 使用 *Expression* 类来创建规则，并解析它们。\n\n![img](5.png)\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```\nJohn is male? true\nJulie is a married women? true\n```","tags":["DesignPatterns"]},{"title":"命令模式","url":"/2020/06/12/命令模式/","content":"\n## 命令模式\n\n> **命令模式（Command Pattern）**是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n\n<!--more-->\n\n### 介绍\n\n**意图：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n\n**主要解决：**在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n\n**何时使用：**在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n\n**如何解决：**通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n\n**关键代码：**定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n\n**应用实例：**struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n\n**优点：** \t1、降低了系统耦合度。 \n\n​\t\t\t\t2、新的命令可以很容易添加到系统中去。\n\n**缺点：**\t使用命令模式可能会导致某些系统有过多的具体命令类。\n\n**使用场景：**认为是命令的地方都可以使用命令模式，\n\n比如： \n\n​\t1、GUI 中每一个按钮都是一条命令。 \n\n​\t2、模拟 CMD。\n\n**注意事项：**系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n\n### 实现\n\n我们首先创建作为命令的接口 *Order*，然后创建作为请求的 *Stock* 类。实体命令类 *BuyStock* 和 *SellStock*，实现了 *Order* 接口，将执行实际的命令处理。创建作为调用对象的类 *Broker*，它接受订单并能下订单。\n\n*Broker* 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。*CommandPatternDemo*，我们的演示类使用 *Broker* 类来演示命令模式。\n\n![命令模式的 UML 图](1.jpg)\n\n#### 步骤1\n\n创建一个命令接口。\n\n##### Order.java\n\n```java\npublic interface Order {\n   void execute();\n}\n```\n\n#### 步骤 2\n\n创建一个请求类。\n\n##### Stock.java\n\n```java\npublic class Stock {\n   \n   private String name = \"ABC\";\n   private int quantity = 10;\n \n   public void buy(){\n      System.out.println(\"Stock [ Name: \"+name+\", \n         Quantity: \" + quantity +\" ] bought\");\n   }\n   public void sell(){\n      System.out.println(\"Stock [ Name: \"+name+\", \n         Quantity: \" + quantity +\" ] sold\");\n   }\n}\n```\n\n\n\n#### 步骤 3\n\n创建实现了 *Order* 接口的实体类。\n\n##### BuyStock.java\n\n```java\npublic class BuyStock implements Order {\n   private Stock abcStock;\n \n   public BuyStock(Stock abcStock){\n      this.abcStock = abcStock;\n   }\n \n   public void execute() {\n      abcStock.buy();\n   }\n}\n```\n\n\n\n##### SellStock.java\n\n```java\npublic class SellStock implements Order {\n   private Stock abcStock;\n \n   public SellStock(Stock abcStock){\n      this.abcStock = abcStock;\n   }\n \n   public void execute() {\n      abcStock.sell();\n   }\n}\n```\n\n\n\n#### 步骤 4\n\n创建命令调用类。\n\n##### Broker.java\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Broker {\n   private List<Order> orderList = new ArrayList<Order>(); \n \n   public void takeOrder(Order order){\n      orderList.add(order);      \n   }\n \n   public void placeOrders(){\n      for (Order order : orderList) {\n         order.execute();\n      }\n      orderList.clear();\n   }\n}\n```\n\n\n\n使用 Broker 类来接受并执行命令。\n\n##### CommandPatternDemo.java\n\n```java\npublic class CommandPatternDemo {\n   public static void main(String[] args) {\n      Stock abcStock = new Stock();\n \n      BuyStock buyStockOrder = new BuyStock(abcStock);\n      SellStock sellStockOrder = new SellStock(abcStock);\n \n      Broker broker = new Broker();\n      broker.takeOrder(buyStockOrder);\n      broker.takeOrder(sellStockOrder);\n \n      broker.placeOrders();\n   }\n}\n```\n\n\n\n#### 步骤 6\n\n执行程序，输出结果：\n\n```\nStock [ Name: ABC, Quantity: 10 ] bought\nStock [ Name: ABC, Quantity: 10 ] sold\n```","tags":["DesignPatterns"]},{"title":"责任链模式","url":"/2020/06/11/责任链模式/","content":"\n### 责任链模式\n\n> **责任链模式（Chain of Responsibility Pattern）**为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 \n\n<!--more-->\n\n### 介绍\n\n**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\n\n**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。\n\n**何时使用：**在处理消息的时候以过滤很多道。\n\n**如何解决：**拦截的类都实现统一接口。\n\n**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。\n\n**应用实例：** 1、红楼梦中的\"击鼓传花\"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。\n\n**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。\n\n**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。\n\n**使用场景：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。\n\n**注意事项：**在 JAVA WEB 中遇到很多应用。\n\n---\n\n## 实现\n\n我们创建抽象类 *AbstractLogger*，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 *AbstractLogger*。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。\n\n![责任链模式的 UML 图](1.jpg)\n\n### 步骤1\n\n创建抽象的记录器类。\n\n##### AbstractLogger.java\n\n```java\npublic abstract class AbstractLogger {\n   public static int INFO = 1;\n   public static int DEBUG = 2;\n   public static int ERROR = 3;\n \n   protected int level;\n \n   //责任链中的下一个元素\n   protected AbstractLogger nextLogger;\n \n   public void setNextLogger(AbstractLogger nextLogger){\n      this.nextLogger = nextLogger;\n   }\n \n   public void logMessage(int level, String message){\n      if(this.level <= level){\n         write(message);\n      }\n      if(nextLogger !=null){\n         nextLogger.logMessage(level, message);\n      }\n   }\n \n   abstract protected void write(String message);\n   \n}\n```\n\n\n\n### 步骤 2\n\n创建扩展了该记录器类的实体类。\n\n##### ConsoleLogger.java\n\n```java\npublic class ConsoleLogger extends AbstractLogger {\n \n   public ConsoleLogger(int level){\n      this.level = level;\n   }\n \n   @Override\n   protected void write(String message) {    \n      System.out.println(\"Standard Console::Logger: \" + message);\n   }\n}\n```\n\n\n\n##### ErrorLogger.java\n\n```java\npublic class ErrorLogger extends AbstractLogger {\n \n   public ErrorLogger(int level){\n      this.level = level;\n   }\n \n   @Override\n   protected void write(String message) {    \n      System.out.println(\"Error Console::Logger: \" + message);\n   }\n}\n```\n\n\n\n##### FileLogger.java\n\n```java\npublic class FileLogger extends AbstractLogger {\n \n   public FileLogger(int level){\n      this.level = level;\n   }\n \n   @Override\n   protected void write(String message) {    \n      System.out.println(\"File::Logger: \" + message);\n   }\n}\n```\n\n\n\n### 步骤 3\n\n创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。\n\n##### ChainPatternDemo.java\n\n```java\npublic class ChainPatternDemo {\n   \n   private static AbstractLogger getChainOfLoggers(){\n \n      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);\n      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);\n      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);\n \n      errorLogger.setNextLogger(fileLogger);\n      fileLogger.setNextLogger(consoleLogger);\n \n      return errorLogger;  \n   }\n \n   public static void main(String[] args) {\n      AbstractLogger loggerChain = getChainOfLoggers();\n \n      loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\");\n \n      loggerChain.logMessage(AbstractLogger.DEBUG, \n         \"This is a debug level information.\");\n \n      loggerChain.logMessage(AbstractLogger.ERROR, \n         \"This is an error information.\");\n   }\n}\n```\n\n\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```java\nStandard Console::Logger: This is an information.\nFile::Logger: This is a debug level information.\nStandard Console::Logger: This is a debug level information.\nError Console::Logger: This is an error information.\nFile::Logger: This is an error information.\nStandard Console::Logger: This is an error information.\n```","tags":["DesignPatterns"]},{"title":"RESUME","url":"/2020/06/11/简历/","content":"\n# RESUME\n\n<!--more-->\n\n\n\n![img](0001.jpg)\n\n\n\n","tags":["resume"]},{"title":"代理模式","url":"/2020/06/09/代理模式/","content":"\n### 代理模式\n\n> *为其他对象提供一种代理以控制对这个对象的访问。* \n>\n> <!--more-->\n\n在**代理模式（Proxy Pattern）**中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。\n\n在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n\n\n## 介绍\n\n**意图：**为其他对象提供一种代理以控制对这个对象的访问。\n\n**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n\n**何时使用：**想在访问一个类时做一些控制。\n\n**如何解决：**增加中间层。\n\n**关键代码：**实现与被代理类组合。\n\n**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。\n\n**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。\n\n**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。\n\n**注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n## 实现\n\n我们将创建一个 *Image* 接口和实现了 *Image* 接口的实体类。*ProxyImage* 是一个代理类，减少 *RealImage* 对象加载的内存占用。\n\n*ProxyPatternDemo*，我们的演示类使用 *ProxyImage* 来获取要加载的 *Image* 对象，并按照需求进行显示。\n\n![代理模式的 UML 图](代理模式.jpg)\n\n\n\n- \n\n代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：\n\n```java\npublic BAdapter implements B {\n    private A a;\n    public BAdapter(A a) {\n        this.a = a;\n    }\n    public void b() {\n        a.a();\n    }\n}\n```\n\n而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：\n\n```java\npublic AProxy implements A {\n    private A a;\n    public AProxy(A a) {\n        this.a = a;\n    }\n    public void a() {\n        this.a.a();\n    }\n}\n```\n\n合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？\n\n当然不是。我们观察Proxy的实现A接口的方法：\n\n```java\npublic void a() {\n    this.a.a();\n}\n```\n\n这样写当然没啥卵用。但是，如果我们在调用`a.a()`的前后，加一些额外的代码：\n\n```java\npublic void a() {\n    if (getCurrentUser().isRoot()) {\n        this.a.a();\n    } else {\n        throw new SecurityException(\"Forbidden\");\n    }\n}\n```\n\n这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。\n\n有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？\n\n因为我们编写代码的原则有：\n\n- 职责清晰：一个类只负责一件事；\n- 易于测试：一次只测一个功能。\n\n用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：\n\n- A接口：只定义接口；\n- ABusiness类：只实现A接口的业务逻辑；\n- APermissionProxy类：只实现A接口的权限检查代理。\n\n如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。\n\n实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：\n\n### 远程代理\n\n远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。\n\n### 虚代理\n\n虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。\n\n### 保护代理\n\n保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。\n\n### 智能引用\n\n智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。\n\n我们来看一下如何应用代理模式编写一个JDBC连接池（`DataSource`）。我们首先来编写一个虚代理，即如果调用者获取到`Connection`后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：\n\n```java\nDataSource lazyDataSource = new LazyDataSource(jdbcUrl, jdbcUsername, jdbcPassword);\nSystem.out.println(\"get lazy connection...\");\ntry (Connection conn1 = lazyDataSource.getConnection()) {\n    // 并没有实际打开真正的Connection\n}\nSystem.out.println(\"get lazy connection...\");\ntry (Connection conn2 = lazyDataSource.getConnection()) {\n    try (PreparedStatement ps = conn2.prepareStatement(\"SELECT * FROM students\")) { // 打开了真正的Connection\n        try (ResultSet rs = ps.executeQuery()) {\n            while (rs.next()) {\n                System.out.println(rs.getString(\"name\"));\n            }\n        }\n    }\n}\n```\n\n现在我们来思考如何实现这个`LazyConnectionProxy`。为了简化代码，我们首先针对`Connection`接口做一个抽象的代理类：\n\n```java\npublic abstract class AbstractConnectionProxy implements Connection {\n\n    // 抽象方法获取实际的Connection:\n    protected abstract Connection getRealConnection();\n\n    // 实现Connection接口的每一个方法:\n    public Statement createStatement() throws SQLException {\n        return getRealConnection().createStatement();\n    }\n\n    public PreparedStatement prepareStatement(String sql) throws SQLException {\n        return getRealConnection().prepareStatement(sql);\n    }\n\n    ...其他代理方法...\n}\n```\n\n这个`AbstractConnectionProxy`代理类的作用是把`Connection`接口定义的方法全部实现一遍，因为`Connection`接口定义的方法太多了，后面我们要编写的`LazyConnectionProxy`只需要继承`AbstractConnectionProxy`，就不必再把`Connection`接口方法挨个实现一遍。\n\n`LazyConnectionProxy`实现如下：\n\n```java\npublic class LazyConnectionProxy extends AbstractConnectionProxy {\n    private Supplier<Connection> supplier;\n    private Connection target = null;\n\n    public LazyConnectionProxy(Supplier<Connection> supplier) {\n        this.supplier = supplier;\n    }\n\n    // 覆写close方法：只有target不为null时才需要关闭:\n    public void close() throws SQLException {\n        if (target != null) {\n            System.out.println(\"Close connection: \" + target);\n            super.close();\n        }\n    }\n\n    @Override\n    protected Connection getRealConnection() {\n        if (target == null) {\n            target = supplier.get();\n        }\n        return target;\n    }\n}\n```\n\n如果调用者没有执行任何SQL语句，那么`target`字段始终为`null`。只有第一次执行SQL语句时（即调用任何类似`prepareStatement()`方法时，触发`getRealConnection()`调用），才会真正打开实际的JDBC Connection。\n\n最后，我们还需要编写一个`LazyDataSource`来支持这个`LazyConnecitonProxy`：\n\n```java\npublic class LazyDataSource implements DataSource {\n    private String url;\n    private String username;\n    private String password;\n\n    public LazyDataSource(String url, String username, String password) {\n        this.url = url;\n        this.username = username;\n        this.password = password;\n    }\n\n    public Connection getConnection(String username, String password) throws SQLException {\n        return new LazyConnectionProxy(() -> {\n            try {\n                Connection conn = DriverManager.getConnection(url, username, password);\n                System.out.println(\"Open connection: \" + conn);\n                return conn;\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    ...\n}\n```\n\n我们执行代码，输出如下：\n\n```java\nget lazy connection...\nget lazy connection...\nOpen connection: com.mysql.jdbc.JDBC4Connection@7a36aefa\n小明\n小红\n小军\n小白\n...\nClose connection: com.mysql.jdbc.JDBC4Connection@7a36aefa\n```\n\n可见第一个`getConnection()`调用获取到的`LazyConnectionProxy`并没有实际打开真正的JDBC Connection。\n\n使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：\n\n```java\nDataSource pooledDataSource = new PooledDataSource(jdbcUrl, jdbcUsername, jdbcPassword);\ntry (Connection conn = pooledDataSource.getConnection()) {\n}\ntry (Connection conn = pooledDataSource.getConnection()) {\n    // 获取到的是同一个Connection\n}\ntry (Connection conn = pooledDataSource.getConnection()) {\n    // 获取到的是同一个Connection\n}\n```\n\n调用方并不关心是否复用了`Connection`，但从`PooledDataSource`获取的`Connection`确实自带这个优化功能。如何实现可复用`Connection`的连接池？答案仍然是使用代理模式。\n\n```java\npublic class PooledConnectionProxy extends AbstractConnectionProxy {\n    // 实际的Connection:\n    Connection target;\n    // 空闲队列:\n    Queue<PooledConnectionProxy> idleQueue;\n\n    public PooledConnectionProxy(Queue<PooledConnectionProxy> idleQueue, Connection target) {\n        this.idleQueue = idleQueue;\n        this.target = target;\n    }\n\n    public void close() throws SQLException {\n        System.out.println(\"Fake close and released to idle queue for future reuse: \" + target);\n        // 并没有调用实际Connection的close()方法,\n        // 而是把自己放入空闲队列:\n        idleQueue.offer(this);\n    }\n\n    protected Connection getRealConnection() {\n        return target;\n    }\n}\n```\n\n复用连接的关键在于覆写`close()`方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。\n\n空闲队列由`PooledDataSource`负责维护：\n\n```java\npublic class PooledDataSource implements DataSource {\n    private String url;\n    private String username;\n    private String password;\n\n    // 维护一个空闲队列:\n    private Queue<PooledConnectionProxy> idleQueue = new ArrayBlockingQueue<>(100);\n\n    public PooledDataSource(String url, String username, String password) {\n        this.url = url;\n        this.username = username;\n        this.password = password;\n    }\n\n    public Connection getConnection(String username, String password) throws SQLException {\n        // 首先试图获取一个空闲连接:\n        PooledConnectionProxy conn = idleQueue.poll();\n        if (conn == null) {\n            // 没有空闲连接时，打开一个新连接:\n            conn = openNewConnection();\n        } else {\n            System.out.println(\"Return pooled connection: \" + conn.target);\n        }\n        return conn;\n    }\n\n    private PooledConnectionProxy openNewConnection() throws SQLException {\n        Connection conn = DriverManager.getConnection(url, username, password);\n        System.out.println(\"Open new connection: \" + conn);\n        return new PooledConnectionProxy(idleQueue, conn);\n    }\n    ...\n}\n```\n\n我们执行调用方代码，输出如下：\n\n```shell\nOpen new connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nFake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nReturn pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nFake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nReturn pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nFake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa\n```\n\n除了第一次打开了一个真正的JDBC Connection，后续获取的`Connection`实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。\n\n我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。\n\n有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。\n\n\n\n\n\n","tags":["DesignPatterns"]},{"title":"享元模式","url":"/2020/06/09/享元模式/","content":"\n### 享元\n\n> *运用共享技术有效地支持大量细粒度的对象。* \n>\n> <!--more-->\n\n享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。\n\n享元模式在Java标准库中有很多应用。我们知道，包装类型如`Byte`、`Integer`都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以`Integer`为例，如果我们通过`Integer.valueOf()`这个静态工厂方法创建`Integer`实例，当传入的`int`范围在`-128`~`+127`之间时，会直接返回缓存的`Integer`实例：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Integer n1 = Integer.valueOf(100);\n        Integer n2 = Integer.valueOf(100);\n        System.out.println(n1 == n2); // true\n    }\n}\n```\n\n对于`Byte`来说，因为它一共只有256个状态，所以，通过`Byte.valueOf()`创建的`Byte`实例，全部都是缓存对象。\n\n因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。\n\n**总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。**\n\n在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。\n\n我们以`Student`为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：\n\n```java\npublic class Student {\n    // 持有缓存:\n    private static final Map<String, Student> cache = new HashMap<>();\n\n    // 静态工厂方法:\n    public static Student create(int id, String name) {\n        String key = id + \"\\n\" + name;\n        // 先查找缓存:\n        Student std = cache.get(key);\n        if (std == null) {\n            // 未找到,创建新对象:\n            System.out.println(String.format(\"create new Student(%s, %s)\", id, name));\n            std = new Student(id, name);\n            // 放入缓存:\n            cache.put(key, std);\n        } else {\n            // 缓存中存在:\n            System.out.println(String.format(\"return cached Student(%s, %s)\", std.id, std.name));\n        }\n        return std;\n    }\n\n    private final int id;\n    private final String name;\n\n    public Student(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n 在实际应用中，我们经常使用成熟的缓存库，例如`Guava`的`Cache`，因为它提供了最大缓存数量限制、定时过期等实用功能。 \n\n","tags":["DesignPatterns"]},{"title":"外观模式","url":"/2020/06/09/外观模式/","content":"\n### 外观模式\n\n> 为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n>\n> <!--more-->\n\n外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：\n\n如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。\n\n我们以注册公司为例，假设注册公司需要三步：\n\n1. 向工商局申请公司营业执照；\n2. 在银行开设账户；\n3. 在税务局开设纳税号。\n\n以下是三个系统的接口：\n\n```java\n// 工商注册:\npublic class AdminOfIndustry {\n    public Company register(String name) {\n        ...\n    }\n}\n\n// 银行开户:\npublic class Bank {\n    public String openAccount(String companyId) {\n        ...\n    }\n}\n\n// 纳税登记:\npublic class Taxation {\n    public String applyTaxCode(String companyId) {\n        ...\n    }\n}\n```\n\n如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：\n\n```java\npublic class Facade {\n    public Company openCompany(String name) {\n        Company c = this.admin.register(name);\n        String bankAccount = this.bank.openAccount(c.getId());\n        c.setBankAccount(bankAccount);\n        String taxCode = this.taxation.applyTaxCode(c.getId());\n        c.setTaxCode(taxCode);\n        return c;\n    }\n}\n```\n\n这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：\n\n```java\nCompany c = facade.openCompany(\"Facade Software Ltd.\");\n```\n\n很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个`RestApiController`，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。\n\n更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。","tags":["DesignPatterns"]},{"title":"装饰器模式","url":"/2020/06/09/装饰器模式/","content":"\n### 装饰器模式\n\n> 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。\n>\n> <!--more-->\n\n**装饰器（Decorator）**模式，是一种在运行期动态给某个对象的实例增加功能的方法。\n\n我们在IO的Filter模式一节中其实已经讲过装饰器模式了。在Java标准库中，`InputStream`是抽象类，`FileInputStream`、`ServletInputStream`、`Socket.getInputStream()`这些`InputStream`都是最终数据源。\n\n现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。\n\nDecorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。\n\n例如：给`FileInputStream`增加缓冲和解压缩功能，用Decorator模式写出来如下：\n\n```java\n// 创建原始的数据源:\nInputStream fis = new FileInputStream(\"test.gz\");\n// 增加缓冲功能:\nInputStream bis = new BufferedInputStream(fis);\n// 增加解压缩功能:\nInputStream gis = new GZIPInputStream(bis);\n```\n\n或者一次性写成这样：\n\n```java\nInputStream input = new GZIPInputStream( // 第二层装饰\n                        new BufferedInputStream( // 第一层装饰\n                            new FileInputStream(\"test.gz\") // 核心功能\n                        ));\n```\n\n观察`BufferedInputStream`和`GZIPInputStream`，它们实际上都是从`FilterInputStream`继承的，这个`FilterInputStream`就是一个抽象的Decorator。我们用图把Decorator模式画出来如下：\n\n```ascii\n             ┌───────────┐\n             │ Component │\n             └───────────┘\n                   ▲\n      ┌────────────┼─────────────────┐\n      │            │                 │\n┌───────────┐┌───────────┐     ┌───────────┐\n│ComponentA ││ComponentB │...  │ Decorator │\n└───────────┘└───────────┘     └───────────┘\n                                     ▲\n                              ┌──────┴──────┐\n                              │             │\n                        ┌───────────┐ ┌───────────┐\n                        │DecoratorA │ │DecoratorB │...\n                        └───────────┘ └───────────┘\n```\n\n最顶层的Component是接口，对应到IO的就是`InputStream`这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是`FileInputStream`、`ServletInputStream`这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是`FilterInputStream`。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是`BufferedInputStream`、`GZIPInputStream`等。\n\nDecorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指`FileInputStream`这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如`ByteInputStream`。如果我们要增加附加功能，就增加Decorator的子类，例如`CipherInputStream`。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。\n\n如果我们要自己设计完整的Decorator模式，应该如何设计？\n\n我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。\n\n首先，仍然需要定义顶层接口`TextNode`：\n\n```java\npublic interface TextNode {\n    // 设置text:\n    void setText(String text);\n    // 获取text:\n    String getText();\n}\n```\n\n对于核心节点，例如``，它需要从`TextNode`直接继承：\n\n```java\npublic class SpanNode implements TextNode {\n    private String text;\n\n    public void setText(String text) {\n        this.text = text;\n    }\n\n    public String getText() {\n        return \"<span>\" + text + \"</span>\";\n    }\n}\n```\n\n紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：\n\n```java\npublic abstract class NodeDecorator implements TextNode {\n    protected final TextNode target;\n\n    protected NodeDecorator(TextNode target) {\n        this.target = target;\n    }\n\n    public void setText(String text) {\n        this.target.setText(text);\n    }\n}\n```\n\n这个`NodeDecorator`类的核心是持有一个`TextNode`，即将要把功能附加到的`TextNode`实例。接下来就可以写一个加粗功能：\n\n```java\npublic class BoldDecorator extends NodeDecorator {\n    public BoldDecorator(TextNode target) {\n        super(target);\n    }\n\n    public String getText() {\n        return \"<b>\" + target.getText() + \"</b>\";\n    }\n}\n```\n\n类似的，可以继续加`ItalicDecorator`、`UnderlineDecorator`等。客户端可以自由组合这些Decorator：\n\n```java\nTextNode n1 = new SpanNode();\nTextNode n2 = new BoldDecorator(new UnderlineDecorator(new SpanNode()));\nTextNode n3 = new ItalicDecorator(new BoldDecorator(new SpanNode()));\nn1.setText(\"Hello\");\nn2.setText(\"Decorated\");\nn3.setText(\"World\");\nSystem.out.println(n1.getText());\n// 输出<span>Hello</span>\n\nSystem.out.println(n2.getText());\n// 输出<b><u><span>Decorated</span></u></b>\n\nSystem.out.println(n3.getText());\n// 输出<i><b><span>World</span></b></i>\n```","tags":["DesignPatterns"]},{"title":"组合模式","url":"/2020/06/09/组合模式/","content":"\n### 组合模式\n\n> 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。\n>\n> <!--more-->\n\n组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。\n\n我们来看一个具体的例子。在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。\n\n要以树的结构表示XML，我们可以先抽象出节点类型`Node`：\n\n```java\npublic interface Node {\n    // 添加一个节点为子节点:\n    Node add(Node node);\n    // 获取子节点:\n    List<Node> children();\n    // 输出为XML:\n    String toXml();\n}\n```\n\n对于一个`这样的节点，我们称之为` **`ElementNode`**，它可以作为容器包含多个子节点：\n\n```java\npublic class ElementNode implements Node {\n    private String name;\n    private List<Node> list = new ArrayList<>();\n\n    public ElementNode(String name) {\n        this.name = name;\n    }\n\n    public Node add(Node node) {\n        list.add(node);\n        return this;\n    }\n\n    public List<Node> children() {\n        return list;\n    }\n\n    public String toXml() {\n        String start = \"<\" + name + \">\\n\";\n        String end = \"</\" + name + \">\\n\";\n        StringJoiner sj = new StringJoiner(\"\", start, end);\n        list.forEach(node -> {\n            sj.add(node.toXml() + \"\\n\");\n        });\n        return sj.toString();\n    }\n}\n```\n\n对于普通文本，我们把它看作`TextNode`，它没有子节点：\n\n```java\npublic class TextNode implements Node {\n\tprivate String text;\n\n\tpublic TextNode(String text) {\n\t\tthis.text = text;\n\t}\n\n\tpublic Node add(Node node) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tpublic List<Node> children() {\n\t\treturn List.of();\n\t}\n\n\tpublic String toXml() {\n\t\treturn text;\n\t}\n}\n```\n\n此外，还可以有注释节点：\n\n```java\npublic class CommentNode implements Node {\n\tprivate String text;\n\n\tpublic CommentNode(String text) {\n\t\tthis.text = text;\n\t}\n\n\tpublic Node add(Node node) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tpublic List<Node> children() {\n\t\treturn List.of();\n\t}\n\n\tpublic String toXml() {\n\t\treturn \"<!-- \" + text + \" -->\";\n\t}\n}\n```\n\n通过`ElementNode`、`TextNode`和`CommentNode`，我们就可以构造出一颗树：\n\n```java\nNode root = new ElementNode(\"school\");\nroot.add(new ElementNode(\"classA\")\n        .add(new TextNode(\"Tom\"))\n        .add(new TextNode(\"Alice\")));\nroot.add(new ElementNode(\"classB\")\n        .add(new TextNode(\"Bob\"))\n        .add(new TextNode(\"Grace\"))\n        .add(new CommentNode(\"comment...\")));\nSystem.out.println(root.toXml());\n```\n\n最后通过`root`节点输出的XML如下：\n\n```xml\n<school>\n<classA>\nTom\nAlice\n</classA>\n<classB>\nBob\nGrace\n<!-- comment... -->\n</classB>\n</school>\n```\n\n可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：\n\n```ascii\n             ┌───────────┐\n             │   Node    │\n             └───────────┘\n                   ▲\n      ┌────────────┼────────────┐\n      │            │            │\n┌───────────┐┌───────────┐┌───────────┐\n│ElementNode││ TextNode  ││CommentNode│\n└───────────┘└───────────┘└───────────┘\n```\n\n作为容器节点的`ElementNode`又可以添加任意个`Node`，这样就可以构成层级结构。\n\n类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。","tags":["DesignPatterns"]},{"title":"桥接模式","url":"/2020/06/09/桥接模式/","content":"\n### 桥接模式\n\n>  *将抽象部分与它的实现部分分离，使它们都可以独立地变化。* \n>\n> <!--more-->\n\n假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：\n\n```ascii\n                   ┌───────┐\n                   │  Car  │\n                   └───────┘\n                       ▲\n    ┌──────────────────┼───────────────────┐\n    │                  │                   │\n┌───────┐          ┌───────┐          ┌───────┐\n│BigCar │          │TinyCar│          │BossCar│\n└───────┘          └───────┘          └───────┘\n    ▲                  ▲                  ▲\n    │                  │                  │\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │\n    │ └───────────────┘│ └───────────────┘│ └───────────────┘\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│\n    │ └───────────────┘│ └───────────────┘│ └───────────────┘\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │\n      └───────────────┘  └───────────────┘  └───────────────┘\n```\n\n如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。\n\n所以，桥接模式就是为了避免直接继承带来的**子类爆炸**。\n\n我们来看看**桥接模式**如何解决上述问题。\n\n在桥接模式中，首先把`Car`按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。\n\n首先定义抽象类`Car`，它引用一个`Engine`：\n\n```java\npublic abstract class Car {\n    // 引用Engine:\n    protected Engine engine;\n\n    public Car(Engine engine) {\n        this.engine = engine;\n    }\n\n    public abstract void drive();\n}\n```\n\n`Engine`的定义如下：\n\n```java\npublic interface Engine {\n    void start();\n}\n```\n\n紧接着，在一个“修正”的抽象类`RefinedCar`中定义一些额外操作：\n\n```java\npublic abstract class RefinedCar extends Car {\n    public RefinedCar(Engine engine) {\n        super(engine);\n    }\n\n    public void drive() {\n        this.engine.start();\n        System.out.println(\"Drive \" + getBrand() + \" car...\");\n    }\n\n    public abstract String getBrand();\n}\n```\n\n这样一来，最终的不同品牌继承自`RefinedCar`，例如`BossCar`：\n\n```java\npublic class BossCar extends RefinedCar {\n    public BossCar(Engine engine) {\n        super(engine);\n    }\n\n    public String getBrand() {\n        return \"Boss\";\n    }\n}\n```\n\n而针对每一种引擎，继承自`Engine`，例如`HybridEngine`：\n\n```java\npublic class HybridEngine implements Engine {\n    public void start() {\n        System.out.println(\"Start Hybrid Engine...\");\n    }\n}\n```\n\n客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：\n\n```java\nRefinedCar car = new BossCar(new HybridEngine());\ncar.drive();\n```\n\n使用桥接模式的好处在于，如果要增加一种引擎，只需要针对`Engine`派生一个新的子类，如果要增加一个品牌，只需要针对`RefinedCar`派生一个子类，任何`RefinedCar`的子类都可以和任何一种`Engine`自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。\n\n```ascii\n       ┌───────────┐\n       │    Car    │\n       └───────────┘\n             ▲\n             │\n       ┌───────────┐       ┌─────────┐\n       │RefinedCar │ ─ ─ ─>│ Engine  │\n       └───────────┘       └─────────┘\n             ▲                  ▲\n    ┌────────┼────────┐         │ ┌──────────────┐\n    │        │        │         ├─│  FuelEngine  │\n┌───────┐┌───────┐┌───────┐     │ └──────────────┘\n│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐\n└───────┘└───────┘└───────┘     ├─│ElectricEngine│\n                                │ └──────────────┘\n                                │ ┌──────────────┐\n                                └─│ HybridEngine │\n                                  └──────────────┘\n```\n\n桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。","tags":["DesignPatterns"]},{"title":"HTTP协议","url":"/2020/06/09/HTTP协议/"},{"title":"适配器模式","url":"/2020/06/08/适配器模式/","content":"\n### 适配器模式\n\n> *将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。* \n>\n> <!--more-->\n\n适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？\n\n我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：\n\n![adapter](1.png)\n\n```java\npublic class Task implements Callable<Long> {\n    private long num;\n    public Task(long num) {\n        this.num = num;\n    }\n\n    public Long call() throws Exception {\n        long r = 0;\n        for (long n = 1; n <= this.num; n++) {\n            r = r + n;\n        }\n        System.out.println(\"Result: \" + r);\n        return r;\n    }\n}\n```\n\n现在，我们想通过一个线程去执行它：\n\n```java\nCallable<Long> callable = new Task(123450000L);\nThread thread = new Thread(callable); // compile error!\nthread.start();\n```\n\n发现编译不过！因为`Thread`接收`Runnable`接口，但不接收`Callable`接口，肿么办？\n\n一个办法是改写`Task`类，把实现的`Callable`改为`Runnable`，但这样做不好，因为`Task`很可能在其他地方作为`Callable`被引用，改写`Task`的接口，会导致其他正常工作的代码无法编译。\n\n另一个办法不用改写`Task`类，而是用一个Adapter，把这个`Callable`接口“变成”`Runnable`接口，这样，就可以正常编译：\n\n```java\nCallable<Long> callable = new Task(123450000L);\nThread thread = new Thread(new RunnableAdapter(callable));\nthread.start();\n```\n\n这个`RunnableAdapter`类就是Adapter，它接收一个`Callable`，输出一个`Runnable`。怎么实现这个`RunnableAdapter`呢？我们先看完整的代码：\n\n```java\npublic class RunnableAdapter implements Runnable {\n    // 引用待转换接口:\n    private Callable<?> callable;\n\n    public RunnableAdapter(Callable<?> callable) {\n        this.callable = callable;\n    }\n\n    // 实现指定接口:\n    public void run() {\n        // 将指定接口调用委托给转换接口调用:\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n编写一个Adapter的步骤如下：\n\n1. 实现目标接口，这里是`Runnable`；\n2. 内部持有一个待转换接口的引用，这里是通过字段持有`Callable`接口；\n3. 在目标接口的实现方法内部，调用待转换接口的方法。\n\n这样一来，Thread就可以接收这个`RunnableAdapter`，因为它实现了`Runnable`接口。`Thread`作为调用方，它会调用`RunnableAdapter`的`run()`方法，在这个`run()`方法内部，又调用了`Callable`的`call()`方法，相当于`Thread`通过一层转换，间接调用了`Callable`的`call()`方法。\n\n适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是`String[]`，但是需要`List`接口时，可以用一个Adapter：\n\n```java\nString[] exist = new String[] {\"Good\", \"morning\", \"Bob\", \"and\", \"Alice\"};\nSet<String> set = new HashSet<>(Arrays.asList(exist));\n```\n\n注意到`List Arrays.asList(T[])`就相当于一个转换器，它可以把数组转换为`List`。\n\n我们再看一个例子：假设我们持有一个`InputStream`，希望调用`readText(Reader)`方法，但它的参数类型是`Reader`而不是`InputStream`，怎么办？\n\n当然是使用适配器，把`InputStream`“变成”`Reader`：\n\n```java\nInputStream input = Files.newInputStream(Paths.get(\"/path/to/file\"));\nReader reader = new InputStreamReader(input, \"UTF-8\");\nreadText(reader);\n```\n\n`InputStreamReader`就是Java标准库提供的`Adapter`，它负责把一个`InputStream`适配为`Reader`。类似的还有`OutputStreamWriter`。\n\n如果我们把`readText(Reader)`方法参数从`Reader`改为`FileReader`，会有什么问题？这个时候，因为我们需要一个`FileReader`类型，就必须把`InputStream`适配为`FileReader`：\n\n```java\nFileReader reader = new InputStreamReader(input, \"UTF-8\"); // compile error!\n```\n\n直接使用`InputStreamReader`这个Adapter是不行的，因为它只能转换出`Reader`接口。事实上，要把`InputStream`转换为`FileReader`也不是不可能，但需要花费十倍以上的功夫。这时，**面向抽象编程**这一原则就体现出了威力：**持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。**\n\n","tags":["DesignPatterns"]},{"title":"原型","url":"/2020/06/08/原型/","content":"\n### 原型\n\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n>\n> <!--more-->\n\n**原型模式**，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。\n\n我们举个例子：如果我们已经有了一个`String[]`数组，想再创建一个一模一样的`String[]`数组，怎么写？\n\n实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：\n\n```java\n// 原型:\nString[] original = { \"Apple\", \"Pear\", \"Banana\" };\n// 新对象:\nString[] copy = Arrays.copyOf(original, original.length);\n```\n\n对于普通类，我们如何实现原型拷贝？Java的`Object`提供了一个`clone()`方法，它的意图就是复制一个新的对象出来，我们需要实现一个`Cloneable`接口来标识一个对象是“可复制”的：\n\n```java\npublic class Employee implements Cloneable {\n    private int id;\n    private String name;\n    private int score;\n\n    // 复制新对象并返回:\n    public Object clone() {\n        Employee employee = new Employee();\n        employee.id = this.id;\n        employee.name = this.name;\n        employee.score = this.score;\n        return employee;\n    }\n}\n```\n\n使用的时候，因为`clone()`的方法签名是定义在`Object`中，返回类型也是`Object`，所以要强制转型，比较麻烦：\n\n```java\nEmployee employee = new Employee();\nemployee.setId(123);\nemployee.setName(\"Bob\");\nemployee.setScore(88);\n// 复制新对象:\nEmployee employee2 = (Employee) employee.clone();\nSystem.out.println(employee);\nSystem.out.println(employee2);\nSystem.out.println(employee == employee2); // false\n```\n\n实际上，使用原型模式更好的方式是定义一个`copy()`方法，返回明确的类型：\n\n```java\npublic class Employee {\n    private int id;\n    private String name;\n    private int score;\n\n    public Employee copy() {\n        Student employee = new Employee();\n        employee.id = this.id;\n        employee.name = this.name;\n        employee.score = this.score;\n        return employee;\n    }\n}\n```\n\n原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。","tags":["DesignPatterns"]},{"title":"生成器","url":"/2020/06/08/生成器/","content":"\n### 生成器\n\n> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 \n>\n> <!--more-->\n\n**生成器模式（Builder）**是使用多个“小型”工厂来最终创建出一个完整对象。\n\n当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。\n\n##### 使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。\n\nJavaMail的`MimeMessage`就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是`MimeMessage`：\n\n```\nMultipart multipart = new MimeMultipart();\n// 添加text:\nBodyPart textpart = new MimeBodyPart();\ntextpart.setContent(body, \"text/html;charset=utf-8\");\nmultipart.addBodyPart(textpart);\n// 添加image:\nBodyPart imagepart = new MimeBodyPart();\nimagepart.setFileName(fileName);\nimagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, \"application/octet-stream\")));\nmultipart.addBodyPart(imagepart);\n\nMimeMessage message = new MimeMessage(session);\n// 设置发送方地址:\nmessage.setFrom(new InternetAddress(\"me@example.com\"));\n// 设置接收方地址:\nmessage.setRecipient(Message.RecipientType.TO, new InternetAddress(\"xiaoming@somewhere.com\"));\n// 设置邮件主题:\nmessage.setSubject(\"Hello\", \"UTF-8\");\n// 设置邮件内容为multipart:\nmessage.setContent(multipart);\n```\n\n##### 很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：\n\n```\nStringBuilder builder = new StringBuilder();\nbuilder.append(secure ? \"https://\" : \"http://\")\n       .append(\"www.liaoxuefeng.com\")\n       .append(\"/\")\n       .append(\"?t=0\");\nString url = builder.toString();\n```\n\n##### 由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：\n\n```\nString url = URLBuilder.builder() // 创建Builder\n        .setDomain(\"www.liaoxuefeng.com\") // 设置domain\n        .setScheme(\"https\") // 设置scheme\n        .setPath(\"/\") // 设置路径\n        .setQuery(Map.of(\"a\", \"123\", \"q\", \"K&R\")) // 设置query\n        .build(); // 完成build\n```","tags":["DesignPatterns"]},{"title":"工厂设计模式","url":"/2020/06/06/工厂设计模式/","content":"\n## 工厂设计模式\n\n### 工厂方法\n\n工厂方法即Factory Method，是一种对象创建型模式。\n\n<!--more-->\n\n工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：\n\n```ascii\n┌─────────────┐      ┌─────────────┐\n│   Product   │      │   Factory   │\n└─────────────┘      └─────────────┘\n       ▲                    ▲\n       │                    │\n┌─────────────┐      ┌─────────────┐\n│ ProductImpl │<─ ─ ─│ FactoryImpl │\n└─────────────┘      └─────────────┘\n```\n\n 例如实现一个解析字符串到`Number`的`Factory`，可以定义如下： \n\n```java\npublic class NumberFactoryImpl implements NumberFactory {\n    public Number parse(String s) {\n        return new BigDecimal(s);\n    }\n}\n```\n\n而产品接口是`Number`，`NumberFactoryImpl`返回的实际产品是`BigDecimal`。\n\n那么客户端如何创建`NumberFactoryImpl`呢？通常我们会在接口`Factory`中定义一个静态方法`getFactory()`来返回真正的子类：\n\n```java\npublic interface NumberFactory {\n    // 创建方法:\n    Number parse(String s);\n    // 获取工厂实例:\n    static NumberFactory getFactory() {\n        return impl;\n    }\n    static NumberFactory impl = new NumberFactoryImpl();\n}\n```\n\n 在客户端中，我们只需要和工厂接口`NumberFactory`以及抽象产品`Number`打交道： \n\n```java\nNumberFactory factory = NumberFactory.getFactory();\nNumber result = factory.parse(\"123.456\");\n```\n\n 调用方可以完全忽略真正的工厂`NumberFactoryImpl`和实际的产品`BigDecimal`，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。 \n\n 实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即： \n\n```java\npublic class NumberFactory {\n    public static Number parse(String s) {\n        return new BigDecimal(s);\n    }\n}\n```\n\n这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：\n\n```java\nInteger n = Integer.valueOf(100);\n```\n\n`Integer`既是产品又是静态工厂。它提供了静态方法`valueOf()`来创建`Integer`。那么这种方式和直接写`new Integer(100)`有何区别呢？我们观察`valueOf()`方法：\n\n```java\npublic final class Integer {\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n    ...\n}\n```\n\n它的好处在于，`valueOf()`内部可能会使用`new`创建一个新的`Integer`实例，但也可能直接返回一个缓存的`Integer`实例。对于调用方来说，没必要知道`Integer`创建的细节。\n\n> 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。\n\n如果调用方直接使用`Integer n = new Integer(100)`，那么就失去了使用缓存优化的可能性。\n\n我们经常使用的另一个静态工厂方法是`List.of()`：\n\n```java\nList<String> list = List.of(\"A\", \"B\", \"C\");\n```\n\n这个静态工厂方法接收可变参数，然后返回`List`接口。需要注意的是，调用方获取的产品总是`List`接口，而且并不关心它的实际类型。即使调用方知道`List`产品的实际类型是`java.util.ImmutableCollections$ListN`，也不要去强制转型为子类，因为静态工厂方法`List.of()`保证返回`List`，但也完全可以修改为返回`java.util.ArrayList`。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。\n\n> 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。\n\n和`List.of()`类似，我们使用`MessageDigest`时，为了创建某个摘要算法，总是使用静态工厂方法`getInstance(String)`：\n\n```java\nMessageDigest md5 = MessageDigest.getInstance(\"MD5\");\nMessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n```\n\n调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是`MessageDigest`这个抽象类。\n\n### 抽象工厂\n\n>  *提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。* \n\n抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。\n\n抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：\n\n```ascii\n                                ┌────────┐\n                             ─ >│ProductA│\n┌────────┐    ┌─────────┐   │   └────────┘\n│ Client │─ ─>│ Factory │─ ─\n└────────┘    └─────────┘   │   ┌────────┐\n                   ▲         ─ >│ProductB│\n           ┌───────┴───────┐    └────────┘\n           │               │\n      ┌─────────┐     ┌─────────┐\n      │Factory1 │     │Factory2 │\n      └─────────┘     └─────────┘\n           │   ┌─────────┐ │   ┌─────────┐\n            ─ >│ProductA1│  ─ >│ProductA2│\n           │   └─────────┘ │   └─────────┘\n               ┌─────────┐     ┌─────────┐\n           └ ─>│ProductB1│ └ ─>│ProductB2│\n               └─────────┘     └─────────┘\n```\n\n这种模式有点类似于多个供应商负责提供一系列类型的产品。我们举个例子：\n\n假设我们希望为用户提供一个Markdown文本转换为HTML和Word的服务，它的接口定义如下：\n\n```java\npublic interface AbstractFactory {\n    // 创建Html文档:\n    HtmlDocument createHtml(String md);\n    // 创建Word文档:\n    WordDocument createWord(String md);\n}\n```\n\n注意到上面的抽象工厂仅仅是一个接口，没有任何代码。同样的，因为`HtmlDocument`和`WordDocument`都比较复杂，现在我们并不知道如何实现它们，所以只有接口：\n\n```java\n// Html文档接口:\npublic interface HtmlDocument {\n    String toHtml();\n    void save(Path path) throws IOException;\n}\n\n// Word文档接口:\npublic interface WordDocument {\n    void save(Path path) throws IOException;\n}\n```\n\n这样，我们就定义好了抽象工厂（`AbstractFactory`）以及两个抽象产品（`HtmlDocument`和`WordDocument`）。因为实现它们比较困难，我们决定让供应商来完成。\n\n现在市场上有两家供应商：FastDoc Soft的产品便宜，并且转换速度快，而GoodDoc Soft的产品贵，但转换效果好。我们决定同时使用这两家供应商的产品，以便给免费用户和付费用户提供不同的服务。\n\n我们先看看FastDoc Soft的产品是如何实现的。首先，FastDoc Soft必须要有实际的产品，即`FastHtmlDocument`和`FastWordDocument`：\n\n```java\npublic class FastHtmlDocument implements HtmlDocument {\n    public String toHtml() {\n        ...\n    }\n    public void save(Path path) throws IOException {\n        ...\n    }\n}\n\npublic class FastWordDocument implements WordDocument {\n    public void save(Path path) throws IOException {\n        ...\n    }\n}\n```\n\n然后，FastDoc Soft必须提供一个实际的工厂来生产这两种产品，即`FastFactory`：\n\n```java\npublic class FastFactory implements AbstractFactory {\n    public HtmlDocument createHtml(String md) {\n        return new FastHtmlDocument(md);\n    }\n    public WordDocument createWord(String md) {\n        return new FastWordDocument(md);\n    }\n}\n```\n\n这样，我们就可以使用FastDoc Soft的服务了。客户端编写代码如下：\n\n```java\n// 创建AbstractFactory，实际类型是FastFactory:\nAbstractFactory factory = new FastFactory();\n// 生成Html文档:\nHtmlDocument html = factory.createHtml(\"#Hello\\nHello, world!\");\nhtml.save(Paths.get(\".\", \"fast.html\"));\n// 生成Word文档:\nWordDocument word = fastFactory.createWord(\"#Hello\\nHello, world!\");\nword.save(Paths.get(\".\", \"fast.doc\"));\n```\n\n如果我们要同时使用GoodDoc Soft的服务怎么办？因为用了抽象工厂模式，GoodDoc Soft只需要根据我们定义的抽象工厂和抽象产品接口，实现自己的实际工厂和实际产品即可：\n\n```java\n// 实际工厂:\npublic class GoodFactory implements AbstractFactory {\n    public HtmlDocument createHtml(String md) {\n        return new GoodHtmlDocument(md);\n    }\n    public WordDocument createWord(String md) {\n        return new GoodWordDocument(md);\n    }\n}\n\n// 实际产品:\npublic class GoodHtmlDocument implements HtmlDocument {\n    ...\n}\n\npublic class GoodWordDocument implements HtmlDocument {\n    ...\n}\n```\n\n客户端要使用GoodDoc Soft的服务，只需要把原来的`new FastFactory()`切换为`new GoodFactory()`即可。\n\n注意到客户端代码除了通过`new`创建了`FastFactory`或`GoodFactory`外，其余代码只引用了产品接口，并未引用任何实际产品（例如，`FastHtmlDocument`），如果把创建工厂的代码放到`AbstractFactory`中，就可以连实际工厂也屏蔽了：\n\n```java\npublic interface AbstractFactory {\n    public static AbstractFactory createFactory(String name) {\n        if (name.equalsIgnoreCase(\"fast\")) {\n            return new FastFactory();\n        } else if (name.equalsIgnoreCase(\"good\")) {\n            return new GoodFactory();\n        } else {\n            throw new IllegalArgumentException(\"Invalid factory name\");\n        }\n    }\n}\n```","tags":["DesignPatterns"]},{"title":"单例模式","url":"/2020/06/06/单例模式/","content":"\n## 单例设计模式\n\n所谓类的单例设计模式，就是采用一定的方法保证在整个软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得对象实例的方法(静态方法)。\n\n<!--more-->\n\n###### 比如*Hibernate*的*SessionFactory*，它充当数据存储源的代理，并负责创建*Session* 对象。*SessionFactory*并不是轻量级的，一般情况下，一个项目通常只需要一个 *SessionFactory*就够，这是就会使用到单例模式。 \n\n 单例模式有八种方式：\n\n- 饿汉式(静态常量)\n\n- 饿汉式（静态代码块） \n\n- 懒汉式(线程不安全) \n\n- 懒汉式(线程安全，同步方法) \n\n- 懒汉式(线程安全，同步代码块) \n\n- 双重检查\n\n- 静态内部类 \n\n- 枚举 \n\n  \n\n#### 饿汉式(静态变量)\n\n  ![img](1.png)\n\n  ```java\n  /**\n   * @Author: Wizard\n   * @Date: 2020/6/6 14:13\n   */\n  public class Singleton1 {\n      public static void main(String[] args) {\n          //Test\n          SingleTon instance1 = SingleTon.getInstance();\n          SingleTon instance2 = SingleTon.getInstance();\n          System.out.println(instance1==instance2);//true\n      }\n  }\n  //饿汉式(静态变量)\n  class SingleTon1 {\n      //1.构造器私有化, 外部不能new\n      private SingleTon1() {\n      }\n      //2.在本类内部创建对象实例\n      private final static SingleTon1 instance = new SingleTon1();\n      //3.提供一个公有的静态方法，返回实例对象\n      public static SingleTon1 getInstance() {\n        return instance;\n      }\n  }\n  ```\n\n  \n\n> 优缺点：\n>\n> - 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。 \n> - 缺点：在类装载的时候就完成实例化，没有达到*Lazy Loading*的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费\n> - 这种方式基于*classloder*机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到 *lazy loading*的效果\n> - 结论：这种单例模式可用，可能造成**内存浪费** \n\n#### 饿汉式(静态代码块)\n\n![img](2.png)\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/6 14:13\n */\n\n//饿汉式(静态代码块)\nclass SingleTon2 {\n    //1.构造器私有化, 外部不能new\n    private SingleTon2() {\n    }\n\n    //2.在本类内部创建对象实例\n    private static SingleTon2 instance;\n\n    static {\n        //在静态代码块中，创建单例对象,静态代码块只执行一次\n        instance = new SingleTon2();\n    }\n    //3.提供一个公有的静态方法，返回实例对象\n    public static SingleTon2 getInstance() {\n        return instance;\n    }\n}\n```\n\n> 优缺点和静态变量相同\n\n#### 懒汉式(线程不安全)\n\n![img](3.png)\n\n```java\n//懒汉式\nclass SingleTon3 {\n    private static SingleTon3 instance;\n\n    private SingleTon3() {\n    }\n    //提供一个静态的公有方法,当使用到该方法时，才去创建instance\n    public static SingleTon3 getInstance(){\n        if (instance==null){\n            instance = new SingleTon3();\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点： \n>\n> - 起到了Lazy Loading的效果，但是只能在单线程下使用。 \n> - 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 \n> - 结论：在实际开发中，不要使用这种方式. \n\n#### 懒汉式(线程安全，同步方法)\n\n![img](4.png)\n\n```JAVA\n//懒汉式(线程安全，同步方法)\nclass SingleTon4 {\n    private static SingleTon4 instance;\n\n    private SingleTon4() {\n    }\n    //提供一个静态的公有方法,加入同步处理的代码，解决线程安全问题\n    public static synchronized SingleTon4 getInstance(){\n        if (instance==null){\n            instance = new SingleTon4();\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点说明：\n>\n> - 解决了线程不安全问题\n> - 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低\n> - 结论：在实际开发中，不推荐使用这种方式 \n\n#### 懒汉式(线程安全，同步代码块)\n\n![img](5.png)\n\n```java\n//懒汉式(线程安全，同步代码块)\nclass SingleTon5 {\n    private static SingleTon5 instance;\n    private SingleTon5() {\n    }\n    //提供一个静态的公有方法,加入同步处理的代码，解决线程安全问题\n    public static SingleTon5 getInstance() {\n        if (instance == null) {\n            synchronized (SingleTon5.class) {\n                instance = new SingleTon5();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点说明： \n>\n> - 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低， 改为同步产生实例化的的代码块 \n> - **但是这种同步并不能起到线程同步的作用**。跟第3种实现方式遇到的情形一 致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行， 另一个线程也通过了这个判断语句，这时便会产生多个实例 \n> - 结论：在实际开发中，不能使用这种方式 \n\n#### 双重检查\n\n![img](6.png)\n\n```java\n//懒汉式(线程安全,双重检查)\nclass SingleTon6 {\n    //必须加volatile关键字的原因：new对象分为3步:1.分配空间 2.初始化对象 3.指向对象内存地址\n    // 2和3可能被编译器自动重排序,导致判断非空但是实际拿的对象还未完成初始化\n    private static volatile SingleTon6 instance;\n\n    private SingleTon6() {\n    }\n    //提供一个静态的公有方法,加入双重检查代码，解决线程安全问题,同时解决懒加载的问题\n    public static SingleTon6 getInstance() {\n        if (instance == null) {\n            synchronized (SingleTon6.class) {\n                if (instance == null) {\n                    instance = new SingleTon6();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点说明： \n>\n> - Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。\n> - 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步\n> - 线程安全；延迟加载；效率较高 \n>\n> - 结论：在实际开发中，推荐使用这种单例设计模式 \n\n#### 静态内部类\n\n![img](7.png)\n\n```java\n//静态内部类\nclass SingleTon7 {\n    private static volatile SingleTon7 instance;\n    private SingleTon7() {\n    }\n\n    //写一个静态内部类,该类中有一个静态属性SingleTon7\n    //静态内部类SingletonInstance在外部类SingleTon7在类装载的时候,并不会马上执行,不会导致静态内部类SingletonInstance马上装载\n    //在JVM中，类的转载是线程安全的，导致了INSTANCE的初始化是线程安全的\n    private static class SingletonInstance {\n        private static final SingleTon7 INSTANCE = new SingleTon7();\n    }\n\n    public static SingleTon7 getInstance() {\n        //当调用getInstance这个方法时,会去取静态内部类SingletonInstance里的INSTANCE属性,这时会导致SingletonInstance会被装载\n\n        return SingletonInstance.INSTANCE;\n    }\n}\n```\n\n>  优缺点说明： \n>\n> - 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。 \n> - 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。 \n> - 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 \n> - 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 \n> - 结论：推荐使用. \n\n#### 枚举\n\n![img](8.png)\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/6 14:38\n */\npublic class Singleton8 {\n    public static void main(String[] args) {\n        Singleton instance = Singleton.INSTANCE;\n        Singleton instance2 = Singleton.INSTANCE;\n        System.out.println(instance == instance2);//true\n        System.out.println(instance.hashCode());\n        System.out.println(instance2.hashCode());\n    }\n}\n//枚举\nenum Singleton {\n    INSTANCE;\n\n    public void ok() {\n        System.out.println(\"ok\");\n    }\n}\n```\n\n> 优缺点说明： \n>\n>- 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。\n>- 这种方式是Effective Java作者Josh Bloch 提倡的方式\n>- 结论：推荐使用 \n\n\n\n #### 单例模式在JDK 应用的源码分析 \n\n单例模式在JDK 应用的源码分析 \n\nJDK中，java.lang.Runtime就是经典的单例模式(饿汉式) \n\n\n\n### 单例模式注意事项和细节说明 \n\n1. 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需 要频繁创建销毁的对象，使用单例模式可以提高系统性能 \n2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new \n3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等) ","tags":["DesignPatterns"]},{"title":"合成复用原则","url":"/2020/06/05/合成复用原则/","content":"\n### 合成复用原则\n\n> Composite Resue Principle\n>\n> <!--more-->\n\n##### 基本介绍\n\n原则是尽量使用合成/聚合的方式，而不是使用继承。\n\n![1591350916399](1.png)\n\n```java\n不使用继承的方法：\n\n使用:\n      1.依赖(参数传递)\n      2.聚合(set)\n      3.组合(new)\n```\n\n#### 设计原则核心思想\n\n- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。\n- 针对接口编程，而不是针对实现编程\n- 为了交互对象之间的松耦合设计而努力","tags":["DesignPatterns"]},{"title":"迪米特法则","url":"/2020/06/05/迪米特法则/","content":"\n ### 基本介绍\n\n> Demeter Principle\n>\n> <!--more-->\n\n-  一个对象应该对其他对象保持最少的了解 \n- 类与类关系越密切，耦合度越大\n- 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息\n- 迪米特法则还有个更简单的定义：只与直接的朋友通信 \n- **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量 的形式出现在类的内部。 \n\n##### 细节：\n\n- 迪米特法则的核心是降低类之间的耦合 \n- 注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低 类间(对象间)耦合关系， 并不是要求完全没有依赖关系 \n\n","tags":["DesignPatterns"]},{"title":"开闭原则","url":"/2020/06/05/开闭原则/","content":"\n### 开闭原则\n\n> Open Closed Principle\n\n基本介绍\n\n<!--more-->\n\n- 开闭原则是编程中最基础、最重要的设计原则\n- 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。**用抽象构建框架，用实体扩展细节。**\n- 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n- 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。\n\n```java\npublic class Ocp{\n    public status void main(String[] args){\n        GraphicEditor graphicEditor = new GraphicEditor();\n        graphicEditor.drawShape(new Rectangle());\n    }\n}\nclass GraphicEditor{\n    public void drawShape(Shape shape){\n        shape.draw();\n    }\n}\n//Shape类，基类\nabstract class Shape{\n    int m_type;\n    public abstract void draw();//抽象方法\n}\nclass Rectangle extends Shape{\n    Rectangle(){\n        super.m_type = 1;\n    }\n    @Override\n    public void draw(){\n        System.out.println(\"绘制矩形\")\n    }\n}\nclass Circle extends Shape{\n    Circle(){\n        super.m_type = 2;\n    }\n    @Override\n    public void draw(){\n        System.out.println(\"绘制圆形\")\n    }\n}\n```\n\n","tags":["DesignPatterns"]},{"title":"里氏替换原则","url":"/2020/06/04/里氏替换原则/","content":"\n### 里氏替换原则\n\n> Liskov Substitution Principle\n\n- 里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的。\n\n  <!--more-->\n\n- 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。所有引用基类的地方必须能透明地使用其子类的对象。换句话说，既然抽象出来当作共同的实现方法就不应再具体实现类中重写。\n\n- 在使用继承时，遵守里氏替换原则，在子类中尽量不要重写父类的方法\n\n- 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。\n\n  \n\n  ```java\n  //A类\n  class A{\n      //返回两个数的差\n      public in func1(int num1,int num2){\n          return num1 - num2;\n      }\n  }\n  //B类继承了A类\n  class B extends A{\n      //    ↓重写了A的方法\n      public int func1(int a,int b){\n          return a + b;\n      }\n      public int func2(int a,int b){\n          return func1(a,b)+9;\n      }\n  }\n  ```\n\n  改进：\n\n  ```java\n  class Base{\n      //把更加基础的方法和成员写到Base类\n  }\n  \n  //A类\n  class A extends Base{\n      //返回两个数的差\n      public in func1(int num1,int num2){\n          return num1 - num2;\n      }\n  }\n  //B类继承了A类\n  class B extends Base{\n      //如果B需要使用A类的方法，使用组合关系\n      private A a = new A();\n      //    ↓重写了A的方法\n      public int func1(int a,int b){\n          return a + b;\n      }\n      public int func2(int a,int b){\n          return func1(a,b)+9;\n      }\n      \n      //使用A的方法\n      public int func3(int a,int b){\n          return this.a.func1(a,b);\n      }\n  }\n  ```\n\n  \n\n\n\n","tags":["DesignPatterns"]},{"title":"依赖倒转原则","url":"/2020/06/03/依赖倒转原则/","content":"\n### 依赖倒转原则\n\n>  Dependence Inversion Priciple\n>\n>  <!--more-->\n\n##### 基本介绍\n\n- 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n- 抽象不应该依赖细节，细节应该依赖抽象\n- 依赖倒转的中心思想是面向接口编程\n- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类\n- 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成\n\n#### 细节\n- 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好\n- 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层。利于程序扩展和优化\n- 继承时遵循里氏替换原则\n\n###### 1通过接口传递实现依赖\n```java\ninterface IOpenAndClose{\n    //抽象方法\n    public void open(ITV tv);\n}\ninterface ITV{\n    //ITV接口\n    public void play();\n}\n\nclass Htc implements ITV{\n    @Override\n    public void play() {\n        System.out.println(\"htc电视机，打开\");\n    }\n}\n//实现接口\nclass OpenAndClose implements IOpenAndClose{\n    public void open(ITV tv){\n        tv.play();\n    }\n}\n```\n##### 2.通过构造方法依赖传递\n\n```java\ninterface IOpenAndClose{\n    //抽象方法\n    public void open(ITV tv);\n}\ninterface ITV{\n    //ITV接口\n    public void play();\n}\n\nclass Htc implements ITV{\n    @Override\n    public void play() {\n        System.out.println(\"htc电视机，打开\");\n    }\n}\n//实现接口\nclass OpenAndClose implements IOpenAndClose{\n    public ITV tv;\n    public OpenAndClose(ITV tv){\n        //构造器\n        this.tv = tv;\n    }\n    public void open(){\n        tv.play();\n    }\n}\n```\n\n##### 3.通过setter方法传递\n\n```java\ninterface IOpenAndClose{\n    //抽象方法\n    public void open(ITV tv);\n    public void name(ITV tv);\n}\ninterface ITV{\n    //ITV接口\n    public void play();\n}\n\nclass Htc implements ITV{\n    @Override\n    public void play() {\n        System.out.println(\"htc电视机，打开\");\n    }\n}\n//实现接口\nclass OpenAndClose implements IOpenAndClose{\n    public ITV tv;\n    public setTv(ITV tv){\n        //构造器\n        this.tv = tv;\n    }\n    public void open(){\n        tv.play();\n    }\n}\n```\n\n","tags":["DesignPatterns"]},{"title":"接口隔离原则","url":"/2020/06/03/接口隔离原则/","content":"\n### 接口隔离原则\n\n> Interface Segregation Principle\n>\n> <!--more-->\n\n##### 基本介绍\n\n- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。\n\n- 类A通过接口Interface依赖类D，类C通过接口Interface依赖类D，如果接口Interface对于类A和来说不是最小接口那么类B和类D必须去实现他们不需要的方法。\n\n  \n\n  按隔离原则应当这样处理：\n\n  > 将接口Interface拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n\n","tags":["DesignPatterns"]},{"title":"单一职责原则","url":"/2020/06/03/单一职责原则/","content":"\n### 单一职责原则\n\n------\n\n<!--more-->\n\n##### 基本介绍\n\n> 对类来说，即一个类应该只负责一个原则。如果A负责两个不同的原则：职责1，职责2。当职责1需求变更而改变A时，可能导致职责2执行错误。所以需要将类A的粒度分解为A1，A2\n\n##### 细节\n\n- 降低类的复杂度，一个类只负责一项职责。\n- 降低类的可读性，可维护性。\n- 降低变更引起的风险。\n- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一原则。\n\n","tags":["DesignPatterns"]},{"title":"XSS跨站脚本攻击","url":"/2020/05/31/XSS跨站脚本攻击/","content":"\n### XSS跨站脚本攻击\n\n在做社区项目的时候，发现了一个XSS漏洞。\n\n![img](xss.png)\n\n<!--more-->\n\n##### 什么是XSS跨站脚本攻击？\n\n> XSS攻击全称跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。\n\n在点击回复二级评论时，JavaScript脚本会注入页面:\n\n示例：\n\n ![img](2.png) \n\n ![img](3.png) \n\n然后客户端就调用脚本alert导致无限弹窗。\n\n还可以使用\n\n```javascript\n<script>alert(document.cookie)</script>\n```\n\n获取页面cookie，比如登录的token。\n\n解决办法：\n\n> Jsoup使用标签白名单的机制用来进行防止XSS攻击\n\n参考：\n\n[[XSS跨站脚本攻击]][1]\n\n[1]: https://www.zykcoderman.xyz/web/post/detail/401 \"XSS\"","tags":["safe"]},{"title":"SQL注入式攻击","url":"/2020/05/30/SQL注入式攻击/","content":"\n### SQL注入式攻击\n\n 攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。 \n\n<!--more-->\n\n#### 常见的SQL注入式攻击主要是利用Statement的缺陷，\n\n服务端验证：\n\n```java\n@Override\n    public void login(Account account) throws SQLException {\n\n        String sql = \"insert into account values(null,\" + account.userName + \",\" + account.password + \")\";\n\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/account?characterEncoding=UTF-8\",\n                \"root\", \"password\")) {\n            try (Statement stmt = conn.createStatement()) {\n                try (ResultSet rs = stmt.executeQuery(\"SELECT id, grade, name, gender FROM students WHERE gender=1\")) {\n                    while (rs.next()) {\n                        int id = rs.getInt(1);\n                        String username = rs.getString(2);\n                        String password = rs.getString(3);\n                    }\n                }\n            }\n        }\n    }\n```\n\n客户端\n\n```html\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\">\n<script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"></script>\n<div class=\"col-xs-8 col-sm-8 col-md-8 jumbotron\">\n    <form>\n        <div class=\"form-group\">\n            <label for=\"exampleInputEmail1\">Username</label>\n            <input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Email\">\n        </div>\n        <div class=\"form-group\">\n            <label for=\"exampleInputPassword1\">Password</label>\n            <input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\">\n        </div>\n        <div class=\"form-group\">\n            <label for=\"exampleInputFile\">File input</label>\n            <input type=\"file\" id=\"exampleInputFile\">\n            <p class=\"help-block\">Example block-level help text here.</p>\n        </div>\n        <div class=\"checkbox\">\n            <label>\n                <input type=\"checkbox\"> Check me out\n            </label>\n        </div>\n        <button type=\"submit\" class=\"btn btn-default\">Submit</button>\n    </form>\n</div>\n\n```\n\n![img](1.png)\n\n如果是客户端精心构造的字符串，例如\n\n```sql\nname = \"kayleh' OR pass=\", pass = \" OR pass='\"\n' or 1= ' 1\n```\n\n命令行永远为真，导致注入成功。\n\n> 所以使用JDBC时，尽量使用速度比较快且安全的 PreparedStatement ，PreparedStatement 使用的是预编译机制。\n\n","tags":["safe"]},{"title":"01面试题","url":"/2020/05/23/01面试题/","content":"\n### 面试题(updateing)\n\n<!--more-->\n\n- ArrayList和LinkedList的区别？(链表和数组的优缺点)\n\n  ArrayList是一个动态的数组结构，而LinkedList是双向链表结构；存取数据的时候，ArrayList更适合按位随机存取，而LinkedList更适合顺序读存取；插入\\删除数据时，ArrayList的开销比LinkedList更大，因为对于ArrayList插入\\删除一个数据时，需要移动其后的所有数据。而LinkedList只需要修改几个指针。\t\n\n- HashMap的本质仍然是数组，不过数据中储存的不是数据，而是一个链表的头节点。所有准确的说，其实就是链表数组。HashMap保存的是一个键值对，插入对象必须提供一个键对象；查找对象的时候必须给定一个键对象(因此必须记住键)，键对象是不允许重复的，但是允许null空键的存在。\n\n  HashMap插入对象时，根据给定的键key计算hashcode，然后再与数组长度进行求余运算得到数据下标。然后与该位置上的链表中已存储的键进行比较，对于以存在的键，则覆盖；对于不存在的键，添加至链表尾。\n\n"},{"title":"维护2","url":"/2020/05/21/维护2/","content":"\n#### 维护2\n\n###### fixed 12 bugs. \n\n- 1 网站成功双线部署GitHub、Coding\n\n  境外： https://kayleh.github.io/ \n\n  境内访问： http://dqlcr5.coding-pages.com/ \n\n- 2 完善标签tags功能\n\n- 3 完善搜索功能\n\n- 4 修复3处页面重定向","tags":["maintain"]},{"title":"二叉排序树","url":"/2020/05/20/二叉排序树/","content":"\n### 二叉排序树\n\n二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。\n\n如果有相同的值，可以将该节点放在左子节点或右子节点\n\n<!--more-->\n\n​                                           数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为  \n\n​                                                              ![img](0.png)\n\n​                                                                          ↓\n\n​                                                              ![img](1.png)\n\n\n\n二叉排序树的删除情况比较复杂，有下面三种情况需要考虑\n\n1)删除叶子节点 (比如：2, 5, 9, 12)\n\n2)删除只有一颗子树的节点 (比如：1)\n\n3)删除有两颗子树的节点. (比如：7, 3，10 )\n\n```shell\n第一种情况:\n删除叶子节点 (比如：2, 5, 9, 12)\n思路\n(1) 需求先去找到要删除的结点  targetNode\n(2)  找到targetNode 的 父结点 parent \n(3)  确定 targetNode 是 parent的左子结点 还是右子结点\n(4)  根据前面的情况来对应删除\n左子结点 parent.left = null\n右子结点 parent.right = null;\n第二种情况: 删除只有一颗子树的节点 比如 1\n思路\n(1) 需求先去找到要删除的结点  targetNode\n(2)  找到targetNode 的 父结点 parent \n(3) 确定targetNode 的子结点是左子结点还是右子结点\n(4) targetNode 是 parent 的左子结点还是右子结点\n(5) 如果targetNode 有左子结点\n5. 1 如果 targetNode 是 parent 的左子结点\nparent.left = targetNode.left;\n5.2  如果 targetNode 是 parent 的右子结点\nparent.right = targetNode.left;\n(6) 如果targetNode 有右子结点\n6.1 如果 targetNode 是 parent 的左子结点\nparent.left = targetNode.right;\n6.2 如果 targetNode 是 parent 的右子结点\nparent.right = targetNode.right\n\n\n情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )\n思路\n(1) 需求先去找到要删除的结点  targetNode\n(2)  找到targetNode 的 父结点 parent \n(3)  从targetNode 的右子树找到最小的结点\n(4) 用一个临时变量，将 最小结点的值保存 temp = 11\n(5)  删除该最小结点\n(6)  targetNode.value = temp\n\n```\n\n#### 代码实现\n\n```java\npackage binarysorttree;\n\n/**\n * @Author: Wizard\n * @Date: 2020/5/20 11:42\n */\npublic class BinarySortTreeDemo {\n    public static void main(String[] args) {\n//        int[] arr = {7, 3, 10, 12, 5, 1, 9};\n        int[] arr = {7,3};\n        BinarySortTree binarySortTree = new BinarySortTree();\n        for (int i = 0; i < arr.length; i++) {\n            binarySortTree.add(new Node(arr[i]));\n        }\n        binarySortTree.infixOrder();\n\n        binarySortTree.delNode(7);\n\n        System.out.println(\"删除后\");\n        binarySortTree.infixOrder();\n    }\n}\n\n\n//创建二叉排序树\nclass BinarySortTree {\n\n    private Node root;\n\n    //查找要删除的结点\n    public Node search(int value) {\n        if (root == null) {\n            return null;\n        } else {\n            return root.search(value);\n        }\n    }\n\n    //查找父结点\n    public Node searchParent(int value) {\n        if (root == null) {\n            return null;\n        } else {\n            return root.searchParent(value);\n        }\n    }\n\n    /**\n     * 右边找最小的\n     * 左边找最大的\n     *\n     * 返回的 以node为根结点的最小结点的值\n     * 删除以node为根结点的最小结点的值\n     *\n     * @param node 传入的结点（当做二叉排序树的根结点）\n     * @return 返回的 以node为根结点的最小结点的值\n     */\n    public int delRightTreeMin(Node node) {\n        Node target = node;\n        //循环的查找左子节点，就会找到最小值\n        while (target.left != null) {\n            target = target.left;\n        }\n        //这是target就指向了最小结点\n        //删除最小结点\n        delNode(target.value);\n        return target.value;\n    }\n\n\n    //删除结点\n    public void delNode(int value) {\n\n        if (root == null) {\n            return;\n        } else {\n            //需要先去找到要删除的结点 targetNode\n            Node targetNode = search(value);\n            //如果没有找到要删除的结点\n            if (targetNode == null) {\n                return;\n            }\n            //如果发现targetNode没有父结点（就是根结点）(只有一个结点)\n            if (root.left == null && root.right == null) {\n                root = null;\n                return;\n            }\n\n            //去找到targetNode的父结点\n            Node parent = searchParent(value);\n            //如果要删除的结点是叶子结点\n            if (targetNode.left == null && targetNode.right == null) {\n                //判断targetNode是父结点的左子结点还是右子结点\n                if (parent.left != null && parent.left.value == value) {\n                    parent.left = null;\n                } else if (parent.right != null && parent.right.value == value) {\n                    parent.right = null;\n                }\n            } else if (targetNode.left != null && targetNode.right != null) {\n                //删除有两颗子树的结点\n                int min = delRightTreeMin(targetNode.right);//target右边最小的值\n\n                targetNode.value = min;\n            } else {\n                //删除只有一颗子树的结点\n                //如果要删除的结点有左子结点\n//                System.out.println(parent);\n                if (parent!=null) {\n                    if (targetNode.left != null) {\n                        //如果targetNode是parent的左子结点\n                        if (parent.left.value == value) {\n                            parent.left = targetNode.left;\n                        } else {\n                            //如果targetNode是parent的右子结点\n                            parent.right = targetNode.left;\n                        }\n                    } else {\n                        //如果要删除的结点有右子结点\n                        if (parent.left.value == value) {\n                            //如果targetNode是parent的左子结点\n                            parent.left = targetNode.right;\n                        } else {\n                            //如果targetNode是parent的右子结点\n                            parent.right = targetNode.right;\n\n                        }\n                    }\n                }else {\n                    if (root.left!=null){\n                        root = root.left;\n                    }else {\n                        root = root.right;\n                    }\n                }\n            }\n        }\n    }\n\n    //添加结点的方法\n    public void add(Node node) {\n        if (root == null) {\n            root = node;\n        } else {\n            root.add(node);\n        }\n    }\n\n    //中序遍历方法\n    public void infixOrder() {\n        if (root != null) {\n            root.infixOrder();\n        } else {\n            System.out.println(\"当前二叉排序树为空，不能遍历\");\n        }\n    }\n}\n\n\n//创建Node结点\nclass Node {\n    int value;\n    Node left;\n    Node right;\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"value=\" + value +\n                '}';\n    }\n\n\n    /**\n     * 查找要删除的结点\n     *\n     * @param value 希望删除的结点的值\n     * @return 如果找到返回该结点，否则返回null\n     */\n    public Node search(int value) {\n        if (value == this.value) {\n            //找到就是该结点\n            return this;\n        } else if (value < this.value) {\n            //如果查找的值小于当前结点，向左子树递归查找\n            //如果左子结点为空\n            if (this.left == null) {\n                return null;\n            }\n            return this.left.search(value);\n        } else {\n            //如果查找的值不小于当前结点，向右子树递归查找\n            if (this.right == null) {\n                return null;\n            }\n            return this.right.search(value);\n\n        }\n    }\n\n    /**\n     * 查找要删除结点的父结点\n     *\n     * @param value 要找到结点的值\n     * @return 返回的是要删除的结点的父结点，如果没有就返回null\n     */\n    public Node searchParent(int value) {\n\n        //如果当前结点就是要删除的结点的父结点，就返回\n        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {\n            return this;\n        } else {\n            //如果查找的值小于当前结点的值，并且当前结点的左子结点不为空\n            if (value < this.value && this.left != null) {\n                return this.left.search(value);//向左子树递归查找\n            } else if (value >= this.value && this.right != null) {\n                return this.right.search(value);//向右子树递归查找\n            } else {\n                return null;//没有找到父结点\n            }\n\n        }\n\n    }\n\n    public Node(int value) {\n        this.value = value;\n    }\n\n    //添加结点的方式\n    //递归的形式添加结点，需要满足二叉排序树的要求\n    public void add(Node node) {\n        if (node == null) {\n            return;\n        }\n        //判断传入的结点的值，和当前子树的根结点的值的关系\n        if (node.value < this.value) {\n            //如果当前结点的左子结点为null\n            if (this.left == null) {\n                //把结点挂在左子结点\n                this.left = node;\n            } else {\n                //如果左子结点不为空，向左子树递归添加\n                this.left.add(node);\n            }\n        } else {\n            //如果 添加的结点的值 大于 根结点的值\n            if (this.right == null) {\n                this.right = node;\n            } else {\n                this.right.add(node);\n            }\n        }\n    }\n\n    //中序遍历\n    public void infixOrder() {\n\n        if (this.left != null) {\n            this.left.infixOrder();\n        }\n        System.out.println(this);\n        if (this.right != null) {\n            this.right.infixOrder();\n        }\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"堆排序","url":"/2020/05/18/堆排序/","content":"\n### 堆排序\n\n1.堆排序是利用堆这种数据结构而设计的一种算法，堆排序是一种选择排序，它的最坏，最好，平均复杂度均为O(nlogn)，它也是不稳定的排序。\n\n<!--more-->\n\n2.堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。没有要求结点的左孩子的值和右孩子的值大小关系。\n\n3.每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆\n\n![img](1.gif)\n\n```java\npackage sort;\n\nimport java.util.Arrays;\n\n/**\n * @Author: Wizard\n * @Date: 2020/5/18 21:16\n */\npublic class heapSort {\n    public static void main(String[] args) {\n        //要求将数组进行升序排列\n    }\n\n    //编写一个堆排序的方法\n    public static void heapSort(int arr[]) {\n        int temp = 0;\n        System.out.println(\"堆排序！\");\n\n\n        //  i  第一个非叶子结点\n        //  这里的目的是把最大的数交换到堆顶，成为一个大顶堆结构\n        for (int i = arr.length / 2 - 1; i >= 0; i--) {\n            adjustHeap(arr, i, arr.length);\n            System.out.println(Arrays.toString(arr));\n        }\n\n\n        /*\n        将堆顶元素于末尾元素交换，将最大元素“沉”到数组末端\n        重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序\n         */\n        //一共5个数，调整4个数就可以了\n        for (int j = arr.length - 1; j > 0; j--) {\n            temp = arr[j];\n            arr[j] = arr[0];//arr[0] 是上面调整后的最大值\n            arr[0] = temp;\n            adjustHeap(arr, 0, j);\n            System.out.println(\"第\"+(arr.length-j)+\"次沉\"+Arrays.toString(arr));\n        }\n        System.out.println(Arrays.toString(arr));\n\n\n        //每次遍历把最大的数（在调整之后的父节点，第一位）沉到数组的末端\n        //然后 再调整 把最大的数交换到堆顶（adjustHeap），再沉到数组的末端的位置-1，随着j的递减，末尾的前几个数字逐渐确定（调整的范围减少）\n\n    }\n\n\n    //将一个数组(二叉树),调整为一个大顶堆\n\n    /**\n     * 功能：完成将以 i 对应的非叶子结点的树调整为大顶堆\n     * int arr[] = {4,6,8,5,9};   → i = 1 → adjustHeap → 得到{4,9,8,5,6}\n     * 再次调用adjustHeap 传入的是 i= 0 → 得到{9,6,8,5,4}\n     *\n     * @param arr    待调整的数组\n     * @param i      表示非叶子结点在数组中的索引\n     * @param lenght 表示归多少个元素继续调整，length 是在逐渐的减少\n     */\n    public static void adjustHeap(int arr[], int i, int lenght) {\n        int temp = arr[i];//取出当前元素的值，保存在临时变量，   以 i 作为父节点（局部）\n        //开始调整\n        //k = i对应的左子节点\n        for (int k = 2 * i + 1; k < lenght; k = 2 * i + 1) {\n            if (k + 1 < lenght && arr[k] < arr[k + 1]) {\n                //说明左子节点的值小于右子节点\n                k++;//让 k 指向右子节点\n            }\n            if (arr[k] > temp) {\n                //如果子节点大于父节点\n                //就把较大的值赋值给当前节点\n                arr[i] = arr[k];\n                // ! i指向k 继续循环比较\n                i = k; //把i（父节点）指向 k（子节点）。作为父节点继续循环\n            } else {\n                //如果子节点小于父节点\n                //堆排序是从左至右，从下至上\n                break;\n            }\n        }\n        //当for循环结束后，已经将以i为父节点的树的最大值，放在了最顶（局部）\n        arr[i] = temp;//将temp值放到调整后的位置\n\n        //adjustHeap()方法中依然要循环, 是因为最后在堆排序的时候是从下到上的, 排序中向上调用这个方法时 , i也会往上走, 这时再次调用adjustHeapt\n        //这时再次调用adjustHeap方法时, i就不是最后一个非叶子节点了, 会破坏原先已经排序好的大顶堆, 所以需要循环往下将被破坏的大顶堆重新建立起来\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"7种排序算法","url":"/2020/05/17/7种排序算法/","content":"\n\n\n## 冒泡排序\n\n- `冒泡排序（BubbleSorting)`的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部。\n\n  \n\n![img](1.png)\n\n<!--more-->\n\n代码实现\n\n```java\n// 将前面的冒泡排序算法，封装成一个方法\n    public static void bubbleSort(int[] arr) {\n        // 冒泡排序 的时间复杂度 O(n^2), 自己写出\n        int temp = 0; // 临时变量\n        boolean flag = false; // 标识变量，表示是否进行过交换\n        for (int i = 0; i < arr.length - 1; i++) {\n            for (int j = 0; j < arr.length - 1 - i; j++) {\n                // 如果前面的数比后面的数大，则交换\n                if (arr[j] > arr[j + 1]) {\n                    flag = true;\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n            //System.out.println(\"第\" + (i + 1) + \"趟排序后的数组\");\n            //System.out.println(Arrays.toString(arr));\n\n            if (!flag) {\n                // 在一趟排序中，一次交换都没有发生过\n                break;\n            } else {\n                flag = false;\n                // 重置flag!!!, 进行下次判断\n            }\n        }\n```\n\n------\n\n## 插入排序\n\n- `插入排序（insertSorting)`\n- 基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n- \n\n代码实现\n\n```java\n public static void insertSort(int attr[]) {\n        //从第2个数开始遍历 【1】\n        for (int i = 1; i < attr.length - 1; i++) {\n            // 等待插入的数的前一个数下标\n            int insertIndex = i - 1;\n            //等待插入的数的值\n            int insertValue = attr[i];\n            // insertIndex不能越界\n            // insertValue待插入到前面有序列表的数\n            // insertValue待插入的数 小于 前1个数\n            while (insertIndex >= 0 && attr[insertIndex] > insertValue) {\n                // 交换\n                //  attr[insertIndex]后移\n                attr[insertIndex + 1] = attr[insertIndex];\n                insertIndex--;\n            }\n            //当退出while循环时，说明插入的位置找到, insertIndex + 1\n            if (insertIndex + 1 != i) {\n                attr[insertIndex + 1] = insertValue;\n            }\n        }\n\n    }\n```\n\n## 选择排序\n\n- `选择排序（selectSorting)`的基本思想是：\n\n- 第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…,第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。\n\n  \n\n![img](2.png)\n\n\n\n代码实现\n\n\n\n```java\npublic class selectSort {\n    public static void selectSort(int attr[]) {\n        for (int i = 0; i < attr.length - 1; i++) {\n            //假设第一个数就是最小值\n            int minindex = 0;\n            int min = attr[0];\n            //从1开始遍历\n            for (int j = 1; j < attr.length - 1; j++) {\n                //如果第0个数（最小值）比第1个数 大\n                //说明假设的第0个并不是最小值\n                if (min > attr[j]) {\n                    min = attr[j];//重置最小值\n                    minindex = j;//重置最小值索引\n                }\n            }\n            //如果最小值的索引不是0，就发生交换\n            if (minindex != i) {\n                //把第0个数（不是最小值）赋值到 第1个数（较小值）的位置\n                attr[minindex] = attr[i];\n                //把较小值赋值给第1个数\n                attr[i] = min;\n            }\n        }\n    }\n```\n\n\n\n## 希尔排序\n\n- `冒泡排序（BubbleSorting)`的基本思想是：\n\n  把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\n\n  \n\n![img](3.png)\n\n\n\n代码实现\n\n\n\n```java\n\t\t//移动法\n        //增量gap，并逐步的缩小增量\n        for (int gap = attr.length/2;gap>0;gap/=2){\n            //从第gap个元素开始，逐个对其所在的组进行直接插入排序\n            for (int i =gap;i<attr.length;i++){\n                // 当前位置\n                int j = i;\n\n                //当前位置的值赋值给temp\n                int temp = attr[j];\n                // 如果 当前组的gap个步长前面的数大于当前位置的数\n                if(attr[j]<attr[j-gap]){\n                    while (j-gap >= 0 && temp < attr[j-gap]){\n                        //移动\n                        attr[j] = attr[j-gap];\n                        j -= gap;\n                    }\n                    //当退出while循环后，就给temp找到插入的位置\n                    attr[j] = temp;\n                }\n            }\n        }\n```\n\n\n\n## 快速排序\n\n- `快速排序（QuickSorting)`\n\n  是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列\n\n![img](4.png)\n\n\n\n代码实现\n\n\n\n```java\npublic static void quickSort(int[] arr,int left, int right) {\n        int l = left; //左下标\n        int r = right; //右下标\n        //pivot 中轴值\n        int pivot = arr[(left + right) / 2];\n        int temp = 0; //临时变量，作为交换时使用\n        //while循环的目的是让比pivot 值小放到左边\n        //比pivot 值大放到右边\n        while( l < r) {\n            //在pivot的左边一直找,找到大于等于pivot值,才退出\n            while( arr[l] < pivot) {\n                l += 1;\n            }\n            //在pivot的右边一直找,找到小于等于pivot值,才退出\n            while(arr[r] > pivot) {\n                r -= 1;\n            }\n            //如果l >= r说明pivot 的左右两的值，已经按照左边全部是\n            //小于等于pivot值，右边全部是大于等于pivot值\n            if( l >= r) {\n                break;\n            }\n            //交换\n            temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n\n            //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移\n            if(arr[l] == pivot) {\n                r -= 1;\n            }\n            //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移\n            if(arr[r] == pivot) {\n                l += 1;\n            }\n        }\n\n        // 如果 l == r, 必须l++, r--, 否则为出现栈溢出\n        if (l == r) {\n            l += 1;\n            r -= 1;\n        }\n        //向左递归\n        if(left < r) {\n            quickSort(arr, left, r);\n        }\n        //向右递归\n        if(right > l) {\n            quickSort(arr, l, right);\n        }\n    }\n```\n\n\n\n## 归并排序\n\n- `归并排序（mergeSorting)`的基本思想是：\n\n  是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案\"修补\"在一起，即分而治之)。\n\n![img](5.png)\n\n\n\n代码实现\n\n\n\n```java\n //分+合方法\n    public static void mergeSort(int[] arr, int left, int right, int[] temp) {\n        if(left < right) {\n            int mid = (left + right) / 2; //中间索引\n            //向左递归进行分解\n            mergeSort(arr, left, mid, temp);\n            //向右递归进行分解\n            mergeSort(arr, mid + 1, right, temp);\n            //合并\n            merge(arr, left, mid, right, temp);\n        }\n    }\n\n    //合并的方法\n    /**\n     *\n     * @param arr 排序的原始数组\n     * @param left 左边有序序列的初始索引\n     * @param mid 中间索引\n     * @param right 右边索引\n     * @param temp 做中转的数组\n     */\n    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {\n        int i = left; // 初始化i, 左边有序序列的初始索引\n        int j = mid + 1; //初始化j, 右边有序序列的初始索引\n        int t = 0; // 指向temp数组的当前索引\n        //(一)\n        //先把左右两边(有序)的数据按照规则填充到temp数组\n        //直到左右两边的有序序列，有一边处理完毕为止\n        while (i <= mid && j <= right) {//继续\n            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素\n            //即将左边的当前元素，填充到 temp数组\n            //然后 t++, i++\n            if(arr[i] <= arr[j]) {\n                temp[t] = arr[i];\n                t += 1;\n                i += 1;\n            } else { //反之,将右边有序序列的当前元素，填充到temp数组\n                temp[t] = arr[j];\n                t += 1;\n                j += 1;\n            }\n        }\n        //(二)\n        //把有剩余数据的一边的数据依次全部填充到temp\n        while( i <= mid) { //左边的有序序列还有剩余的元素，就全部填充到temp\n            temp[t] = arr[i];\n            t += 1;\n            i += 1;\n        }\n        while( j <= right) { //右边的有序序列还有剩余的元素，就全部填充到temp\n            temp[t] = arr[j];\n            t += 1;\n            j += 1;\n        }\n        //(三)\n        //将temp数组的元素拷贝到arr\n        //注意，并不是每次都拷贝所有\n        t = 0;\n        int tempLeft = left; //\n        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3\n        //最后一次 tempLeft = 0  right = 7\n        while(tempLeft <= right) {\n            arr[tempLeft] = temp[t];\n            t += 1;\n            tempLeft += 1;\n        }\n\n    }\n```\n\n\n\n\n\n\n\n## 基数排序\n\n- `基数排序（mergeSorting)`的基本思想是：\n\n  将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n\n![img](6.png)\n\n\n\n代码实现\n\n\n\n```java\n\n    //基数排序方法\n    public static void radixSort(int[] arr) {\n\n        //根据前面的推导过程，我们可以得到最终的基数排序代码\n\n        //1. 得到数组中最大的数的位数\n        int max = arr[0]; //假设第一数就是最大数\n        for(int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        //得到最大数是几位数\n        int maxLength = (max + \"\").length();\n\n        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组\n        //说明\n        //1. 二维数组包含10个一维数组\n        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length\n        //3. 名明确，基数排序是使用空间换时间的经典算法\n        int[][] bucket = new int[10][arr.length];\n\n        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数\n        //可以这里理解\n        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数\n        int[] bucketElementCounts = new int[10];\n\n        //这里使用循环将代码处理\n\n        for(int i = 0 , n = 1; i < maxLength; i++, n *= 10) {\n            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..\n            for(int j = 0; j < arr.length; j++) {\n                //取出每个元素的对应位的值\n                int digitOfElement = arr[j] / n % 10;\n                //放入到对应的桶中\n                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];\n                bucketElementCounts[digitOfElement]++;\n            }\n            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)\n            int index = 0;\n            //遍历每一桶，并将桶中是数据，放入到原数组\n            for(int k = 0; k < bucketElementCounts.length; k++) {\n                //如果桶中，有数据，我们才放入到原数组\n                if(bucketElementCounts[k] != 0) {\n                    //循环该桶即第k个桶(即第k个一维数组), 放入\n                    for(int l = 0; l < bucketElementCounts[k]; l++) {\n                        //取出元素放入到arr\n                        arr[index++] = bucket[k][l];\n                    }\n                }\n                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！\n                bucketElementCounts[k] = 0;\n            }\n\n        }\n\n    }\n```\n\n\n\n各个算法的复杂度\n\n![img](7.png)\n\n\n\n\n\n","tags":["dataAlgorithm"]},{"title":"计算机组成原理","url":"/2020/05/14/计算机组成原理/","content":"\n# 计算机组成原理\n\n#### 1.第一台电子计算机何时何地诞生？英文全称？\n\n1946年2月14日 美国宾夕法尼亚大学<!--more-->\n\nENIAC：电子数字积分计算机\n\nElectronic(电子的) Numerical(数字的) Integrator(综合者) And Calculator(计算机)\n\n#### 2.冯·诺依曼型计算机组成,思想?\n\n计算机组成:\n\n运算器、控制器、存储器、输入设备、输出设备。\n\n思想：\n\n采用二进制的形式表示数据和指令，将数据和指令事先保存在存储器中，按照顺序执行程序来控制计算机工作运行。\n\n#### 3.现代计算机硬件系统与冯·诺依曼型计算机组成有什么不同？\n\n相同点：\n\n现代计算机仍是冯·诺依曼体系结构。\n\n不同点：组成形式改变很大\n\n(1)逻辑元件组装成电路高度集成,把运算、控制器集成到一块CPU芯片上。\n\n(2)存储器分为三级：高速缓冲存储器Cache，主存储器(内存),外部存储器;\n\n其中Cache现在都集成在CPU里,主存由内存条实现,外部存储器主要有机械硬盘,固态硬盘等;\n\n(3)输出与输入设备主要有显示屏,鼠标,键盘.\n\n显示器有专门显示接口(集成或独立显卡)连接CPU或主存,键盘和鼠标也通过集成接口CPU.\n\n此外还配置集成网卡和声卡.\n\n(4)USB多种连接接口实现网络与多媒体连接.整个系统采用多级总线结构组成.\n\n#### 4.CPU的性能公式,性能指标,如何评价?"},{"title":"队列","url":"/2020/05/14/队列/","content":"\n### 队列\n\n##### 定义：\n\n遵循先进先出，就是队列。可以想象为排队，先排队的人先办理业务。\n\n<!--more-->\n\n- 队列是一个有序列表。\n\n- 遵循先进先出的原则。即：先存入的数据先取出，后存入的数据后取出。\n\n- 示意：数组模拟：\n\n  \n\n  ![img](2.png)\n\n队列本身是有序列表，如使用数组的结构来存储队列的数据，因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，其中 maxSize是该队列的最大容量。如图所示。\n\n\n\n用稀疏数组代替二维数组，第0行表示稀疏数组的总行，总列和所需内容的个数。\n\n代码实现\n\n```java\npackage queue;\n\nimport java.util.Scanner;\n\npublic class CircleArrayQueueDemo {\n\n  public static void main(String[] args) {\n\n    //测试\n    System.out.println(\"测试数组模拟环形队列的案例~~~\");\n\n    // 创建一个环形队列\n    CircleArray queue = new CircleArray(4); //说明设置4, 其队列的有效数据最大是3\n    char key = ' '; // 接收用户输入\n    Scanner scanner = new Scanner(System.in);//\n    boolean loop = true;\n    // 输出一个菜单\n    while (loop) {\n      System.out.println(\"s(show): 显示队列\");\n      System.out.println(\"e(exit): 退出程序\");\n      System.out.println(\"a(add): 添加数据到队列\");\n      System.out.println(\"g(get): 从队列取出数据\");\n      System.out.println(\"h(head): 查看队列头的数据\");\n      key = scanner.next().charAt(0);// 接收一个字符\n      switch (key) {\n        case 's':\n          queue.showQueue();\n          break;\n        case 'a':\n          System.out.println(\"输出一个数\");\n          int value = scanner.nextInt();\n          queue.addQueue(value);\n          break;\n        case 'g': // 取出数据\n          try {\n            int res = queue.getQueue();\n            System.out.printf(\"取出的数据是%d\\n\", res);\n          } catch (Exception e) {\n            // TODO: handle exception\n            System.out.println(e.getMessage());\n          }\n          break;\n        case 'h': // 查看队列头的数据\n          try {\n            int res = queue.headQueue();\n            System.out.printf(\"队列头的数据是%d\\n\", res);\n          } catch (Exception e) {\n            // TODO: handle exception\n            System.out.println(e.getMessage());\n          }\n          break;\n        case 'e': // 退出\n          scanner.close();\n          loop = false;\n          break;\n        default:\n          break;\n      }\n    }\n    System.out.println(\"程序退出~~\");\n  }\n\n}\n\n\nclass CircleArray {\n  private int maxSize; // 表示数组的最大容量\n  //front 变量的含义做一个调整：front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素\n  //front 的初始值 = 0\n  private int front;\n  //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.\n  //rear 的初始值 = 0\n  private int rear; // 队列尾\n  private int[] arr; // 该数据用于存放数据, 模拟队列\n\n  public CircleArray(int arrMaxSize) {\n    maxSize = arrMaxSize;\n    arr = new int[maxSize];\n  }\n\n  // 判断队列是否满\n  public boolean isFull() {\n    return (rear  + 1) % maxSize == front;\n  }\n\n  // 判断队列是否为空\n  public boolean isEmpty() {\n    return rear == front;\n  }\n\n  // 添加数据到队列\n  public void addQueue(int n) {\n    // 判断队列是否满\n    if (isFull()) {\n      System.out.println(\"队列满，不能加入数据~\");\n      return;\n    }\n    //直接将数据加入\n    arr[rear] = n;\n    //将 rear 后移, 这里必须考虑取模\n    rear = (rear + 1) % maxSize;\n  }\n\n  // 获取队列的数据, 出队列\n  public int getQueue() {\n    // 判断队列是否空\n    if (isEmpty()) {\n      // 通过抛出异常\n      throw new RuntimeException(\"队列空，不能取数据\");\n    }\n    // 这里需要分析出 front是指向队列的第一个元素\n    // 1. 先把 front 对应的值保留到一个临时变量\n    // 2. 将 front 后移, 考虑取模\n    // 3. 将临时保存的变量返回\n    int value = arr[front];\n    front = (front + 1) % maxSize;\n    return value;\n\n  }\n\n  // 显示队列的所有数据\n  public void showQueue() {\n    // 遍历\n    if (isEmpty()) {\n      System.out.println(\"队列空的，没有数据~~\");\n      return;\n    }\n    // 思路：从front开始遍历，遍历多少个元素\n    // 动脑筋\n    for (int i = front; i < front + size() ; i++) {\n      System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]);\n    }\n  }\n\n  // 求出当前队列有效数据的个数\n  public int size() {\n    // rear = 2\n    // front = 1\n    // maxSize = 3\n    return (rear + maxSize - front) % maxSize;\n  }\n\n  // 显示队列的头数据， 注意不是取出数据\n  public int headQueue() {\n    // 判断\n    if (isEmpty()) {\n      throw new RuntimeException(\"队列空的，没有数据~~\");\n    }\n    return arr[front];\n  }\n}\n```\n\n","tags":["dataAlgorithm"]},{"title":"Inversion of Control控制反转","url":"/2020/05/13/Inversion-of-Control控制反转/","content":"\n### 控制反转的定义：\n\nInversion of Control控制反转，贯穿Spring的始终，Spring的核心。由spring来负责控制对象的生命周期和对象间的关系。\n\n<!--more-->\n\nIOC的思想是反转资源获取方向.传统的资源查找方式要求组件向容器发起请求查找资源.作为回应,容器适时的返回资源,而应用IOC之后,则是容器主动的将资源推送给它所管理的组件,组件所要做的仅仅是选择一种合适的方式来接受资源,这种行为也被称为查找的被动形式.\n\n\n\n▼传统的方法获取：\n\n```java\nPojo pojo = new Pojo( );\n```\n\n\n\n▼Spring管理的bean获取：\n\n```java\n@AutowiredPojo \npojo;\n```\n\n’ 对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。‘","tags":["frame"]},{"title":"链表","url":"/2020/05/12/链表/","content":"\n链表是有序的列表，但它在内存里是无序的。\n\n![img](链表.png)\n\n<!--more-->\n\n- 链表是以节点的方式来存储,是链式存储\n- 每个节点包含data 域， next 域：指向下一个节点\n- 各个节点不一定是连续存储.\n- 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定\n\n▼单链表：\n\n![img](单链表.png)\n\n实现：\n\n```java\npackage linkedlist;\n\n/**\n * @Author\n * @Date: 2020/5/11 10:59\n */\n\nimport java.util.Stack;\n\npublic class SingleLinkedListDemo {\n\n    public static void main(String[] args) {\n        //进行测试\n        //先创建节点\n        HeroNode hero1 = new HeroNode(1, \"宋江\", \"及时雨\");\n        HeroNode hero2 = new HeroNode(2, \"卢俊义\", \"玉麒麟\");\n        HeroNode hero3 = new HeroNode(3, \"吴用\", \"智多星\");\n        HeroNode hero4 = new HeroNode(4, \"林冲\", \"豹子头\");\n\n        //创建要给链表\n        SingleLinkedList singleLinkedList = new SingleLinkedList();\n\n\n        //加入\n        singleLinkedList.add(hero1);\n        singleLinkedList.add(hero4);\n        singleLinkedList.add(hero2);\n        singleLinkedList.add(hero3);\n\n        // 测试一下单链表的反转功能\n        System.out.println(\"原来链表的情况~~\");\n        singleLinkedList.list();\n\n//    System.out.println(\"反转单链表~~\");\n//    reversetList(singleLinkedList.getHead());\n//    singleLinkedList.list();\n\n        System.out.println(\"测试逆序打印单链表, 没有改变链表的结构~~\");\n        reversetList(singleLinkedList.getHead());\n\n\n    //加入按照编号的顺序\n    singleLinkedList.addByOrder(hero1);\n    singleLinkedList.addByOrder(hero4);\n    singleLinkedList.addByOrder(hero2);\n    singleLinkedList.addByOrder(hero3);\n\n    //显示一把\n    singleLinkedList.list();\n\n    //测试修改节点的代码\n    HeroNode newHeroNode = new HeroNode(2, \"小卢\", \"玉麒麟~~\");\n    singleLinkedList.update(newHeroNode);\n\n    System.out.println(\"修改后的链表情况~~\");\n    singleLinkedList.list();\n\n    //删除一个节点\n    singleLinkedList.del(1);\n    singleLinkedList.del(4);\n    System.out.println(\"删除后的链表情况~~\");\n    singleLinkedList.list();\n\n    //测试一下 求单链表中有效节点的个数\n    System.out.println(\"有效的节点个数=\" + getLength(singleLinkedList.getHead()));//2\n\n    //测试一下看看是否得到了倒数第K个节点\n    HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3);\n    System.out.println(\"res=\" + res);\n\n\n    }\n    //将单链表反转\n    public static void reversetList(HeroNode head) {\n        //如果当前链表为空，或者只有一个节点，无需反转，直接返回\n        if(head.next == null || head.next.next == null) {\n            return ;\n        }\n\n        //定义一个辅助的指针(变量)，帮助我们遍历原来的链表\n        HeroNode cur = head.next;\n        HeroNode next = null;// 指向当前节点[cur]的下一个节点\n        HeroNode reverseHead = new HeroNode(0, \"\", \"\");\n        //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端\n        //动脑筋\n        while(cur != null) {\n            next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用\n            cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端\n            reverseHead.next = cur; //将cur 连接到新的链表上\n            cur = next;//让cur后移\n        }\n        //将head.next 指向 reverseHead.next , 实现单链表的反转\n        head.next = reverseHead.next;\n    }\n\n    //查找单链表中的倒数第k个结点 【新浪面试题】\n    //思路\n    //1. 编写一个方法，接收head节点，同时接收一个index\n    //2. index 表示是倒数第index个节点\n    //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength\n    //4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到\n    //5. 如果找到了，则返回该节点，否则返回nulll\n    public static HeroNode findLastIndexNode(HeroNode head, int index) {\n        //判断如果链表为空，返回null\n        if(head.next == null) {\n            return null;//没有找到\n        }\n        //第一个遍历得到链表的长度(节点个数)\n        int size = getLength(head);\n        //第二次遍历  size-index 位置，就是我们倒数的第K个节点\n        //先做一个index的校验\n        if(index <=0 || index > size) {\n            return null;\n        }\n        //定义给辅助变量， for 循环定位到倒数的index\n        HeroNode cur = head.next; //3 // 3 - 1 = 2\n        for(int i =0; i< size - index; i++) {\n            cur = cur.next;\n        }\n        return cur;\n\n    }\n\n    //方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)\n    /**\n     *\n     * @param head 链表的头节点\n     * @return 返回的就是有效节点的个数\n     */\n    public static int getLength(HeroNode head) {\n        if(head.next == null) { //空链表\n            return 0;\n        }\n        int length = 0;\n        //定义一个辅助的变量, 这里我们没有统计头节点\n        HeroNode cur = head.next;\n        while(cur != null) {\n            length++;\n            cur = cur.next; //遍历\n        }\n        return length;\n    }\n\n}\n\n\n//定义SingleLinkedList 管理我们的英雄\nclass SingleLinkedList {\n    //先初始化一个头节点, 头节点不要动, 不存放具体的数据\n    private HeroNode head = new HeroNode(0, \"\", \"\");\n\n\n    //返回头节点\n    public HeroNode getHead() {\n        return head;\n    }\n\n    //添加节点到单向链表\n    //思路，当不考虑编号顺序时\n    //1. 找到当前链表的最后节点\n    //2. 将最后这个节点的next 指向 新的节点\n    public void add(HeroNode heroNode) {\n\n        //因为head节点不能动，因此我们需要一个辅助遍历 temp\n        HeroNode temp = head;\n        //遍历链表，找到最后\n        while(true) {\n            //找到链表的最后\n            if(temp.next == null) {//\n                break;\n            }\n            //如果没有找到最后, 将将temp后移\n            temp = temp.next;\n        }\n        //当退出while循环时，temp就指向了链表的最后\n        //将最后这个节点的next 指向 新的节点\n        temp.next = heroNode;\n    }\n\n    //第二种方式在添加英雄时，根据排名将英雄插入到指定位置\n    //(如果有这个排名，则添加失败，并给出提示)\n    public void addByOrder(HeroNode heroNode) {\n        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置\n        //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了\n        HeroNode temp = head;\n        boolean flag = false; // flag标志添加的编号是否存在，默认为false\n        while(true) {\n            if(temp.next == null) {//说明temp已经在链表的最后\n                break; //\n            }\n            if(temp.next.no > heroNode.no) { //位置找到，就在temp的后面插入\n                break;\n            } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在\n\n                flag = true; //说明编号存在\n                break;\n            }\n            temp = temp.next; //后移，遍历当前链表\n        }\n        //判断flag 的值\n        if(flag) { //不能添加，说明编号存在\n            System.out.printf(\"准备插入的英雄的编号 %d 已经存在了, 不能加入\\n\", heroNode.no);\n        } else {\n            //插入到链表中, temp的后面\n            heroNode.next = temp.next;\n            temp.next = heroNode;\n        }\n    }\n\n    //修改节点的信息, 根据no编号来修改，即no编号不能改.\n    //说明\n    //1. 根据 newHeroNode 的 no 来修改即可\n    public void update(HeroNode newHeroNode) {\n        //判断是否空\n        if(head.next == null) {\n            System.out.println(\"链表为空~\");\n            return;\n        }\n        //找到需要修改的节点, 根据no编号\n        //定义一个辅助变量\n        HeroNode temp = head.next;\n        boolean flag = false; //表示是否找到该节点\n        while(true) {\n            if (temp == null) {\n                break; //已经遍历完链表\n            }\n            if(temp.no == newHeroNode.no) {\n                //找到\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        //根据flag 判断是否找到要修改的节点\n        if(flag) {\n            temp.name = newHeroNode.name;\n            temp.nickname = newHeroNode.nickname;\n        } else { //没有找到\n            System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no);\n        }\n    }\n\n    //删除节点\n    //思路\n    //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点\n    //2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较\n    public void del(int no) {\n        HeroNode temp = head;\n        boolean flag = false; // 标志是否找到待删除节点的\n        while(true) {\n            if(temp.next == null) { //已经到链表的最后\n                break;\n            }\n            if(temp.next.no == no) {\n                //找到的待删除节点的前一个节点temp\n                flag = true;\n                break;\n            }\n            temp = temp.next; //temp后移，遍历\n        }\n        //判断flag\n        if(flag) { //找到\n            //可以删除\n            temp.next = temp.next.next;\n        }else {\n            System.out.printf(\"要删除的 %d 节点不存在\\n\", no);\n        }\n    }\n\n    //显示链表[遍历]\n    public void list() {\n        //判断链表是否为空\n        if(head.next == null) {\n            System.out.println(\"链表为空\");\n            return;\n        }\n        //因为头节点，不能动，因此我们需要一个辅助变量来遍历\n        HeroNode temp = head.next;\n        while(true) {\n            //判断是否到链表最后\n            if(temp == null) {\n                break;\n            }\n            //输出节点的信息\n            System.out.println(temp);\n            //将temp后移， 一定小心\n            temp = temp.next;\n        }\n    }\n}\n\n//定义HeroNode ， 每个HeroNode 对象就是一个节点\nclass HeroNode {\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode next; //指向下一个节点\n    //构造器\n    public HeroNode(int no, String name, String nickname) {\n        this.no = no;\n        this.name = name;\n        this.nickname = nickname;\n    }\n    //为了显示方法，我们重新toString\n    @Override\n    public String toString() {\n        return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\";\n    }\n\n}\n\n\n\n\n▼双向链表：\n\n单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点\n\npackage linkedlist;\n\n\npublic class DoubleLinkedListDemo {\n\n    public static void main(String[] args) {\n        // 测试\n        System.out.println(\"双向链表的测试\");\n        // 先创建节点\n        HeroNode2 hero1 = new HeroNode2(1, \"宋江\", \"及时雨\");\n        HeroNode2 hero2 = new HeroNode2(2, \"卢俊义\", \"玉麒麟\");\n        HeroNode2 hero3 = new HeroNode2(3, \"吴用\", \"智多星\");\n        HeroNode2 hero4 = new HeroNode2(4, \"林冲\", \"豹子头\");\n        // 创建一个双向链表\n        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();\n        doubleLinkedList.add(hero1);\n        doubleLinkedList.add(hero2);\n        doubleLinkedList.add(hero3);\n        doubleLinkedList.add(hero4);\n\n        doubleLinkedList.list();\n\n        // 修改\n        HeroNode2 newHeroNode = new HeroNode2(4, \"公孙胜\", \"入云龙\");\n        doubleLinkedList.update(newHeroNode);\n        System.out.println(\"修改后的链表情况\");\n        doubleLinkedList.list();\n\n        // 删除\n        doubleLinkedList.del(3);\n        System.out.println(\"删除后的链表情况~~\");\n        doubleLinkedList.list();\n\n\n\n    }\n\n}\n\n// 创建一个双向链表的类\nclass DoubleLinkedList {\n\n    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据\n    private HeroNode2 head = new HeroNode2(0, \"\", \"\");\n\n    // 返回头节点\n    public HeroNode2 getHead() {\n        return head;\n    }\n\n    // 遍历双向链表的方法\n    // 显示链表[遍历]\n    public void list() {\n        // 判断链表是否为空\n        if (head.next == null) {\n            System.out.println(\"链表为空\");\n            return;\n        }\n        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历\n        HeroNode2 temp = head.next;\n        while (true) {\n            // 判断是否到链表最后\n            if (temp == null) {\n                break;\n            }\n            // 输出节点的信息\n            System.out.println(temp);\n            // 将temp后移， 一定小心\n            temp = temp.next;\n        }\n    }\n\n    // 添加一个节点到双向链表的最后.\n    public void add(HeroNode2 heroNode) {\n\n        // 因为head节点不能动，因此我们需要一个辅助遍历 temp\n        HeroNode2 temp = head;\n        // 遍历链表，找到最后\n        while (true) {\n            // 找到链表的最后\n            if (temp.next == null) {//\n                break;\n            }\n            // 如果没有找到最后, 将将temp后移\n            temp = temp.next;\n        }\n        // 当退出while循环时，temp就指向了链表的最后\n        // 形成一个双向链表\n        temp.next = heroNode;\n        heroNode.pre = temp;\n    }\n\n    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样\n    // 只是 节点类型改成 HeroNode2\n    public void update(HeroNode2 newHeroNode) {\n        // 判断是否空\n        if (head.next == null) {\n            System.out.println(\"链表为空~\");\n            return;\n        }\n        // 找到需要修改的节点, 根据no编号\n        // 定义一个辅助变量\n        HeroNode2 temp = head.next;\n        boolean flag = false; // 表示是否找到该节点\n        while (true) {\n            if (temp == null) {\n                break; // 已经遍历完链表\n            }\n            if (temp.no == newHeroNode.no) {\n                // 找到\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        // 根据flag 判断是否找到要修改的节点\n        if (flag) {\n            temp.name = newHeroNode.name;\n            temp.nickname = newHeroNode.nickname;\n        } else { // 没有找到\n            System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no);\n        }\n    }\n\n    // 从双向链表中删除一个节点,\n    // 说明\n    // 1 对于双向链表，我们可以直接找到要删除的这个节点\n    // 2 找到后，自我删除即可\n    public void del(int no) {\n\n        // 判断当前链表是否为空\n        if (head.next == null) {// 空链表\n            System.out.println(\"链表为空，无法删除\");\n            return;\n        }\n\n        HeroNode2 temp = head.next; // 辅助变量(指针)\n        boolean flag = false; // 标志是否找到待删除节点的\n        while (true) {\n            if (temp == null) { // 已经到链表的最后\n                break;\n            }\n            if (temp.no == no) {\n                // 找到的待删除节点的前一个节点temp\n                flag = true;\n                break;\n            }\n            temp = temp.next; // temp后移，遍历\n        }\n        // 判断flag\n        if (flag) { // 找到\n            // 可以删除\n            // temp.next = temp.next.next;[单向链表]\n            temp.pre.next = temp.next;\n            // 这里我们的代码有问题?\n            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针\n            if (temp.next != null) {\n                temp.next.pre = temp.pre;\n            }\n        } else {\n            System.out.printf(\"要删除的 %d 节点不存在\\n\", no);\n        }\n    }\n\n}\n\n// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点\nclass HeroNode2 {\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode2 next; // 指向下一个节点, 默认为null\n    public HeroNode2 pre; // 指向前一个节点, 默认为null\n    // 构造器\n\n    public HeroNode2(int no, String name, String nickname) {\n        this.no = no;\n        this.name = name;\n        this.nickname = nickname;\n    }\n\n    // 为了显示方法，我们重新toString\n    @Override\n    public String toString() {\n        return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\";\n    }\n\n}\n\n\n\n▼循环链表：\n\npackage linkedlist;\n\npublic class Josepfu {\n\n  public static void main(String[] args) {\n    // 测试一把看看构建环形链表，和遍历是否ok\n    CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();\n    circleSingleLinkedList.addBoy(125);// 加入5个小孩节点\n    circleSingleLinkedList.showBoy();\n\n    //测试一把小孩出圈是否正确\n    circleSingleLinkedList.countBoy(10, 20, 125); // 2->4->1->5->3\n    //String str = \"7*2*2-5+1-5+3-3\";\n  }\n\n}\n\n// 创建一个环形的单向链表\nclass CircleSingleLinkedList {\n  // 创建一个first节点,当前没有编号\n  private Boy first = null;\n\n  // 添加小孩节点，构建成一个环形的链表\n  public void addBoy(int nums) {\n    // nums 做一个数据校验\n    if (nums < 1) {\n      System.out.println(\"nums的值不正确\");\n      return;\n    }\n    Boy curBoy = null; // 辅助指针，帮助构建环形链表\n    // 使用for来创建我们的环形链表\n    for (int i = 1; i <= nums; i++) {\n      // 根据编号，创建小孩节点\n      Boy boy = new Boy(i);\n      // 如果是第一个小孩\n      if (i == 1) {\n        first = boy;\n        first.setNext(first); // 构成环\n        curBoy = first; // 让curBoy指向第一个小孩\n      } else {\n        curBoy.setNext(boy);//\n        boy.setNext(first);//\n        curBoy = boy;\n      }\n    }\n  }\n\n  // 遍历当前的环形链表\n  public void showBoy() {\n    // 判断链表是否为空\n    if (first == null) {\n      System.out.println(\"没有任何小孩~~\");\n      return;\n    }\n    // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历\n    Boy curBoy = first;\n    while (true) {\n      System.out.printf(\"小孩的编号 %d \\n\", curBoy.getNo());\n      if (curBoy.getNext() == first) {// 说明已经遍历完毕\n        break;\n      }\n      curBoy = curBoy.getNext(); // curBoy后移\n    }\n  }\n\n  // 根据用户的输入，计算出小孩出圈的顺序\n  /**\n   *\n   * @param startNo\n   *            表示从第几个小孩开始数数\n   * @param countNum\n   *            表示数几下\n   * @param nums\n   *            表示最初有多少小孩在圈中\n   */\n  public void countBoy(int startNo, int countNum, int nums) {\n    // 先对数据进行校验\n    if (first == null || startNo < 1 || startNo > nums) {\n      System.out.println(\"参数输入有误， 请重新输入\");\n      return;\n    }\n    // 创建要给辅助指针,帮助完成小孩出圈\n    Boy helper = first;\n    // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点\n    while (true) {\n      if (helper.getNext() == first) { // 说明helper指向最后小孩节点\n        break;\n      }\n      helper = helper.getNext();\n    }\n    //小孩报数前，先让 first 和  helper 移动 k - 1次\n    for(int j = 0; j < startNo - 1; j++) {\n      first = first.getNext();\n      helper = helper.getNext();\n    }\n    //当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈\n    //这里是一个循环操作，知道圈中只有一个节点\n    while(true) {\n      if(helper == first) { //说明圈中只有一个节点\n        break;\n      }\n      //让 first 和 helper 指针同时 的移动 countNum - 1\n      for(int j = 0; j < countNum - 1; j++) {\n        first = first.getNext();\n        helper = helper.getNext();\n      }\n      //这时first指向的节点，就是要出圈的小孩节点\n      System.out.printf(\"小孩%d出圈\\n\", first.getNo());\n      //这时将first指向的小孩节点出圈\n      first = first.getNext();\n      helper.setNext(first); //\n\n    }\n    System.out.printf(\"最后留在圈中的小孩编号%d \\n\", first.getNo());\n\n  }\n}\n\n// 创建一个Boy类，表示一个节点\nclass Boy {\n  private int no;// 编号\n  private Boy next; // 指向下一个节点,默认null\n\n  public Boy(int no) {\n    this.no = no;\n  }\n\n  public int getNo() {\n    return no;\n  }\n\n  public void setNo(int no) {\n    this.no = no;\n  }\n\n  public Boy getNext() {\n    return next;\n  }\n\n  public void setNext(Boy next) {\n    this.next = next;\n  }\n\n}\n\n```\n\n\n\n","tags":["dataAlgorithm"]},{"title":"栈Stack","url":"/2020/05/11/栈Stack/","content":"\n## 栈(stack)\n\n1`栈`是一个**先入后出**(FILO-First In Last Out)的有序列表。\n\n<!--more-->\n\n2栈(stack)是限制线性表中元素的插入和删除**只能在线性表的同一端**进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为**栈顶**(Top)，另一端为固定的一端，称为**栈底**(Bottom)。\n\n3.根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除\n\n```\n           ───────────────────────────────┐\n  (\\(\\       (\\(\\    (\\(\\    (\\(\\    (\\(\\ │\n (='.') <─> (='.')  (='.')  (='.')  (='.')│\nO(_\")\")    O(_\")\") O(_\")\") O(_\")\") O(_\")\")│\n           ───────────────────────────────┘\n           stack\n```\n\n<!--more-->\n\n和队列区别开\n\n```\n          ────────────────────────\n  (\\(\\      (\\(\\    (\\(\\    (\\(\\      (\\(\\\n (='.') ─> (='.')  (='.')  (='.') ─> (='.')\nO(_\")\")   O(_\")\") O(_\")\") O(_\")\")   O(_\")\")\n          ────────────────────────\n           Queue\n```\n\n---\n\n##### 栈的结构\n\n```\n           ───────────────────────────────┐\n             (\\(\\    (\\(\\    (\\(\\    (\\(\\ │\n            (='.')  (='.')  (='.')  (='.')│\n           O(_\")\") O(_\")\") O(_\")\") O(_\")\")│\n           ───────────────────────────────┘\n             ↑                        ↑\n           Top栈顶                 Bottom栈底\n          初始化为-1\n```\n\n\n\n##### 入栈\n\n```\n           ───────────────────────────────┐\n  (\\(\\               (\\(\\    (\\(\\    (\\(\\ │\n (='.')  ─>         (='.')  (='.')  (='.')│\nO(_\")\")            O(_\")\") O(_\")\") O(_\")\")│\n  data     ───────────────────────────────┘\n           push入栈\n           top++;\n           stack[top]=data     \n```\n\n##### 出栈\n\n```\n           ───────────────────────────────┐\n         (\\(\\        (\\(\\    (\\(\\    (\\(\\ │\n    <─  (='.')      (='.')  (='.')  (='.')│\n       O(_\")\")     O(_\")\") O(_\")\") O(_\")\")│\n           ───────────────────────────────┘\n           pop出栈\n          int value = stack[top];\n          top--;\n          return value;\n```\n\n","tags":["dataAlgorithm"]},{"title":"SparseArray稀疏数组","url":"/2020/05/07/SparseArray稀疏数组/","content":"\nSparseArray\n\n## 稀疏数组\n\n\n\n\n\n\n\n![img](https://mmbiz.qpic.cn/mmbiz_jpg/LqMJZoibIrPxkb7YYhRmbdmHxsFb2c7Tol4pytSR2yW4pq9wSCjiaSkxlEY2V4L1AflRGQ8HqQcibtVfRSFofENcQ/640?wx_fmt=jpeg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**（稀疏数组）**\n\n<!--more-->\n\n### 定义\n\n##### 当一个数组中大部分的值未被使用，只有少部分的值的空间使用，造成了内存的浪费，这个时候就可以用到稀疏数组，保存需要的数据，节约内存空间。\n\n当记录一个棋盘时：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/LqMJZoibIrPzz08etWsVDczAaxvuTLF53AO9Y95X14hib9758qNT74snT2caWibZhtNQHCstK4KibDDibWcIxZhcPyQ/640?wx_fmt=png)\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/LqMJZoibIrPzz08etWsVDczAaxvuTLF53Lic6f7kA2vWzahAXd97hT2SjHxbZT4DociaLjYkS4q91sApHcibtMiaBNg/640?wx_fmt=png)\n\n记录棋盘的位置，只有两个内容，其他未被使用没有意义的值浪费了内存空间\n\n使用稀疏数组代替二维数组，第0行表示稀疏数组的总行，总列和所需内容的个数。\n\n### 实现\n\n```java\npackage com.kayleh.tmall.controller;\n\n/**\n * @Author: Wizard\n * @Date: 2020/5/7 9:16\n */\npublic class SparseArray {\n    public static void main(String[] args) {\n        //创建一个二维数组\n        //0:表示没有棋子 1表示黑子 2表示蓝子\n        int chessArr[][] = new int[11][10];\n        chessArr[1][2] = 1;\n        chessArr[2][3] = 2;\n        for(int[] row:chessArr){\n            for(int data:row){\n                System.out.printf(\"%d\\t\",data);\n            }\n            System.out.println();\n        }\n\n        int[][] array = getSparseArray(chessArr);\n        System.out.println(\"-------\");\n        for(int i = 0 ; i< array.length;i++){\n            System.out.printf(\"%d\\t%d\\t%d\\t\\n\",array[i][0],array[i][1],array[i][2]);\n        }\n        System.out.println(\"--------\");\n        int[][] startArr = recovery(array);\n        for(int[] row:startArr){\n            for(int data:row){\n                System.out.printf(\"%d\\t\",data);\n            }\n            System.out.println();\n        }\n    }\n\n    /**\n     * 将普通数组转换为稀疏数组\n     * @param chessArr\n     * @return\n     */\n    public static int[][] getSparseArray(int[][] chessArr){\n        if(!checkIsRight(chessArr)){\n            return null;\n        }\n\n        //1.拿到数组后 首先获取元素的个数,然后才能建立稀疏数组\n        int sum = 0;\n        for(int[] arr:chessArr){\n            for(int i:arr){\n                if(i != 0){\n                    sum++;\n                }\n            }\n        }\n\n        //2.建立稀疏数组\n        int[][] sparseArr = new int[sum+1][3];\n        sparseArr[0][0] = chessArr.length; //行\n        sparseArr[0][1] = chessArr[0].length;//列\n        sparseArr[0][2] = sum; //元素个数\n\n        //3.数组存放\n        int count = 0;\n        for(int i = 0; i <chessArr.length; i++ ){\n            for(int j = 0; j <chessArr[i].length;j++ ){\n                if(chessArr[i][j] != 0){\n                    sparseArr[++count][0] = i;//行\n                    sparseArr[count][1] = j;//列\n                    sparseArr[count][2] = chessArr[i][j];\n                }\n            }\n        }\n\n        return sparseArr;\n    }\n\n    /**\n     * 将稀疏数组转回普通数组\n     * @param sparseArr\n     * @return\n     */\n    public static int[][] recovery(int[][] sparseArr){\n        if(!checkIsRight(sparseArr)){\n            return null;\n        }\n\n        //获取原数组的 行数和列数 并创建原数组\n        int arr[][] = new int[sparseArr[0][0]][sparseArr[0][1]];\n\n        for(int i = 1; i < sparseArr.length;i++){\n            arr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n        }\n\n        return arr;\n    }\n\n        \n    public static boolean checkIsRight(int[][] arr){\n        if(arr == null || arr.length <= 1 ){\n            return false;\n        }\n        return true;\n    }\n\n}\n```\n\n\n\n每日学习干货 ∣一个有用的公众号\n\n<img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/LqMJZoibIrPyPJDbc4wR8wu8zW98s0OTbHnwdmFpVv0pYAAblBa6lR0eT93ajVcthgdepV1ngELmGHVoq66yyFg/640?wx_fmt=jpeg\" alt=\"img\" style=\"zoom: 25%;\" />\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/LqMJZoibIrPyPJDbc4wR8wu8zW98s0OTbeYy7VLjmJiblFGanJ8zZRlUQoCKfEvNQFeeGN68vRV6icv8HOL4lW96A/640?wx_fmt=png)\n\n长按，识别二维码，加关注\n\n\n\n\n\n\n","tags":["dataAlgorithm"]},{"title":"维护1","url":"/2020/05/01/维护1/","content":"\n#### 维护1\n\n<!--more-->\n\n1.添加评论功能\n\n2.添加鼠标点击出现爱心事件\n\n","tags":["maintain"]},{"title":"Java memory model内存模型","url":"/2020/04/30/Java-memory-model内存模型/","content":"\n### Java内存模型\n\n​\tjmm规范，他规范了java虚拟机与计算机内存如何协调工作，他规定了一个线程如何及何时看到其他线程修改过的变量的值，以及在必须时，如何同步的访问共享变量。\n\n<!--more-->\n\n### jmm内存分配概念\n\n#### 堆heap:\n\n优点:运行时数据区,动态分配内存大小,有gc;\n\n缺点:因为要在运行时动态分配,所以存取速度慢,对象存储在堆上,静态类型的变量跟着类的定义一起存储在堆上.\n\n#### 栈stack:\n\n存取速度快,仅次于寄存器,\n\n缺点: 数据大小与生存期必须是确定的,缺乏灵活性,栈中主要存放基本类型变量(比如,int,short,byte,char,double,float,boolean和对象句柄),jmm要求,调用栈和本地变量存放在线程栈上\n\n当一个线程可以访问一个对象时,也可以访问对象的成员变量,如果有两个线程访问对象的成员变量,则每个线程都有对象的成员变量,则每个线程都有对象的成员变量的私有拷贝.","tags":["jvm"]},{"title":"面向对象的特征","url":"/2020/04/29/面向对象的特征/","content":"\n## 面向对象的特征有哪些方面\n\n### 封装\n\n最常见的是把属性私有化封装在一个类里面，只能通过方法去访问\n\n<!--more-->\n\n### 继承extends\n\n可以复用代码， 继承是面向对象编程的一种强大的代码复用方式； \n\n子类继承父类，从而继承了父类的方法和属性；\n\n Java只允许单继承，所有类最终的根类是`Object`； \n\n `protected`允许子类访问父类的字段和方法；  `protected`关键字可以把字段和方法的访问权限控制在继承树内部，一个`protected`字段和方法可以被其子类，以及子类的子类所访问。 \n\n父类没有无参构造器时，子类任何class调用父类构造器时，必须调用super父类有的构造器。\n\n如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法。即子类*不会继承*任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。\n\n##### 向上转型\n\n类型提升。\n\n把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。\n\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型。\n\n##### 向下转型\n\n 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。  向下转型很可能会失败。 \n\n### 抽象\n\n 由于多态的存在，每个子类都可以覆写父类的方法 \n\n如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰。\n\n因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。\n\n使用`abstract`修饰的类就是抽象类。我们无法实例化一个抽象类。\n\n- 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；\n- 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；\n- 如果不实现抽象方法，则该子类仍是一个抽象类；\n- 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。\n\n### 多态\n\n 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。\n\n 多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 \n\n- 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；\n- Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；\n- `final`修饰符有多种作用：\n  - `final`修饰的方法可以阻止被覆写；\n  - `final`修饰的class可以阻止被继承；\n  - `final`修饰的field必须在创建对象时初始化，随后不可修改。\n\n"},{"title":"动态数组","url":"/2020/04/26/动态数组/","content":"\n# 数组(Array)\n\n#### 数组是一种顺序储存的线性表,所有元素的内存地址是连续. \n\n```java\nint[] array = new int[]{20, 30, 40}\n//向内存申请了12个字节地址\n```\n\n<!--more-->\n\n![在这里插入图片描述](20200328103402109.png)\n\n- 在很多编程语言中，数组有个致命的缺点， **无法动态修改容量**。\n\n- 实际开发中我们希望数组的容量是动态变化的。\n\n  \n\n# 动态数组\n\n创建ArrayList类,创建size属性来管理数组中元素的个数,创建element属性来管理存取的数据.\n\n可以对动态数组进行增删改查操作.\n\n![](0200328103943700.png)\n\n```java\npublic class ArrayList<E> {\n    private int size;\n    private E[] elements;\n\n\t// 元素的数量\n\tint size(); \n\t// 是否为空\n\tboolean isEmpty();\n\t// 是否包含某个元素\n\tboolean contains(E element); \n\t// 添加元素到最后面\n\tvoid add(E element); \n\t// 返回index位置对应的元素\n\tE get(int index); \n\t// 设置index位置的元素\n\tE set(int index, E element); \n\t// 往index位置添加元素\n\tvoid add(int index, E element); \n\t// 删除index位置对应的元素 \n\tE remove(int index); \n\t// 查看元素的位置\n\tint indexOf(E element); \n\t// 清除所有元素\n\tvoid clear(); \n}\n\n```\n\n### 动态数组的实现\n\n#### 构造方法\n\n如果构建的数组空间小于默认空间,则会以默认空间创建数组.\n\n```java\npublic class ArrayList<E> {\n    /**\n     * 元素的数量\n     */\n    private int size;\n\n    /**\n     * 所有元素\n     */\n    private E[] elements;\n\n    /**\n     * 数组的默认容量\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\t/**\n     * 找不到元素返回-1\n     */\n    private static final int ELEMENT_NOT_FOUNT = -1;\n\n    public ArrayList() {\n        // 默认容量\n        //elements = new int[DEFAULT_CAPACITY];\n        this(DEFAULT_CAPACITY); // 调用下面的构造器\n    }\n\n    public ArrayList(int capacity) {\n        // 设置默认容量为 10\n        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;\n\n        // 因为泛型(所以传一个Object数组,然后通过强转)\n        elements = (E[]) new Object[capacity];\n    }\n}\n\n```\n\n\n\n#### 添加元素\n\n- 数组添加元素分为`在最后一个元素的后面添加新元素`和`将元素插入到某个位置（非最后面）`两种情况。\n- 第一种情况，这个`新元素需要添加到的索引`等于`当前数组元素的个数`，在ArrayList中`size`属性就是`当前数组元素的个数`，所以就是将新元素添加到数组的`size`位置上，然后`size加1`。\n\n![](20200328104623565.png)\n\n```java\npublic void add(int index, E element) {\n    elements[index] = element;\n    size++;\n}\n```\n\n- 如果是第二种情况，只需要将插入位置后面的元素向后移动即可。\n- 注意：需要从后向前移动元素，如果从前向后移动元素，那么会进行元素覆盖, 最后出错。\n\n![](20200328105012778.png)\n\n#### 数组越界\n\n添加元素,还要注意传入的索引不能越界,即不能小于0,也不能大于size.\n\n```java\n/**\n * 根据index插入元素时,判断index是否有效\n *\n * @param index\n */\nprivate void rangeCheckForAdd(int index) {\n    if (index < 0 || index > size) {\n        indexOutOfBounds(index);\n    }\n}\n```\n\n```java\n/**\n * 封装数组越界异常\n *\n * @param index\n */\nprivate void indexOutOfBounds(int index) {\n    throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size:\" + size);\n}\n\n```\n\n#### 数组扩容\n\n动态扩容思路:\n\n- 通过默认容量创建的数组,是在堆空间中随机生成的地址;如此一来再申请空间拼接到该数组后,这种方式不可能实现;\n- 我们只能再创建一个大容量的数组,然后将之前数组中的元素移动到这个数组中;然后将引用指向新数组即可!\n\n- 由于数组elements最大的容量只有10，所以当数组存满元素时，就需要对数组进行扩容。\n\n- 因为数组是无法动态扩容的，所以需要创建一个新的数组，这个数组的容量要比之前数组的容量大。\n\n- 然后在将原数组中的元素存放到新数组中，这样就实现了数组的扩容。\n\n![](2020032810554134.png)\n\n-  该方法确保默认容量为多少,为了验证`是否超过给定的默认容量`,然后进行判断是否要扩容;这里`size+1`为数组当前数量+1, 因为每次`add`都会增加一个容量。 \n\n```java\n/**\n * 确保至少要有capacity个容量\n *\n * @param capacity\n */\nprivate void ensureCapacity(int capacity) {\n\n    // 获取数组当前容量\n    int oldCapacity = elements.length;\n    // 判断是否要扩容\n    if (oldCapacity >= capacity)\n        return; // 此时不扩容\n\n    // 这种方式是扩容1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n\n    E[] newElements = (E[]) new Object[newCapacity];\n    // 将原来数组中的元素移动到新数组中\n    for (int i = 0; i < size; i++) {\n        newElements[i] = elements[i];\n    }\n    // 将数组引用指向新数组\n    elements = newElements;\n}\n\n```\n\n 实现add函数，需要在添加新元素之前，判断数组越界和扩容。 \n\n```java\n/**\n * 在index位置插入一个元素\n *\n * @param index\n * @param element\n */\npublic void add(int index, E element) {\n    // 在添加元素的时候,判断index是否有效\n    rangeCheckForAdd(index);\n\n    ensureCapacity(size + 1);\n\n    // 注意: 插入元素后,元素是从后开始往后挪\n    for (int i = size - 1; i >= index; i--) {\n        elements[i + 1] = elements[i];\n    }\n    elements[index] = element;\n    size++;\n}\n\n```\n\n 最终在最后一个元素的后面添加新元素，即添加元素到尾部的实现方式如下 \n\n```java\n/**\n * 添加元素到尾部\n *\n * @param element\n */\npublic void add(E element) {\n    // elements[size++] = element;\n    // 传入数组数量(相当于在最后插入元素)\n    add(size, element);\n}\n```\n\n#### 删除元素\n\n- 删除元素，实际上就是`移除指定位置的元素`，并将`后面的元素向前移动`。\n- 如下图，当删除索引为`3`的元素时，只需要将后面的元素向前移动，然后在去掉最后一个元素，`size减1`即可。\n\n![](20200328110106999.png)\n\n#### 数组越界\n\n-  删除元素时传入的索引不能越界, 即不能小于0, 也不能大于等于size所以我们在删除元素之前需要先进行索引检查。 \n\n  \n\n```java\nprivate void indexOutOfBounds(int index) {\n    throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size:\" + size);\n}\n\t\nprivate void rangeCheck(int index) {\n    if (index < 0 || index >= size) {\n        outOfBounds(index);\n    }\n}\n```\n\n#### 数组缩容\n\n- 当数组中的元素删除后，数组剩余的空间可能会很大，这样就会造成内存的浪费。\n\n- 所以当数组中元素删除后，我们需要对数组进行`缩容`。\n\n- 实现方法类似于扩容，当数组中容量小于某个值时，创建新的数组，然后将原有数组中的元素存入新数组即可。\n\n  \n\n```java\n/**\n * 数组缩容\n */\npublic void trim() {\n    // 获取当前数组的容量\n    int capacity = elements.length;\n    // 当size大于等于容量的一半, 或则容量已经小于默认容量(10)时, 直接返回\n    if (size >= capacity >> 1 || capacity < CAPACITY_DEFAULT) return;\n    // 计算新的容量 = 原有容量的一半\n    int newCapacity = capacity >> 1;\n    // 创建新数组\n    E[] newElements = (E[]) new Object[newCapacity];\n    // 将原数组元素存入新数组\n    for (int i = 0; i < size; i++) {\n    \tnewElements[i] = elements[i];\n    }\n    // 引用新数组\n    elements = newElements;\n}\n```\n\n 最终, remove方法实现如下 \n\n```java\n/**\n * 删除index位置的元素\n *\n * @param index\n * @return 被删除的元素\n */\npublic E remove(int index) {\n    rangeCheck(index);\n    E delEle = elements[index];\n\n    // 当删除一个元素时,需要挪动后面元素的范围\n    for (int i = index + 1; i <= size - 1; i++) {\n        elements[i - 1] = elements[i];\n    }\n    size--;\n    // 同clear的细节,当从后往前以后时,最后一个的地址需要释放\n    elements[size] = null;\n    // 判断数组是否需要缩容\n    trim();\n    return delEle;\n}\n\n/**\n * 删除传入的元素\n * @param element\n */\npublic void remove(E element){\n    remove(indexOf(element));\n}\n```\n\n#### 清空数组\n\n 清空数组时，需要将所有的元素置为null，只有这样才能真正的释放对象，然后size置为0。 \n\n![](20200328110807352.png)\n\n```java\n/**\n * 清除所有元素\n */\npublic void clear() {\n    for (int i = 0; i < size; i++) {\n        elements[i] = null;\n    }\n    size = 0;\n}\n```\n\n#### 修改元素\n\n 修改元素时，只需要将原有位置的元素`替换`掉即可，同样需要注意一下索引是否`越界`。 \n\n```java\n/**\n * 设置index位置的元素\n *\n * @param index\n * @param element\n * @return 原来的元素\n */\npublic E set(int index, E element) {\n    rangeCheck(index);\n\n    E oldEle = elements[index];\n    elements[index] = element;\n    return oldEle;\n}\n```\n\n#### 查询元素\n\n 查询元素，只需要将指定索引的元素返回，注意索引是否越界即可。 \n\n```java\n/**\n * 获取index位置的元素\n *\n * @param index\n * @return\n */\npublic E get(int index) {\n    // 约束Index\n    rangeCheck(index);\n    return elements[index];\n}\n```\n\n#### 查看元素位置\n\n- 可以通过循环, 查找元素在数组中的位置。\n- 注意：假如数组中可以存储`null`，而null是不能调用`equals`方法的，所以需要对传入的元素进行判断，如果查找的元素是`null`，需要单独处理。\n- 当元素存在时返回索引，否则返回变量`ELEMENT_ON_FOUND`的值。\n\n```java\n/**\n * 查看元素的索引\n *\n * @param element\n * @return\n */\npublic int indexOf(E element) {\n    if (element == null) {\n        // 循环判断如果element为null,直接返回null的索引\n        for (int i = 0; i < size; i++) {\n            if (elements[i] == null)\n                return i;\n        }\n    } else {\n        for (int i = 0; i < size; i++) {\n            // 因为element肯定不为null了,所以放在前面;避免空指针异常\n            if (element.equals(elements[i]))\n                return i;\n        }\n    }\n    return ELEMENT_NOT_FOUNT;\n}\n```\n\n#### 是否包含某元素\n\n 只需通过判断索引是否等于`ELEMENT_ON_FOUND`即可。 \n\n```java\n/**\n * 是否包含某个元素\n *\n * @param element\n * @return\n */\npublic boolean contains(E element) {\n    // 如果element元素可以找到\n    return indexOf(element) != ELEMENT_NOT_FOUNT;\n}\n```\n\n#### 元素的数量\n\n size的值，即为元素的数量 \n\n```java\n/**\n * 元素的数量\n *\n * @return\n */\npublic int size() {\n    return size;\n}\n\n```\n\n#### 数组是否为空\n\n 通过判断`size`的值是否为`0`即可 \n\n```java\n/**\n * 是否为空\n *\n * @return\n */\npublic boolean inEmpty() {\n    return size == 0;\n}\n\n```\n\n#### 动态数组打印\n\n 可以重写`toString`方法, 来打印`ArrayList`中的元素。 \n\n```java\n@Override\npublic String toString() {\n    // 打印格式: size=3, [10, 20, 30]\n    // 使用StringBuilder 效率高一些\n    StringBuilder string = new StringBuilder();\n    string.append(\"size=\").append(size).append(\", [\");\n    for (int i = 0; i < size; i++) {\n        string.append(elements[i]);\n        if (i != size - 1) {\n            string.append(\", \");\n        }\n    }\n    string.append(\"]\");\n    return string.toString();\n}\n\n```\n\n **这样就实现了动态数组的基本操作。** \n\n# ArrayList能否进一步优化？\n\n- 在ArrayList中，如果要删除索引0位置的元素，则需要将索引0之后的元素全部往前移一位。\n- 如果要在索引`0`位置添加元素，也需要将索引`0`及之后的元素全`部往后移一位`。\n\n![](20200328112238774.png)\n\n- 在ArrayList中`增加一个记录首元素位置的属性`。\n- 删除索引`0`位置的元素，我们只需要将`first`属性改为`1`。\n- -在索引`0`位置添加元素，则只需要将`first`属性改为`0`。\n\n![](20200328112539197.png)\n\n- 如果继续往前插入元素，则将插入的元素存放在索引`8`这个位置，并将`first`改为`8`。\n- 当要获取索引`8`下一个元素时，对索引取`模`，则拿到索引`0`位置的元素。\n\n![](D:\\Blog\\source\\_posts\\【数据结构和算法】动态数组\\20200328112630777.png)\n\n- 如果插入元素，则可选择挪动`前半段`数据或`后半段`数据。\n- 在索引`2`处插入元素`99`，可以选择将元素`22`，`33`左移，然后插入`99`即可。\n- `扩容`和`缩容`同样可以优化。\n\n![](20200413231142422.png)\n\n\n\n# 重点总结\n\n\n#### 动态扩容思路\n\n通过默认容量创建的数组,是在堆空间中随机生成的地址;如此一来\n再申请空间拼接到该数组后,这种方式不可能实现;\n我们只能再创建一个大容量的数组,然后将之前数组中的元素移动到\n这个数组中;然后将引用指向新数组即可!\n\n#### 如何确保容量是否越界\n\n该方法确保默认容量为多少, 为了验证是否超过给定的默认容量,然后进行判断是否要扩容; 这里size+1为数组当前数量+1, 因为每次add都会增加一个容量。\n\n```java\n  ensureCapacity(size + 1);\n```\n\n#### 增加泛型\n\n使用泛型, 使动态数组可以添加任何类型的数据。\n\n```java\n  elements = (E[]) new Object[capacity];\n```\n\n\n##### clear方法的过渡细节\n\n因为之前存储的都是int数据, 直接设置size=0时, 开辟的存储int类型的空间就不能被访问, 当add后, 就可以访问后面的空间, 所以此时的空间可以重复利用;\n\n当使用泛型后, 动态数组中存储的都是对象类型, 实际存储的都是对象的地址, 每一个对象的地址又有一块空间引用着; 此时如果仍设置 size=0, 当clear后,开辟的存储空间中的地址没有被销毁, 地址仍被对象空间引用着; 这样以来存储对象的空间就不会被释放; 但是存储地址的数组可以重复利用; 所以要将地址数组都置为null, 然后size=0, 这样以来,引用该地址的对象空间也就释放了!\n\n#### remove、indexOf的细节\n\n\nremove最后一个地址也要情况, 同clear细节\n在indexOf方法中,不用==比较, 因为比较的是地址值,一般重写equals方法自己定义比较内容即可;\nnull值处理: 当往数组传null的时候,indexOf的比较处理: 如果那null.equals来比较会出现空指针异常;\n","tags":["dataAlgorithm"]},{"title":"斐波那契数列","url":"/2020/04/22/斐波那契数列/","content":"\n## 斐波那契数列\n\n斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。\n\n<!--more-->\n\n#### 求：斐波那契数列的第n个数是？\n\n简单的代码就可以实现：\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/4/22 20:38\n */\npublic class main {\n    /**\n     * 斐波那契数列\n     * @param args\n     */\n    public static void main(String[] args) {\n        System.out.println(fib(21));\n    }\n\n    public static int fib(int n) {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n\n```\n\n运用递归的写法，可以实现但是有个缺点\n\n我们可以用currentTimeMillis计算耗时 fib( 40 )：\n\n```bash\n耗时5.16秒\n```\n\n换一种算法，不实现递归。\n\n```java\n/**\n     * 0  1   2   3   4   5   6\n     * 0  1   1   2   4   8  16\n     *   fr  sd  sum\n     *       fr  sd\n     *\t思想是假设计算第3个斐波那契数时,用于计算的数是第一个数(fr)和第二个数(sd)相加,得到第三个数sum.\n     *  那么计算第四个数是第三个数加第四个数,也就是sd和sum, 把sd和sum赋值给计算第四个数计算的时候的fr和sd\t  *  就可以了.我们可以先把数列的第一个数first,第二个数second赋值为0,1.在进行for循环.\n     * @param n\n     * @return\n     */\npublic static int fib1(int n) {\n        if (n <= 1) return n;\n        int first = 0;\n        int second = 1;\n        for (int i = 0; i < n - 1; i++) {\n            int sum = first + second;\n            first = second;\n            second = sum;\n        }\n        return second;\n    }\n```\n\n\n\n当我们测试运行第123112340的数:\n\n```\n耗时0.54秒\n```\n\n性能比递归高了不少.","tags":["dataAlgorithm"]},{"title":"Spring、SpringMVC、Mybatis整合","url":"/2020/04/20/Spring、SpringMVC、Mybatis整合/","content":"\n### 整合说明\n服务器开发分为三层,表现层、业务层、持久层\n表现层使用SpringMVC实现,业务程使用Spring实现,持久层使用Mybatis实现\n使用Spring框架来整合 SpringMVC和Mybatis框架\n这里使用xml配置文件+注解的方式进行搭建\n<!-- more -->\n\n#### 最终目标\n\n##### 最终实现通过前端页面对数据库进行查询和插入,实现用户的登录注册功能\n\n### 准备\n\n#### 创建Maven工程\n![](start.png)\n\n##### 选择webapp\n![](new.png)\n![](3.png)\n\n##### 数据库准备\n``` sql\ncreate database ssm;\nuse ssm;\ncreate table account(\nid int primary key auto_increment,\nname varchar(20),\nmoney double\n);\n```\n![](data.png)\n####创建目录\n![](root.png)\n####导入依赖\n![](deloy.png)\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.kayleh</groupId>\n  <artifactId>SSM</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n  <name>SSM Maven Webapp</name>\n  <!-- FIXME change it to the project's website -->\n  <url>http://www.example.com</url>\n\n  <!--版本锁定-->\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n    <spring.version>5.0.2.RELEASE</spring.version>\n    <slf4j.version>1.6.6</slf4j.version>\n    <log4j.version>1.2.12</log4j.version>\n    <mysql.version>5.1.6</mysql.version>\n    <mybatis.version>3.4.5</mybatis.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n    <!-- spring -->\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.6.8</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aop</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-tx</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>${mysql.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>servlet-api</artifactId>\n      <version>2.5</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet.jsp</groupId>\n      <artifactId>jsp-api</artifactId>\n      <version>2.0</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>jstl</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n    <!-- log start -->\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>${log4j.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>${slf4j.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>${slf4j.version}</version>\n    </dependency>\n    <!-- log end -->\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>${mybatis.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis-spring</artifactId>\n      <version>1.3.0</version>\n    </dependency>\n    <dependency>\n      <groupId>c3p0</groupId>\n      <artifactId>c3p0</artifactId>\n      <version>0.9.1.2</version>\n      <type>jar</type>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n  <build>\n    <finalName>SSM</finalName>\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n```\n#### 编写实体类\n``` java\npackage com.kayleh.domain;\nimport java.io.Serializable;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:06\n *\n * 账户\n */\npublic class Account implements Serializable {\n    private Integer id;\n    private String name;\n    private Double money;\n    public Integer getId() {\n        return id;\n    }\n    .........\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n}\n```\n#### dao接口\n``` java\npackage com.kayleh.dao;\nimport com.kayleh.domain.Account;\nimport java.util.List;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:11\n * <p>\n * 账户dao接口\n */\npublic interface AccountDao {\n    //查询所有账户\n    public List<Account> findAll();\n    //保存账户信息\n    public void saveAccount(Account account);\n}\n```\n#### 业务service层和实现\n```java\npackage com.kayleh.service;\nimport com.kayleh.domain.Account;\nimport java.util.List;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:16\n */\npublic interface AccountService {\n    //查询所有账户\n    public List<Account> findAll();\n    //保存账户信息\n    public void saveAccount(Account account);\n}\n-----------------------------------------------------\npackage com.kayleh.service.impl;\nimport com.kayleh.domain.Account;\nimport com.kayleh.service.AccountService;\nimport org.springframework.stereotype.Service;\nimport java.util.List;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:18\n */\n@Service(\"accountService\")\npublic class AccountServiceImpl implements AccountService {\n    public List<Account> findAll() {\n        System.out.println(\"业务层:查询所有账户...\");\n        return null;\n    }\n    public void saveAccount(Account account) {\n        System.out.println(\"业务层:保存账户...\");\n    }\n}\n```\n## Spring整合\n在resource下创建Spring配置文件\n![](1.png)\n####命名空间\n```xml\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx.xsd\">\n```\n####注解扫描\n```xml\n<!-- 开启注解的扫描,希望处理service和dao,controller不需要Spring框架去处理,controller注解由SpringMVC处理 -->\n    <context:component-scan base-package=\"com.kayleh\">\n        <!-- 配置哪些注解不扫描 -->\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n```\n####测试\n```java\npackage com.kayleh.test;\nimport com.kayleh.service.AccountService;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:38\n */\npublic class TestSpring {\n    @Test\n    public void run1(){\n        //加载配置文件\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        //获取对象\n        AccountService as = (AccountService) ac.getBean(\"accountService\");\n        //调用方法\n        as.findAll();\n    }\n}\n```\n###### 运行测试,成功调用accountService\n\n---\n## 搭建和测试SpringMVC的开发环境\n1.在web.xml中配置DispatcherServlet前端控制器\n```xml\n<!-- 配置前端控制器：服务器启动必须加载,需要加载springmvc.xml配置文件 -->\n<servlet>\n<servlet-name>dispatcherServlet</servlet-name>\n<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n<!-- 配置初始化参数,创建完DispatcherServlet对象,加载springmvc.xml配置文件 -->\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>classpath:springmvc.xml</param-value>\n</init-param>\n<!-- 服务器启动的时候,让DispatcherServlet对象创建 -->\n<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n<servlet-name>dispatcherServlet</servlet-name>\n<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n2.在web.xml中配置DispatcherServlet过滤器解决中文乱码\n```xml\n<!-- 配置解决中文乱码的过滤器 -->\n<filter>\n<filter-name>characterEncodingFilter</filter-name>\n<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n<init-param>\n<param-name>encoding</param-name>\n<param-value>UTF-8</param-value>\n</init-param>\n</filter>\n<filter-mapping>\n<filter-name>characterEncodingFilter</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n3.创建springmvc.xml的配置文件,编写配置文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/mvc\nhttp://www.springframework.org/schema/mvc/spring-mvc.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- 开启注解扫描 -->\n    <context:component-scan base-package=\"com.kayleh\">\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n\n    <!--配置的视图解析器对象-->\n    <bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/pages/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n\n    <!--过滤静态资源-->\n    <mvc:resources mapping=\"/CSS/**\" location=\"/CSS/\"/>\n    <mvc:resources mapping=\"/images/**\" location=\"/images/\"/>\n    <mvc:resources mapping=\"/js/**\" location=\"/js/\"/>\n    <!--开启SpringMVC的注解支持-->\n    <mvc:annotation-driven/>\n</beans>\n```\n4. 测试SpringMVC的框架搭建是否成功\n   1.编写index.jsp和list.jsp编写,超链接\n    自带的index.jsp没有头部信息，需要重新创建\n``` xml\n    <a href=\"account/findAll\">查询所有</a>\n```\n   2.创建AccountController类,编写方法,进行测试\n    \n``` java\n    package cn.kayleh.controller;\n    import org.springframework.stereotype.Controller;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    @Controller\n    @RequestMapping(\"/account\")\n    public class AccountController {\n    /**\n    * 查询所有的数据\n    * @return\n    */\n    @RequestMapping(\"/findAll\")\n    public String findAll() {\n    System.out.println(\"表现层：查询所有账户...\");\n    return \"list\";\n    }\n    }\n```\n\n##Spring整合SpringMVC的框架\n1. 目的：在controller中能成功的调用service对象中的方法.\n2. 在项目启动的时候,就去加载applicationContext.xml的配置文件,在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文\n件）。\n```xml\n<!-- 配置Spring的监听器 -->\n<listener>\n<listener-class>org.springframework.web.context.ContextLoaderListener</listenerclass>\n</listener>\n<!-- 配置加载类路径的配置文件 -->\n<context-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>classpath:applicationContext.xml</param-value>\n</context-param>\n```\n\n\n3. 在controller中注入service对象,调用service对象的方法进行测试\n```java\npackage cn.itcast.controller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport cn.kayleh.service.AccountService;\n@Controller\n@RequestMapping(\"/account\")\npublic class AccountController {\n        @Autowired\n        private AccountService accoutService;\n/**\n* 查询所有的数据\n* @return\n*/\n@RequestMapping(\"/findAll\")\npublic String findAll() {\nSystem.out.println(\"表现层：查询所有账户...\");\naccoutService.findAll();\nreturn \"list\";\n    }\n}\n```\n\n## Spring整合MyBatis框架\n### 搭建和测试MyBatis的环境\n###### 在web项目中编写SqlMapConfig.xml的配置文件，编写核心配置文件,在后面整合进applicationContext.xml后可以删除\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\nPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n<environments default=\"mysql\">\n<environment id=\"mysql\">\n<transactionManager type=\"JDBC\"/>\n<dataSource type=\"POOLED\">\n<property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n<property name=\"url\" value=\"jdbc:mysql:///ssm\"/>\n<property name=\"username\" value=\"root\"/>\n<property name=\"password\" value=\"admin\"/>\n</dataSource>\n</environment>\n</environments>\n<!-- 使用的是注解 -->\n<mappers>\n<!-- <mapper class=\"cn.kayleh.dao.AccountDao\"/> -->\n<!-- 该包下所有的dao接口都可以使用 -->\n<package name=\"cn.kayleh.dao\"/>\n</mappers>\n</configuration>\n```\n#####在AccountDao接口的方法上添加注解，编写SQL语句\n```java\npackage com.kayleh.dao;\n\nimport com.kayleh.domain.Account;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Select;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:11\n * <p>\n * 账户dao接口\n */\n\n@Repository\npublic interface AccountDao {\n\n    //查询所有账户\n    @Select(\"select * from account\")\n    public List<Account> findAll();\n\n    //保存账户信息\n    @Insert(\"insert into account(name,money) values (#{name},#{money})\")\n    public void saveAccount(Account account);\n}\n\n```\n##### 编写测试的方法\n```java\npackage com.kayleh.test;\nimport com.kayleh.service.AccountService;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:38\n */\npublic class TestSpring {\n    @Test\n    public void run1(){\n        //加载配置文件\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        //获取对象\n        AccountService as = (AccountService) ac.getBean(\"accountService\");\n        //调用方法\n        as.findAll();\n    }\n}\n\n```\n## Spring整合MyBatis框架\n#####目的：把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中\n```xml\n <!--Srping整合MyBatis框架-->\n    <!--配置连接池-->\n    <!--引入外部配置文件-->\n<!-- <context:property-placeholder location=\"classpath:jdbc.properties\"/>-->\n    <bean id=\"ds\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssm\"/><!--省略了localhost:3306-->\n        <property name=\"user\" value=\"root\"/>\n        <property name=\"password\" value=\"admin\"/>\n    </bean>\n\n    <!--配置SqlSessionFactory工厂-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"ds\"/>\n    </bean>\n\n    <!--配置AccountDao接口所在包-->\n    <bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"basePackage\" value=\"com.kayleh.dao\" />\n    </bean>\n```\n##### 在AccountDao接口中添加@Repository注解\n##### 在service中注入dao对象，进行测试\n```java\npackage com.kayleh.dao;\n\nimport com.kayleh.domain.Account;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Select;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:11\n * <p>\n * 账户dao接口\n */\n\n@Repository\npublic interface AccountDao {\n\n    //查询所有账户\n    @Select(\"select * from account\")\n    public List<Account> findAll();\n\n    //保存账户信息\n    @Insert(\"insert into account(name,money) values (#{name},#{money})\")\n    public void saveAccount(Account account);\n}\n\n-------------------------------------------------------------\npackage com.kayleh.service.impl;\n\nimport com.kayleh.dao.AccountDao;\nimport com.kayleh.domain.Account;\nimport com.kayleh.service.AccountService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:18\n */\n\n@Service(\"accountService\")\npublic class AccountServiceImpl implements AccountService {\n\n    @Autowired\n    private AccountDao accountDao;\n\n    public List<Account> findAll() {\n        System.out.println(\"业务层:查询所有账户...\");\n        return accountDao.findAll();\n    }\n\n    public void saveAccount(Account account) {\n        System.out.println(\"业务层:保存账户...\");\n        accountDao.saveAccount(account);\n    }\n}\n\n-------------------------------------------------------------\npackage com.kayleh.controller;\n\nimport com.kayleh.domain.Account;\nimport com.kayleh.service.AccountService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.ws.RequestWrapper;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:21\n * <p>\n * 用户web层\n */\n\n@Controller\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n    @Autowired\n    private AccountService accountService;\n\n    @RequestMapping(\"/findAll\")\n    public String findAll(Model model) {\n        System.out.println(\"表现层:查询所有的账户...\");\n\n        List<Account> list = accountService.findAll();\n\n        model.addAttribute(\"list\", list);\n\n        return \"list\";\n    }\n```\n##### 配置Spring的声明式事务管理\n```xml\napplicationContext.xml\n <!-- 配置Spring框架声明式事务管理 -->\n    <!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"ds\"/>\n    </bean>\n\n    <!-- 配置事务通知 -->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <tx:attributes>\n            <tx:method name=\"find*\" read-only=\"true\"/>\n            <tx:method name=\"*\" isolation=\"DEFAULT\"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <!-- 配置AOP增强 -->\n    <aop:config>\n        <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.kayleh.service.impl.*ServiceImpl.*(..))\"/>\n\n    </aop:config>\n```\n\n```java\n/**\n     * 保存\n     *\n     * @param account\n     * @return\n     */\n    @RequestMapping(\"/save\")\n    public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        System.out.println(\"表现层:查询所有的账户...\");\n\n        accountService.saveAccount(account);\n\n        response.sendRedirect(request.getContextPath() + \"/account/findAll\");\n        return;\n    }\n```\n","tags":["frame"]},{"title":"回文数","url":"/2020/04/19/回文数/","content":"\n### 什么是回文数？\n\n回文数指的是正序和倒序读都是一样的数，例如121从左到右，从右到左读都是121。任何一个自然数与它的倒序数相加，所得的和再与和的倒序数相加，……如此反复进行下去，经过有限次步骤后，最后必定能得到一个回文数。\n\n<!-- more -->\n\n#### 问题：判断一个数是否为回文数，是返回true，否侧抛出false。\n\n``` bash\n\n@题目来源lettcode\n\n利用Java的StringBuilder通过把整数转换为字符串来实现↓\n\n\n\nimport java.util.Scanner;\n/**\n * @Author: Wizard\n * @Date: 2020/4/12 13:14\n */\npublic class palindrome {\n    public static boolean ispalindrome(int i) {\n        String str = (new StringBuilder(i + \"\")).reverse().toString();\n        return (i + \"\").equals(str);\n    }\n    public static void main(String[] args) {\n        while (true) {\n            System.out.println(\"输入需要判断的整数\");\n            Scanner scanner = new Scanner(System.in);\n            int str1 = scanner.nextInt();\n            System.out.println(ispalindrome(str1));\n        }\n    }\n}\n/**\n * 输入需要判断的整数：1\n * false\n * 输入需要判断的整数：12121\n * true\n */\n```\n\n---\n\n``` bash \n进阶：不改变整数为字符串\n\n通过取整和取余获取整数中的数字进行比较\n/**\n * @Author: Wizard\n * @Date: 2020/4/12 13:14\n */\npublic class palindrome {\n    public static boolean ispalindrome(int i) {\n        if(i<0||(i%10==0&&i!=0))\n            return false;\n        int number = 0;\n        while(i>number){\n            number = number * 10 + i % 10;\n            i /=10;\n        }\n        return i == number || i==number/10;\n    }\n    public static void main(String[] args) {\n        while (true) {\n            System.out.println(\"输入需要判断的整数\");\n            Scanner scanner = new Scanner(System.in);\n            int str1 = scanner.nextInt();\n            System.out.println(ispalindrome(str1));\n        }\n    }\n}\n```\n\n###### 微信公众号:每日学习干货↓\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![](1.jpg) \n","tags":["dataAlgorithm"]},{"title":"【SpringMVC】-@ModelAttribute","url":"/2020/04/19/【SpringMVC】-@ModelAttribute/","content":"\n## @ModelAttribute？\n\n@ModelAttribute的原理比较复杂，需要对源码有一定的理解。它可以使被\n<!-- more -->\n@ModelAttribute修饰的方法在控制器的处理方法之前调用。\n但如果@ModelAttribute标注在方法的入参前，它可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入入参。\n\n---\n\n### 实际场景：\n\nSpring在进行数据库update全字段更新操作提交表单的时候，从页面获取的数据会封装成一个new的pojo对象，没有带的值为null；所以我们只能更新我们提交的数据。ModelAttribute暂时保存表单pojo对象，覆盖数据库保存的pojo对象的数据即可。\n\n\n\n\n``` bash\nModelAttribute提前与目标方法运行\n/**\n * @author Kayleh\n */\n@Controller\npublic class ModelAttributeTest {\n  \n  @RequestMapping(\"/update\")\n  public String update(){     \n    System.out.println(\"页面update的bean对象：\"+bean);  \n  }\n  @ModelAttribute\n  public void modelAttribute(){     \n    System.out.println(\"ModelAttribute调用了...\");  \n  }\n\n\n===========输出=========\nModelAttribute调用了...\n页面update的bean对象：bean{......}\n```\n\n###### 可以得出：ModelAttribute标注的方法总会在目标方法(update)前执行。\n\n\n### ModelAttribute可以取出隐含对象的值\n\n``` bash\n@ModelAttribute\n  public void TestModelAttribute(Map<String, Object> map){\n    \n    POJO pojo = new POJO(\"kayleh\", 1104);\n    map.put(\"value\",pojo);\n    System.out.println(\"modelAttribute方法...);\n  }\n@RequestMapping(\"/updateBook\")\n  public String updateBook(@RequestParam(value=\"author\")String author,\n      Map<String, Object> model,\n      HttpServletRequest request,\n      @ModelAttribute(\"value\")POJO pojo\n      ){\n   \n    System.out.println(pojo);\n    return \"ok\";\n  }\n```\n\n @ModelAttribute(\"value\")这里如果指定的\"value\",value就是从map取出参数的key.如果是@ModelAttribute,没有指定key,SpringMVC会默认使用返回值类型的首字母小写作为key.如pOJO.\n\n###### 微信公众号:每日学习干货↓\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![](1.jpg) \n","tags":["frame"]},{"title":"Spring架构","url":"/2020/04/19/Spring架构/","content":"\n![](spring1.jpg)\n\n<!-- more -->\n\n\n微信公众号:每日学习干货","tags":["frame"]},{"title":"并发:原理","url":"/2020/04/19/并发：原理/","content":"\n## 多线程\n\n### 为什么要创建线程池\n\n``` bash\n如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降.\n```\n<!-- more -->\n创建线程池,可以:\n1.降低资源消耗\n2.提升响应速度\n3.提高\n\n### 线程池原理\n\n``` bash\n提交一个任务到线程池中,线程池的处理流程如下:\n1.判断线程池里的核心线程是否都在执行任务,如果不是(核心线程空闲或者核心线程没有被创建)则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程.\n2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程.\n3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务.\n```\n\n### 线程池的分类\n\n``` java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler);\n```\n\nThreadPoolExecutor是线程池的真正实现,\n他通过构造方法的一系列参数，来构成不同配置的线程池。\ncorePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中\nmaximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程；\nkeepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。\nunit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。\nworkQueue：一个阻塞队列，提交的任务将会被放到这个队列里。\nthreadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。\nhandler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。\n\n### 线程池的创建方法\n\nJava通过Executors（jdk1.5并发包）提供四种线程池，分别为：\n\nnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n案例演示:\n\nnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\nnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n\nnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n``` java\nnewCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，\n若无可回收，则新建线程。\n\npackage cn.qbz.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Test111907 {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp);\n                }\n            });\n        }\n    }\n}\n\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n``` bash\nnewFixedThreadPool\n创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\npackage cn.qbz.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Test111907 {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp);\n                }\n            });\n        }\n    }\n}\n\n\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n``` bash\nnewScheduledThreadPool\n创建一个定长线程池，支持定时及周期性任务执行。\n\npackage cn.qbz.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class Test111907 {\n    public static void main(String[] args) {\n        final long begin = System.currentTimeMillis();\n        ExecutorService executorService = Executors.newScheduledThreadPool(3);\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            final long time = begin;\n            executorService.schedule(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp + \"   time=\" + (System.currentTimeMillis() - time));\n                }\n            }, 5, TimeUnit.SECONDS);\n        }\n    }\n}\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n```\n\n``` bash\nnewSingleThreadExecutor\n创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，\n保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\npublic class Test111907 {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp);\n                }\n            });\n        }\n    }\n}\n```\n\n微信公众号:每日学习干货"},{"title":"unix的常用指令","url":"/2020/04/19/unix/","content":"\n## unix的常用指令\n\n<!-- more -->\n\n``` bash\nls 显示指定目录下的文件目录清单相当于dos下的dir命令。\npwd 显示当前目录。\nmkdir 在当前目录下创建目录。\nrm 删除文件或目录。\ncp 复制文件。\nmv 移动文件。\ncd 切换工作目录。\nps 查看进程。\nftp 传送文件。\ntelnet 远程登录命令。\nping 用来测试本机与目标主机是否联通。\nenv 查看当前系统中的环境变量。\nmore 分屏显示指定文件的内容。\necho在终端上显示你要显示的内容，向C语言中的printf函数。\n\n```\n\n微信公众号:每日学习干货"},{"title":"Rest架构风格","url":"/2020/04/18/Rest架构/Rest架构/","content":"\n## Rest是什么?\n\n``` bash\nREST(Representational State Transfe),是一种软件架构风格，它结构清晰、符合标准、易于理解、扩展方便，并且规范了URI的风格；规范了HTTP请求动作的使用，具有对应的语义。Spring支持并推荐使用这种风格的URL地址。他可以处理除POST或GET的其他请求.\nrest可以把普通的请求转化(如:GET.POST)为规定形式的请求(DELETE等等),使URL请求地址状态化.\n```\n\n<!-- more -->\n\n## Rest实现\n\n### 配置web.xml文件,添加一个Filter过滤器\n  \n``` bash\n<filter>\n    <!--HiddenHttpMethodFilter继承HttpServletRequest类-->\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n  </filter>\n  <filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n  \n   <!--要想获取其他类型的请求,要先创建一个form表单-->\n<form action=\"pojo/1\" method=\"post\">\n    <!--添加一个_method参数,它的值就是请求的类型-->\n    <input name=\"_method\" value=\"delete\">\n    <input type=\"submit\" value=\"删除请求\">\n  </form>\n```\n\n## 注意\n\n### ≥8.0版本的Tomcat服务器Filter会拦截JSP页面,这种情况需要在index.jsp页面加上这个约定.isErrorPage=\"true\"\n\n``` bash\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n  pageEncoding=\"UTF-8\"% isErrorPage=\"true\">\n  ```\n\n## 没有HiddenHttpMethodFilter的提示话,需要绑定源码jar包.\n\n微信公众号:每日学习干货"},{"title":"SpringMVC环境搭建","url":"/2020/04/17/SpringMVC环境搭建/","content":"\n## 什么是SpringMVC？\n\n\n\n``` bash\nSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架，实现MVC模块，简化了Web开发。\n\nMVC提倡每一层只写自己的东西，不写其他任何代码。为了解耦，为了维护方便和分工合作。\n\nSpringMVC为展现层提供的基于MVC设计理念的优秀Web框架，是目前最主流的框架之一。\n```\n\n<!-- more -->\n\n\n## 环境搭建\n\n### 1.导包(Maven工程忽略) \n  需要导入log包，spring核心包，SpringMVC包\n\n``` bash\n1.junit-x.x.x.jar \n2.spring-webmvc-x.x.x.RELEASE.jar\n3.spring-aop-x.x.x.RELEASE.jar\n4.spring-beans-x.x.x.RELEASE.jar\n5.spring-context-x.x.x.RELEASE.jar\n6.spring-core-x.x.x.RELEASE.jar\n7.spring-expression-x.x.x.RELEASE.jar\n8.spring-web-x.x.x.RELEASE.jar\n9.commons-log-.x.x.x.RELEASE.jar\n```\n\n\n\n### 写配置\n\n``` bash\n\n/**\n * web.xml\n */\n<servlet>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n     <init-param>\n      <!-- contextConfigLocation：指定SpringMVC配置文件位置 -->\n       <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:springmvc.xml</param-value>\n     </init-param>  \n    <load-on-startup>1</load-on-startup>\n  </servlet>\n <servlet-mapping>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n  ===========================================================\n /**\n * springmvc.xml\n */\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:context=\"http://www.springframework.org/schema/context\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n  <!-- 这里是扫描所有组件 -->\n  <context:component-scan base-package=\"com.wizard\"></context:component-scan>\n  \n  <!-- 配置一个视图解析器 作用是拼接页面的地址，方便调用-->\n  <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <!--前缀-->\n    <property name=\"prefix\" value=\"/WEB-INF/page/\"></property>\n    <!--后缀-->\n    <property name=\"suffix\" value=\".jsp\"></property>\n  </bean>\n  \n</beans>\n```\n\n\n``` bash\n\n/*\n*view层\n*/\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<h1>来了!</h1>\n</body>\n</html>\n```\n\n\n``` bash\n\n控制器层\n/**\n * @author Kayleh\n * @Controller:标识哪个组件是控制器\n *@RequestMapping\n *  告诉SpringMVC，这个方法用来处理什么请求;\n */\n\n@Controller\npublic class firstController {//这是一次转发操作\n  @RequestMapping(\"/hello\")\n  public String firstRequest(){\n    System.out.println(\"收到请求\");\n    return \"success\";\n  }\n\n}\n```\n\n``` bash\nindex.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<a href=\"hello\">Hello bug</a>\n</body>\n</html>\n```\n\n## 运行结果\n\n\n``` bash\nHello bug\n```\n\n## 其他细节\n\n细节：\n@RequestMapping注解不仅可以写在方法前,还可以写在类前,如果写在类前,意思为当前类所有的方法的请求地址指定一个基准路径,访问firstRequest方法的路径为/类前的注解/方法的注解(/hello).\n\n@RequestMapping注解的参数(\"/hello\")的/可以不写,但习惯为了方便维护应该写上.\n\n控制器处理的请求 firstController 是请求转发操作,Tomcat访问地址栏不变\n\n如果前端控制器没有指定配置文件位置,Spring也会在/WEB-INF/xxx-servlet.xml路径下查找文件.xxx为web.xml配置的前端控制器\n\n## 详细流程\n\n 1.客户端点击链接会发送http://localhost:8080/springmvc/hello请求\n\n 2.来到Tomcat服务器\n\n 3.springMVC的前端控制器收到所有请求\n\n 4.看请求地址和@RequestMapping标注的哪个匹配,来找到使用什么类的什么方法\n\n 5.前端控制器找到了目标处理器类和目标方法,直接利用反射执行目标方法\n\n 6.方法执行完成之后会有一个返回值;SpringMVC认为这个返回值就是要去的页面\n\n 7.拿到方法返回值后,用视图解析器进行拼串得到完整的页面地址\n\n 8.拿到页面地址,前端控制器转发到页面\n\n\n ### 其他问题?\n\n1为什么web.xml中配置的拦截为\n\n``` bash\n <servlet-mapping>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n```\n\n\n为什么没有拦截index.jsp??\n\n因为Tomcat的底层本来就能拦截jsp页面,配置的\"/\"的子类web.xml相当于覆盖了Webapp的父类web.xml中的DefaultServlet,DefaultServlet的作用是处理静态资源,覆盖了DefaultServlet,也就拦截了除jsp和servlet外的静态资源,而JspServlet的配置并没有覆盖.\n\n而\"/*\"的作用是拦截所有请求,包括jsp页面.\n----------\n\n","tags":["frame"]},{"title":"Hello World","url":"/2020/04/17/HelloWord/hello-world/","content":"\n<!-- more -->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]