[{"title":"MYSQL","url":"/2020/07/09/MYSQL/","content":"\n# MYSQL索引\n\n<!--more-->\n\n> MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。\n>\n> 打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。\n>\n> 拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。\n>\n> 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。\n>\n> 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。\n>\n> 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。\n>\n> 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。\n>\n> 建立索引会占用磁盘空间的索引文件。\n\n## 普通索引\n\n### 创建索引\n\n这是最基本的索引，它没有任何限制。它有以下几种创建方式：\n\n```mysql\nCREATE INDEX indexName ON mytable(username(length)); \n```\n\n如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。\n\n### 修改表结构(添加索引)\n\n```mysql\nALTER table tableName ADD INDEX indexName(columnName)\n```\n\n### 创建表的时候直接指定\n\n```mysql\nCREATE TABLE mytable(  \n \nID INT NOT NULL,   \n \nusername VARCHAR(16) NOT NULL,  \n \nINDEX [indexName] (username(length))  \n \n);  \n```\n\n### 删除索引的语法\n\n```sql\nDROP INDEX [indexName] ON mytable; \n```\n\n## 唯一索引\n\n它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：\n\n### 创建索引\n\n```mysql\nCREATE UNIQUE INDEX indexName ON mytable(username(length)) \n```\n\n### 修改表结构\n\n```mysql\nALTER table mytable ADD UNIQUE [indexName] (username(length))\n```\n\n### 创建表的时候直接指定\n\n```mysql\nCREATE TABLE mytable(  \n \nID INT NOT NULL,   \n \nusername VARCHAR(16) NOT NULL,  \n    \nUNIQUE [indexName] (username(length))  \n \n);  \n```\n\n### 使用ALTER 命令添加和删除索引\n\n有四种方式来添加数据表的索引：\n\n- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**\n\n   该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。\n\n- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** \n\n  这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。\n\n- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** \n\n  添加普通索引，索引值可出现多次。\n\n- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**\n\n  该语句指定了索引为 FULLTEXT ，用于全文索引。\n\n以下实例为在表中添加索引。\n\n```mysql\nmysql> ALTER TABLE testalter_tbl ADD INDEX (c);\n```\n\n你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:\n\n```mysql\nmysql> ALTER TABLE testalter_tbl DROP INDEX c;\n```\n\n------\n\n### 使用 ALTER 命令添加和删除主键\n\n主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：\n\n```mysql\nmysql> ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;\nmysql> ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);\n```\n\n你也可以使用 ALTER 命令删除主键：\n\n```mysql\nmysql> ALTER TABLE testalter_tbl DROP PRIMARY KEY;\n```\n\n删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。\n\n------\n\n### 显示索引信息\n\n你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \\G 来格式化输出信息。\n\n尝试以下实例:\n\n```mysql\nmysql> SHOW INDEX FROM table_name; \\G\n........\n```\n\n# MySQL 临时表\n\n> MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。\n>\n> MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。\n>\n> 如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。\n\n#### 实例\n\n以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数。\n\n```mysql\nmysql> CREATE TEMPORARY TABLE SalesSummary (\n    -> product_name VARCHAR(50) NOT NULL\n    -> , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00\n    -> , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00\n    -> , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0\n);\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> INSERT INTO SalesSummary\n    -> (product_name, total_sales, avg_unit_price, total_units_sold)\n    -> VALUES\n    -> ('cucumber', 100.25, 90, 2);\n\nmysql> SELECT * FROM SalesSummary;\n+--------------+-------------+----------------+------------------+\n| product_name | total_sales | avg_unit_price | total_units_sold |\n+--------------+-------------+----------------+------------------+\n| cucumber     |      100.25 |          90.00 |                2 |\n+--------------+-------------+----------------+------------------+\n1 row in set (0.00 sec)\n```\n\n当你使用 **SHOW TABLES**命令显示数据表列表时，你将无法看到 SalesSummary表。\n\n如果你退出当前MySQL会话，再使用 **SELECT**命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。\n\n## 删除MySQL 临时表\n\n默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 **DROP TABLE** 命令来手动删除临时表。\n\n以下是手动删除临时表的实例：\n\n```mysql\nmysql> CREATE TEMPORARY TABLE SalesSummary (\n    -> product_name VARCHAR(50) NOT NULL\n    -> , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00\n    -> , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00\n    -> , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0\n);\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> INSERT INTO SalesSummary\n    -> (product_name, total_sales, avg_unit_price, total_units_sold)\n    -> VALUES\n    -> ('cucumber', 100.25, 90, 2);\n\nmysql> SELECT * FROM SalesSummary;\n+--------------+-------------+----------------+------------------+\n| product_name | total_sales | avg_unit_price | total_units_sold |\n+--------------+-------------+----------------+------------------+\n| cucumber     |      100.25 |          90.00 |                2 |\n+--------------+-------------+----------------+------------------+\n1 row in set (0.00 sec)\nmysql> DROP TABLE SalesSummary;\nmysql>  SELECT * FROM SalesSummary;\nERROR 1146: Table 'RUNOOB.SalesSummary' doesn't exist\n```\n\n## MySQL 复制表\n\n如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用**CREATE TABLE ... SELECT** 命令，是无法实现的。\n\n本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下：\n\n- 使用 **SHOW CREATE TABLE** 命令获取创建数据表(**CREATE TABLE**) 语句，该语句包含了原数据表的结构，索引等。\n- \n- 复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。\n- 如果你想复制表的内容，你就可以使用 **INSERT INTO ... SELECT** 语句来实现。\n\n### 实例\n\n尝试以下实例来复制表 runoob_tbl 。\n\n**步骤一：**\n\n获取数据表的完整结构。\n\n```\nmysql> SHOW CREATE TABLE runoob_tbl \\G;\n*************************** 1. row ***************************\n       Table: runoob_tbl\nCreate Table: CREATE TABLE `runoob_tbl` (\n  `runoob_id` int(11) NOT NULL auto_increment,\n  `runoob_title` varchar(100) NOT NULL default '',\n  `runoob_author` varchar(40) NOT NULL default '',\n  `submission_date` date default NULL,\n  PRIMARY KEY  (`runoob_id`),\n  UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)\n) ENGINE=InnoDB \n1 row in set (0.00 sec)\n\nERROR:\nNo query specified\n```\n\n**步骤二：**\n\n修改SQL语句的数据表名，并执行SQL语句。\n\n```\nmysql> CREATE TABLE `clone_tbl` (\n  -> `runoob_id` int(11) NOT NULL auto_increment,\n  -> `runoob_title` varchar(100) NOT NULL default '',\n  -> `runoob_author` varchar(40) NOT NULL default '',\n  -> `submission_date` date default NULL,\n  -> PRIMARY KEY  (`runoob_id`),\n  -> UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)\n-> ) ENGINE=InnoDB;\nQuery OK, 0 rows affected (1.80 sec)\n```\n\n**步骤三：**\n\n执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用 **INSERT INTO... SELECT** 语句来实现。\n\n```\nmysql> INSERT INTO clone_tbl (runoob_id,\n    ->                        runoob_title,\n    ->                        runoob_author,\n    ->                        submission_date)\n    -> SELECT runoob_id,runoob_title,\n    ->        runoob_author,submission_date\n    -> FROM runoob_tbl;\nQuery OK, 3 rows affected (0.07 sec)\nRecords: 3  Duplicates: 0  Warnings: 0\n```\n\n执行以上步骤后，你将完整的复制表，包括表结构及表数据。\n\n### 另一种完整复制表的方法:\n\n```\nCREATE TABLE targetTable LIKE sourceTable;\nINSERT INTO targetTable SELECT * FROM sourceTable;\n```\n\n其他:\n\n可以拷贝一个表中其中的一些字段:\n\n```\nCREATE TABLE newadmin AS\n(\n    SELECT username, password FROM admin\n)\n```\n\n可以将新建的表的字段改名:\n\n```\nCREATE TABLE newadmin AS\n(  \n    SELECT id, username AS uname, password AS pass FROM admin\n)\n```\n\n可以拷贝一部分数据:\n\n```\nCREATE TABLE newadmin AS\n(\n    SELECT * FROM admin WHERE LEFT(username,1) = 's'\n)\n```\n\n可以在创建表的同时定义表中的字段信息:\n\n```\nCREATE TABLE newadmin\n(\n    id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY\n)\nAS\n(\n    SELECT * FROM admin\n)  \n```\n\n**区分下mysql复制表的两种方式。**\n\n**第一、只复制表结构到新表**\n\ncreate table 新表 select * from 旧表 where 1=2\n\n或者\n\ncreate table 新表 like 旧表 \n\n**第二、复制表结构及数据到新表**\n\ncreate table新表 select * from 旧表 \n\n","tags":["sql"]},{"title":"Linux","url":"/2020/07/02/Linux/","content":"\n## 虚拟机\n\n<!--more-->\n\n下载中文支持\n\n![1593837102375](1593837102375.png)\n\n网络连接的三种形式\n\n**桥连接**：Linux可以和其他系统通信，但是会造成IP冲突\n\n**NAT**：网络地址转换方式，Linux可以访问外网，不会造成IP冲突\n\n**主机模式**：你的Linux是一个独立的主机，不能访问外网\n\n\n\n分区：\n\nboot分区：200M\n\nswap分区：交换分区，虚拟内存，没有挂载点，2048M\n\n根分区/：使用全部剩余空间\n\n\n\n安装VMTool复制到/opt下\n\ntar -zxvf VM...... .tar.gz\n\n解压,进去文件夹，执行 /vmware-install.pl\n\n\n\n设置共享文件夹，在/mnt/hgfs下\n\n\n\nLinux文件系统采用的是级层式的树状结构，最上层的是根目录“/”。\n\n/bin 是Binary的缩写，这个目录存放着最经常使用的命令\n\n/dev 管理设备\n\n/etc管理配置文件\n\n/home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 \n\n/lib 系统开机需要\n\n/media dvd相关\n\n/mnt 挂载文件夹\n\n/opt 安装的软件\n\n/proc 内核\n\n/root 系统管理员，超级权限者的用户主目录\n\n/sbin Super user系统管理员使用的系统管理程序\n\n/selinux 安全加强\n\n/sys 系统\n\n/tmp 临时文件\n\n/usr 用户，安装的程序\n\n/var 变量，日志\n\n\n\n![img](clip_image004.png)  \n\n![img](clip_image0014.png)  \n\n\n\n### 远程登陆\n\nXShell\n\n- 需要Linux开启一个sshd服务22\n\n终端打开setup，打开系统服务，找到sshd，空格键打开服务。tab键退出。\n\n该服务会监听22端口。\n\n**ubuntu方法：** \n\n先试着开启SSH服务\n\n在使用SSH之前，可以先检查SSH服务有没有开启。使用命令：sudo ps -e | grep ssh来查看，如果返回的结果是“xxxx? 00:00:00 sshd”,代表服务开启。那个四个x代表四位数字，每台机数字不一样的，如图：\n\n![img](894368-20181110064124048-505138018.png)\n\n如果没有反应或者其他结果，再试着开启SSH服务。使用命令sudo /etc/init.d/ssh start来开启服务，如图：\n\n![img](894368-20181110064515920-1613146923.png)\n\n如果是图中结果，说明没有安装SSH服务，此时需要安装 SSH服务，为了能提高安装成功率，建议先更新源：sudo apt-get update更新安装源，如图：\n\n![img](894368-20181110065024263-2090018697.png)\n\n然后安装SSH服务，使用命令：sudo apt-get install openssh-server。如图：\n\n![img](894368-20181110065349975-237913277.png)\n\n等待安装结束即可。然后再次查看服务有没有启动：sudo ps -e | grep ssh：\n\n ![img](894368-20181110065558878-1157322075.png)\n\n有sshd那个东西，说明服务启动了，如果需要再次确认或者没有图中的结果，使用命令来启动:sudo /etc/init.d/ssh start:\n\n![img](894368-20181110065759521-304903884.png)\n\n看到服务starting了，服务成功开启。另外，还有几条命令需要记住：\n\nsudo service ssh status 查看服务状态：\n\n![img](894368-20181110070229962-1792308008.png)\n\nsudo service ssh stop 关闭服务：\n\nsudo service ssh restart 重启服务\n\n\n\nXshell新建会话，先查看linux的ip地址。\n\n```\nipconfig\n```\n\n![1593769665771](1593769665771.png)\n\n箭头指向的是ip地址。\n\n填写到xshell\n\n![1593769808715](1593769808715.png)\n\nUbuntu需要配置sshd服务\n\n输入Linux的用户名和密码。成功连接。\n\n\n\n如果远程使用命令：\n\n```shell\nreboot\n```\n\n服务器也会重启\n\n\n\n### 文件的上传下载XFTP\n\n协议选择SFTP\n\n端口号选择22\n\n![1593782048647](1593782048647.png)\n\n**乱码解决**：![1593782224041](1593782224041.png)\n\n选择要传输的文件，右键传输就可以了。\n\n\n\n### Vi和Vim编辑器\n\n ![img](078207F0-B204-4464-AAEF-982F45EDDAE9.jpg) \n\n#### 正常模式\n\n在正常模式下，我们可以使用快捷键。\n\n以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。\n\n#### 插入模式/编辑模式\n\n在模式下，程序员可以输入内容。\n\n按下 i, I 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可\n\n#### 命令行模式\n\n在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！\n\n#### 各模式之间的互相转换\n\n![1593783036444](1593783036444.png)\n\n#### 快捷键的使用案例\n\n1)  拷贝当前行   yy , 拷贝当前行向下的 5 行 5yy，并粘贴（p）。\n\n2)  删除当前行  dd  , 删除当前行向下的 5 行 5dd\n\n3)  在文件中查找某个单词  [命令行下  /关键字  ， 回车  查找  ,    输入 n 就是查找下一个 ],查询\n\nhello.\n\n4)  设置文件的行号，取消文件的行号.[命令行下  : set nu 和  :set nonu]\n\n5)  编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg],注意这些都是在正常模式下执行的。\n\n6)  在一个文件中输入  \"hello\" ,然后又撤销这个动作，再正常模式下输入 u\n\n7)  编辑  /etc/profile 文件，并将光标移动到  第 20 行  shift+g\n\n第一步：显示行号 :set nu \n\n第二步：输入 20 这个数\n\n第三步: 输入 shift+g\n\n ![img](vi-vim-cheat-sheet-sch.gif) \n\n\n\n### 关机&重启命令\n\n#### 基本介绍\n\nshutdown\n\nshutdown -h now : 表示立即关机\n\nshutdown -h 1 : 表示 1 分钟后关机\n\nshutdown -r now: 立即重启\n\nhalt\n\n就是直接使用，效果等价于关机\n\nreboot\n\n就是重启系统。\n\nsync：  把内存的数据同步到磁盘\n\n#### 注意细节\n\n当我们关机或者重启时，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失。\n\n### 用户登录和注销\n\n1)  登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份.\n\n2)  在提示符下输入 logout 即可注销用户\n\n#### 使用细节\n\n1)logout 注销指令在图形运行级别无效，在 运行级别 3 下有效.\n\n\n\n ### 用户管理\n\n  ![img](clip_image003.gif)\n\n**说明**\n\nLinux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号\n\n#### 添加用户\n\n##### 基本语法\n\nuseradd  [选项]  用户名\n\n1)  当创建用户成功后，会自动的创建和用户同名的家目录\n\n2)  也可以通过  useradd -d 指定目录   新的用户名，给新创建的用户指定家目录\n\n#### **设置密码**\n\n基本语法           \n\npasswd  用户名\n\n#### 删除用户\n\n##### 基本语法\n\nuserdel  用户名\n\n1)       删除用户 xm，但是要保留家目录\n\n```shell\nuserdel xm\n```\n\n2) 删除用户 xh 以及用户主目录\n\n```\nuserdel xh -r\n```\n\n**在删除用户时，我们一般不会将家目录删除。**\n\n#### 查询用户信息\n\n##### 基本语法\n\n```shell\nid  用户名\nuid=0(root) gid=0(root)  组=0(root)\n |           |            |\n V           V            V\n用户id号   所在组的id号    组名 \n```\n\n#### 切换用户\n\n在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root\n\n**基本语法**\n\n```shell\nsu\t–\t切换用户名\n//高权限用户向低权限用户不需要密码\nexit   //可以回到原来的用户\n```\n\n1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。\n\n2)当需要返回到原来用户时，使用 exit 指令\n\n```\nwhoami  //查看当前用户\n```\n\n#### 用户组\n\n类似于角色，系统可以对有共性的多个用户进行统一的管理。\n\n**增加组**\n\ngroupadd 组 名\n\n**删除组**\n\ngroupdel 组 名\n\n**增加用户时直接加上组**\n\nuseradd  -g 用户组 用户名\n\n**修改用户的组**\n\nusermod  -g 用户组 用户名\n\n\n\n#### **用户和组的相关文件**\n\n**/etc/passwd 文件**\n\n用户（user）的配置文件，记录用户的各种信息 \n\n每行的含义：         \n\n用户名 : 口令 : 用户标识号 : 组标识号 : 注释性描述 : 主目录 : 登录 Shell \n\n\n\n**/etc/shadow 文件**\n\n口令的配置文件\n每行的含义：\n\n登录名 : 加密口令 : 最后一次修改时间 : 最小时间间隔 : 最大时间间隔 : 警告时间 : 不活动时间 : 失效时间 : 标志\n\n\n\n**/etc/group 文件**\n组(group)的配置文件，记录 Linux 包含的组的信息每行含义：\n\n组名:口令:组标识号:组内用户列表\n\n\n\n### 运行级别\n\n运行级别说明：\n0：关机\n1：单用户【找回丢失密码】\n2：多用户状态没有网络服务\n3：多用户状态有网络服务\n4：系统未使用保留给用户\n5：图形界面\n6：系统重启\n\n常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件\n\n/etc/inittab 的   `id:5:initdefault:`   这一行中的数字\n\n![1593838451860](1593838451860.png)\n\n#### 指定运行级别\n\n![img](clip_image001.gif)\n\ninit [012356]\n\nint   3\n\ninit [012356]\n\n##### 如何找回 root 密码  \n\n进入到 单用户模式，然后修改 root 密码。因为进入单用户模式，root 不需要密码就可以登录。\n\n开机在引导期间使用enter进入页面，按e进入选择第二行的内核kenral再按e进入，输入1告诉内核进入单用户模式，再按回车回去上一级按b启动。\n\n启动后使用passwd root就可以重置密码了。reboot重启。\n\n### 获得帮助信息\n\n#### man\n\nman [命令或配置文件]（功能描述：获得帮助信息）\n\nman  ls\n\n#### help 指令\n\nhelp 命令 （功能描述：获得 shell 内置命令的帮助信息）\n\nhelp cd\n\n### 文件目录类\n\n#### pwd 指令\n\npwd   (功能描述：显示当前工作目录的绝对路径)\n\n#### ls 指令\n\nls [ 选 项] [目录或是文件]\n\n#### cd 指令\n\ncd .当前目录(不变)\n\ncd  [参数] (功能描述：切换到指定目录)\n\ncd ~ 或者 cd ：回到自己的家目录\n\ncd .. 回到当前目录的上一级目录\n\ncd   /root  使用绝对路径切换到 root 目录\n\ncd  ../../root    使用相对路径到/root 目录\n\n#### mkdir 指令\n\nmkdir 指令用于创建目录(make directory)\n\nmkdir  [选项]  要创建的目录\n\n-p ：创建多级目录\n\n```\nmkdir -p /aaa/bbb/ccc\n```\n\n#### rmdir 指令\n\nrmdir 指令删除空目录\n\nrmdir  [选项]  要删除的空目录\n\n`rmdir `删除的是空目录，如果目录下有内容时无法删除的。\n提示：如果需要删除非空目录，需要使用`rm -rf `要删除的目录\n\n#### touch 指令\n\ntouch 指令创建空文件\n\ntouch 文件名称\n\n#### cp 指令[*]\n\ncp 指令拷贝文件到指定目录\n\ncp [选项] source dest\n\n-r ：递归复制整个文件夹\n\ncp -r  源目录  目标目录\n\n#### rm 指令\n\nrm 指令移除【删除】文件或目录\n\nrm  [选项]  要删除的文件或目录\n\n-r ：递归删除整个文件夹\n\n-f ： 强制删除不提示\n\n#### mv 指令\n\nmv 移动文件与目录或重命名\n\nmv  oldNameFile newNameFile \t\t(功能描述：重命名)\n\n mv /temp/movefile /targetFolder\t (功能描述：移动文件)\n\n#### cat 指令\n\ncat 查看文件内容，是以只读的方式打开。\n\ncat  [选项] 要查看的文件\n\n-n ：显示行号\n\ncat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上  管道命令 | more\n\ncat 文件名 | more [分页浏览]\n\n#### more 指令\n\nmore 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容\n\n快捷键：\n\n![1593843318484](1593843318484.png)\n\n#### less 指令\n\nless 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。\n\n```\nless 要查看的文件\n```\n\n![1593843382522](1593843382522.png)\n\n#### > 指令 和 >> 指令\n\n\\> 输出重定向 : 会将原来的文件的内容覆盖\n\n\\>> 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部。\n\n```\nls -l >文件    \t\t（功能描述：列表的内容写入文件 a.txt 中（覆盖写））\nls -al >>文件\t\t\t（功能描述：列表的内容追加到文件 aa.txt 的末尾）\ncat 文件 1 > 文件 2\t\t（功能描述：将文件 1 的内容覆盖到文件 2）\ncal >> /home/mycal\t\t将当前日历信息  追加到 /home/mycal 文件中 [提示 cal ]  \n```\n\n#### echo 指令\n\necho 输出内容到控制台。\n\necho  [选项]  [输出内容]\n\n```\necho $PATH   使用 echo 指令输出环境变量,输出当前的环境路径。\n```\n\n#### head 指令  \n\nhead 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容\n\n```\nhead  文件\t(功能描述：查看文件头 10 行内容)\nhead -n 5 文件\t(功能描述：查看文件头 5 行内容，5 可以是任意行数)\n```\n\n#### tail 指令\n\ntail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。\n\n```\ntail 文件\t\t\t（功能描述：查看文件后 10 行内容）\ntail -n 5 文件  \t（功能描述：查看文件后 5 行内容，5 可以是任意行数）\ntail -f\t文件\t\t（功能描述：实时追踪该文档的所有更新，工作经常使用）\n```\n\n#### ln 指令\n\n软链接也叫符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径\n\n```\nln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）\nln -s /root linkToRoot\t\t在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录\nrm -rf  linkToRoot          删除软连接\nln 硬链接 \n##软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名（filename）进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件），硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。\n```\n\n当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。\n\n#### history 指令\n\n查看已经执行过历史命令,也可以执行历史指令\n\n```\nhistory    （功能描述：查看已经执行过历史命令）\nhistory 10 \t显示最近使用过的 10 个指令。\n!10   \t\t执行编号为10的指令\n```\n\n### 时间日期类\n\n#### date 指令-显示当前日期\n\n```\n1) date\t\t（功能描述：显示当前时间）\n2) date +%Y （功能描述：显示当前年份）\n3) date +%m\t（功能描述：显示当前月份）\n4) date +%d\t（功能描述：显示当前是哪一天）\n5) date \"+%Y-%m-%d %H:%M:%S\"（功能描述：显示年月日时分秒）\n```\n\n#### date 指令-设置日期\n\n```\ndate -s\t字符串时间\n\n设置系统当前时间 ， 比如设置成 2018-10-10 11:22:22\ndate -s \"2018-10-10 11:22:22\"\n```\n\n#### 查看日历指令\n\n```\ncal [选项]    （功能描述：不加选项，显示本月日历）\ncal\ncal 2021\n```\n\n### 搜索查找类\n\n#### find 指令         \n\nfind 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端  \n\nfind  [搜索范围]  [选项]\n\n![1593844669367](1593844669367.png)\n\n```\n按文件名：根据名称查找/home 目录下的 hello.txt 文件\nfind /home -name hello.txt\n\n按拥有者：查找/opt 目录下，用户名称为 nobody 的文件\nfind /opt -user nobody\n\n查找整个 linux 系统下大于 20m 的文件（+n  大于\t-n 小于\tn 等于）\nfind / -size +20M\nfind / -size +20480K\n\n查询\t/ 目录下，所有 .txt 的文件\nfind / -name *.txt\n```\n\n#### locate 指令\n\nlocaate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。 \n\n```\nupdatedb \nlocate 搜索文件 \n```\n\n由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。\n\n#### grep 指令和 管道符号 |\n\ngrep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。\n\n```\ngrep [选项] 查找内容 源文件\n```\n\n -n 显示匹配行及行号\n\n -i 忽略字母大小写\n\n ```\n请在  hello.txt  文件中，查找\t\"yes\"\t所在行，并且显示行号\ncat hello.txt | grep -n yes\n ```\n\n### 压缩和解压类\n\n#### gzip/gunzip 指令\n\ngzip 用于压缩文件， gunzip 用于解压的\n\ngzip 文件   （功能描述：压缩文件，只能将文件压缩为*.gz 文件）\n\ngunzip 文 件.gz  （功能描述：解压缩文件命令）\n\n```\ngzip 压缩， 将 /home 下的 hello.txt 文件进行压缩\ngzip  hello.txt\n\ngunzip 压缩， 将 /home 下的 hello.txt.gz 文件进行解压缩\ngunzip  hello.txt.gz\n```\n\n当我们使用 gzip 对文件进行压缩后，不会保留原来的文件。\n\n#### zip/unzip 指令\n\nzip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的\n\n```\nzip\t\t[选项] XXX.zip\t 将要压缩的内容（功能描述：压缩文件和目录的命令）\nunzip\t[选项] XXX.zip \t（功能描述：解压缩文件）\n```\n\nzip  -r：递归压缩，即压缩目录\n\nunzip   -d<目录> ：指定解压后文件的存放目录\n\n````shell\n将 /home 下的 所有文件进行压缩成 mypackage.zip\nzip -r mypackage.zip /home/\n\n将 mypackge.zip 解压到 /opt/tmp 目录下\nunzip -d /opt/tmp/ mypackage.zip\n````\n\n#### tar 指令\n\ntar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。\n\n```\ntar\t[选项]\tXXX.tar.gz\t打包的内容\t(功能描述：打包目录，压缩后的文件格式.tar.gz)\n```\n\n![1593845537786](1593845537786.png)\n\n```shell\n压缩多个文件，将  /home/a1.txt 和  /home/a2.txt 压缩成 a.tar.gz\ntar -zcvf a.tar.gz  a1.txt a2.txt\n\n将/home 的文件夹 压缩成 myhome.tar.gz\ntar -zcvf myhome.tar.gz /home/\n\n将  a.tar.gz\t解压到当前目录\ntar -zxvf a.tar.gz\n\n将 myhome.tar.gz\t解压到 /opt/ 目录下\n#指定解压到的那个目录，事先要存在才能成功，否则会报错。\ntar -zxvf myhome.tar.gz -C /opt/\n```\n\n\n\n### 组管理和权限管理\n#### Linux 组基本介绍\n\n在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。\n1)\t所有者\n2)\t所在组\n3)\t其它组\n4)\t改变用户所在的组\n\n \n\n![1593864434878](1593864434878.png)\n\n\n\n#### 文件/目录 所有者\n\n一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。\n\n### 查看文件的所有者\n\n指令：ls  -ahl\n\n创建一个组 police,再创建一个用户 tom,将 tom 放在 police 组 ,然后使用 tom 来创建一个文件 ok.txt\n\n![1593864576338](1593864576338.png)\n\n所有者👆\n\n#### 修改文件所有者\n\n指令：chown 用户名 文件名\n\n使用 root 创建一个文件 apple.txt ，然后将其所有者修改成 tom\n\n![1593864639589](1593864639589.png)\n\n#### 组的创建\n\ngroupadd 组 名\n\n创建一个组, ,monster\n\n创建一个用户  fox ，并放入到 monster 组中\n\n```\ngroupadd monster\nuseradd -g monster fox\nid fox //查看\n```\n\n#### 文件/目录 所在组\n\n当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。\n\n#### 查看文件/目录所在组\n\nls –ahl \n\n#### 修改文件所在的组\n\nchgrp 组名 文件名\n\n使用 root 用户创建文件 orange.txt ,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到 police 组 。\n\n![1593865387296](1593865387296.png)\n\n#### 其它组\n\n除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组.\n\n#### 改变用户所在组\n\n在添加用户时，可以指定将该用户添加到哪个组中，同样的用 root 的管理权限可以改变某个用户所在的组。\n\n```\nusermod   –g    组名  用户名\nusermod –d  目录名 用户名  改变该用户  \n```\n\n创建一个土匪组（bandit）将 tom 这个用户从原来所在的 police 组，修改到 bandit(土匪) 组\n\n![1593865717951](1593865717951.png)\n\n### 权限的基本介绍\n\nls  -l 中显示的内容如下：\n\n```shell\n-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc\n```\n\n0-9 位说明\n\n1)第 0 位确定文件类型(d, - , l , c , b)\n\n2)第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。---User\n\n3)第 4-6 位确定所属组（同用户组的）拥有该文件的权限，---Group\n\n4)第 7-9 位确定其他用户拥有该文件的权限 ---Other\n\n![1593865847037](1593865847037.png)\n\n\n\n### rwx权限详解\n\n#### rwx作用到文件\n\n1) [ r ]代表可读(read): 可以读取,查看\n\n2)  [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.\n\n3) [ x ]代表可执行(execute):可以被执行\n\n#### rwx作用到目录\n\n1) [ r ]代表可读(read): 可以读取，ls 查看目录内容\n\n2) [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录\n\n3) [ x ]代表可执行(execute):可以进入该目录\n\n### 文件及目录权限实际案例\n\nls  -l 中显示的内容如下：\n\n-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc\n\n10 个字符确定不同用户能对文件干什么\n\n第一个字符代表文件类型： 文件 (-),目录(d),链接(l)\n其余字符每 3 个一组(rwx) 读(r) 写(w) 执行(x) \n第一组 rwx : 文件拥有者的权限是读、写和执行\n第二组 rw- :  与文件拥有者同一组的用户的权限是读、写但不能执行\n\n第三组 r-- :\t不与文件拥有者同组的其他用户的权限是读不能写和执行\n\n可用数字表示为: r=4,w=2,x=1  因此 rwx=4+2+1=7\n\n| **1**           | **文件：硬连接数或\t目录：子目录数**           |\n| --------------- | ------------------------------------------------ |\n| **root**        | **用户**                                         |\n| **root**        | **组**                                           |\n| **1213**        | **文件大小(字节)，如果是文件夹，显示 4096 字节** |\n| **Feb 2 09:39** | **最后修改日期**                                 |\n| **abc**         | **文件名**                                       |\n\n​\t\n\n#### 修改权限-chmod\n\n通过 chmod 指令，可以修改文件或者目录的权限\n\n#### 第一种方式：+ 、-、= 变更权限\n\nu:所有者  g:所有组  o:其他人  a:所有人(u、g、o 的总和)\n\n1) chmod   u=rwx,g=rx,o=x   文件目录名\n\n2) chmod   o+w    文件目录名\n\n3) chmod   a-x    文件目录名\n\n给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。\n![1593866461439](1593866461439.png)\n\n给 abc 文件的所有者除去执行的权限，增加组写的权限\n\n![1593866504885](1593866504885.png)\n\n给 abc 文件的所有用户添加读的权限  \n\n![1593866558942](1593866558942.png)\n\n#### 第二种方式：通过数字变更权限\n\n规则：r=4 w=2 x=1,rwx=4+2+1=7 \n\nchmod u=rwx,g=rx,o=x    文件目录名\n\n相当于  chmod  751\t文件目录名\n\n\n\n将  /home/abc.txt    文件的权限修改成\trwxr-xr-x, 使用给数字的方式实现：\n\nrwx = 4+2+1 = 7\n\nr-x = 4+1=5\n\nr-x = 4+1 =5\n\n指令：chmod 755 /home/abc.txt\n\n#### 修改文件所有者-chown\n\nchown  newowner  file  \t\t\t\t\t\t改变文件的所有者\n\nchown newowner:newgroup file \t改变用户的所有者和所有组    \n\n-R                       如果是目录 则使其下所有子文件或目录递归生效\n\n\n\n请将 /home/abc .txt 文件的所有者修改成 tom\n\n![1593866819855](1593866819855.png)\n\n请将 /home/kkk 目录下所有的文件和目录的所有者都修改成 tom\n\n首选我们应该使用 root 操作。  \n\n![1593866872283](1593866872283.png)\n\n#### 修改文件所在组-chgrp\n\nchgrp newgroup file  改变文件的所有组\n\n1)    请将 /home/abc .txt 文件的所在组修改成 bandit (土匪)\n\n```shell\nchgrp bandit /home/abc.txt\n```\n\n2)    请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)\n\n```\nchgrp -R bandit /home/kkk\n```\n\n![1593866984875](1593866984875.png)\n\n### 最佳实践-警察和土匪游戏\n\npolice警察     bandit土匪\n\njack, jerry: 警 察\n\nxh, xq: 土 匪\n\n(1)  创建组\n\nbash> groupadd police \n\nbash> groupadd bandit\n\n(2)  创建用户 \n\n ![1593867122713](1593867122713.png)\n\n ![1593867129607](1593867129607.png)\n\n (3)    jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限\n\n ![1593867173773](1593867173773.png)\n\n (4)   jack 修改该文件，让其它组人可以读, 本组人可以读写\n\n ![1593867219396](1593867219396.png)\n\n (5)   xh 投靠 警察，看看是否可以读写. \n\n先用 root 修改 xh 的组 ：\n\n ![1593867266232](1593867266232.png)\n\n使用 jack 给他的家目录 /home/jack 的所在组一个 rx 的权限\n\n ![1593867293834](1593867293834.png)\n\nxh 需要重新注销在到 jack 目录就可以操作    jack 的文件  \n\n![1593867344404](1593867344404.png)\n\n\n\n## crond 任务调度\n\n### 原理  \n\n![1593948751281](1593948751281.png)\n\n![1593948778770](1593948778770.png)\n\n**crontab  进行 定时任务的设置**  \n\n**任务调度**：是指系统在某个时间执行的特定的命令或程序。\n\n任务调度分类：\n\n1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等\n\n2.个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。\n\n#### 基本语法\n\n```\ncrontab [选项]\n```\n\n![1593948881827](1593948881827.png)\n\n#### 要求\n\n设置任务调度文件：/etc/crontab\n\n设置个人任务调度。执行 crontab –e 命令。  \n\n接着输入任务到调度文件  \n\n如：*/1 * * * * ls –l   /etc/ > /tmp/to.txt\n\n意思说每小时的每分钟执行 ls –l /etc/ > /tmp/to.txt 命令\n\n#### 步骤如下\n\n1)  cron -e\n\n2)  */ 1 * * * * ls -l /etc >> /tmp/to.txt\n\n3)  当保存退出后就程序。\n\n4)  在每一分钟都会自动的调用 ls -l /etc >> /tmp/to.txt\n\n#### 参数细节说明  \n\n![1593949018840](1593949018840.png)\n\n![1593949051397](1593949051397.png)\n\n![1593949079188](1593949079188.png)\n\n##### **案例 1**：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中\n\n1)  先编写一个文件 /home/mytask1.sh     \n\ndate >> /tmp/mydate\n\n2)  给 mytask1.sh 一个可以执行权限\n\nchmod 744 /home/mytask1.sh\n\n3)  crontab -e\n\n4)  */1 * * * *  /home/mytask1.sh\n\n5)  成功\n\n##### **案例 2**：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal 文件中  \n\n1)  先编写一个文件  \n\n/home/mytask2.sh\n\ndate >> /tmp/mycal\n\n cal >> /tmp/mycal\n\n2)  给 mytask1.sh 一个可以执行权限\n\nchmod 744 /home/mytask2.sh\n\n3) crontab -e\n\n4) */1 * * * *  /home/mytask2.sh\n\n5)  成功\n\n##### **案例 3:**     每天凌晨 2:00 将 mysql 数据库 testdb ，备份到文件中mydb.bak。\n\n1)  先编写一个文件  /home/mytask3.sh\n\n/usr/local/mysql/bin/mysqldump -u root -proot testdb > /tmp/mydb.bak\n\n2)  给 mytask3.sh 一个可以执行权限\n\n```\nchmod 744 /home/mytask3.sh\n```\n\n3) \n\n```\ncrontab -e\n```\n\n4)    \n\n```\n0 2 * * *  /home/mytask3.sh\n```\n\n5)  成功\n\n#### crond 相关指令:\n\n1)  conrtab –r：终止任务调度。\n\n2)  crontab –l：列出当前有那些任务调度\n\n3)  service crond restart   [重启任务调度]\n\n## Linux 磁盘分区、挂载\n\n### 分区基础知识\n\n#####  windows 下的磁盘分区\n\n![1593951062587](1593951062587.png)\n\n#### 分区的方式：\n\n1) mbr 分区:\n\n1.最多支持四个主分区\n\n2.系统只能安装在主分区\n\n3.扩展分区要占一个主分区\n\n4.MBR 最大只支持 2TB，但拥有最好的兼容性\n\n2) gtp 分区:\n\n1.支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区）\n\n2.最大支持 18EB 的大容量（1EB=1024 PB，1PB=1024 TB ）\n\n3.windows7 64 位以后支持 \n\n#### windows 下的磁盘分区\n\n![1593950528566](1593950528566.png)\n\n### Linux 分区\n\n#### 原理介绍\n\n1)Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。\n\n2)Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。\n\n![1593950575312](1593950575312.png)\n\n#### 硬盘说明\n\n1)Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘\n\n2)对于 IDE 硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“~”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。  \n\n3)对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样 . \n\n##### 使用 lsblk 指令查看当前系统的分区情况  \n\n![1593950651437](1593950651437.png)\n\n![1593950681315](1593950681315.png)\n\n#### 挂载的经典案例\n\n需求是给我们的 Linux 系统增加一个新的硬盘，并且挂载到/home/newdisk\n\n![1593950721662](1593950721662.png)\n\n### 如何增加一块硬盘\n\n1)虚拟机添加硬盘\n\n2)分区    fdisk         /dev/sdb \n\n3)格式化 mkfs   -t    ext4    /dev/sdb1\n\n4)挂载   先创建一个  /home/newdisk , 挂 载  mount     /dev/sdb1    /home/newdisk\n\n5)设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 /home/newdisk) 。\n\nvim   /etc/fstab\n\n/dev/sdb1          /home/newdisk           ext4    defaults        0 0\n\n#### 具体的操作步骤整理\n\n##### 虚拟机增加硬盘步骤 1\n\n在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！\n\n![1593953351911](1593953351911.png)\n\n![1593953412730](1593953412730.png)\n\n![1593953444288](1593953444288.png)\n\n![1593953468858](1593953468858.png)\n\n![1593953495297](1593953495297.png)\n\n重启虚拟机reboot\n\n重启后使用 lsblk -f \n\n可以看见多了个sdb\n\n##### 虚拟机增加硬盘步骤 2\n\n使用分区命令\n\n```\n  fdisk  /dev/sdb\n```\n\n开始对/sdb 分区\n\n输入m可以看到帮助\n\nm\t显示命令列表\n\np\t显示磁盘分区 同 fdisk –l\n\nn\t新增分区\n\nd\t删除分区\n\nw\t写入并退出\n\n\n\n```\n输入n\n\n显示  e  extended\n\t p  primary partition(1-4)\n选择p\t \n```\n\n\n\n说明： 开始分区后输入 n，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出，若不保存退出输入 q。\n\n![img](clip_image005.jpg)\n\n##### 虚拟机增加硬盘步骤 3\n\n格式化磁盘\n\n分区命令:\n\n```\nmkfs -t ext4  /dev/sdb1\n```\n\n其中 ext4 是分区类型\n\n##### 虚拟机增加硬盘步骤 4\n\n**挂载**: 将一个分区与一个目录联系起来，\n\n•mount     设备名称  挂载目录\n\n•例如：  mount   /dev/sdb1   /home/newdisk\n\n•umount   设备名称  或者 挂载目录 \n\n•例如：   umount   /dev/sdb1    或者   umount  /newdisk\n\n##### 虚拟机增加硬盘步骤 5\n\nvim   /etc/fstab\n\n在UUID上面一行插入\n\n```shell\n/dev/sdb1     /home/newdisk     ext4  defaults  0 0\n```\n\n这句话可以使开机后能自动挂载\n\n使用命令mount -a立即生效\n\n\n\n 永久挂载通过修改实现挂载添加完成后  执行 –即刻生效\n\n![1593950964217](1593950964217.png)\n\n### 磁盘情况查询\n\n#### 查询系统整体磁盘使用情况\n\n```\ndf -h\n```\n\n![1594016323677](1594016323677.png)\n\n#### 查询指定目录的磁盘占用情况\n\n```\ndu -h\t/目录\n```\n\n查询指定目录的磁盘占用情况，默认为当前目录\n\n```\n-s 指定目录占用大小汇总\n\n-h 带计量单位\n\n-a 含文件\n\n--max-depth=1  子目录深度\n\n-c 列出明细的同时，增加汇总值\n```\n\n#### 查询 /opt 目录的磁盘占用情况，深度为 1  \n\n![1594016421875](1594016421875.png)\n\n#### 磁盘情况-工作实用指令\n\n1)    统计/home 文件夹下文件的个数\n\n```\n^-  表示以\"-\"打头的，表示文件\n```\n\n\n\n![1594016824199](1594016824199.png)\n\n2)    统计/home 文件夹下目录的个数\n\n![1594016885378](1594016885378.png)\n\n3)统计计/home 文件夹下文件的个数，包括子文件夹里的\n\n![1594016923222](1594016923222.png)\n\n4)    统计文件夹下目录的个数，包括子文件夹里的\n\n![1594016946230](1594016946230.png)\n\n5)以树状显示目录结构  \n\n![1594016968695](1594016968695.png)\n\n![1594017008507](1594017008507.png)\n\n###  网络配置  \n\nLinux 网络配置原理图(含虚拟机)  \n\n目前我们的网络配置采用的是 NAT。\n\n![1594018740806](1594018740806.png)\n\n#### 查看网络 IP 和网关\n\n查看虚拟网络编辑器  \n\n![1594018794841](1594018794841.png)\n\n#### 修改 ip 地址(修改虚拟网络的 ip)\n\n![1594018819402](1594018819402.png)\n\n#### 查看网关  \n\n![1594018857189](1594018857189.png)\n\n#### 查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令)\n\n1)  使用 ipconfig 查看\n\n2)  界面查看\n\n![1594018892385](1594018892385.png)\n\n#### ping 测试主机之间网络连通  \n\nping  目的主机 （功能描述：测试当前服务器是否可以连接目的主机）\n\n**测试当前服务器是否可以连接百度**\n\n[root@hadoop100 桌面]# ping [www.baidu.com](http://www.baidu.com/)\n\n#### linux 网络环境配置\n\n**第一种方法(自动获取)**\n\n![1594018974152](1594018974152.png)\n\n缺点: linux 启动后会自动获取 IP,缺点是每次自动获取的 ip 地址可能不一样。这个不适用于做服务器，因为我们的服务器的 ip 需要时固定的。  \n\n**第二种方法(指定固定的 ip)**\n\n直 接 修 改 配 置 文 件 来 指 定 IP, 并 可 以 连 接 到 外 网 ( 程 序 员 推 荐 ) ， 编 辑                                                                     vi      /etc/sysconfig/network-scripts/ifcfg-eth0\n\n要求：将 ip 地址配置的静态的，ip 地址为 192.168.184.130\n\n![1594019066944](1594019066944.png)\n\n修改后，一定要 重启服务\n\n1)  service network restart\n\n2)  reboot 重启系统\n\n![1594019131820](1594019131820.png)\n\n## 进程管理  \n\n#### 进程的基本介绍\n\n 1)在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号。\n\n2)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如 www 服务器。\n\n3)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。\n\n4)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。\n\n#### 显示系统执行的进程\n\n查看进行使用的指令是  ps ,一般来说使用的参数是 ps -aux\n\n![1594038649910](1594038649910.png)\n\n![1594038680528](1594038680528.png)\n\n#### ps 指令详解\n\n1)指令：ps –aux|grep xxx ，比如我看看有没有 sshd 服务\n\n指令说明\n\n•  System V 展示风格\n\n•  USER：用户名称\n\n•  PID：进程号\n\n•  %CPU：进程占用 CPU 的百分比\n\n•  %MEM：进程占用物理内存的百分比\n\n• VSZ：进程占用的虚拟内存大小（单位：KB）\n\n• RSS：进程占用的物理内存大小（单位：KB）\n\n• TT：终端名称,缩写 .\n\n• STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等\n\n• STARTED：进程的启动时间\n\n• TIME：CPU 时间，即进程使用 CPU 的总时间\n\n• COMMAND：启动进程所用的命令和参数，如果过长会被截断显示\n\n**要求：以全格式显示当前所有的进程，查看进程的父进程。**\n\n![1594038857538](1594038857538.png)\n\n**•**  ps -ef 是以全格式显示当前所有的进程\n\n**•**  -e 显示所有进程。-f 全格式。\n\n​\t\t**•**  ps -ef|grep xxx\n\n​\t\t**•** 是 BSD 风格\n\n​\t\t**•** UID：用户 ID\n\n​\t\t**•** PID：进程 ID\n\n​\t\t**•** PPID：父进程 ID\n\n​\t\t**•** C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高\n\n​\t\t**•** STIME：进程启动的时间\n\n​\t\t**•** TTY：完整的终端名称\n\n​\t\t**•** TIME：CPU 时间\n\n​\t\t**•** CMD：启动进程所用的命令和参数\n\n如果我们希望查看 sshd 进程的父进程号是多少，应该怎样查询 ？\n\n![1594038908719](1594038908719.png)\n\n可以看到是1.\n\n#### 终止进程 kill 和 killall\n\n若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务。\n\n```\nkill  [选项] 进程号（功能描述：通过进程号杀死进程）\n\nkillall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）\n```\n\n**选项:**\n\n-9 :表示强迫进程立即停止\n\n**踢掉某个非法登录用户**  \n\nxshell用jack登录\n\n![1594039007134](1594039007134.png)\n\n**终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务**\n\n![1594039036135](1594039036135.png)\n\n**终止多个 gedit 编辑器 【killall , 通过进程名称来终止进程】**  \n\n![1594039077859](1594039077859.png)\n\n**强制杀掉一个终端**  \n\n![1594039104006](1594039104006.png)\n\n#### 查看进程树 pstree\n\n```shell\npstree [选项] ,可以更加直观的来看进程信息\n```\n\n-p :显示进程的 PID\n\n-u :显示进程的所属用户\n\n\n\n**树状的形式显示进程的 pid**  \n\n![1594039184688](1594039184688.png)\n\n**树状的形式进程的用户 id pstree -u 即可。**  \n\n## 服务(Service)管理\n\n服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。  \n\n在 CentOS7.0 后 不再使用 service ,而是 systemctl\n\n![1594039258444](1594039258444.png)\n\n#### service 管理指令：\n\n```\nservice  服务名 [start | stop | restart | reload | status]\n```\n\n**查看当前防火墙的状况，关闭防火墙和重启防火墙。**\n\n![1594039305238](1594039305238.png)\n\n![1594039336933](1594039336933.png)\n\nCentOS用firewalld:   systemctl  status  firewalld\n\n\n\n1) 关闭或者启用防火墙后，立即生效。[telnet 测试  某个端口即可]\n\n在window下\n\ntelnet不是命令的，是因为没有telnet客户端\n\n![1594039381169](1594039381169.png)\n\n2)这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。\n\n如果希望设置某个服务自启动或关闭永久生效，要使用 chkconfig 指令\n\n#### 查看服务名:\n\n方式 1：使用 setup -> 系统服务 就可以看到。(空格选中，回车确认，tab切换)\n\n![1594039460191](1594039460191.png)\n\n方式 2:     /etc/init.d/服务名称\n\n![1594039571261](1594039571261.png)\n\n#### 服务的运行级别(runlevel):\n\n查看或者修改默认级别：\n\n```\n  vi    /etc/inittab\n```\n\nLinux 系统有 7 种运行级别(runlevel)：常用的是级别 3 和 5\n\n• 运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动\n\n• 运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆\n\n• 运行级别 2：多用户状态(没有 NFS)，不支持网络\n\n• 运行级别 3：完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式\n\n• 运行级别 4：系统未使用，保留\n\n• 运行级别 5：X11 控制台，登陆后进入图形 GUI 模式\n\n• 运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动\n\n#### 开机的流程说明  \n\n![1594039668145](1594039668145.png)\n\n开机、BIOS自检、boot引导、init进程、判断运行级别、\n\n#### chkconfig 指令  \n\n通过 chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭\n\n```\n查看服务 chkconfig --list|grep xxx\n```\n\n![1594039757144](1594039757144.png)\n\n\n\nchkconfig   服务名   --list\n\n\n\nchkconfig   --level  5   服务名   on/off\n\n**将 sshd 服务在运行级别为 5 的情况下，不要自启动**  \n\n![1594039797350](1594039797350.png)\n\n\n\n**请显示当前系统所有服务的各个运行级别的运行状态**\n\nbash> chkconfig --list\n\n**查看 sshd 服务的运行状态****\n\nbash> service sshd status\n\n**将 sshd 服务在运行级别 5 下设置为不自动启动，看看有什么效果？**\n\nbash> chkconfig --level 5 sshd off\n\n**当运行级别为 5 时，关闭防火墙。**\n\nbash> chkconfig  --level 5  iptables off\n\n **在所有运行级别下，关闭防火墙**\n\nbash> chkconfig  iptables off\n\n**在所有运行级别下，开启防火墙**\n\nbash> chkconfig  iptables  on\n\n#### 动态监控进程\n\n> top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程。\n\n```\ntop [选项]\n```\n\n![1594039987313](1594039987313.png)\n\n**监视特定用户**\n\ntop：输入此命令，按回车键，查看执行的进程。\n\nu：然后输入“u”回车，再输入用户名，即可\n\n![1594040023371](1594040023371.png)\n\n**终止指定的进程**\n\ntop：输入此命令，按回车键，查看执行的进程。\n\nk：然后输入“k”回车，再输入要结束的进程 ID 号\n\n![1594040063985](1594040063985.png)\n\n**指定系统状态更新的时间(每隔 10 秒自动更新， 默认是 3 秒)：**\n\nbash> top -d 10\n\n#### 查看系统网络情况 netstat(重要)\n\n```\nnetstat   [选项]\n\nnetstat  -anp\n\n-an  按一定顺序排列输出\n\n-p  显示哪个进程在调用\n```\n\n查看系统所有的网络服务\n\n![1594040174174](1594040174174.png)\n\n查看服务名为 sshd 的服务的信息。\n\n![1594040196413](1594040196413.png)\n\n### RPM   和 YUM  \n\n#### rpm 包的管理  \n\n> 一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。\n>\n> Linux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。\n\n#### rpm 包的简单查询指令  \n\n查询已安装的 rpm 列表 rpm  –qa|grep xx\n\n请查询看一下，当前的 Linux 有没有安装 firefox .\n\n![1594089056566](1594089056566.png)\n\n### rpm 包名基本格式：\n\n 一个 rpm 包名：firefox-45.0.1-1.el6.centos.x86_64.rpm 名称:firefox\n\n版本号：45.0.1-1\n\n适用操作系统: el6.centos.x86_64\n\n表示 centos6.x 的 64 位系统\n\n如果是 i686i386 32 noarch \n\n#### rpm 包的其它查询指令：\n\n rpm -qa :查询所安装的所有 rpm 软件包\n\nrpm -qa | more [分页显示]  \n\nrpm -qa | grep X [rpm -qa | grep firefox ]\n\n![1594089139190](1594089139190.png)\n\nrpm -q 软件包名 :查询软件包是否安装\n\nrpm -q firefox\n\n rpm -qi 软件包名 ：查询软件包信息\n\n![1594089158445](1594089158445.png)\n\nrpm -qi file  \n\nrpm -ql 软件包名 :查询软件包中的文件\n\nrpm -ql firefox\n\n![1594089191772](1594089191772.png)\n\nrpm -qf 文件全路径名 查询文件所属的软件包\n\nrpm -qf /etc/passwd \n\nrpm -qf /root/install.log\n\n![img](clip_image001.jpg)\n\n#### 卸载 rpm 包：\n\n```\nrpm -e RPM 包的名称\n```\n\n删除 firefox  软件包 \n\n![1594089294137](1594089294137.png)\n\n\n\n1)  如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：   $ rpm -e  foo\n\nremoving these packages would break dependencies:foo is needed by bar-1.0-1\n\n2)  如果我们就是要删除 foo 这个 rpm 包，可以增加参数 --nodeps ,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行\n\n如：$ rpm -e --nodeps foo\n\n带上 --nodeps 就是强制删除。\n\n#### 安装 rpm 包：\n\n```\nrpm -ivh  RPM 包全路径名称\n```\n\ni=install 安 装\n\nv=verbose 提 示\n\nh=hash  进度条\n\n1) 演示安装 firefox 浏览器\n\n步骤先找到 firefox 的安装 rpm 包,你需要挂载上我们安装 centos 的 iso 文件，然后到/media/下去找 rpm 找 。\n\n```\ncp firefox-45.0.1-1.el6.centos.x86_64.rpm /opt/\n```\n\n![1594089388980](1594089388980.png)\n\n### yum\n\n>  Yum 是一个 [Shell ](https://baike.baidu.com/item/Shell)前端软件包管理器。基于 [RPM ](https://baike.baidu.com/item/RPM)包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用 yum 的前提是可以联网。\n\n![1594089423920](1594089423920.png)\n\n```shell\n查询 yum 服务器是否有需要安装的软件\nyum list|grep xx 软件列表\n安装指定的 yum 包\nyum install xxx\t下载安装\n\n```\n\n### \n\n**使用 yum 的方式来安装 firefox**\n\n先查看一下 firefox    rpm 在 yum 服务器有没有  \n\n![1594089517271](1594089517271.png)\n\n1)  安装\n\nyum install firefox\n\n## 搭建 JavaEE 环境  \n\n![1594089578388](1594089578388.png)\n\n![1594089603193](1594089603193.png)\n\n#### 安装 JDK\n\n0)  先将软件通过 xftp5 上传到 /opt 下\n\n1)  解压缩到 /opt\n\n2)    配置环境变量的配置文件 vim    /etc/profile\n\n![1594089685175](1594089685175.png)\n\nJAVA_HOME=/opt/jdk1.7.0_79 \n\nPATH=/opt/jdk1.7.0_79/bin:$PATH \n\nexport JAVA_HOME PATH\n\n**3)需要注销用户，环境变量才能生效**  \n\n如果是在 3 运行级别， logout\n\n如果是在 5 运行级别，\n\n4) 在任何目录下就可以使用 java 和 javac\n\n![1594089893452](1594089893452.png)\n\n测试是否安装成功\n\n​                ![img](clip_imag1e001.jpg)    \n编写一个简单的 输出\n\nHello.java 输出\"hello,world!\"  \n\n![1594089954309](1594089954309.png)\n\n#### 安装 tomcat\n\n1)  解压缩到/opt\n\n![1594089990057](1594089990057.png)\n\n2)启动 tomcat    ./startup.sh\n\n先进入到 tomcat 的 bin 目录\n\n![1594090017998](1594090017998.png)\n\n![1594090025822](1594090025822.png)\n\n使用 Linux 本地的浏览是可以访问到 tomcat\n\n开放端口 8080 ,这样外网才能访问到 tomcat vim /etc/sysconfig/iptables\n\n ![1594090060315](1594090060315.png)\n\n重启防火墙\n\n![1594090082996](1594090082996.png)\n\n测试是否安装成功：\n\n在 windows、Linux  下  访问 http://linuxip:8080\n\n![1594090112721](1594090112721.png)\n\n#### Eclipse 的安装\n\n1)  解压缩到/opt\n\n![1594090161102](1594090161102.png)\n\n2)启动 eclipse，配置 jre 和 server\n\n启动方法 1: 创建一个快捷方式\n\n启动方式 2: 进入到  eclipse 解压后的文件夹，然后执行        ./eclipse    即可\n\n3)编写 jsp 页面,并测试成功!\n\n![1594090202684](1594090202684.png)\n\n#### mysql 的安装和配置","tags":["Linux"]},{"title":"Interview(updateing)","url":"/2020/07/02/Interview(updating)/","content":"\n# Interview(updateing)\n\n<!--more-->\n\n# J2SE\n\n## Object-oriented\n\n### 关于Synchronized和lock \n\n`synchronized`是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。\n\nLock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。\n\n### volatile\n\n volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。 \n\n### 请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？\n\n synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。\nsynchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。 \n\n### 若对一个类不重写，它的equals()方法是如何比较的？\n\n 比较是对象的地址。 \n\n### 请解释hashCode()和equals()方法有什么联系？\n\nJava对象的eqauls方法和hashCode方法是这样规定的：\n\n➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。\n\n➁ 如果两个对象的hashCode相同，它们并不一定相同。\n\n### 什么是构造函数？什么是构造函数重载？什么是复制构造函数？\n\n 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。\nJava中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。\nJava不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 \n\n### 请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？\n\n **Java中的方法重载**发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。\n\n与此相对，**方法覆盖**是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 \n\n### Query接口的list方法和iterate方法有什么区别？\n\n ① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。\n②  list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题 \n\n### 面向对象的\"六原则一法则\"。\n\n \\- **单一职责原则：一个类只做它该做的事情**。（单一职责原则想表达的就是\"高内聚\"，写代码最终极的原则只有六个字\"高内聚、低耦合\"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- **开闭原则**：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- **依赖倒转原则**：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）**里氏替换原则**：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）**- 接口隔离原则**：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- **合成聚合复用原则**：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- **迪米特法则**：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。 \n\n### 如何通过反射获取和设置对象私有字段的值？\n\n 可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。\n\n下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, \"owner.car.engine.id\");可以获得dog对象的主人的汽车的引擎的ID号。 \n\n```java\nimport java.lang.reflect.Method;\nclass MethodInvokeTest {\n    public static void main(String[] args) throws Exception {\n        String str = \"hello\";\n    Method m = str.getClass().getMethod(\"toUpperCase\");\n        System.out.println(m.invoke(str));  // HELLO\n    }\n}\n```\n\n### 请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n\n 方法的重载和重写都是实现多态的方式，\n\n区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n\n重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 \n\n### 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？\n\n 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：\n\n(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；\n\n(2)如果两个对象的hashCode相同，它们并不一定相同。\n\n当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 \n\n### 请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？\n\n 一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性.内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。 \n\n### 请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？\n\n Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。\n\nJava的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。 \n\n###  请说明Java的接口和C++的虚类的相同和不同处\n\n 由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。\n与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。 \n\n### 当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?\n\n 是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 \n\n### 请你说说Static Nested Class 和 Inner Class的不同\n\n Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance).Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能Access Outer Class的动态成员(instance member).而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员, 这个概念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member),反过来就可以, 一个CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). \n\n### 请你讲讲abstract class和interface有什么区别?\n\n声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。\n\n接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。\n\n### 请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?\n\n 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 \n\n### 请说明一下final, finally, finalize的区别。\n\nfinal 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。\nfinally是异常处理语句结构的一部分，表示总是执行。\nfinalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源\n回收，例如关闭文件等。 \n\n### 面向对象的特征有哪些方面\n\n**抽象：**\n抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只\n是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。\n**继承：**\n继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派\n生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。\n**封装：**\n封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。\n**多态：**\n多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 \n\n### 请说明Comparable和Comparator接口的作用以及它们的区别。\n\n Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。\nJava提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 \n\n### 接口和抽象类的区别是什么？\n\n Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：\n接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。\n类可以实现很多个接口，但是只能继承一个抽象类\n类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。\n抽象类可以在不提供接口方法实现的情况下实现接口。\nJava接口中声明的变量默认都是final的。抽象类可以包含非final的变量。\nJava接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。\n接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。\n也可以参考JDK8中抽象类和接口的区别 \n\n### 请说明Java是否支持多继承？\n\n Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 \n\n### 如何通过反射创建对象？\n\n- 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()\n- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(\"Hello\"); \n\n### 是否可以在static环境中访问非static变量？\n\nstatic变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 \n\n### extends 和super 泛型限定符\n\n（1）泛型中上界和下界的定义\n\n上界<? extend Fruit>\n\n下界<? super Apple>\n\n（2）上界和下界的特点\n\n上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）\n\n下界的list只能add，不能get\n\n （3）示例代码 \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n  \nclass Fruit {}\nclass Apple extends Fruit {}\nclass Jonathan extends Apple {}\nclass Orange extends Fruit {}\n  \npublic class CovariantArrays {\n  public static void main(String[] args) {\n    //上界\n    List<? extends Fruit> flistTop = new ArrayList<Apple>();\n    flistTop.add(null);\n    //add Fruit对象会报错\n    //flist.add(new Fruit());\n    Fruit fruit1 = flistTop.get(0);\n  \n    //下界\n    List<? super Apple> flistBottem = new ArrayList<Apple>();\n    flistBottem.add(new Apple());\n    flistBottem.add(new Jonathan());\n    //get Apple对象会报错\n    //Apple apple = flistBottem.get(0);\n  }\n}\n```\n\n（4）上界<? extend Fruit> ，表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。\n\n下界<? super Apple>，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object 。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。\n\n所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。\n\n### 什么是泛型？\n\n 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 \n\n```java\npublic class GenericTest {\n  \n      public static void main(String[] args) {\n          /*\n          List list = new ArrayList();\n          list.add(\"qqyumidi\");\n          list.add(\"corn\");\n          list.add(100);\n          */\n  \n         List<String> list = new ArrayList<String>();\n         list.add(\"qqyumidi\");\n         list.add(\"corn\");\n         //list.add(100);   // 1  提示编译错误\n  \n         for (int i = 0; i < list.size(); i++) {\n             String name = list.get(i); // 2\n             System.out.println(\"name:\" + name);\n         }\n     }\n }\n```\n\n 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<String>，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 \n\n### 静态变量存在什么位置\n\n方法区\n\n### 解释类加载机制，双亲委派模型，好处是什么？\n\n某个特定的类加载器在接到加载类的请求时， 首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 \n\n 使用双亲委派模型的好处在于使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。 \n\n\n\n> 双亲委派机制的意义主要是保护一些基本类不受影响。\n> 比如常用的 String类， 其全限定名是 java.lang.String， 只是 java.lang 这个包下的类在使用的时候，可以不用 import 而直接使用。\n> 像这种基本类 按照双亲委派机制 都应该从 rt.jar 里去获取，而不应该从自定义加载器里去获取某个开发人员自己写的 java.lang.String, 毕竟开发人员自己写的 java.lang.String 可能有很多 bug, 通过这种方式，无论如何大家使用的都是 rt.jar 里的 java.lang.String 类了。 \n\n### 请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？\n\nStringBuffer线程安全，StringBuilder线程不安全，\n\n底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。\n\n### 请说明String是否能能继承？\n\n 不能，char数组用final修饰的。 \n\n### 说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？\n\n “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。\nJava中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 \n\n###  请说明重载和重写的区别，相同参数不同返回值能重载吗？\n\n**重载(Overloading)**\n\n（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。\n\n重载Overloading是一个类中多态性的一种表现。\n\n（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。\n\n调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。\n\n（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。\n\n**重写（Overriding）**\n\n（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。\n\n但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。\n\n方法重写又称方法覆盖。\n\n（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。\n\n如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。\n\n（3）子类函数的访问修饰权限不能少于父类的。\n\n### 请列举你所知道的Object类的方法并简要说明。\n\nObject()默认构造方法。\n\nclone() 创建并返回此对象的一个副本。\n\nequals(Object obj) 指示某个其他对象是否与此对象“相等”。\n\nfinalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\n\ngetClass()返回一个对象的运行时类。\n\nhashCode()返回该对象的哈希码值。 \n\nnotify()唤醒在此对象监视器上等待的单个线程。\n\nnotifyAll()唤醒在此对象监视器上等待的所有线程。\n\ntoString()返回该对象的字符串表示。\n\nwait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。\n\nwait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。\n\nwait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 \n\n### 类和对象的区别\n\n1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。\n\n比如：“人”是一个类，而“教师”则是“人”的一个实例。\n\n2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。\n\n### String为什么不可变？\n\n不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。\n\nString 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。\n\n### 请讲讲Java有哪些特性，并举一个和多态有关的例子。\n\n 封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） \n\n### 请你讲讲wait方法的底层原理\n\nObjectSynchronizer::wait方法通过object的对象中找到ObjectMonitor对象调用方法 void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)\n\n通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队列的末尾中然后在ObjectMonitor::exit释放锁，接着 thread_ParkEvent->park 也就是wait。\n\n## Array\n\n### List、Map、Set三个接口存取元素时，各有什么特点？\n\n List以特定索引来存取元素，可以有重复元素。\n\nSet不能存放重复元素（用对象的equals()方法来区分元素是否重复）。\n\nMap保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。\n\nSet和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 \n\n### 阐述ArrayList、Vector、LinkedList的存储性能和特性\n\n ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以**索引数据快而插入数据慢**，Vector中的方法由于**添加了synchronized修饰**，因此Vector是线程安全的容器，但性能上较ArrayList差，**因此已经是Java中的遗留容器**。\n\nLinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 \n\n### 判断List、Set、Map是否继承自Collection接口？\n\n List、Set 是，Map 不是。\n\nMap是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素\n\n（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 \n\n### 你所知道的常用集合类以及主要方法？\n\n最常用的集合类是List 和 Map。\n\nList 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。\n\nMap 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作\"键\"和\"值\"），其中每个键映射到一个值。\n\n### 说明Collection 和 Collections的区别\n\nCollection是集合类的上级接口，继承与他的接口主要有Set 和List.\nCollections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 \n\n### 说明ArrayList,Vector,LinkedList的存储性能和特性是什么？\n\n ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 \n\n### ArrayList和LinkedList的区别？(链表和数组的优缺点)\n\n ArrayList和LinkedList都实现了List接口，他们有以下的不同点：\nArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。\n相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。\nLinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 \n\n### 说明HashMap和Hashtable的区别？ \n\nHashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：\nHashMap允许键和值是null，而Hashtable不允许键或者值是null。\nHashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。\nHashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。\n一般认为Hashtable是一个遗留的类。 \n\n### 请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？\n\nIterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。\n\n### 说说Iterator和ListIterator的区别？\n\nIterator和ListIterator的区别是：\nIterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。\nIterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。\nListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 \n\n### 请简单说明一下什么是迭代器？\n\nIterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,\n每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.\n有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.\n\n![img](1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9.png) \n\n### 解释为什么集合类没有实现Cloneable和Serializable接口？\n\n克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。\n**实现Serializable序列化的作用**：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。\n实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。 \n\n### Java集合类框架的基本接口有哪些？\n\n集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。\nJava集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：\nCollection：代表一组对象，每一个对象都是它的子元素。\nSet：不包含重复元素的Collection。\nList：有顺序的collection，并且可以包含重复元素。\nMap：可以把键(key)映射到值(value)的对象，键不能重复。 \n\n### ConcurrentHashMap的原理？\n\n ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。\n\nHashEntry 用来封装映射表的键 / 值对；\n\nSegment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。\n\n一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。 \n\n```java\nstatic final class HashEntry<K,V> {\n       final K key;                       // 声明 key 为 final 型\n       final int hash;                   // 声明 hash 值为 final 型\n       volatile V value;                 // 声明 value 为 volatile 型\n       final HashEntry<K,V> next;      // 声明 next 为 final 型\n  \n       HashEntry(K key, int hash, HashEntry<K,V> next, V value) {\n           this.key = key;\n           this.hash = hash;\n           this.next = next;\n           this.value = value;\n       }\n}\n```\n\n在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图： \n\n 插入三个节点后桶的结构示意图： \n\n ![img](308572_1537878284540_B6C31D01D41C9E1714958F9C56D01D8F.png) \n\n 注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。 \n\nSegment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。 \n\n### 解释一下TreeMap?\n\nTreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。\nTreeMap的特性：\n根节点是黑色\n每个节点都只能是红色或者黑色\n每个叶节点（NIL节点，空节点）是黑色的。\n如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个红色的节点。\n从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 \n\n### 请说明ArrayList是否会越界？\n\nArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。 \n\n### 说明concurrenthashmap有什么优势以及1.7和1.8区别？\n\nConcurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；\n\n1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；\n\n### TreeMap的底层实现？\n\nTreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。\n\n红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：\n\n性质1：每个节点要么是红色，要么是黑色。\n\n性质2：根节点永远是黑色的。\n\n性质3：所有的叶节点都是空节点（即 null），并且是黑色的。\n\n性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）\n\n性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。\n\n### 说明ConcurrentHashMap锁加在了哪些地方？\n\n加在每个Segment 上面。\n\n### 解释HashMap的容量为什么是2的n次幂？\n\n负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。 \n\n### 请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？\n\nArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。\n\n### 如果hashMap的key是一个自定义的类，怎么办？\n\n使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。\n\n### 解释一下hashMap具体如何实现的？\n\n Hashmap基于数组实现的，通过对key的hashcode & 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode & （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。 \n\n## THREAD\n\n### 如何保证线程安全？\n\n通过合理的时间调度，避开共享资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证一个客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。 \n\n### 简要说明一下线程的基本状态以及状态之间的关系？\n\n其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。 \n\n### 解释一下什么是线程池（thread pool）？\n\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。\nJava 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\n\\- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\\- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n\\- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n\\- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\\- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 \n\n###  举例说明同步和异步\n\n如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 \n\n### 介绍一下线程同步和线程调度的相关方法。\n\n \\- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n\\- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；\n\\- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；\n\\- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。 \n\n### 请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？\n\n不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。\n\n### 请简述一下线程的sleep()方法和yield()方法有什么区别？\n\n①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；\n\nyield()方法只会给相同优先级或更高优先级的线程以运行的机会；\n\n② 线程执行sleep()方法后转入阻塞（blocked）状态，\n\n而执行yield()方法后转入就绪（ready）状态；\n\n### Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用，请说明原因？\n\n有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法，\n\n反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。\n\n调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 \n\n### 多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么?  \n\n多线程有两种实现方法，分别是继承Thread类与实现Runnable接口同步的实现方面有两种，分别是synchronized,wait与notify。\n\n### 说出你所知道的线程同步的方法\n\nwait():使一个线程处于等待状态，并且释放所持有的对象的lock。\nsleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。\nnotify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。\nAllnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 \n\n### 启动一个线程是用run()还是start()?\n\n启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。\n\n### 请使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。\n\n```java\npublic class ThreadTest1{\nprivate int j;\npublic static void main(String args[]){\nThreadTest1 tt=new ThreadTest1();\nInc inc=tt.new Inc();\nDec dec=tt.new Dec();\nfor(int i=0;i<2;i++){\nThread t=new Thread(inc);\nt.start();\nt=new Thread(dec);\nt.start();\n}\n}\nprivate synchronized void inc(){\nj++;\nSystem.out.println(Thread.currentThread().getName()+\"-inc:\"+j);\n}\nprivate synchronized void dec(){\nj--;\nSystem.out.println(Thread.currentThread().getName()+\"-dec:\"+j);\n}\nclass Inc implements Runnable{\npublic void run(){\nfor(int i=0;i<100;i++){\ninc();\n}\n}\n}\nclass Dec implements Runnable{\npublic void run(){\nfor(int i=0;i<100;i++){\ndec();\n}\n}\n}\n}\n```\n\n\n\n### 说明一下线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？\n\n如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。\n当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 \n\n### 明一下sleep() 和 wait() 有什么区别？\n\nsleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。\nwait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 \n\n### 请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？ \n\n监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。\n\n### 分析一下同步方法和同步代码块的区别是什么？\n\n同步方法默认用this或者当前类class对象作为锁；\n同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法。 \n\n### 请详细描述一下线程从创建到死亡的几种状态都有哪些？\n\n1. 新建( new )：新创建了一个线程对象。\n2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。\n3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。\n4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：\n      (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。\n      (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。\n      (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。\n5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 "},{"title":"C prime plus","url":"/2020/06/28/C-prime-plus/","content":"\n## 指针\n\n###### 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。\n\n<!--more-->\n\n取地址&\n\n取值*\n\n```C\n#include <stdio.h>\nint main()\n{\n    int a;\n    char b[10];\n    printf(\"a变量的内存地址：%p\\n\", &a);\n    printf(\"b变量的内存地址：%p\\n\", &b);\n    return 0;\n}\n```\n\n访问数组b的地址其实就是数组第一个变量的数组\n\n **指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： \n\n```c\ntype *var-name;\n```\n\n 在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： \n\n```c\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;     /* 一个字符型的指针 */\n```\n\n 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。 \n\n#### 指针的使用\n\n 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： \n\n```c\n#include <stdio.h>\n \nint main ()\n{\n   int  var = 20;   /* 实际变量的声明 */\n   int  *ip;        /* 指针变量的声明 */\n \n   ip = &var;  /* 在指针变量中存储 var 的地址 */\n \n   printf(\"Address of var variable: %p\\n\", &var  );\n \n   /* 在指针变量中存储的地址 */\n   printf(\"Address stored in ip variable: %p\\n\", ip );\n \n   /* 使用指针访问值 */\n   printf(\"Value of *ip variable: %d\\n\", *ip ); //20\n \n   return 0;\n}\n```\n\n#### C 中的 NULL 指针\n\n在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。\n\nNULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：\n\n```c\n#include <stdio.h>\n \nint main ()\n{\n   int  *ptr = NULL;\n \n   printf(\"ptr 的地址是 %p\\n\", ptr  );\n \n   return 0;\n}\n```\n\n在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。\n\n如需检查一个空指针，您可以使用 if 语句，如下所示：\n\n```c\nif(ptr)     /* 如果 p 非空，则完成 */\nif(!ptr)    /* 如果 p 为空，则完成 */\n```\n\n#### 指针的算数运算\n\nC 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。\n\n假设 **ptr** 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：\n\n```c\nptr++\n```\n\n在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。\n\n我们概括一下：\n\n- 指针的每一次递增，它其实会指向下一个元素的存储单元。\n- 指针的每一次递减，它都会指向前一个元素的存储单元。\n- **指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度**，比如 int 就是 4 个字节。\n\n##### 递增一个指针\n\n我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：\n\n```c\n#include <stdio.h>\n \nconst int MAX = 3;\n \nint main ()\n{\n   int  var[] = {10, 100, 200};\n   int  i, *ptr;\n \n   /* 指针中的数组地址 */\n   ptr = var;\n   for ( i = 0; i < MAX; i++)\n   {\n \n      printf(\"存储地址：var[%d] = %x\\n\", i, ptr );\n      printf(\"存储值：var[%d] = %d\\n\", i, *ptr );\n \n      /* 移动到下一个位置 */\n      ptr++;\n   }\n   return 0;\n}\n----\n存储地址：var[0] = bf882b30\n存储值：var[0] = 10\n存储地址：of var[1] = bf882b34\n存储值： var[1] = 100\n存储地址：of var[2] = bf882b38\n存储值：var[2] = 200\n```\n\n##### 指针的比较\n\n指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。\n\n下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]，则把变量指针进行递增：\n\n```c\n#include <stdio.h>\n \nconst int MAX = 3;\n \nint main ()\n{\n   int  var[] = {10, 100, 200};\n   int  i, *ptr;\n \n   /* 指针中第一个元素的地址 */\n   ptr = var;\n   i = 0;\n   while ( ptr <= &var[MAX - 1] )\n   {\n \n      printf(\"Address of var[%d] = %p\\n\", i, ptr );\n      printf(\"Value of var[%d] = %d\\n\", i, *ptr );\n \n      /* 指向上一个位置 */\n      ptr++;\n      i++;\n   }\n   return 0;\n}\n----------------\nAddress of var[0] = bfdbcb20\nValue of var[0] = 10\nAddress of var[1] = bfdbcb24\nValue of var[1] = 100\nAddress of var[2] = bfdbcb28\nValue of var[2] = 200\n```\n\n#### 指针数组\n\n一个指向整数的指针数组的声明：\n\n```c\nint *ptr[MAX];\n```\n\n 在这里，把 **ptr** 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示： \n\n```c\n#include <stdio.h>\n \nconst int MAX = 3;\n \nint main ()\n{\n   int  var[] = {10, 100, 200};\n   int i, *ptr[MAX];\n \n   for ( i = 0; i < MAX; i++)\n   {\n      ptr[i] = &var[i]; /* 赋值为整数的地址 */\n   }\n   for ( i = 0; i < MAX; i++)\n   {\n      printf(\"Value of var[%d] = %d\\n\", i, *ptr[i] );\n   }\n   return 0;\n}\n------\nValue of var[0] = 10\nValue of var[1] = 100\nValue of var[2] = 200\n```\n\n 您也可以用一个指向字符的指针数组来存储一个字符串列表，如下： \n\n```c\n#include <stdio.h>\n \nconst int MAX = 4;\n \nint main ()\n{\n   const char *names[] = {\n                   \"Zara Ali\",\n                   \"Hina Ali\",\n                   \"Nuha Ali\",\n                   \"Sara Ali\",\n   };\n   int i = 0;\n \n   for ( i = 0; i < MAX; i++)\n   {\n      printf(\"Value of names[%d] = %s\\n\", i, names[i] );\n   }\n   return 0;\n}\n------\nValue of names[0] = Zara Ali\nValue of names[1] = Hina Ali\nValue of names[2] = Nuha Ali\nValue of names[3] = Sara Ali\n```\n\n#### 指向指针的指针\n\n 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 \n\n```\n              Pointer               Pointer \t\t\t\tVariable\n           _____________          _____________           _____________\n          |  Address    | ------>|  Address    |-------->|    Value    |\n          |_____________|        |_____________|         |_____________|\n```\n\n一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：\n\n```c\nint **var;\n```\n\n 当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示： \n\n```c\n#include <stdio.h>\n \nint main ()\n{\n   int  var;\n   int  *ptr;\n   int  **pptr;\n\n   var = 3000;\n\n   /* 获取 var 的地址 */\n   ptr = &var;\n\n   /* 使用运算符 & 获取 ptr 的地址 */\n   pptr = &ptr;\n\n   /* 使用 pptr 获取值 */\n   printf(\"Value of var = %d\\n\", var );\n   printf(\"Value available at *ptr = %d\\n\", *ptr );\n   printf(\"Value available at **pptr = %d\\n\", **pptr);\n\n   return 0;\n}\n-------------------\nValue of var = 3000\nValue available at *ptr = 3000\nValue available at **pptr = 3000\n```\n\n#### 指针数组和数组指针\n\n```c\nint *p1[5] ----------指针数组\nint (*p2)[5]---------数组指针\n```\n\n**指针数组**是一个数组，每个数组元素存放一个指针变量。\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    //指针数组，里面存的是指针\n    char *p1[5] = {\"wo\",\n                   \"jiao\",\n                   \"Kayleh\",\n                   \"!\"};\n    int i;\n    for (i = 0; i < 5; i++)\n    {\n        /* code */\n        // %s会取地址对应的值，char形是特列,通过字符串首地址输出字符串\n        printf(\"%s\\n\", p1[i]);\n    }\n}\n```\n\n**数组指针**是一个指针，它指向的是一个数组\n\n```c\n#include <stdio.h>\nint main()\n{\n    int temp[5] = {1, 2, 3, 4, 5};\n    //&temp表示取出整个数组的地址\n    //temp表示数组的第一个元素的地址\n    int(*p2)[5] = &temp;\n    int i;\n    for (i = 0; i < 5; i++)\n    {\n        /* code */\n        //内部的*取得是数组的，外部的取得是数组元素的\n        printf(\"%d\\n\", *(*p2 + i));\n    }\n    return 0;\n}\n```\n\n#### 二维数组\n\n数组名实际上是第一组一维数组的指针。\n\n```c\narray[4][5]\n*(array+1) = array[1] = &array[1][0]\n\n*(array+1)+3 == &array[1][3]\n```\n\n结论\n\n```c\n*(array+i) == array[i]\n*(*(array+i)+j) == &array[i][j]\n*(*(*(array+i)+j)+k) == &array[i][j][k]\n```\n\n初始化二维数组\n\n```\nint array[][3];//前面的可不写\n```\n\n**数组指针和二维数组**\n\n#### void指针\n\n> void指针称为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int num = 1024;\n    int *pi = &num;\n    char *pc = \"Kayleh\";\n    void *pv;\n\n    pv = pi;\n    printf(\"pi:%p,pv:%p\\n\", pi, pv);\n    printf(\"pv:%d\\n\", *(int *)pv); //强制转换\n\n    pv = pc;\n    printf(\"pc:%p,pv:%p\\n\", pc, pv);\n    //因为字符数组中每一个元素都相当于一个指针变量，就不需要在加*了，不用解引用\n    printf(\"pv:%s\\n\", pv);\n\n    return 0;\n}\n```\n\n\n\n#### NULL指针\n\n```c\n#define NULL ((void *)0)\n```\n\n```c\n#include <stdio.h>\nint main()\n{\n    int *p1;\n    int *p2 = NULL;\n\n    printf(\"%d\\n\", *p1);\n    printf(\"%d\\n\", *p2);\n    return 0;\n}\n```\n\n\n\n## 函数\n\n定义\n\n```c\nreturn_type function_name( parameter list )\n{\n   body of the function\n}\n```\n\n- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。\n- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数主体：**函数主体包含一组定义函数执行任务的语句。\n\n## 函数指针\n\n函数指针是指向函数的指针变量。\n\n通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。\n\n函数指针可以像一般函数一样，用于调用函数、传递参数。\n\n函数指针变量的声明：\n\n```c\ntypedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型\n```\n\n```c\n#include <stdio.h>\n \nint max(int x, int y)\n{\n    return x > y ? x : y;\n}\n \nint main(void)\n{\n    /* p 是函数指针 */\n    int (* p)(int, int) = & max; // &可以省略\n    int a, b, c, d;\n \n    printf(\"请输入三个数字:\");\n    scanf(\"%d %d %d\", & a, & b, & c);\n \n    /* 与直接调用函数等价，d = max(max(a, b), c) */\n    d = p(p(a, b), c); \n \n    printf(\"最大的数字是: %d\\n\", d);\n \n    return 0;\n}\n------------------\n请输入三个数字:1 2 3\n最大的数字是: 3\n```\n\n### 回调函数\n\n#### 函数指针作为某个函数的参数\n\n函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。\n\n简单讲：回调函数是由别人的函数执行时调用你实现的函数。\n\n> 以下是来自知乎作者常溪玲的解说：\n>\n> 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。\n\n#### 实例\n\n实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。\n\n实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。\n\npopulate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。\n\n```c\n#include <stdlib.h>  \n#include <stdio.h>\n \n// 回调函数\nvoid populate_array(int *array, size_t arraySize, int (*getNextValue)(void))\n{\n    for (size_t i=0; i<arraySize; i++)\n        array[i] = getNextValue();\n}\n \n// 获取随机值\nint getNextRandomValue(void)\n{\n    return rand();\n}\n \nint main(void)\n{\n    int myarray[10];\n    populate_array(myarray, 10, getNextRandomValue);\n    for(int i = 0; i < 10; i++) {\n        printf(\"%d \", myarray[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n--------------------\n16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 \n```\n\n### C 传递指针给函数\n\nC 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。\n\n下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：\n\n```c\n#include <stdio.h>\n#include <time.h>\n \nvoid getSeconds(unsigned long *par);\n\nint main ()\n{\n   unsigned long sec;\n\n\n   getSeconds( &sec );\n\n   /* 输出实际值 */\n   printf(\"Number of seconds: %ld\\n\", sec );\n\n   return 0;\n}\n\nvoid getSeconds(unsigned long *par)\n{\n   /* 获取当前的秒数 */\n   *par = time( NULL );\n   return;\n}\n------------------\nNumber of seconds :1294450468\n```\n\n 能接受指针作为参数的函数，也能接受数组作为参数，如下所示： \n\n```c\n#include <stdio.h>\n \n/* 函数声明 */\ndouble getAverage(int *arr, int size);\n \nint main ()\n{\n   /* 带有 5 个元素的整型数组  */\n   int balance[5] = {1000, 2, 3, 17, 50};\n   double avg;\n \n   /* 传递一个指向数组的指针作为参数 */\n   avg = getAverage( balance, 5 ) ;\n \n   /* 输出返回值  */\n   printf(\"Average value is: %f\\n\", avg );\n   \n   return 0;\n}\n\ndouble getAverage(int *arr, int size)\n{\n  int    i, sum = 0;      \n  double avg;          \n \n  for (i = 0; i < size; ++i)\n  {\n    sum += arr[i];\n  }\n \n  avg = (double)sum / size;\n \n  return avg;\n}\n------------------\nAverage value is: 214.40000\n```\n\n### C 从函数返回指针\n\n C 允许您从函数返回指针。为了做到这点，您必须声明一个返回指针的函数，如下所示： \n\n```c\nint * myFunction()\n{\n.\n.\n.\n}\n```\n\nC 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 **static** 变量。\n\n现在，让我们来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：\n\n```c\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> \n \n/* 要生成和返回随机数的函数 */\nint * getRandom( )\n{\n   static int  r[10];\n   int i;\n \n   /* 设置种子 */\n   srand( (unsigned)time( NULL ) );\n   for ( i = 0; i < 10; ++i)\n   {\n      r[i] = rand();\n      printf(\"%d\\n\", r[i] );\n   }\n \n   return r;\n}\n \n/* 要调用上面定义函数的主函数 */\nint main ()\n{\n   /* 一个指向整数的指针 */\n   int *p;\n   int i;\n \n   p = getRandom();\n   for ( i = 0; i < 10; i++ )\n   {\n       printf(\"*(p + [%d]) : %d\\n\", i, *(p + i) );\n   }\n \n   return 0;\n}\n-----------------------\n1523198053\n1187214107\n1108300978\n430494959\n1421301276\n930971084\n123250484\n106932140\n1604461820\n149169022\n*(p + [0]) : 1523198053\n*(p + [1]) : 1187214107\n*(p + [2]) : 1108300978\n*(p + [3]) : 430494959\n*(p + [4]) : 1421301276\n*(p + [5]) : 930971084\n*(p + [6]) : 123250484\n*(p + [7]) : 106932140\n*(p + [8]) : 1604461820\n*(p + [9]) : 149169022\n```\n\n字符串\n\nC 中有大量操作字符串的函数：\n\n| 函数                | 目的                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| **strcpy(s1, s2);** | 复制字符串 s2 到字符串 s1。                                  |\n| **strcat(s1, s2);** | 连接字符串 s2 到字符串 s1 的末尾。                           |\n| **strlen(s1);**     | 返回字符串 s1 的长度。                                       |\n| **strcmp(s1, s2);** | 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| **strchr(s1, ch);** | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。   |\n| **strstr(s1, s2);** | 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n## C 结构体\n\nC 数组允许定义可存储相同类型数据项的变量，**结构**是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。\n\n结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：\n\n- Title\n- Author\n- Subject\n- Book ID\n\n#### 定义结构\n\n为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：\n\n```c\nstruct tag { \n    member-list\n    member-list \n    member-list  \n    ...\n} variable-list ;\n```\n\n**tag** 是结构体标签。\n\n**member-list** 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。\n\n**variable-list** 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：\n\n```c\nstruct Books\n{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;\n} book\n```\n\n 在一般情况下，**tag、member-list、variable-list** 这 3 部分至少要出现 2 个。\n\n 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。 \n\n```c\n//此结构体的声明包含了其他的结构体\nstruct COMPLEX\n{\n    char string[100];\n    struct SIMPLE a;\n};\n \n//此结构体的声明包含了指向自己类型的指针\nstruct NODE\n{\n    char string[100];\n    struct NODE *next_node;\n};\n```\n\n","tags":["C"]},{"title":"Redis","url":"/2020/06/27/Redis/","content":"\n# Redis\n\n<!--more-->\n\n### 在Linux下安装\n\n https://redis.io/ 官网下载，移动到`/opt` 目录下. 在终端使用命令解压\n\n```shell\n$ tar -zxvf redis-XXXXXX.tar.gz\n```\n\n进入解压后的目录,运行make指令(需要GCC编译器)\n\n```\n$ cd redis.XXX\n$ make\n$ make install\n```\n\n进入默认安装的目录\n\n```\n$ cd usr/local/bin\n```\n\n在根目录创建一个文件夹/myredis，把安装目录下的redis.conf复制到/myredis，复制的目的是不影响出厂的设置\n\n```\ncp redis.conf /myredis\n```\n\n要把myredis的权限修改,否则会出现redis无法SHUTDOWN的问题\n\n```\nsudo chmod 777 /myredis\n```\n\n修改复制过来的conf\n\n```\nvim redis.conf\n```\n\n修改为为yes\n\n```\n原来的：\n##########GENERAL###################\nXXX\ndaemonzie no\n\n修改为:\ndaemonize yes\n```\n\n检查有没有启动Redis\n\n```\n$ ps -ef|gref redis\n```\n\n检查端口是否启动\n\n```\nlsof -i :6379\n```\n\n结果是没有启动的\n\n##### 启动方法：\n\n在/usr/local/bin下：\n\n```\n$ redis-server /myredis/redis.conf\n```\n\n默认端口是6379\n\n```\n$ redis-cli -p 6379\n```\n\n检查是否连接成功\n\n```\n127.0.0.1:6379> ping\n```\n\n```\nPONG\n```\n\n返回PONG表示成功\n\n退出：\n\n```\n127.0.0.1:6379> SHUTDOWN\nexit\n```\n\n### KEY关键字\n\n```\nDBSIZE //当前数据库的key的数量\nselect db //切换数据库\nFlushdb  //清空当前库\nFlushall //清空所有库\nkey * 当前库所有的key\nexists key //判断key是否存在，有返回1，无则0\nmove key db //移动到目标库，当前库的移除\nexpire key 秒钟 //给key设置过期时间，过期后查询到的是nid空值\nttl key //查看还有多久过期，-1表示永不过期，-2表示已过期\ntype key //查看key是什么类型\n```\n\n### redis五种数据结构\n\n##### String：字符串\n\n```\nset key value\nget key\ndel key\nappend key value //在value后追加\nstrlen //String长度\nINCR/DECR KEY//一定要是数字，自增自减\nINCRBY/DECRBY KEY 步长  //多步递增递减\ngetrange/setrange key index index  //根据索引取值设置值\nsetex key 秒钟 value   //设置值的时候设置过期时间\nsetnx  //set if not exist\nmset key1 value1 key2 value2 // 设置多个值\nmget/msetnx\n\n```\n\n##### List：列表\n\n```\nLPUSH list1 1 2 3 4 5 (类似栈)\nLRANGE list1 0 -1\n5\n4\n3\n2\n1\nlpop list1\n\"5\"\nrpop list1\n\"1\"\n```\n\n```\nRPUSH list2 1 2 3 4 5\nLRANGE list2 0 -1\n1\n2\n3\n4\n5\nlpop list2\n\"1\"\nrpop list2\n\"5\"\n```\n\n```\nlindex //按照索引下标获得元素，（从上到下）\nllen  //长度\nLREM KEY N Value  //删除key数组中的N个Value\nLTRIM KEY 开始index 结束index //截取指定范围的值后在赋值给key\nrpoplpush 源列表 目的列表  //把源列表的最底的值移动到目的列表的最上面\nlset key index value //根据数组下标设置成value\nlinsert key before/after 值1 值2  //把值2的值插入到key数组值1的前面/后面\n```\n\n##### Set：集合\n\n```\nsadd  key value1，value1，value2  //只会进去不重复的值 \nsmembers key value 0 -1 //打印全部\nsismember key value //判断value是否在key里\nscard  //获取集合里面的元素\nsrem key value //删除集合中元素\nsrandmember key //随机出几个数\nspop key //随机出栈\nsmove key1 key2 在key1里某个值  //将key1里的某个值赋给key2\nsdiff set1 set2  //差集，set1里有的，set2没有的\nsinter set1 set2 //交集，都有的\nsunion set1 set2 //并集\n```\n\n##### Hash ：哈希\n\n```\nvalue是一个键值对\nhset key <key1,value1>\nhget key key1\nhmset KEY1 keyA valueA KEY2 keyB valueB\nhmgetall  \nhdel KEY1 keyA\nHEXISTS KEY1 keyA //判断是否存在\nhkeys/kvals KEY1\nhincrby/hincrbyfloat KEY1  keyA  步长/浮点数    //自增自减\nhsetnx\n```\n\n##### Zset（sorted set）：有序集合\n\n在set基础上，加一个score值\n\nset是 k1 v1 v2 v3 \n\nzset是 k1  score1  v1  score2  v2\n\n```\nzadd  key  k1  score1  v1  score2  v2\nzrange key 0 -1  //只会打印value\nzrange key 0 -1 withscores  //会打印v1，score，v2，score\nzrangebyscore key 开始score 结束score //  \"（\" 表示不包含， a（ b  表示大于等于a，小于b \nzrangebyscore key 开始score 结束score withscore\nzrangebyscore key 开始score 结束score limit 开始下标步 多少步  \nzrem key score对应的value  //删除元素\nzacard  key  //统计key里value的个数\nzcount key score区间\nzrank key value  //获取下标\nzrevrank  key value //获取反转后的下标\nzrevrange key 0 -1//反转集合\nzrevrangebyscore key 结束score 开始score   //反转集合，index也要反转\n\n```\n\n### 配置文件\n\n#### Units\n\n1.配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit\n\n2.对大小写不敏感\n\n![1593308699248](1.png)\n\n#### INCLUDES\n\n可以通过includes包含，redis.conf可以作为总闸,包含其他\n\n![1593308936736](2.png)\n\n#### GENERAL\n\ndaemonize 默认为no\n\npidfile 进程管道id文件\n\nport 默认端口\n\ntcp-backlog,backlog  511是一个连接队列,在高并发环境下你需要一个高backlog值来避免慢客户端连接问题\n\nbind 端口及网卡的绑定\n\ntimeout 0 当系统空闲一段时间后中断\n\nTcp-keepalive 单位为秒,设置为0则不会进行Keepalive检测\n\nloglevel notice 日志级别\n\nlogfile 日志文件\n\nsyslog-enabled 是否把日志输出到syslog中\n\nsyslog-ident 指定syslog里的日志标志\n\nsyslog-facility 指定syslog设备,值可以是USER或LOCAL0-LOCAL7\n\ndatabases 默认有16个库\n\n![1593309132453](3.png)\n\n#### SECURITY\n\n```\nconfig get requirepass\nconfig set requirepass \"123456\"   //立即生效\n访问任何命令前使用 auth 123456\n```\n\n#### LIMIT\n\nmaxclients 10000   允许10000人连接\n\nmaxmemory <bytes>\n\nmaxmemory-policy  noexiction  缓存过期清洁策略 ,默认永不过期\n\n- volatile-lru:使用LRU算法移除key,只对设置了过期时间的键\n- allkeys-lru:使用LRU算法移除key\n- volatile-random:在过期集合中移除随机的key,只对设置了过期时间的键\n- allkeys-random:移除随机的key\n- volatile-ttl:移除那些TTL值最小的key,即那些最近要过期的key\n- noexiction :不进行移除.针对写操作,只是返回错误信息\n\nLRU算法:最近最少使用的\n\nMaxmemory-samples  设置样本数量,LRU算法和最小TTL算法都并非是精确的算法,而是估算值,所以你可以设置样本的大小,redis默认会检查这么多个key并选择其中LRU的那个;\n\n#### 常用配置\n\n- redis默认不是以守护进程的方式运行,可以通过该配置项修改,使用yes启动守护进程\n\n  ```\n  daemonize no\n  ```\n\n- 当Redis以守护进程方式运行时,Redis默认会把pid写入/var/run/redis.pid文件,可以通过pidfile指定\n```\npid /var/run/redis.pid\n```\n- 指定redis监听端口,默认端口为6379\n```\nport 6379\n```\n- 绑定的主机地址\n```\nblind 127.0.0.1\n```\n- 当客户端闲置多长时间后关闭连接,如果指定为0,表示关闭该功能\n```\ntimeout 300\n```\n- 指定日志记录级别,Redis总共支持四个级别,debug、verbose、notice、warning，默认为verbose\n```\nloglevel verbose\n```\n- 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n```\nlogfile stdout\n```\n\n- 设置数据库的数量，默认数据库为0，可以使用<dbid>命令在连接上指定数据库id\n\n```\ndatabases 16\n```\n\n- 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\n```\nsave <seconds> <changes>\nRedis默认配置文件中提供了三个条件:\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n- 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n\n```\nrdbcompression yes\n```\n\n- 指定本地数据库文件名，默认为dump.rdb\n\n```\ndbfilename dump.rdb\n```\n\n- 指定本地数据库存放目录\n\n```\ndir ./\n```\n\n- 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n\n```\nslaveof <masterip> <masterport>\n```\n\n- 当master服务先设置了密码保护，slav服务连接master的密码\n\n```\nmasterauth <master-password>\n```\n\n- 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n\n```\nrequirepass foobared\n```\n\n- 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max numbers of clients reached 错误信息\n\n```\nmaxclients 128\n```\n\n- 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把key存放内存，value会存放在swap区。\n\n```\nmaxmemory <bytes>\n```\n\n- 指定是否在每次更新操作后进行日志记录。Redis在默认情况下时异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件时按save条件来同步的，所以有的数据会在一段时间内只存在内存中。默认为no\n\n```\nappendonly no\n```\n\n- 指定更新日志文件名，默认为appendonly.aof\n\n```\nappendfilename appendonly.aof\n```\n\n- 指定更新日志条件，共有3个可选值：\n\n```\nappendfsync everysec\nno: 表示等操作系统进行数据缓存同步到磁盘（快）\nalways：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）\neverysec：表示每秒同步一次（折中，默认值）\n```\n\n- 指定是否启用虚拟内存机制，默认为no。VM机制将数据分页存放，有Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘换出到内存中\n\n```\nvm-enabled no\n```\n\n- 虚拟内存文件路径,默认值为/tmp/redis.swap\n\n```\nvm-swap-file /tmp/redis.swap\n```\n\n- 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(Redis的索引数据 就是keys)，也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认为0\n\n```\nvm-max-memory 0\n```\n\n- Redis swap文件分成了很多page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes;如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值\n\n```\nvm-page-size 32\n```\n\n- 设置swap文件中的page数量，由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的，在磁盘上每8个page将消耗1bytes的内存\n\n```\nvm-pages 134217728\n```\n\n- 设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n\n```\nvm-max-threads 4\n```\n\n- 设置在向客户端应答时，是否把较小的包含并为一个包发送，默认为开启\n\n```\nglueoutputbuf yes\n```\n\n- 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n```\nhash-max-zipmap-entries 64\nhash-max-zipmap-value 512\n```\n\n- 指定是否激活重置哈希，默认为开启\n\n```\nactiverehashing yes\n```\n\n- 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n\n```\ninclue /path/to.local,conf\n```\n\n## Redis持久化RDB\n\n>在指定的时间间隔内将内存中的数据集快照写入磁盘，即Snapshot快照，它恢复时是将快照文件直接读到内存里\n\n#### 是什么？\n\nRedis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件，替换上次持久化好的文件。\n\n整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。\n\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方法要比AOF方式更加的高效。\n\nRDB的缺点是最后一次持久化后的数据可能丢失。\n\n#### Fork\n\n> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）\n>\n> 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\n\n\nRDB保存的是dump.rdb文件,\n\n先拷贝一份rdb，删除原rdb，再重命名为dump.rdb，即可恢复\n\n#### 配置文件的位置\n\n##########SNAPSHOT###########\n\nsave 秒钟 写操作次数\n\n禁用 save “”\n\n\n\n指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n\nrdbcompression yes\n\n\n\nstop-writes-on-bgsave-error   yes\n\n如果后台在save操作出现错误的时候，停止写入\n\n如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制\n\n\n\nrgbchecksum  yes    ##是否校验rdb文件\n\n在存储快照后，还可以让Redis使用CRC算法来进行数据校验，但是这样做会增加大约10%的性能消耗，\n\n如果希望获取到最大的性能提升，可以关闭此功能。\n\n\n\n**触发RDB快照**\n\n命令\n\n`save` 手动保存 `save`只管保存，其他不管，全部阻塞\n\n`bgsave` Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求，可以通过lastsave命令获得最后一次成功执行快照的时间\n\n\n\n执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。\n\nconfig get dir获取目录\n\n停止\n\n动态所有停止RDB保存规则的方法：redis-cli config set save “”\n\n### 优势\n\n1.适合大规模的数据恢复\n\n2.对数据完整性和一致性要求不高\n\n### 劣势\n\n1.在一定间隔时间做一次备份，所有如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n\n2.fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n\n#### 总结\n\n```\n\n\n内存中的      rdbSave     磁盘中的\n数据对象   ----------》    RDB文件\n            rdbload                \n\n\n```\n\n- RDB是一个非常紧凑的文件\n\n- RDB在保存文件时父进程唯一要做的就是fork出一个子进程来做，接下来的工作全部由子进程来做，\n\n  父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能\n\n- 与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。\n\n\n\n- 数据丢失风险大\n- RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能响应客户端的请求。\n\n## Redis持久化之AOF\n\n> 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n\nAOF保存的是appendonly.aof文件\n\n###########appendonly##########\n\n恢复：删除dump.rdb，vim  appendonly.aof，删除末尾行的FLUSHALL，再次连接数据库即可访问。\n\n两者可以共存，优先找aof，如果aof有修改为不能识别的字符，开启redis时会被拒绝。\n\n这时，当前文件夹下有一个redis-check-aof，使用命令：\n\n```\nredis-check-aof --fix appendonly.aof\ncontinue?[y/N]:y\n```\n\n命令会删除不符合语法规范的字段。\n\n### rewrite\n\nAOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用bgrewriteaof\n\n重写原理：\n\nAOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set 语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。\n\n触发机制：\n\nRedis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。\n\nauto-aof-rewrite-percentage 100  一倍\n\nauto-aof-rewrite-min-size 64mb\n\n#### 优势\n\n每秒同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整比较好\n\n每修改同步：appendfsync  everysec  异步操作，每秒记录  如果一秒内宕机，有数据丢失。\n\n不同步：appendfsync  no 从不同步\n\n#### 劣势\n\n相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢与rdb\n\naof运行效率要慢与rdb，每秒同步策略较好，不同步效率和rdb相同\n\n```\n                              AOF                   网络协议格式\n  _________________   命令请求     ________________   的命令内容   ____________________\n |      客户端      | __________> |     服务器      | __________>|       AOF文件      |\n |_________________|             |________________|            |___________________|\n```\n\n- aof文件时一个只进行追加的日志文件\n- Redis可以在AoF文件体积变得过大时，自动地在后台对AOF进行重写\n\n\n\n- 对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积\n- 根据所使用的fsync策略，AOF的速度可能会慢于RDB\n\n#### 总结\n\n- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储\n\n- AOP持久化方式记录每次对服务器写的操作，当服务器重启的时候回重新执行这些命令来回复原始的数据，AOP命令以redis协议追加保存每次写的操作到文件末尾.\n\n- Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大\n\n- 只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式.\n\n- 同时开启两种持久化方式.在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. \n\n- RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件, 建议不要只使用AOF,因为RDB更适合于备份数据库(AOF在不断变化不好备份),\n\n  快速重启,而且不会有AOF可能存在的bug,留着作为一个万一的手段.\n\n## 事务\n\n> 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞\n\n#### 能做什么？\n\n一个队列中，一次性的、顺序性、排他性的执行一系列命令\n\n#### 常用命令\n\n| **DISCARD**              | **取消事务，放弃执行事务块内的所有命令。**                   |\n| ------------------------ | ------------------------------------------------------------ |\n| **EXEC**                 | **执行所有事务块内的命令。**                                 |\n| **MULTI**                | **标记一个事务块的开始。**                                   |\n| **UNWATCH**              | **取消 WATCH 命令对所有 key 的监视。**                       |\n| **WATCH key [key ...\\]** | **监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。** |\n\n##### 正常执行\n\nMULTI 相当与 一个新的购物车，每输入一条命令返回QUEUED相当于加入购物车，EXEC执行命令相当于结账。\n\n##### 放弃事务\n\n在事务没有EXEC之前调用DISCARD\n\n##### 全体连坐\n\n如果有一个指令不能正常运行（编译出错），事务EXEC会报错\n\n##### 冤头债主\n\n**运行时出错的命令**不会执行，而其他命令仍然会放行。\n\n> Redis是否支持事务？ 是部分支持。\n\n##### watch监控\n\n- 悲观锁(Pessimistic Lock)\n\n  > 我对这个事情的发展很悲观，每次去拿数据的时候都认为别人会修改，为了避免出事，把整张表锁了，\n  >\n  > 表锁，并发性最差，一致性最好。\n\n- **乐观锁(Optimistic Lock)**\n\n  > 我认为这个事没有人会去干，不会上锁，乐观锁在每条记录的后面加一个version版本号字段。\n  >\n  > 乐观锁策略：提交版本必须大于记录当前版本才能执行。\n\n在调用MULTI之前，先调用  WATCH  + KEY\n\n**UNWATCH取消所有key的监控**\n\n有加塞篡改，监控了key，key被修改了，事务将被打断，调用UNWATCH再执行一次\n\n#### 阶段\n\n开启：以MULTI开始一个事务\n\n入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面。\n\n执行：由EXEC命令触发事务\n\n#### 总结\n\nwatch指令，类似乐观锁，事务提交时，如果key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会执行。\n\n通过watch命令在事务执行之前监控了多个keys，倘若在watch之后有任何key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。\n\n#### 特性：\n\n单独的隔离操作：事务中的所有命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的请求所打断。\n\n没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个问题。\n\n不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。\n\n## 消息订阅发布\n\n是什么？\n\n> 进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息\n\n下图展示了频道channel1，以及订阅这个频道的三个客户端---client2和client5、client1之间的关系\n\n ![img](pubsub1.png) \n\n当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会发送给订阅它的三个客户端\n\n ![img](pubsub2.png) \n\n\n\n下表列出了 redis 发布订阅常用命令：\n\n| **命令**                                         | **描述**                               |\n| :----------------------------------------------- | :------------------------------------- |\n| **PSUBSCRIBE pattern [pattern ...\\]**            | **订阅一个或多个符合给定模式的频道。** |\n| **PUBSUB subcommand [argument [argument ...\\]]** | **查看订阅与发布系统状态。**           |\n| **PUBLISH channel message**                      | **将信息发送到指定的频道。**           |\n| **PUNSUBSCRIBE [pattern [pattern ...\\]]**        | **退订所有给定模式的频道。**           |\n| **SUBSCRIBE channel[channel ...\\]**              | **订阅给定的一个或多个频道的信息。**   |\n| **UNSUBSCRIBE[channel [channel ...\\]]**          | **指退订给定的频道。**                 |\n\nSUBSCRIBE   c1 c2 \n\nPULISH c1 message\n\nPSUBSCRIBE  new*  \n\nPULISH  new4  message\n\n## 主从复制\n\n> 主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，Master以写为主，Slave以读为主。\n\n##### 在/myredis下：\n\n```\ncp redis.conf  redis6379.conf\ncp redis.conf  redis6380.conf\ncp redis.conf  redis6381.conf\n```\n\n修改配置文件\n\n```\nvim redis6379.conf\npidfile  /var/run/redis.pid  ->  /var/run/redis6379.pid\nport 6379\nlogfile \"\"  ->   logfile \"6379.log\"\n备份\ndbfilename  dump.rdb   ->    dump6379.rdb\n\n6380,6381 以此为例\n```\n\n分别启动\n\n```\nredis-server /myredis/redis6379.conf\nredis-cli -p 6379\n```\n\n检查是否启动\n\n```\nps -ef|gref redis\n```\n\n使用命令 info replication查看信息,他们的角色都是master\n\n```\nrole:master\n```\n\n在主机（6379）下往数据库设值\n\n```\nset k1 v1\nset k2 v2\nset k3 v3\n```\n\n在从机（6380,6381）分别使用SLAVEOF命令\n\n```\nSLAVEOF 127.0.0.1  6379\n```\n\n这时再往主机6379设值\n\n```\nset k4 v4\n```\n\n从机可以获取值\n\n```redis\nget k4\n\"v4\"\nget k1\n\"v1\"\n```\n\n再次使用命令 info replication查看信息\n\n6379主机下多了两个奴隶：6380,6381\n\n6780、6781的角色变成了奴隶。\n\n\n\n- **如果从机尝试写入数据。会出错。因为Master以写为主，Slave以读为主**\n\n\n\n- 如果主机SHUTDOWN死了，调用从机的 info replication\n\n```\nmaster_link_status: 由up变成了down\n```\n\n从机在原地待命\n\n\n\n- 如果主机重新连接回来了，并设值\n\n```\nset k7 v7\n```\n\n从机依然可以获取k7的值\n\n```\nget k7\n\"v7\"\n```\n\n- 如果从机退出并重新连接role角色会变成master，并且会丢失退出期间的数据,\n\n  调用SLAVEOF 127.0.0.1  6379就可以恢复连接并获取到原来丢失的值\n\n  \n\n  **每次与master断开之后，都需要重新连接，除非配置进redis.conf**\n\n  \n\n#### 薪火相传\n\n> 去中心化\n>\n> 上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中的下一个的master，可以有效减轻master的写压力。\n\n中途变更转向：会清除之前的数据，重新建立拷贝最新的\n\nSlaveof 新主库IP 新主库端口\n\n\n\n例如81是80的从机，80是79的从机，那么80是79的奴隶，80还是奴隶，81是80的奴隶。\n\n#### 反客为主\n\n一主二仆里，主机挂了，从机使用命令：\n\n```\nSLAVEOF no one\n```\n\n当前从机的角色就变成了主机，其他从机需要调用：\n\n```\nSlaveof 新主库IP 新主库端口\n//使当前数据库停止与其他数据库同步，转成组数据库。\n```\n\n才能跟随新主机。\n\n### 复制原理\n\n- Slave启动成功连接到master后会发送一个sync命令\n\n- Master接到命令启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步\n\n- 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n- 增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步\n\n  但是只要是重新连接master，一次完全同步（全量复制）将会被自动执行。\n\n### 哨兵模式\n\n> 反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库\n\n#### 启动\n\n在/myredis下面创建一个sentinel.conf文件\n\n```shell\ntouch sentinel.conf\nvim sentinel.conf\n```\n\n修改为以下内容：\n\n*一组 sentinel.conf 可以监控多个Master*\n\n```shell\nsentinel monitor 被监控数据库名字(自己起名字)  127.0.0.1  6379  1\n\n//数字1 表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机\n```\n\n启动redis：\n\n```\nredis-sentinel  /myredis/sentinel.conf \n```\n\n主机断开之后，哨兵监控到了，就开始投票，如果两个从机一人一票，就会重新投票，\n\n票数高的从机替换主机，其他从机都跟随这个新主机。\n\n断开的主机回来之后变成了从机，并跟随新主机。\n\n### 复制的缺点\n\n由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步带Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n\n### Jedis\n\n测试联通\n\n先启动\n\n在/usr/local/bin下：\n\n```\n$ redis-server /myredis/redis.conf\n```\n\n```\n$ redis-cli -p 6379\n```\n\nJava：\n\n依赖：\n\n```xml\n<dependencies>\n        <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 -->\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n            <version>2.8.0</version>\n        </dependency>\n\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>3.3.0</version>\n        </dependency>\n    </dependencies>\n```\n\n\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 18:33\n */\npublic class TestPing {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        System.out.println(jedis.ping());\n    }\n}\n------\nPONG\n```\n\nAPI\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 18:33\n */\npublic class TestAPI {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.set(\"k1\", \"v2\");\n        jedis.get(\"k1\");\n        Set<String> keys = jedis.keys(\"*\");\n        //事务\n        Transaction multi = jedis.multi();\n        multi.set(\"k2\", \"v2\");\n//        multi.exec();\n        multi.discard();\n    }\n}\n```\n\n事务\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 20:04\n */\npublic class TestTX {\n    public static void main(String[] args) throws InterruptedException {\n        TestTX test = new TestTX();\n        boolean b = test.transMethod();\n        System.out.println(b);\n    }\n\n    public boolean transMethod() throws InterruptedException {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        int balance;//可用余额\n        int debt;//欠额\n        int amtToSubtract = 10;//实刷额度\n        jedis.watch(\"balance\");\n        //其他程序执行\n        // Thread.sleep(3000);\n        //jedis.set(\"balance\", \"5\");\n        balance = Integer.parseInt(jedis.get(\"balance\"));\n        if (balance < amtToSubtract) {\n            jedis.unwatch();\n            System.out.println(\"modify\");\n            return false;\n        }\n        return true;\n    }\n}\n```\n\n主从\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 20:04\n */\npublic class TestMS {\n    public static void main(String[] args) {\n        Jedis jedis_M = new Jedis(\"127.0.0.1\", 6379);\n        Jedis jedis_S = new Jedis(\"127.0.0.1\", 6380);\n\n        jedis_S.slaveof(\"127.0.0.1\", 6379);\n        jedis_M.set(\"class\", \"1\");\n\n        System.out.println(jedis_S.get(\"class\"));\n    }\n}\n```\n\n池\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/29 20:29\n */\npublic class JedisPoolUtils {\n\n    private static volatile JedisPool jedisPool = null;\n\n    private JedisPoolUtils() {\n    }\n\n    public static JedisPool getJedisPoolInstance() {\n        if (null == jedisPool) {\n            synchronized (JedisPoolUtils.class) {\n                if (null == jedisPool) {\n                    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n                    jedisPoolConfig.setMaxActive();\n                    jedisPoolConfig.setMaxIdle(32);\n                    jedisPoolConfig.setMaxWaitMillis(100*1000);\n                    jedisPoolConfig.setTestOnBorrow(true);\n                    jedisPool = new JedisPool(\"127.0.0.1\", 6379);\n                }\n            }\n        }\n        return jedisPool;\n    }\n}\n```\n\nJedisPoolConfig:\n\n![1593434346091](1593434346091.png)\n\n### 缓存雪崩\n\n","tags":["sql"]},{"title":"操作系统","url":"/2020/06/20/操作系统/","content":"\n### OS Kernel的特征\n\n<!--more-->\n\n- #### 并发\n\n  并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。 常考易混概念——并行：指两个或多个事件在同一时刻同时发生。\n\n  操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观 上看是交替运行的。 操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。\n\n  **注意**： 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。\n\n  计算机系统中存在多个运行的程序，需要OS管理和调度\n\n- #### 共享\n\n  共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。\n\n  **同时共享**\n  \n  > 系统中的某些资源，虽然可以提供给 多个进程使用，但一个时间段内只允 许一个进程访问该资源\n  \n  **互斥共享**\n  \n  > 系统中的某些资源，允许一个时间段 内由多个进程“同时”对它们进行访 问\n  \n  所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）\n  生活实例：\n  \n  互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 \n  \n  同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。\n  \n  ##### 共享和并发的关系：\n  \n  并发性指计算机系统中同时存在着多个运行着的程序。\n  \n  共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。\n  \n  通过上述例子来看并发与共享的关系： 并发性与共享性是互为存在条件。\n  \n- #### 虚拟\n  \n  利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务。虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上 对应物是用户感受到的。虚拟技术中的“时分复用 技术”。微观上处理机在 各个微小的时间段内交替 着为各个进程服务\n  \n  虚拟技术分为空分复用技术（如虚拟存储器技术）和时分复用技术（如虚拟处理器）。\n  \n  没有并发性，就没有虚拟性\n  \n- #### 异步\n  \n  程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知。\n  \n  但只要运行环境相同，OS需要保证程序运行的结果也要相同。\n  \n  只有拥有并发性才有异步性。\n\n### 操作系统的功能\n\n资源的管理者\n\n- 处理机管理\n\n  > 处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度 \n\n- 存储器管理\n\n  >  内存分配，内存保护，地址映射，内存扩充 \n\n- 文件管理\n\n  > 管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护 \n\n- 设备管理\n\n  >  管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用 \n\n提供接口：程序接口（API）和用户接口（GUI）\n\n联机命令接口实例 \n\n> 联机命令接口就是交互式命令接口(CMD)  用户命令一句，系统执行一句。\n\n脱机命令接口实例\n\n> 脱机命令接口实例，脱机命令接口也就是批处理命令接口   用户命令一堆，系统执行一堆。\n\n程序接口：\n\n> 可以在程序中进行系统调用(广义指令)来使用程序接口。普通用户不能直接使用程序接口，只能通过程 序代码间接使用。\n\n### BIOS关系：\n\nDISK：存放OS\n\nBIOS：基本I/O处理系统，最基本的功能是电源开启后检测外设，之后加载相应的软件来执行\n\nBootloader：加载OS，把OS从硬盘放到内存里，让CPU可以操作系统，\n\n![1592878521236](1.png)\n\n从图可以看出，计算机里面有一部分空间（硬盘）已经给BIOS占用了，但是还有很多地方是空的，BIOS需要从一个特定的地址开始执行，以X86为例，固定的地址为0xf000:fff0. CS寄存器和IP寄存器一起可以形成一个内存地址，一开始加电，BIOS就从这个地址开始执行。执行一系列的工作：\n\n- POST（加电自检）\n\n  寻找显卡和执行BIOS，检查设备是否可以正常工作。初始化的检擦。\n\n- BIOS是如何把bootloader放进去的：\n\n![](2.png)\n\nBootloader一般是放在硬盘的第一个主引导扇区。第一个扇区是512个字节。把bootloader放到内存里，CPU的掌控权就在bootloader；\n\n\n\n#### 运行机制\n\n##### 两种指令\n\n- 特权指令，如内存清零指令----不允许用户程序使用\n- 非特权指令，如普通的运算指令。\n\n##### 两种处理器状态\n\n- 用户态（目态）\n- 核心态（管态）\n\n##### 两种程序\n\n- 内核程序\n- 应用程序\n\n##### 操作系统内核\n\n与硬件关联紧密的模块\n\n- 时钟管理\n- 中断处理\n- 原语\n\n其他：\n\n- 对系统资源进行管理的功能\n\n#### 操作系统的体系结构\n\n- 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态\n\n  优点：高性能\n\n  缺点：内核代码庞大。结构混乱，难以维护。\n\n- 微内核：只把最基本的功能保留在内核、\n\n  优点：内核功能少，结构清晰，方便维护\n\n  缺点：需要频繁的在核心态和用户态之间切换，性能低\n\n1.特权指令只能在核心态下执行\n\n2.内核程序只能在核心态下执行\n\n3.核心态和用户态的切换\n\n### 操作系统与设备和程序交互。\n\n#### 系统调用、异常、中断\n\n- 系统调用（来源于应用程序）sys call\n\n- 应用程序主动向操作系统发出服务请求。\n\n- 异常（来源于不良的应用程序） exception\n\n- 非法指令或者其他坏的处理状态（如：内存出错）\n\n- 中断（来源与外设）interrupt\n\n  - 来自不同硬件设备的计时器和网络中断。\n\n    \n\n为什么应用程序不直接使用外设而要经过操作系统？\n\n- 在计算机运行中，内核是被信任的第三方\n- 只有内核可以执行特权指令\n- 为了方便应用程序\n\n\n\n产生的源头：\n\n- 中断：外设\n- 异常：应用程序意想不到的行为\n- 系统调用：应用程序请求操作提供服务。\n\n\n\n处理时间：\n\n- 中断：异步，异步：当这个事件产生的时候，我们应用程序并不知道什么时候产生。\n- 异常：同步，异常执行到某条特定的指令后一定会产生\n- 系统调用：异步或同步，当系统调用发出请求的时候，返回的时间是异步的\n\n\n\n响应：\n\n- 中断：持续，对用户应用程序是透明的、\n- 异常: 杀死或者重新执行意想不到的应用程序指令\n- 系统调用：等待和持续\n\n###  **进程和线程以及它们的区别** \n\n进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发（如：用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等，然后该进程被放入到进程的就绪队列，进程调度程序选中它，为它分配CPU及其他相关资源，该进程就被运行起来）；\n\n线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；\n\n在没有实现线程的操作系统中，进程既是资源分配的基本单位，又是调度的基本单位，它是系统中并发执行的单元。而在实现了线程的操作系统中，进程是资源分配的基本单位，但是线程是调度的基本单位，是系统中并发执行的单元。\n\n引入线程主要有以下4个方面的优点：\n\n1）易于调度。\n\n2）提高并发性。通过线程可以方便有效地实现并发。\n\n3）开销小。创建线程比创建进程要快，所需要的开销也更小。\n\n4）有利于发挥多处理器的功能。通过创建多线程，每个线程都在一个处理器上运行，从而实现应用程序的并行，使每个处理器都得到充分的运行。\n\n尽管线程和进程很相似，但两者也存在着很大的不同，区别如下：\n\n- 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；\n\n- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存空间。 \n\n- 属于一个进程的所有线程共享该进程的所有资源，包括打开的文件，创建的Socket等。不同的进程互相独立。\n\n- 线程又被称为轻量级进程。进程有进程控制块，线程有线程控制块。但线程控制块比进程控制块小得多。线程间切换代价小，进程间切换代价大。\n\n- 进程是程序的一次执行，线程可以理解为程序中一段程序片段的执行。\n\n### 进程间的通信的几种方式\n\n**管道（pipe）及命名管道（named pipe）**：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；\n\n**信号（signal）**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n\n**消息队列**：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；\n\n**共享内存**：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；\n\n**信号量**：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；\n\n**套接字**：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。\n\n#### 线程的实现方式(用户线程与内核线程的区别)\n\n根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程。\n\n内核线程建立和销毁都是由操作系统负责、通过系统调用完成的，操作系统在调度时，参考各进程内的线程运行情况做出调度决定，如果一个进程中没有就绪态的线程，那么这个进程也不会被调度占用CPU。\n\n和内核线程相对应的是用户线程，用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。用户线程多见于一些历史悠久的操作系统，例如Unix操作系统，不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为“线程包”，用户线程是不能被操作系统所感知的。\n\n##### 引入用户线程，具体而言，有以下四个方面的优势：\n\n（1）可以在不支持线程的操作系统中实现。\n\n（2）创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。\n\n（3）允许每个进程定制自己的调度算法，线程管理比较灵活。\n\n（4）线程能够利用的表空间和堆栈空间比内核级线程多。\n\n##### 用户线程的缺点主要有以下两点：\n\n（1）同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。\n\n（2）页面失效也会产生类似的问题。\n\n内核线程的优缺点刚好跟用户线程相反。实际上，操作系统可以使用混合的方式来实现线程。\n\n### 进程有哪几种状态？\n\n就绪状态：当进程已经分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行；\n\n运行状态：当进程已获得处理机，其程序正在处理机上执行；\n\n阻塞状态： 正在执行的进程，由于某个事件发生而无法执行时，便放弃处理机而处于阻塞状态；引起进程阻塞状态的事件可以有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件（信号）。\n\n![](进程的三种状态.jpg)\n\n#### 注意区别\n\n**就绪状态和等待状态**：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。\n\n**就绪状态 -> 运行状态**：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。\n\n**运行状态 -> 就绪状态**：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。\n\n**运行状态 -> 阻塞状态**：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。\n\n**阻塞状态 -> 就绪状态**：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。\n\n### 用户态和核心态的区别。\n\n当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。\n\n用户态切换到内核态的3种方式：系统调用、异常、外围设备中断。\n\n### 什么是缓冲区溢出？有什么危害？其原因是什么？\n\n缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。\n\n危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。\n\n造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。\n\n\n###  **死锁** \n\n#### 死锁的概念\n\n　　所谓死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。\n\n#### 死锁产生的四个必要条件\n\n- 互斥条件：一个资源每次只能被一个进程使用；若其他进程申请使用该资源，必须等到该资源被释放为止；\n\n- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；\n\n- 不可剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺；\n\n- 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系；\n\n#### 死锁的解除与预防\n\n1 **死锁预防** \n死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：\n\n- 注意：互斥条件无法破坏\n\n- 打破请求与保持条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。\n\n- 打破不可剥夺条件：允许进程强剥夺使用其他进程占有的资源，从而破坏不可剥夺条件。也就是说，一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。\n\n- 打破循环等待条件：实行资源有序分配策略，破坏环路条件。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。\n\n2**死锁避免的基本思想** \n死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。\n\n**银行家算法**：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中所有进程都能完成，所以可避免死锁的发生。\n\n### 内存管理有哪几种方式(块式、页式、段式、段页式).\n\n    内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理。\n    \n    块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。\n    \n    页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。\n    \n    段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。\n    \n    段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。\n###  **分页和分段有什么区别（内存管理）？**\n\n​\t\t段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）\n\n　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分配。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。\n\n两者的不同点：\n\n- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；\n\n- 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；\n\n- 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；\n\n- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；\n\n- 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。\n\n###  **页面置换算法** \n\n**最佳置换算法OPT**：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。\n\n**先进先出置换算法FIFO**：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。\n\n**最近最久未使用算法LRU**：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。\n\n**时钟算法clock(也被称为是最近未使用算法NRU)**：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。\n\n**改进型Clock算法：**在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。\n\n**LFU最少使用算法LFU：**设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。\n\n###  操作系统中进程调度策略\n\n- 先来先服务调度算法FCFS：队列实现，非抢占，先请求CPU的进程先分配到CPU，可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度，对于长作业比较有利；\n\n- 最短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行，平均等待时间最短，但难以知道下一个CPU区间长度；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；\n\n- 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；\n\n- 时间片轮转调度算法(可抢占的)：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。\n\n- 高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间；\n\n- 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。\n\n- 多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。\n  \n\n### **进程同步有哪几种机制**\n\n　　原子操作、信号量机制、自旋锁管程、会合、分布式系统\n\n###  **虚拟内存** \n\n#### 内存的发展历程\n\n　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —> 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程) \n）—> 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —> 不连续内存分配（分段，分页，段页式，虚拟内存）\n\n#### 虚拟内存\n\n　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图所示。 \n注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。\n\n　 ![img](70.png) 　　　　　　　　     　　　　　\n\n由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。\n\n#### 虚拟内存的应用与优点\n\n虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：\n\n在内存中可以保留多个进程，系统并发度提高\n\n解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大\n\n\n### 颠簸\n\n颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。\n\n内存颠簸的解决策略包括：\n\n如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；\n\n如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；\n\n否则，还剩下两个办法：终止该进程或增加物理内存容量。\n\n### 局部性原理\n\n时间上的局部性：最近被访问的页在不久的将来还会被访问；\n\n 空间上的局部性：内存中被访问的页周围的页也很可能被访问。\n\n\n\n\n\n## Linux中常用到的命令\n\n显示文件目录命令ls        如ls\n改变当前目录命令cd        如cd /home\n建立子目录mkdir           如mkdir xiong\n删除子目录命令rmdir       如rmdir /mnt/cdrom\n删除文件命令rm            如rm /ucdos.bat\n文件复制命令cp            如cp /ucdos /fox\n获取帮助信息命令man      如man ls\n显示文件的内容less        如less mwm.lx\n\nLinux文件属性有哪些？（共十位）\n-rw-r--r--那个是权限符号，总共是- --- --- ---这几个位。\n\n第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录（directory）；l表示链接文件（link）；\n\n第一个三个连续的短横是用户权限位（User）\n\n第二个三个连续短横是组权限位（Group）\n\n第三个三个连续短横是其他权限位（Other）。\n每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。\n\n如果每个权限位都有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- --- --- ---。\n权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：\n一个文件aaa具有完全空的权限- --- --- ---。\nchmod u+rw aaa（给用户权限位设置（增加）读写权限，其权限表示为：- rw- --- ---）\nchmod g+r aaa（给组设置权限为可读，其权限表示为：- --- r-- ---）\nchmod ugo+rw aaa（给用户、组、其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）\n如果aaa具有满权限- rwx rwx rwx。\nchmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）\n如果要给aaa赋予制定权限- rwx r-x r-x，命令为：\nchmod u=rwx，go=rx aaa\n","tags":["Operating Systems"]},{"title":"编码算法","url":"/2020/06/19/编码算法/","content":"\n## 编码算法\n\n<!--more-->\n\n------\n\n要学习编码算法，先来看一看什么是编码。\n\nASCII码就是一种编码，字母`A`的编码是十六进制的`0x41`，字母`B`是`0x42`，以此类推：\n\n| 字母 | ASCII编码 |\n| :--- | :-------- |\n| A    | 0x41      |\n| B    | 0x42      |\n| C    | 0x43      |\n| D    | 0x44      |\n| …    | …         |\n\n因为ASCII编码最多只能有127个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是`0x4e2d`，使用UTF-8则需要3个字节编码：\n\n| 汉字 | Unicode编码 | UTF-8编码 |\n| :--- | :---------- | :-------- |\n| 中   | 0x4e2d      | 0xe4b8ad  |\n| 文   | 0x6587      | 0xe69687  |\n| 编   | 0x7f16      | 0xe7bc96  |\n| 码   | 0x7801      | 0xe7a081  |\n| …    | …           | …         |\n\n因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。\n\n比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。\n\n### URL编码\n\nURL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：\n\n[https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87](https://www.baidu.com/s?wd=中文)\n\n之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：\n\n- 如果字符是`A`~`Z`，`a`~`z`，`0`~`9`以及`-`、`_`、`.`、`*`，则保持不变；\n- 如果是其他字符，先转换为UTF-8编码，然后对每个字节以`%XX`表示。\n\n例如：字符`中`的UTF-8编码是`0xe4b8ad`，因此，它的URL编码是`%E4%B8%AD`。URL编码总是大写。\n\nJava标准库提供了一个`URLEncoder`类来对任意字符串进行URL编码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String encoded = URLEncoder.encode(\"中文!\", StandardCharsets.UTF_8);\n        System.out.println(encoded);\n    }\n}\n\n```\n\n上述代码的运行结果是`%E4%B8%AD%E6%96%87%21`，`中`的URL编码是`%E4%B8%AD`，`文`的URL编码是`%E6%96%87`，`!`虽然是ASCII字符，也要对其编码为`%21`。\n\n和标准的URL编码稍有不同，URLEncoder把空格字符编码成`+`，而现在的URL编码标准要求空格被编码为`%20`，不过，服务器都可以处理这两种情况。\n\n如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的`URLDecoder`就可以解码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String decoded = URLDecoder.decode(\"%E4%B8%AD%E6%96%87%21\", StandardCharsets.UTF_8);\n        System.out.println(decoded);\n    }\n}\n\n```\n\n要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为`%`前缀表示的文本，编码后的文本仅包含`A`~`Z`，`a`~`z`，`0`~`9`，`-`，`_`，`.`，`*`和`%`，便于浏览器和服务器处理。\n\n### Base64编码\n\nURL编码是对字符进行编码，表示成`%xx`的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。\n\nBase64编码可以把任意长度的二进制数据变为纯文本，且只包含`A`~`Z`、`a`~`z`、`0`~`9`、`+`、`/`、`=`这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。\n\n举个例子：3个byte数据分别是`e4`、`b8`、`ad`，按6bit分组得到`39`、`0b`、`22`和`2d`：\n\n```ascii\n┌───────────────┬───────────────┬───────────────┐\n│      e4       │      b8       │      ad       │\n└───────────────┴───────────────┴───────────────┘\n┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐\n│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│\n└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘\n┌───────────┬───────────┬───────────┬───────────┐\n│    39     │    0b     │    22     │    2d     │\n└───────────┴───────────┴───────────┴───────────┘\n```\n\n因为6位整数的范围总是`0`~`63`，所以，能用64个字符表示：字符`A`~`Z`对应索引`0`~`25`，字符`a`~`z`对应索引`26`~`51`，字符`0`~`9`对应索引`52`~`61`，最后两个索引`62`、`63`分别用字符`+`和`/`表示。\n\n在Java中，二进制数据就是`byte[]`数组。Java标准库提供了`Base64`来对`byte[]`数组进行编解码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad };\n        String b64encoded = Base64.getEncoder().encodeToString(input);\n        System.out.println(b64encoded);\n    }\n}\n\n```\n\n 编码后得到`5Lit`4个字符。要对`Base64`解码，仍然用`Base64`这个类： \n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] output = Base64.getDecoder().decode(\"5Lit\");\n        System.out.println(Arrays.toString(output)); // [-28, -72, -83]\n    }\n}\n\n```\n\n有的童鞋会问：如果输入的`byte[]`数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个`0x00`，编码后，在结尾加一个`=`表示补充了1个`0x00`，加两个`=`表示补充了2个`0x00`，解码的时候，去掉末尾补充的一个或两个`0x00`即可。\n\n实际上，因为编码后的长度加上`=`总是4的倍数，所以即使不加`=`也可以计算出原始输入的`byte[]`。Base64编码的时候可以用`withoutPadding()`去掉`=`，解码出来的结果是一样的：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, 0x21 };\n        String b64encoded = Base64.getEncoder().encodeToString(input);\n        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);\n        System.out.println(b64encoded);\n        System.out.println(b64encoded2);\n        byte[] output = Base64.getDecoder().decode(b64encoded2);\n        System.out.println(Arrays.toString(output));\n    }\n}\n\n```\n\n 因为标准的Base64编码会出现`+`、`/`和`=`，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把`+`变成`-`，`/`变成`_`： \n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte[] input = new byte[] { 0x01, 0x02, 0x7f, 0x00 };\n        String b64encoded = Base64.getUrlEncoder().encodeToString(input);\n        System.out.println(b64encoded);\n        byte[] output = Base64.getUrlDecoder().decode(b64encoded);\n        System.out.println(Arrays.toString(output));\n    }\n}\n\n```\n\nBase64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。\n\nBase64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。\n\n和URL编码一样，Base64编码是一种编码算法，不是加密算法。\n\n如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。\n\n### 小结\n\nURL编码和Base64编码都是编码算法，它们不是加密算法；\n\nURL编码的目的是把任意文本数据编码为%前缀表示的文本，便于浏览器和服务器处理；\n\nBase64编码的目的是把任意二进制数据编码为文本，但编码后数据量会增加1/3。","tags":["dataAlgorithm"]},{"title":"哈希算法","url":"/2020/06/17/哈希算法/","content":"\n### 哈希算法\n\n> 哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 \n>\n><!--more-->\n\n哈希算法最重要的特点就是：\n\n- 相同的输入一定得到相同的输出；\n- 不同的输入大概率得到不同的输出。\n\n哈希算法的目的就是为了验证原始数据是否被篡改。\n\nJava字符串的`hashCode()`就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节`int`整数：\n\n```\n\"hello\".hashCode(); // 0x5e918d2\n\"hello, java\".hashCode(); // 0x7a9d88e8\n\"hello, bob\".hashCode(); // 0xa0dbae2f\n```\n\n两个相同的字符串永远会计算出相同的`hashCode`，否则基于`hashCode`定位的`HashMap`就无法正常工作。这也是为什么当我们自定义一个class时，覆写`equals()`方法时我们必须正确覆写`hashCode()`方法。\n\n### 哈希碰撞\n\n哈希碰撞是指，两个不同的输入得到了相同的输出：\n\n```\n\"AaAaAa\".hashCode(); // 0x7460e8c0\n\"BBAaBB\".hashCode(); // 0x7460e8c0\n```\n\n有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，`String`的`hashCode()`输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。\n\n碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：\n\n- 碰撞概率低；\n- 不能猜测输出。\n\n不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：\n\n```\nhashA(\"java001\") = \"123456\"\nhashA(\"java002\") = \"123457\"\nhashA(\"java003\") = \"123458\"\n```\n\n那么很容易从输出`123459`反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：\n\n```\nhashB(\"java001\") = \"123456\"\nhashB(\"java002\") = \"580271\"\nhashB(\"java003\") = ???\n```\n\n常用的哈希算法有：\n\n| 算法       | 输出长度（位） | 输出长度（字节） |\n| :--------- | :------------- | :--------------- |\n| MD5        | 128 bits       | 16 bytes         |\n| SHA-1      | 160 bits       | 20 bytes         |\n| RipeMD-160 | 160 bits       | 20 bytes         |\n| SHA-256    | 256 bits       | 32 bytes         |\n| SHA-512    | 512 bits       | 64 bytes         |\n\n根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。\n\nJava标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 创建一个MessageDigest实例:\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        // 反复调用update输入数据:\n        md.update(\"Hello\".getBytes(\"UTF-8\"));\n        md.update(\"World\".getBytes(\"UTF-8\"));\n        byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6\n        System.out.println(new BigInteger(1, result).toString(16));\n    }\n}\n```\n\n使用`MessageDigest`时，我们首先根据哈希算法获取一个`MessageDigest`实例，然后，反复调用`update(byte[])`输入数据。当输入结束后，调用`digest()`方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。\n\n运行上述代码，可以得到输入`HelloWorld`的MD5是`68e109f0f40ca72a15e05cc22786f8e6`。\n\n### 哈希算法的用途\n\n因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。\n\n我们在网站上下载软件的时候，经常看到下载页显示的哈希：\n\n![file-md5](https://www.liaoxuefeng.com/files/attachments/1305351978745921/l)\n\n如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。\n\n哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：\n\n- 数据库管理员能够看到用户明文口令；\n- 数据库数据一旦泄漏，黑客即可获取用户明文口令。\n\n不存储用户的原始口令，那么如何对用户进行认证？\n\n方法是存储用户口令的哈希，例如，MD5。\n\n在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。\n\n因此，数据库存储用户名和口令的表内容应该像下面这样：\n\n| username | password                         |\n| :------- | :------------------------------- |\n| bob      | f30aa7a662c728b7407c54ae6bfd27d1 |\n| alice    | 25d55ad283aa400af464c76d713c07ad |\n| tim      | bed128365216c019988915ed3add75fb |\n\n这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。\n\n使用哈希口令时，还要注意防止彩虹表攻击。\n\n什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。\n\n然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：\n\n| 常用口令 | MD5                              |\n| :------- | :------------------------------- |\n| hello123 | f30aa7a662c728b7407c54ae6bfd27d1 |\n| 12345678 | 25d55ad283aa400af464c76d713c07ad |\n| passw0rd | bed128365216c019988915ed3add75fb |\n| 19700101 | 570da6d5277a646f6552b8832012f5dc |\n| …        | …                                |\n| 20201231 | 6879c0ae9117b50074ce0a0d4c843060 |\n\n这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：\n\nbob的MD5：`f30aa7a662c728b7407c54ae6bfd27d1`，原始口令：`hello123`；\n\nalice的MD5：`25d55ad283aa400af464c76d713c07ad`，原始口令：`12345678`；\n\ntim的MD5：`bed128365216c019988915ed3add75fb`，原始口令：`passw0rd`。\n\n这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。\n\n即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：\n\n```\ndigest = md5(salt+inputPassword)\n```\n\n经过加盐处理的数据库表，内容如下：\n\n| username | salt  | password                         |\n| :------- | :---- | :------------------------------- |\n| bob      | H1r0a | a5022319ff4c56955e22a74abcc2c210 |\n| alice    | 7$p2w | e5de688c99e961ed6e560b972dab8b6a |\n| tim      | z5Sk9 | 1eee304b92dc0d105904e7ab58fd2f64 |\n\n加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。\n\n### SHA-1\n\nSHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。\n\n在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为`\"SHA-1\"`：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 创建一个MessageDigest实例:\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        // 反复调用update输入数据:\n        md.update(\"Hello\".getBytes(\"UTF-8\"));\n        md.update(\"World\".getBytes(\"UTF-8\"));\n        byte[] result = md.digest(); // 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2\n        System.out.println(new BigInteger(1, result).toString(16));\n    }\n}\n\n```\n\n 类似的，计算SHA-256，我们需要传入名称`\"SHA-256\"`，计算SHA-512，我们需要传入名称`\"SHA-512\"`。Java标准库支持的所有哈希算法可以在[这里](https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms)查到。 ","tags":["dataAlgorithm"]},{"title":"插值查找算法","url":"/2020/06/17/插值查找算法/","content":"\n### 插值查找算法\n\n<!--more-->\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/17 9:06\n */\npublic class insertSearch {\n    /**\n     * @param arr     数组\n     * @param left    左边的索引\n     * @param right   右边的索引\n     * @param findVal 要查找的值\n     * @return\n     */\n    public static int insertValue(int[] arr, int left, int right, int findVal) {\n        System.out.println(\"插值查找次数...\");\n\n        //注意：findVal<arr[0]和findVal>arr[arr.length-1]必须需要\n        //否则得到的mid可能越界\n        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {\n            return -1;\n        }\n\n        //求出mid,自适应\n        int mid = left + (right - left) * (findVal - arr[left] / arr[right] - arr[left]);\n        int midVal = arr[mid];\n        if (findVal > midVal) {\n            //应该向右递归\n            return insertValue(arr, mid + 1, right, findVal);\n        } else if (findVal < midVal) {\n            return insertValue(arr, left, mid - 1, findVal);\n        } else {\n            return mid;\n        }\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"二分查找算法","url":"/2020/06/17/二分查找算法/","content":"\n### 二分查找算法\n\n<!--more-->\n\n```java\n/**\n     * 二分查找算法\n     *\n     * @param arr    待查找的数组,arr是升序排序\n     * @param target 需要查找的数\n     * @return 返回对应的下标，-1表示没有\n     */\n    public static int binarySearch(int[] arr, int target) {\n\n        int left = 0;\n        int right = arr.length - 1;\n        while (left <= right) {\n            //说明可以继续查找\n            int mid = (left + right) / 2;\n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] > target) {\n                right = mid - 1;//需要向左边查找\n            } else {\n                left = mid + 1;//需要向右边查找\n            }\n        }\n        return -1;\n\n    }\n```\n\n","tags":["dataAlgorithm"]},{"title":"线性查找算法","url":"/2020/06/17/线性查找算法/","content":"\n### 线性查找算法\n\n<!--more-->\n\n>  有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称\n>\n> 【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值。\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/17 8:57\n */\npublic class OrderSearch {\n    public static void main(String[] args) {\n        int[] arr = {1, 8, 10, 89, 1000, 1234};\n        System.out.println(OrderFind(arr, 10));\n    }\n\n    public static int OrderFind(int[] arr, int value) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            if (arr[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"多线程","url":"/2020/06/15/多线程/","content":"\n## 多线程\n\n<!--more-->\n\n### 一个线程的生命周期\n\n线程是一个动态执行的过程，它也有一个从产生到死亡的过程。\n\n下图显示了一个线程完整的生命周期。\n\n![img](1.jpg)\n\n- 新建状态:\n\n  使用 **new** 关键字和 **Thread** 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 **start()** 这个线程。\n\n- 就绪状态:\n\n  当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n\n- 运行状态:\n\n  如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n\n- 阻塞状态:\n\n  如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：\n\n  - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。\n  - 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。\n  - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。\n\n- 死亡状态:\n\n  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n\n---\n\n### 线程的优先级\n\n每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。\n\nJava 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。\n\n默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。\n\n具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。\n\n---\n\n### 创建一个线程\n\nJava 提供了三种创建线程的方法：\n\n- 通过实现 Runnable 接口；\n- 通过继承 Thread 类本身；\n- 通过 Callable 和 Future 创建线程。\n\n---\n\n## 通过实现 Runnable 接口来创建线程\n\n创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。\n\n为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：\n\n```java\npublic void run()\n```\n\n你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。\n\n在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。\n\nThread 定义了几个构造方法，下面的这个是我们经常使用的：\n\n```java\nThread(Runnable threadOb,String threadName);\n```\n\n这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。\n\n新线程创建之后，你调用它的 start() 方法它才会运行。\n\n```java\nvoid start();\n```\n\n下面是一个创建线程并开始让它执行的实例：\n\n![img](1.png)\n\n编译以上程序运行结果如下：\n\n```shell\nCreating Thread-1\nStarting Thread-1\nCreating Thread-2\nStarting Thread-2\nRunning Thread-1\nThread: Thread-1, 4\nRunning Thread-2\nThread: Thread-2, 4\nThread: Thread-1, 3\nThread: Thread-2, 3\nThread: Thread-1, 2\nThread: Thread-2, 2\nThread: Thread-1, 1\nThread: Thread-2, 1\nThread Thread-1 exiting.\nThread Thread-2 exiting.\n```\n\n---\n\n## 通过继承Thread来创建线程\n\n创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。\n\n继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。\n\n该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。\n\n![](2.png)\n\n编译以上程序运行结果如下：\n\n```\nCreating Thread-1\nStarting Thread-1\nCreating Thread-2\nStarting Thread-2\nRunning Thread-1\nThread: Thread-1, 4\nRunning Thread-2\nThread: Thread-2, 4\nThread: Thread-1, 3\nThread: Thread-2, 3\nThread: Thread-1, 2\nThread: Thread-2, 2\nThread: Thread-1, 1\nThread: Thread-2, 1\nThread Thread-1 exiting.\nThread Thread-2 exiting.\n```\n\n---\n\n## Thread 方法\n\n下表列出了Thread类的一些重要方法：\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **public void start()** 使该线程开始执行；**Java** 虚拟机调用该线程的 run 方法。 |\n| 2        | **public void run()** 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 |\n| 3        | **public final void setName(String name)** 改变线程名称，使之与参数 name 相同。 |\n| 4        | **public final void setPriority(int priority)**  更改线程的优先级。 |\n| 5        | **public final void setDaemon(boolean on)** 将该线程标记为守护线程或用户线程。 |\n| 6        | **public final void join(long millisec)** 等待该线程终止的时间最长为 millis 毫秒。 |\n| 7        |            **public void interrupt()** 中断线程。            |\n| 8        | **public final boolean isAlive()** 测试线程是否处于活动状态。 |\n\n测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **public static void yield()** 暂停当前正在执行的线程对象，并执行其他线程。 |\n| 2        | **public static void sleep(long millisec)** 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 |\n| 3        | **public static boolean holdsLock(Object x)** 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 |\n| 4        | **public static Thread currentThread()** 返回对当前正在执行的线程对象的引用。 |\n| 5        | **public static void dumpStack()** 将当前线程的堆栈跟踪打印至标准错误流。 |\n\n### 实例\n\n如下的ThreadClassDemo 程序演示了Thread类的一些方法：\n\n![](3.png)\n\n![](4.png)\n\n![](5.png)\n\n运行结果如下，每一次运行的结果都不一样。\n\n```\nStarting hello thread...\nStarting goodbye thread...\nHello\nHello\nHello\nHello\nHello\nHello\nGoodbye\nGoodbye\nGoodbye\nGoodbye\nGoodbye\n.......\n```\n\n## 通过 Callable 和 Future 创建线程\n\n- 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。\n- 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。\n- 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n- 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。\n\n![](6.png)\n\n## 创建线程的三种方式的对比\n\n- 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。\n- 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。\n\n------\n\n## 多线程的使用\n\n有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。\n\n通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。\n\n请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！","tags":["Concurrency"]},{"title":"模板方法","url":"/2020/06/13/模板方法/","content":"\n#### 模板方法\n\n------\n\n> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n>\n> <!--more-->\n\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n## 介绍\n\n**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。\n\n**何时使用：**有一些通用的方法。\n\n**如何解决：**将这些通用算法抽象出来。\n\n**关键代码：**在抽象类实现，其他步骤在子类实现。\n\n**应用实例：** 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n\n**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n**注意事项：**为防止恶意操作，一般模板方法都加上 final 关键词。\n\n## 实现\n\n我们将创建一个定义操作的 *Game* 抽象类，其中，模板方法设置为 final，这样它就不会被重写。*Cricket* 和 *Football* 是扩展了 *Game* 的实体类，它们重写了抽象类的方法。\n\n*TemplatePatternDemo*，我们的演示类使用 *Game* 来演示模板模式的用法。\n\n![模板模式的 UML 图](1.jpg)\n\n### 步骤1\n\n创建一个抽象类，它的模板方法被设置为 final。\n\n*Game.java*\n\n```java\npublic abstract class Game {\n   abstract void initialize();\n   abstract void startPlay();\n   abstract void endPlay();\n \n   //模板\n   public final void play(){\n \n      //初始化游戏\n      initialize();\n \n      //开始游戏\n      startPlay();\n \n      //结束游戏\n      endPlay();\n   }\n}\n```\n\n### 步骤 2\n\n创建扩展了上述类的实体类。\n\n*Cricket.java*\n\n```java\npublic class Cricket extends Game {\n \n   @Override\n   void endPlay() {\n      System.out.println(\"Cricket Game Finished!\");\n   }\n \n   @Override\n   void initialize() {\n      System.out.println(\"Cricket Game Initialized! Start playing.\");\n   }\n \n   @Override\n   void startPlay() {\n      System.out.println(\"Cricket Game Started. Enjoy the game!\");\n   }\n}\n```\n\n*Football.java*\n\n```java\npublic class Football extends Game {\n \n   @Override\n   void endPlay() {\n      System.out.println(\"Football Game Finished!\");\n   }\n \n   @Override\n   void initialize() {\n      System.out.println(\"Football Game Initialized! Start playing.\");\n   }\n \n   @Override\n   void startPlay() {\n      System.out.println(\"Football Game Started. Enjoy the game!\");\n   }\n}\n```\n\n### 步骤 3\n\n使用 *Game* 的模板方法 play() 来演示游戏的定义方式。\n\n*TemplatePatternDemo.java*\n\n```java\npublic class TemplatePatternDemo {\n   public static void main(String[] args) {\n \n      Game game = new Cricket();\n      game.play();\n      System.out.println();\n      game = new Football();\n      game.play();      \n   }\n}\n```\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```\nCricket Game Initialized! Start playing.\nCricket Game Started. Enjoy the game!\nCricket Game Finished!\n\nFootball Game Initialized! Start playing.\nFootball Game Started. Enjoy the game!\nFootball Game Finished!\n```","tags":["DesignPatterns"]},{"title":"访问者模式","url":"/2020/06/13/访问者模式/","content":"\n#### 访问者\n\n------\n\n> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n>\n> <!--more-->\n\n# 访问者模式\n\n在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。\n\n## 介绍\n\n**意图：**主要将数据结构与数据操作分离。\n\n**主要解决：**稳定的数据结构和易变的操作耦合问题。\n\n**何时使用：**需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。\n\n**如何解决：**在被访问的类里面加一个对外提供接待访问者的接口。\n\n**关键代码：**在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。\n\n**应用实例：**您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。\n\n**优点：** 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。\n\n**缺点：** 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。\n\n**使用场景：** 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。\n\n**注意事项：**访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。\n\n## 实现\n\n我们将创建一个定义接受操作的 *ComputerPart* 接口。*Keyboard*、*Mouse*、*Monitor* 和 *Computer* 是实现了 *ComputerPart* 接口的实体类。我们将定义另一个接口 *ComputerPartVisitor*，它定义了访问者类的操作。*Computer* 使用实体访问者来执行相应的动作。\n\n*VisitorPatternDemo*，我们的演示类使用 *Computer*、*ComputerPartVisitor* 类来演示访问者模式的用法。\n\n![访问者模式的 UML 图](1.jpg)\n\n### 步骤 1\n\n定义一个表示元素的接口。\n\nComputerPart.java\n\n```java\npublic interface ComputerPart {\n   public void accept(ComputerPartVisitor computerPartVisitor);\n}\n```\n\n\n\n### 步骤 2\n\n创建扩展了上述类的实体类。\n\n*Keyboard.java*\n\n```java\npublic class Keyboard  implements ComputerPart {\n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n*Monitor.java*\n\n```java\npublic class Monitor  implements ComputerPart {\n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n*Mouse.java*\n\n```java\npublic class Mouse  implements ComputerPart {\n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n*Computer.java*\n\n```java\npublic class Computer implements ComputerPart {\n   \n   ComputerPart[] parts;\n \n   public Computer(){\n      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      \n   } \n \n \n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      for (int i = 0; i < parts.length; i++) {\n         parts[i].accept(computerPartVisitor);\n      }\n      computerPartVisitor.visit(this);\n   }\n}\n```\n\n\n\n### 步骤 3\n\n定义一个表示访问者的接口。\n\n*ComputerPartVisitor.java*\n\n```java\npublic interface ComputerPartVisitor {\n   public void visit(Computer computer);\n   public void visit(Mouse mouse);\n   public void visit(Keyboard keyboard);\n   public void visit(Monitor monitor);\n}\n```\n\n\n\n### 步骤 4\n\n创建实现了上述类的实体访问者。\n\n*ComputerPartDisplayVisitor.java*\n\n```java\npublic class ComputerPartDisplayVisitor implements ComputerPartVisitor {\n \n   @Override\n   public void visit(Computer computer) {\n      System.out.println(\"Displaying Computer.\");\n   }\n \n   @Override\n   public void visit(Mouse mouse) {\n      System.out.println(\"Displaying Mouse.\");\n   }\n \n   @Override\n   public void visit(Keyboard keyboard) {\n      System.out.println(\"Displaying Keyboard.\");\n   }\n \n   @Override\n   public void visit(Monitor monitor) {\n      System.out.println(\"Displaying Monitor.\");\n   }\n}\n```\n\n\n\n### 步骤 5\n\n使用 *ComputerPartDisplayVisitor* 来显示 *Computer* 的组成部分。\n\n*VisitorPatternDemo.java*\n\n```java\npublic class VisitorPatternDemo {\n   public static void main(String[] args) {\n \n      ComputerPart computer = new Computer();\n      computer.accept(new ComputerPartDisplayVisitor());\n   }\n}\n```\n\n\n\n### 步骤 6\n\n执行程序，输出结果：\n\n```\nDisplaying Mouse.\nDisplaying Keyboard.\nDisplaying Monitor.\nDisplaying Computer.\n```","tags":["DesignPatterns"]},{"title":"策略模式","url":"/2020/06/13/策略模式/","content":"\n#### 策略\n\n------\n\n> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\n>\n> <!--more-->\n\n**策略模式：Strategy**，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。\n\n策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过`Arrays.sort()`实现忽略大小写排序：\n\n```java\nimport java.util.Arrays; `\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        String[] array = { \"apple\", \"Pear\", \"Banana\", \"orange\" };\n        Arrays.sort(array, String::compareToIgnoreCase);\n        System.out.println(Arrays.toString(array));\n    }\n}\n```\n\n\n\n如果我们想忽略大小写排序，就传入`String::compareToIgnoreCase`，如果我们想倒序排序，就传入`(s1, s2) -> -s1.compareTo(s2)`，这个比较两个元素大小的算法就是策略。\n\n我们观察`Arrays.sort(T[] a, Comparator c)`这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的`Comparator`对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。\n\n因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。\n\n如果我们自己实现策略模式的排序，用冒泡法编写如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        String[] array = { \"apple\", \"Pear\", \"Banana\", \"orange\" };\n        sort(array, String::compareToIgnoreCase);\n        System.out.println(Arrays.toString(array));\n    }\n\n    static <T> void sort(T[] a, Comparator<? super T> c) {\n        for (int i = 0; i < a.length - 1; i++) {\n            for (int j = 0; j < a.length - 1 - i; j++) {\n                if (c.compare(a[j], a[j + 1]) > 0) { // 注意这里比较两个元素的大小依赖传入的策略\n                    T temp = a[j];\n                    a[j] = a[j + 1];\n                    a[j + 1] = temp;\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：\n\n```java\npublic interface DiscountStrategy {\n    // 计算折扣额度:\n    BigDecimal getDiscount(BigDecimal total);\n}\n```\n\n接下来，就是实现各种策略。普通用户策略如下：\n\n```java\npublic class UserDiscountStrategy implements DiscountStrategy {\n    public BigDecimal getDiscount(BigDecimal total) {\n        // 普通会员打九折:\n        return total.multiply(new BigDecimal(\"0.1\")).setScale(2, RoundingMode.DOWN);\n    }\n}\n```\n\n满减策略如下：\n\n```java\npublic class OverDiscountStrategy implements DiscountStrategy {\n    public BigDecimal getDiscount(BigDecimal total) {\n        // 满100减20优惠:\n        return total.compareTo(BigDecimal.valueOf(100)) >= 0 ? BigDecimal.valueOf(20) : BigDecimal.ZERO;\n    }\n}\n```\n\n最后，要应用策略，我们需要一个`DiscountContext`：\n\n```java\npublic class DiscountContext {\n    // 持有某个策略:\n    private DiscountStrategy strategy = new UserDiscountStrategy();\n\n    // 允许客户端设置新策略:\n    public void setStrategy(DiscountStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public BigDecimal calculatePrice(BigDecimal total) {\n        return total.subtract(this.strategy.getDiscount(total)).setScale(2);\n    }\n}\n```\n\n调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：\n\n```java\nDiscountContext ctx = new DiscountContext();\n\n// 默认使用普通会员折扣:\nBigDecimal pay1 = ctx.calculatePrice(BigDecimal.valueOf(105));\nSystem.out.println(pay1);\n\n// 使用满减折扣:\nctx.setStrategy(new OverDiscountStrategy());\nBigDecimal pay2 = ctx.calculatePrice(BigDecimal.valueOf(105));\nSystem.out.println(pay2);\n\n// 使用Prime会员折扣:\nctx.setStrategy(new PrimeDiscountStrategy());\nBigDecimal pay3 = ctx.calculatePrice(BigDecimal.valueOf(105));\nSystem.out.println(pay3);\n```\n\n上述完整的策略模式如下图所示：\n\n```ascii\n┌───────────────┐      ┌─────────────────┐\n│DiscountContext│─ ─ ─>│DiscountStrategy │\n└───────────────┘      └─────────────────┘\n                                ▲\n                                │ ┌─────────────────────┐\n                                ├─│UserDiscountStrategy │\n                                │ └─────────────────────┘\n                                │ ┌─────────────────────┐\n                                ├─│PrimeDiscountStrategy│\n                                │ └─────────────────────┘\n                                │ ┌─────────────────────┐\n                                └─│OverDiscountStrategy │\n                                  └─────────────────────┘\n```\n\n策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。","tags":["DesignPatterns"]},{"title":"状态模式","url":"/2020/06/13/状态模式/","content":"\n#### 状态\n\n------\n\n> 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n>\n> <!--more-->\n\n**状态模式（State）**经常用在带有状态的对象中。\n\n什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：\n\n- 离线状态（尚未登录）；\n- 正在登录状态；\n- 在线状态；\n- 忙状态（暂时离开）。\n\n如何表示状态？我们定义一个`enum`就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：\n\n```java\nif (state == ONLINE) {\n    // 闪烁图标\n} else if (state == BUSY) {\n    reply(\"现在忙，稍后回复\");\n} else if ...\n```\n\n状态模式的目的是为了把上述一大串`if...else...`的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。\n\n例如，我们设计一个聊天机器人，它有两个状态：\n\n- 未连线；\n- 已连线。\n\n对于未连线状态，我们收到消息也不回复：\n\n```java\npublic class DisconnectedState implements State {\n    public String init() {\n        return \"Bye!\";\n    }\n\n    public String reply(String input) {\n        return \"\";\n    }\n}\n```\n\n对于已连线状态，我们回应收到的消息：\n\n```java\npublic class ConnectedState implements State {\n    public String init() {\n        return \"Hello, I'm Bob.\";\n    }\n\n    public String reply(String input) {\n        if (input.endsWith(\"?\")) {\n            return \"Yes. \" + input.substring(0, input.length() - 1) + \"!\";\n        }\n        if (input.endsWith(\".\")) {\n            return input.substring(0, input.length() - 1) + \"!\";\n        }\n        return input.substring(0, input.length() - 1) + \"?\";\n    }\n}\n```\n\n状态模式的关键设计思想在于状态切换，我们引入一个`BotContext`完成状态切换：\n\n```java\npublic class BotContext {\n\tprivate State state = new DisconnectedState();\n\n\tpublic String chat(String input) {\n\t\tif (\"hello\".equalsIgnoreCase(input)) {\n            // 收到hello切换到在线状态:\n\t\t\tstate = new ConnectedState();\n\t\t\treturn state.init();\n\t\t} else if (\"bye\".equalsIgnoreCase(input)) {\n            /  收到bye切换到离线状态:\n\t\t\tstate = new DisconnectedState();\n\t\t\treturn state.init();\n\t\t}\n\t\treturn state.reply(input);\n\t}\n}\n```\n\n这样，一个价值千万的AI聊天机器人就诞生了：\n\n```java\nScanner scanner = new Scanner(System.in);\nBotContext bot = new BotContext();\nfor (;;) {\n    System.out.print(\"> \");\n    String input = scanner.nextLine();\n    String output = bot.chat(input);\n    System.out.println(output.isEmpty() ? \"(no reply)\" : \"< \" + output);\n}\n```\n\n试试效果：\n\n```java\n> hello\n< Hello, I'm Bob.\n> Nice to meet you.\n< Nice to meet you!\n> Today is cold?\n< Yes. Today is cold!\n> bye\n< Bye!\n```","tags":["DesignPatterns"]},{"title":"观察者模式","url":"/2020/06/13/观察者模式/","content":"\n#### 观察者\n\n------\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n>\n> <!--more-->\n\n观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。\n\n要理解观察者模式，我们还是看例子。\n\n假设一个电商网站，有多种`Product`（商品），同时，`Customer`（消费者）和`Admin`（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，`Store`（商场）可以这么写：\n\n```java\npublic class Store {\n    Customer customer;\n    Admin admin;\n\n    private Map<String, Product> products = new HashMap<>();\n\n    public void addNewProduct(String name, double price) {\n        Product p = new Product(name, price);\n        products.put(p.getName(), p);\n        // 通知用户:\n        customer.onPublished(p);\n        // 通知管理员:\n        admin.onPublished(p);\n    }\n\n    public void setProductPrice(String name, double price) {\n        Product p = products.get(name);\n        p.setPrice(price);\n        // 通知用户:\n        customer.onPriceChanged(p);\n        // 通知管理员:\n        admin.onPriceChanged(p);\n    }\n}\n```\n\n我们观察上述`Store`类的问题：它直接引用了`Customer`和`Admin`。先不考虑多个`Customer`或多个`Admin`的问题，上述`Store`类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，`Store`类就必须继续改动。\n\n因此，上述问题的本质是`Store`希望发送通知给那些关心`Product`的对象，但`Store`并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。\n\n要实现这一目标也很简单，`Store`不能直接引用`Customer`和`Admin`，相反，它引用一个`ProductObserver`接口，任何人想要观察`Store`，只要实现该接口，并且把自己注册到`Store`即可：\n\n```java\npublic class Store {\n    private List<ProductObserver> observers = new ArrayList<>();\n    private Map<String, Product> products = new HashMap<>();\n\n    // 注册观察者:\n    public void addObserver(ProductObserver observer) {\n        this.observers.add(observer);\n    }\n\n    // 取消注册:\n    public void removeObserver(ProductObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    public void addNewProduct(String name, double price) {\n        Product p = new Product(name, price);\n        products.put(p.getName(), p);\n        // 通知观察者:\n        observers.forEach(o -> o.onPublished(p));\n    }\n\n    public void setProductPrice(String name, double price) {\n        Product p = products.get(name);\n        p.setPrice(price);\n        // 通知观察者:\n        observers.forEach(o -> o.onPriceChanged(p));\n    }\n}\n```\n\n就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：\n\n```java\n// observer:\nAdmin a = new Admin();\nCustomer c = new Customer();\n// store:\nStore store = new Store();\n// 注册观察者:\nstore.addObserver(a);\nstore.addObserver(c);\n```\n\n甚至可以注册匿名观察者：\n\n```java\nstore.addObserver(new ProductObserver() {\n    public void onPublished(Product product) {\n        System.out.println(\"[Log] on product published: \" + product);\n    }\n\n    public void onPriceChanged(Product product) {\n        System.out.println(\"[Log] on product price changed: \" + product);\n    }\n});\n```\n\n用一张图画出观察者模式：\n\n```ascii\n┌─────────┐      ┌───────────────┐\n│  Store  │─ ─ ─>│ProductObserver│\n└─────────┘      └───────────────┘\n     │                   ▲\n                         │\n     │             ┌─────┴─────┐\n     ▼             │           │\n┌─────────┐   ┌─────────┐ ┌─────────┐\n│ Product │   │  Admin  │ │Customer │ ...\n└─────────┘   └─────────┘ └─────────┘\n```\n\n观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：\n\n```java\npublic interface ProductObservable { // 注意此处拼写是Observable不是Observer!\n    void addObserver(ProductObserver observer);\n    void removeObserver(ProductObserver observer);\n}\n```\n\n对应的实体被观察者就要实现该接口：\n\n```java\npublic class Store implements ProductObservable {\n    ...\n}\n```\n\n有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：\n\n```java\npublic interface ProductObserver {\n    void onEvent(ProductEvent event);\n}\n```\n\n让观察者自己从Event对象中读取通知类型和通知数据。\n\n广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：\n\n```ascii\n                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n                   Messaging System\n                 │                       │\n                   ┌──────────────────┐\n              ┌──┼>│Topic:newProduct  │──┼─┐    ┌─────────┐\n              │    └──────────────────┘    ├───>│ConsumerA│\n┌─────────┐   │  │ ┌──────────────────┐  │ │    └─────────┘\n│Producer │───┼───>│Topic:priceChanged│────┘\n└─────────┘   │  │ └──────────────────┘  │\n              │    ┌──────────────────┐         ┌─────────┐\n              └──┼>│Topic:soldOut     │──┼─────>│ConsumerB│\n                   └──────────────────┘         └─────────┘\n                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\n消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。\n\n使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。\n\n此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：\n\n```java\nobservers.forEach(o -> o.onPublished(p));\n```\n\n这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。\n\n思考：如何改成异步通知，使得所有观察者可以并发同时处理？\n\n有的童鞋可能发现Java标准库有个`java.util.Observable`类和一个`Observer`接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。","tags":["DesignPatterns"]},{"title":"备忘录模式","url":"/2020/06/13/备忘录模式/","content":"\n#### 备忘录模式\n\n------\n\n> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n>\n> <!--more-->\n\n**备忘录模式（Memento）**，主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。\n\n其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把`TextEditor`类的字符串存储到文件，打开就是恢复`TextEditor`类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。\n\n在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把`TextEditor`类的字符串复制一份存起来，这样就可以Undo或Redo。\n\n标准的备忘录模式有这么几种角色：\n\n- Memonto：存储的内部状态；\n- Originator：创建一个备忘录并设置其状态；\n- Caretaker：负责保存备忘录。\n\n实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似`TextEditor`的类，增加`getState()`和`setState()`就可以了。\n\n我们以一个文本编辑器`TextEditor`为例，它内部使用`StringBuilder`允许用户增删字符：\n\n```java\npublic class TextEditor {\n    private StringBuilder buffer = new StringBuilder();\n\n    public void add(char ch) {\n        buffer.append(ch);\n    }\n\n    public void add(String s) {\n        buffer.append(s);\n    }\n\n    public void delete() {\n        if (buffer.length() > 0) {\n            buffer.deleteCharAt(buffer.length() - 1);\n        }\n    }\n}\n```\n\n为了支持这个`TextEditor`能保存和恢复状态，我们增加`getState()`和`setState()`两个方法：\n\n```java\npublic class TextEditor {\n    ...\n\n    // 获取状态:\n    public String getState() {\n        return buffer.toString();\n    }\n\n    // 恢复状态:\n    public void setState(String state) {\n        this.buffer.delete(0, this.buffer.length());\n        this.buffer.append(state);\n    }\n}\n```\n\n对这个简单的文本编辑器，用一个`String`就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。","tags":["DesignPatterns"]},{"title":"中介者模式","url":"/2020/06/13/中介者模式/","content":"\n# 中介者模式\n\n>  中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。\n>\n> <!--more-->\n\n## 介绍\n\n**意图：**用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n**主要解决：**对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。\n\n**何时使用：**多个类相互耦合，形成了网状结构。\n\n**如何解决：**将上述网状结构分离为星型结构。\n\n**关键代码：**对象 Colleague 之间的通信封装到一个类中单独处理。\n\n**应用实例：** 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。\n\n**优点：** 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。\n\n**缺点：**中介者会庞大，变得复杂难以维护。\n\n**使用场景：** 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。\n\n**注意事项：**不应当在职责混乱的时候使用。\n\n## 实现\n\n我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 *ChatRoom* 和 *User*。*User* 对象使用 *ChatRoom* 方法来分享他们的消息。\n\n*MediatorPatternDemo*，我们的演示类使用 *User* 对象来显示他们之间的通信。\n\n![中介者模式的 UML 图](1.jpg)\n\n### 步骤 1\n\n创建中介类。\n\nChatRoom.java\n\n![img](2.png)\n\n### 步骤 2\n\n创建 user 类。\n\nUser.java\n\n![img](3.png)\n\n### 步骤 3\n\n使用 *User* 对象来显示他们之间的通信。\n\nMediatorPatternDemo.java\n\n![img](4.png)\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```c\nThu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!\nThu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!\n```","tags":["DesignPatterns"]},{"title":"迭代器模式","url":"/2020/06/13/迭代器模式/","content":"\n### 迭代器\n\n------\n\n> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n>\n> <!--more-->\n\n**迭代器模式（Iterator）**实际上在Java的集合类中已经广泛使用了。我们以`List`为例，要遍历`ArrayList`，即使我们知道它的内部存储了一个`Object[]`数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用`Iterator`遍历，那么，`ArrayList`和`LinkedList`都可以以一种统一的接口来遍历：\n\n```java\nList<String> list = ...\nfor (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n    String s = it.next();\n}\n```\n\n实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持`Iterator`的集合对象用`foreach`循环写出来：\n\n```java\nList<String> list = ...\nfor (String s : list) {\n\n}\n```\n\n然后由Java编译器完成Iterator模式的所有循环代码。\n\n虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：\n\n```java\npublic class ReverseArrayCollection<T> implements Iterable<T> {\n    // 以数组形式持有集合:\n    private T[] array;\n\n    public ReverseArrayCollection(T... objs) {\n        this.array = Arrays.copyOfRange(objs, 0, objs.length);\n    }\n\n    public Iterator<T> iterator() {\n        return ???;\n    }\n}\n```\n\n实现Iterator模式的关键是返回一个`Iterator`对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个`Iterator`：\n\n```java\npublic class ReverseArrayCollection<T> implements Iterable<T> {\n    private T[] array;\n\n    public ReverseArrayCollection(T... objs) {\n        this.array = Arrays.copyOfRange(objs, 0, objs.length);\n    }\n\n    public Iterator<T> iterator() {\n        return new ReverseIterator();\n    }\n\n    class ReverseIterator implements Iterator<T> {\n        // 索引位置:\n        int index;\n\n        public ReverseIterator() {\n            // 创建Iterator时,索引在数组末尾:\n            this.index = ReverseArrayCollection.this.array.length;\n        }\n\n        public boolean hasNext() {\n            // 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):\n            return index > 0;\n        }\n\n        public T next() {\n            // 将索引移动到下一个元素并返回(倒序往前移动):\n            index--;\n            return array[index];\n        }\n    }\n}\n```\n\n使用内部类的好处是内部类隐含地持有一个它所在对象的`this`引用，可以通过`ReverseArrayCollection.this`引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出`ConcurrentModificationException`，就需要更仔细地设计。","tags":["DesignPatterns"]},{"title":"解释器模式","url":"/2020/06/12/解释器模式/","content":"\n# 解释器模式\n\n> 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n\n<!--more-->\n\n## 介绍\n\n**意图：**给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n\n**主要解决：**对于一些固定文法构建一个解释句子的解释器。\n\n**何时使用：**如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n**如何解决：**构建语法树，定义终结符与非终结符。\n\n**关键代码：**构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。\n\n**应用实例：**编译器、运算表达式计算。\n\n**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。\n\n**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。\n\n**使用场景：** 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。\n\n**注意事项：**可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。\n\n## 实现\n\n我们将创建一个接口 *Expression* 和实现了 *Expression* 接口的实体类。定义作为上下文中主要解释器的 *TerminalExpression* 类。其他的类 *OrExpression*、*AndExpression* 用于创建组合式表达式。\n\n*InterpreterPatternDemo*，我们的演示类使用 *Expression* 类创建规则和演示表达式的解析。\n\n![解释器模式的 UML 图](6.jpg)\n\n### 步骤 1\n\n创建一个表达式接口。\n\n![img](1.png)\n\n### 步骤 2\n\n创建实现了上述接口的实体类。\n\n![img](2.png)\n\n![img](3.png)\n\n![img](4.png)\n\n### 步骤 3\n\n*InterpreterPatternDemo* 使用 *Expression* 类来创建规则，并解析它们。\n\n![img](5.png)\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```\nJohn is male? true\nJulie is a married women? true\n```","tags":["DesignPatterns"]},{"title":"命令模式","url":"/2020/06/12/命令模式/","content":"\n## 命令模式\n\n> **命令模式（Command Pattern）**是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n\n<!--more-->\n\n### 介绍\n\n**意图：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n\n**主要解决：**在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n\n**何时使用：**在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n\n**如何解决：**通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n\n**关键代码：**定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n\n**应用实例：**struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n\n**优点：** \t1、降低了系统耦合度。 \n\n​\t\t\t\t2、新的命令可以很容易添加到系统中去。\n\n**缺点：**\t使用命令模式可能会导致某些系统有过多的具体命令类。\n\n**使用场景：**认为是命令的地方都可以使用命令模式，\n\n比如： \n\n​\t1、GUI 中每一个按钮都是一条命令。 \n\n​\t2、模拟 CMD。\n\n**注意事项：**系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n\n### 实现\n\n我们首先创建作为命令的接口 *Order*，然后创建作为请求的 *Stock* 类。实体命令类 *BuyStock* 和 *SellStock*，实现了 *Order* 接口，将执行实际的命令处理。创建作为调用对象的类 *Broker*，它接受订单并能下订单。\n\n*Broker* 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。*CommandPatternDemo*，我们的演示类使用 *Broker* 类来演示命令模式。\n\n![命令模式的 UML 图](1.jpg)\n\n#### 步骤1\n\n创建一个命令接口。\n\n##### Order.java\n\n```java\npublic interface Order {\n   void execute();\n}\n```\n\n#### 步骤 2\n\n创建一个请求类。\n\n##### Stock.java\n\n```java\npublic class Stock {\n   \n   private String name = \"ABC\";\n   private int quantity = 10;\n \n   public void buy(){\n      System.out.println(\"Stock [ Name: \"+name+\", \n         Quantity: \" + quantity +\" ] bought\");\n   }\n   public void sell(){\n      System.out.println(\"Stock [ Name: \"+name+\", \n         Quantity: \" + quantity +\" ] sold\");\n   }\n}\n```\n\n\n\n#### 步骤 3\n\n创建实现了 *Order* 接口的实体类。\n\n##### BuyStock.java\n\n```java\npublic class BuyStock implements Order {\n   private Stock abcStock;\n \n   public BuyStock(Stock abcStock){\n      this.abcStock = abcStock;\n   }\n \n   public void execute() {\n      abcStock.buy();\n   }\n}\n```\n\n\n\n##### SellStock.java\n\n```java\npublic class SellStock implements Order {\n   private Stock abcStock;\n \n   public SellStock(Stock abcStock){\n      this.abcStock = abcStock;\n   }\n \n   public void execute() {\n      abcStock.sell();\n   }\n}\n```\n\n\n\n#### 步骤 4\n\n创建命令调用类。\n\n##### Broker.java\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Broker {\n   private List<Order> orderList = new ArrayList<Order>(); \n \n   public void takeOrder(Order order){\n      orderList.add(order);      \n   }\n \n   public void placeOrders(){\n      for (Order order : orderList) {\n         order.execute();\n      }\n      orderList.clear();\n   }\n}\n```\n\n\n\n使用 Broker 类来接受并执行命令。\n\n##### CommandPatternDemo.java\n\n```java\npublic class CommandPatternDemo {\n   public static void main(String[] args) {\n      Stock abcStock = new Stock();\n \n      BuyStock buyStockOrder = new BuyStock(abcStock);\n      SellStock sellStockOrder = new SellStock(abcStock);\n \n      Broker broker = new Broker();\n      broker.takeOrder(buyStockOrder);\n      broker.takeOrder(sellStockOrder);\n \n      broker.placeOrders();\n   }\n}\n```\n\n\n\n#### 步骤 6\n\n执行程序，输出结果：\n\n```\nStock [ Name: ABC, Quantity: 10 ] bought\nStock [ Name: ABC, Quantity: 10 ] sold\n```","tags":["DesignPatterns"]},{"title":"责任链模式","url":"/2020/06/11/责任链模式/","content":"\n### 责任链模式\n\n> **责任链模式（Chain of Responsibility Pattern）**为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 \n\n<!--more-->\n\n### 介绍\n\n**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\n\n**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。\n\n**何时使用：**在处理消息的时候以过滤很多道。\n\n**如何解决：**拦截的类都实现统一接口。\n\n**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。\n\n**应用实例：** 1、红楼梦中的\"击鼓传花\"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。\n\n**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。\n\n**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。\n\n**使用场景：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。\n\n**注意事项：**在 JAVA WEB 中遇到很多应用。\n\n---\n\n## 实现\n\n我们创建抽象类 *AbstractLogger*，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 *AbstractLogger*。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。\n\n![责任链模式的 UML 图](1.jpg)\n\n### 步骤1\n\n创建抽象的记录器类。\n\n##### AbstractLogger.java\n\n```java\npublic abstract class AbstractLogger {\n   public static int INFO = 1;\n   public static int DEBUG = 2;\n   public static int ERROR = 3;\n \n   protected int level;\n \n   //责任链中的下一个元素\n   protected AbstractLogger nextLogger;\n \n   public void setNextLogger(AbstractLogger nextLogger){\n      this.nextLogger = nextLogger;\n   }\n \n   public void logMessage(int level, String message){\n      if(this.level <= level){\n         write(message);\n      }\n      if(nextLogger !=null){\n         nextLogger.logMessage(level, message);\n      }\n   }\n \n   abstract protected void write(String message);\n   \n}\n```\n\n\n\n### 步骤 2\n\n创建扩展了该记录器类的实体类。\n\n##### ConsoleLogger.java\n\n```java\npublic class ConsoleLogger extends AbstractLogger {\n \n   public ConsoleLogger(int level){\n      this.level = level;\n   }\n \n   @Override\n   protected void write(String message) {    \n      System.out.println(\"Standard Console::Logger: \" + message);\n   }\n}\n```\n\n\n\n##### ErrorLogger.java\n\n```java\npublic class ErrorLogger extends AbstractLogger {\n \n   public ErrorLogger(int level){\n      this.level = level;\n   }\n \n   @Override\n   protected void write(String message) {    \n      System.out.println(\"Error Console::Logger: \" + message);\n   }\n}\n```\n\n\n\n##### FileLogger.java\n\n```java\npublic class FileLogger extends AbstractLogger {\n \n   public FileLogger(int level){\n      this.level = level;\n   }\n \n   @Override\n   protected void write(String message) {    \n      System.out.println(\"File::Logger: \" + message);\n   }\n}\n```\n\n\n\n### 步骤 3\n\n创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。\n\n##### ChainPatternDemo.java\n\n```java\npublic class ChainPatternDemo {\n   \n   private static AbstractLogger getChainOfLoggers(){\n \n      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);\n      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);\n      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);\n \n      errorLogger.setNextLogger(fileLogger);\n      fileLogger.setNextLogger(consoleLogger);\n \n      return errorLogger;  \n   }\n \n   public static void main(String[] args) {\n      AbstractLogger loggerChain = getChainOfLoggers();\n \n      loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\");\n \n      loggerChain.logMessage(AbstractLogger.DEBUG, \n         \"This is a debug level information.\");\n \n      loggerChain.logMessage(AbstractLogger.ERROR, \n         \"This is an error information.\");\n   }\n}\n```\n\n\n\n### 步骤 4\n\n执行程序，输出结果：\n\n```java\nStandard Console::Logger: This is an information.\nFile::Logger: This is a debug level information.\nStandard Console::Logger: This is a debug level information.\nError Console::Logger: This is an error information.\nFile::Logger: This is an error information.\nStandard Console::Logger: This is an error information.\n```","tags":["DesignPatterns"]},{"title":"RESUME","url":"/2020/06/11/简历/","content":"\n# RESUME\n\n<!--more-->\n\n\n\n![img](0001.jpg)\n\n\n\n","tags":["resume"]},{"title":"代理模式","url":"/2020/06/09/代理模式/","content":"\n### 代理模式\n\n> *为其他对象提供一种代理以控制对这个对象的访问。* \n>\n> <!--more-->\n\n在**代理模式（Proxy Pattern）**中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。\n\n在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n\n\n## 介绍\n\n**意图：**为其他对象提供一种代理以控制对这个对象的访问。\n\n**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n\n**何时使用：**想在访问一个类时做一些控制。\n\n**如何解决：**增加中间层。\n\n**关键代码：**实现与被代理类组合。\n\n**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。\n\n**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。\n\n**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。\n\n**注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n## 实现\n\n我们将创建一个 *Image* 接口和实现了 *Image* 接口的实体类。*ProxyImage* 是一个代理类，减少 *RealImage* 对象加载的内存占用。\n\n*ProxyPatternDemo*，我们的演示类使用 *ProxyImage* 来获取要加载的 *Image* 对象，并按照需求进行显示。\n\n![代理模式的 UML 图](代理模式.jpg)\n\n\n\n- \n\n代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：\n\n```java\npublic BAdapter implements B {\n    private A a;\n    public BAdapter(A a) {\n        this.a = a;\n    }\n    public void b() {\n        a.a();\n    }\n}\n```\n\n而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：\n\n```java\npublic AProxy implements A {\n    private A a;\n    public AProxy(A a) {\n        this.a = a;\n    }\n    public void a() {\n        this.a.a();\n    }\n}\n```\n\n合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？\n\n当然不是。我们观察Proxy的实现A接口的方法：\n\n```java\npublic void a() {\n    this.a.a();\n}\n```\n\n这样写当然没啥卵用。但是，如果我们在调用`a.a()`的前后，加一些额外的代码：\n\n```java\npublic void a() {\n    if (getCurrentUser().isRoot()) {\n        this.a.a();\n    } else {\n        throw new SecurityException(\"Forbidden\");\n    }\n}\n```\n\n这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。\n\n有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？\n\n因为我们编写代码的原则有：\n\n- 职责清晰：一个类只负责一件事；\n- 易于测试：一次只测一个功能。\n\n用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：\n\n- A接口：只定义接口；\n- ABusiness类：只实现A接口的业务逻辑；\n- APermissionProxy类：只实现A接口的权限检查代理。\n\n如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。\n\n实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：\n\n### 远程代理\n\n远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。\n\n### 虚代理\n\n虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。\n\n### 保护代理\n\n保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。\n\n### 智能引用\n\n智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。\n\n我们来看一下如何应用代理模式编写一个JDBC连接池（`DataSource`）。我们首先来编写一个虚代理，即如果调用者获取到`Connection`后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：\n\n```java\nDataSource lazyDataSource = new LazyDataSource(jdbcUrl, jdbcUsername, jdbcPassword);\nSystem.out.println(\"get lazy connection...\");\ntry (Connection conn1 = lazyDataSource.getConnection()) {\n    // 并没有实际打开真正的Connection\n}\nSystem.out.println(\"get lazy connection...\");\ntry (Connection conn2 = lazyDataSource.getConnection()) {\n    try (PreparedStatement ps = conn2.prepareStatement(\"SELECT * FROM students\")) { // 打开了真正的Connection\n        try (ResultSet rs = ps.executeQuery()) {\n            while (rs.next()) {\n                System.out.println(rs.getString(\"name\"));\n            }\n        }\n    }\n}\n```\n\n现在我们来思考如何实现这个`LazyConnectionProxy`。为了简化代码，我们首先针对`Connection`接口做一个抽象的代理类：\n\n```java\npublic abstract class AbstractConnectionProxy implements Connection {\n\n    // 抽象方法获取实际的Connection:\n    protected abstract Connection getRealConnection();\n\n    // 实现Connection接口的每一个方法:\n    public Statement createStatement() throws SQLException {\n        return getRealConnection().createStatement();\n    }\n\n    public PreparedStatement prepareStatement(String sql) throws SQLException {\n        return getRealConnection().prepareStatement(sql);\n    }\n\n    ...其他代理方法...\n}\n```\n\n这个`AbstractConnectionProxy`代理类的作用是把`Connection`接口定义的方法全部实现一遍，因为`Connection`接口定义的方法太多了，后面我们要编写的`LazyConnectionProxy`只需要继承`AbstractConnectionProxy`，就不必再把`Connection`接口方法挨个实现一遍。\n\n`LazyConnectionProxy`实现如下：\n\n```java\npublic class LazyConnectionProxy extends AbstractConnectionProxy {\n    private Supplier<Connection> supplier;\n    private Connection target = null;\n\n    public LazyConnectionProxy(Supplier<Connection> supplier) {\n        this.supplier = supplier;\n    }\n\n    // 覆写close方法：只有target不为null时才需要关闭:\n    public void close() throws SQLException {\n        if (target != null) {\n            System.out.println(\"Close connection: \" + target);\n            super.close();\n        }\n    }\n\n    @Override\n    protected Connection getRealConnection() {\n        if (target == null) {\n            target = supplier.get();\n        }\n        return target;\n    }\n}\n```\n\n如果调用者没有执行任何SQL语句，那么`target`字段始终为`null`。只有第一次执行SQL语句时（即调用任何类似`prepareStatement()`方法时，触发`getRealConnection()`调用），才会真正打开实际的JDBC Connection。\n\n最后，我们还需要编写一个`LazyDataSource`来支持这个`LazyConnecitonProxy`：\n\n```java\npublic class LazyDataSource implements DataSource {\n    private String url;\n    private String username;\n    private String password;\n\n    public LazyDataSource(String url, String username, String password) {\n        this.url = url;\n        this.username = username;\n        this.password = password;\n    }\n\n    public Connection getConnection(String username, String password) throws SQLException {\n        return new LazyConnectionProxy(() -> {\n            try {\n                Connection conn = DriverManager.getConnection(url, username, password);\n                System.out.println(\"Open connection: \" + conn);\n                return conn;\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    ...\n}\n```\n\n我们执行代码，输出如下：\n\n```java\nget lazy connection...\nget lazy connection...\nOpen connection: com.mysql.jdbc.JDBC4Connection@7a36aefa\n小明\n小红\n小军\n小白\n...\nClose connection: com.mysql.jdbc.JDBC4Connection@7a36aefa\n```\n\n可见第一个`getConnection()`调用获取到的`LazyConnectionProxy`并没有实际打开真正的JDBC Connection。\n\n使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：\n\n```java\nDataSource pooledDataSource = new PooledDataSource(jdbcUrl, jdbcUsername, jdbcPassword);\ntry (Connection conn = pooledDataSource.getConnection()) {\n}\ntry (Connection conn = pooledDataSource.getConnection()) {\n    // 获取到的是同一个Connection\n}\ntry (Connection conn = pooledDataSource.getConnection()) {\n    // 获取到的是同一个Connection\n}\n```\n\n调用方并不关心是否复用了`Connection`，但从`PooledDataSource`获取的`Connection`确实自带这个优化功能。如何实现可复用`Connection`的连接池？答案仍然是使用代理模式。\n\n```java\npublic class PooledConnectionProxy extends AbstractConnectionProxy {\n    // 实际的Connection:\n    Connection target;\n    // 空闲队列:\n    Queue<PooledConnectionProxy> idleQueue;\n\n    public PooledConnectionProxy(Queue<PooledConnectionProxy> idleQueue, Connection target) {\n        this.idleQueue = idleQueue;\n        this.target = target;\n    }\n\n    public void close() throws SQLException {\n        System.out.println(\"Fake close and released to idle queue for future reuse: \" + target);\n        // 并没有调用实际Connection的close()方法,\n        // 而是把自己放入空闲队列:\n        idleQueue.offer(this);\n    }\n\n    protected Connection getRealConnection() {\n        return target;\n    }\n}\n```\n\n复用连接的关键在于覆写`close()`方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。\n\n空闲队列由`PooledDataSource`负责维护：\n\n```java\npublic class PooledDataSource implements DataSource {\n    private String url;\n    private String username;\n    private String password;\n\n    // 维护一个空闲队列:\n    private Queue<PooledConnectionProxy> idleQueue = new ArrayBlockingQueue<>(100);\n\n    public PooledDataSource(String url, String username, String password) {\n        this.url = url;\n        this.username = username;\n        this.password = password;\n    }\n\n    public Connection getConnection(String username, String password) throws SQLException {\n        // 首先试图获取一个空闲连接:\n        PooledConnectionProxy conn = idleQueue.poll();\n        if (conn == null) {\n            // 没有空闲连接时，打开一个新连接:\n            conn = openNewConnection();\n        } else {\n            System.out.println(\"Return pooled connection: \" + conn.target);\n        }\n        return conn;\n    }\n\n    private PooledConnectionProxy openNewConnection() throws SQLException {\n        Connection conn = DriverManager.getConnection(url, username, password);\n        System.out.println(\"Open new connection: \" + conn);\n        return new PooledConnectionProxy(idleQueue, conn);\n    }\n    ...\n}\n```\n\n我们执行调用方代码，输出如下：\n\n```shell\nOpen new connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nFake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nReturn pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nFake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nReturn pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa\nFake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa\n```\n\n除了第一次打开了一个真正的JDBC Connection，后续获取的`Connection`实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。\n\n我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。\n\n有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。\n\n\n\n\n\n","tags":["DesignPatterns"]},{"title":"享元模式","url":"/2020/06/09/享元模式/","content":"\n### 享元\n\n> *运用共享技术有效地支持大量细粒度的对象。* \n>\n> <!--more-->\n\n享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。\n\n享元模式在Java标准库中有很多应用。我们知道，包装类型如`Byte`、`Integer`都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以`Integer`为例，如果我们通过`Integer.valueOf()`这个静态工厂方法创建`Integer`实例，当传入的`int`范围在`-128`~`+127`之间时，会直接返回缓存的`Integer`实例：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Integer n1 = Integer.valueOf(100);\n        Integer n2 = Integer.valueOf(100);\n        System.out.println(n1 == n2); // true\n    }\n}\n```\n\n对于`Byte`来说，因为它一共只有256个状态，所以，通过`Byte.valueOf()`创建的`Byte`实例，全部都是缓存对象。\n\n因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。\n\n**总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。**\n\n在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。\n\n我们以`Student`为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：\n\n```java\npublic class Student {\n    // 持有缓存:\n    private static final Map<String, Student> cache = new HashMap<>();\n\n    // 静态工厂方法:\n    public static Student create(int id, String name) {\n        String key = id + \"\\n\" + name;\n        // 先查找缓存:\n        Student std = cache.get(key);\n        if (std == null) {\n            // 未找到,创建新对象:\n            System.out.println(String.format(\"create new Student(%s, %s)\", id, name));\n            std = new Student(id, name);\n            // 放入缓存:\n            cache.put(key, std);\n        } else {\n            // 缓存中存在:\n            System.out.println(String.format(\"return cached Student(%s, %s)\", std.id, std.name));\n        }\n        return std;\n    }\n\n    private final int id;\n    private final String name;\n\n    public Student(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n 在实际应用中，我们经常使用成熟的缓存库，例如`Guava`的`Cache`，因为它提供了最大缓存数量限制、定时过期等实用功能。 \n\n","tags":["DesignPatterns"]},{"title":"外观模式","url":"/2020/06/09/外观模式/","content":"\n### 外观模式\n\n> 为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n>\n> <!--more-->\n\n外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：\n\n如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。\n\n我们以注册公司为例，假设注册公司需要三步：\n\n1. 向工商局申请公司营业执照；\n2. 在银行开设账户；\n3. 在税务局开设纳税号。\n\n以下是三个系统的接口：\n\n```java\n// 工商注册:\npublic class AdminOfIndustry {\n    public Company register(String name) {\n        ...\n    }\n}\n\n// 银行开户:\npublic class Bank {\n    public String openAccount(String companyId) {\n        ...\n    }\n}\n\n// 纳税登记:\npublic class Taxation {\n    public String applyTaxCode(String companyId) {\n        ...\n    }\n}\n```\n\n如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：\n\n```java\npublic class Facade {\n    public Company openCompany(String name) {\n        Company c = this.admin.register(name);\n        String bankAccount = this.bank.openAccount(c.getId());\n        c.setBankAccount(bankAccount);\n        String taxCode = this.taxation.applyTaxCode(c.getId());\n        c.setTaxCode(taxCode);\n        return c;\n    }\n}\n```\n\n这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：\n\n```java\nCompany c = facade.openCompany(\"Facade Software Ltd.\");\n```\n\n很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个`RestApiController`，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。\n\n更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。","tags":["DesignPatterns"]},{"title":"装饰器模式","url":"/2020/06/09/装饰器模式/","content":"\n### 装饰器模式\n\n> 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。\n>\n> <!--more-->\n\n**装饰器（Decorator）**模式，是一种在运行期动态给某个对象的实例增加功能的方法。\n\n我们在IO的Filter模式一节中其实已经讲过装饰器模式了。在Java标准库中，`InputStream`是抽象类，`FileInputStream`、`ServletInputStream`、`Socket.getInputStream()`这些`InputStream`都是最终数据源。\n\n现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。\n\nDecorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。\n\n例如：给`FileInputStream`增加缓冲和解压缩功能，用Decorator模式写出来如下：\n\n```java\n// 创建原始的数据源:\nInputStream fis = new FileInputStream(\"test.gz\");\n// 增加缓冲功能:\nInputStream bis = new BufferedInputStream(fis);\n// 增加解压缩功能:\nInputStream gis = new GZIPInputStream(bis);\n```\n\n或者一次性写成这样：\n\n```java\nInputStream input = new GZIPInputStream( // 第二层装饰\n                        new BufferedInputStream( // 第一层装饰\n                            new FileInputStream(\"test.gz\") // 核心功能\n                        ));\n```\n\n观察`BufferedInputStream`和`GZIPInputStream`，它们实际上都是从`FilterInputStream`继承的，这个`FilterInputStream`就是一个抽象的Decorator。我们用图把Decorator模式画出来如下：\n\n```ascii\n             ┌───────────┐\n             │ Component │\n             └───────────┘\n                   ▲\n      ┌────────────┼─────────────────┐\n      │            │                 │\n┌───────────┐┌───────────┐     ┌───────────┐\n│ComponentA ││ComponentB │...  │ Decorator │\n└───────────┘└───────────┘     └───────────┘\n                                     ▲\n                              ┌──────┴──────┐\n                              │             │\n                        ┌───────────┐ ┌───────────┐\n                        │DecoratorA │ │DecoratorB │...\n                        └───────────┘ └───────────┘\n```\n\n最顶层的Component是接口，对应到IO的就是`InputStream`这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是`FileInputStream`、`ServletInputStream`这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是`FilterInputStream`。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是`BufferedInputStream`、`GZIPInputStream`等。\n\nDecorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指`FileInputStream`这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如`ByteInputStream`。如果我们要增加附加功能，就增加Decorator的子类，例如`CipherInputStream`。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。\n\n如果我们要自己设计完整的Decorator模式，应该如何设计？\n\n我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。\n\n首先，仍然需要定义顶层接口`TextNode`：\n\n```java\npublic interface TextNode {\n    // 设置text:\n    void setText(String text);\n    // 获取text:\n    String getText();\n}\n```\n\n对于核心节点，例如``，它需要从`TextNode`直接继承：\n\n```java\npublic class SpanNode implements TextNode {\n    private String text;\n\n    public void setText(String text) {\n        this.text = text;\n    }\n\n    public String getText() {\n        return \"<span>\" + text + \"</span>\";\n    }\n}\n```\n\n紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：\n\n```java\npublic abstract class NodeDecorator implements TextNode {\n    protected final TextNode target;\n\n    protected NodeDecorator(TextNode target) {\n        this.target = target;\n    }\n\n    public void setText(String text) {\n        this.target.setText(text);\n    }\n}\n```\n\n这个`NodeDecorator`类的核心是持有一个`TextNode`，即将要把功能附加到的`TextNode`实例。接下来就可以写一个加粗功能：\n\n```java\npublic class BoldDecorator extends NodeDecorator {\n    public BoldDecorator(TextNode target) {\n        super(target);\n    }\n\n    public String getText() {\n        return \"<b>\" + target.getText() + \"</b>\";\n    }\n}\n```\n\n类似的，可以继续加`ItalicDecorator`、`UnderlineDecorator`等。客户端可以自由组合这些Decorator：\n\n```java\nTextNode n1 = new SpanNode();\nTextNode n2 = new BoldDecorator(new UnderlineDecorator(new SpanNode()));\nTextNode n3 = new ItalicDecorator(new BoldDecorator(new SpanNode()));\nn1.setText(\"Hello\");\nn2.setText(\"Decorated\");\nn3.setText(\"World\");\nSystem.out.println(n1.getText());\n// 输出<span>Hello</span>\n\nSystem.out.println(n2.getText());\n// 输出<b><u><span>Decorated</span></u></b>\n\nSystem.out.println(n3.getText());\n// 输出<i><b><span>World</span></b></i>\n```","tags":["DesignPatterns"]},{"title":"组合模式","url":"/2020/06/09/组合模式/","content":"\n### 组合模式\n\n> 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。\n>\n> <!--more-->\n\n组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。\n\n我们来看一个具体的例子。在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。\n\n要以树的结构表示XML，我们可以先抽象出节点类型`Node`：\n\n```java\npublic interface Node {\n    // 添加一个节点为子节点:\n    Node add(Node node);\n    // 获取子节点:\n    List<Node> children();\n    // 输出为XML:\n    String toXml();\n}\n```\n\n对于一个`这样的节点，我们称之为` **`ElementNode`**，它可以作为容器包含多个子节点：\n\n```java\npublic class ElementNode implements Node {\n    private String name;\n    private List<Node> list = new ArrayList<>();\n\n    public ElementNode(String name) {\n        this.name = name;\n    }\n\n    public Node add(Node node) {\n        list.add(node);\n        return this;\n    }\n\n    public List<Node> children() {\n        return list;\n    }\n\n    public String toXml() {\n        String start = \"<\" + name + \">\\n\";\n        String end = \"</\" + name + \">\\n\";\n        StringJoiner sj = new StringJoiner(\"\", start, end);\n        list.forEach(node -> {\n            sj.add(node.toXml() + \"\\n\");\n        });\n        return sj.toString();\n    }\n}\n```\n\n对于普通文本，我们把它看作`TextNode`，它没有子节点：\n\n```java\npublic class TextNode implements Node {\n\tprivate String text;\n\n\tpublic TextNode(String text) {\n\t\tthis.text = text;\n\t}\n\n\tpublic Node add(Node node) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tpublic List<Node> children() {\n\t\treturn List.of();\n\t}\n\n\tpublic String toXml() {\n\t\treturn text;\n\t}\n}\n```\n\n此外，还可以有注释节点：\n\n```java\npublic class CommentNode implements Node {\n\tprivate String text;\n\n\tpublic CommentNode(String text) {\n\t\tthis.text = text;\n\t}\n\n\tpublic Node add(Node node) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tpublic List<Node> children() {\n\t\treturn List.of();\n\t}\n\n\tpublic String toXml() {\n\t\treturn \"<!-- \" + text + \" -->\";\n\t}\n}\n```\n\n通过`ElementNode`、`TextNode`和`CommentNode`，我们就可以构造出一颗树：\n\n```java\nNode root = new ElementNode(\"school\");\nroot.add(new ElementNode(\"classA\")\n        .add(new TextNode(\"Tom\"))\n        .add(new TextNode(\"Alice\")));\nroot.add(new ElementNode(\"classB\")\n        .add(new TextNode(\"Bob\"))\n        .add(new TextNode(\"Grace\"))\n        .add(new CommentNode(\"comment...\")));\nSystem.out.println(root.toXml());\n```\n\n最后通过`root`节点输出的XML如下：\n\n```xml\n<school>\n<classA>\nTom\nAlice\n</classA>\n<classB>\nBob\nGrace\n<!-- comment... -->\n</classB>\n</school>\n```\n\n可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：\n\n```ascii\n             ┌───────────┐\n             │   Node    │\n             └───────────┘\n                   ▲\n      ┌────────────┼────────────┐\n      │            │            │\n┌───────────┐┌───────────┐┌───────────┐\n│ElementNode││ TextNode  ││CommentNode│\n└───────────┘└───────────┘└───────────┘\n```\n\n作为容器节点的`ElementNode`又可以添加任意个`Node`，这样就可以构成层级结构。\n\n类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。","tags":["DesignPatterns"]},{"title":"桥接模式","url":"/2020/06/09/桥接模式/","content":"\n### 桥接模式\n\n>  *将抽象部分与它的实现部分分离，使它们都可以独立地变化。* \n>\n> <!--more-->\n\n假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：\n\n```ascii\n                   ┌───────┐\n                   │  Car  │\n                   └───────┘\n                       ▲\n    ┌──────────────────┼───────────────────┐\n    │                  │                   │\n┌───────┐          ┌───────┐          ┌───────┐\n│BigCar │          │TinyCar│          │BossCar│\n└───────┘          └───────┘          └───────┘\n    ▲                  ▲                  ▲\n    │                  │                  │\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │\n    │ └───────────────┘│ └───────────────┘│ └───────────────┘\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│\n    │ └───────────────┘│ └───────────────┘│ └───────────────┘\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │\n      └───────────────┘  └───────────────┘  └───────────────┘\n```\n\n如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。\n\n所以，桥接模式就是为了避免直接继承带来的**子类爆炸**。\n\n我们来看看**桥接模式**如何解决上述问题。\n\n在桥接模式中，首先把`Car`按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。\n\n首先定义抽象类`Car`，它引用一个`Engine`：\n\n```java\npublic abstract class Car {\n    // 引用Engine:\n    protected Engine engine;\n\n    public Car(Engine engine) {\n        this.engine = engine;\n    }\n\n    public abstract void drive();\n}\n```\n\n`Engine`的定义如下：\n\n```java\npublic interface Engine {\n    void start();\n}\n```\n\n紧接着，在一个“修正”的抽象类`RefinedCar`中定义一些额外操作：\n\n```java\npublic abstract class RefinedCar extends Car {\n    public RefinedCar(Engine engine) {\n        super(engine);\n    }\n\n    public void drive() {\n        this.engine.start();\n        System.out.println(\"Drive \" + getBrand() + \" car...\");\n    }\n\n    public abstract String getBrand();\n}\n```\n\n这样一来，最终的不同品牌继承自`RefinedCar`，例如`BossCar`：\n\n```java\npublic class BossCar extends RefinedCar {\n    public BossCar(Engine engine) {\n        super(engine);\n    }\n\n    public String getBrand() {\n        return \"Boss\";\n    }\n}\n```\n\n而针对每一种引擎，继承自`Engine`，例如`HybridEngine`：\n\n```java\npublic class HybridEngine implements Engine {\n    public void start() {\n        System.out.println(\"Start Hybrid Engine...\");\n    }\n}\n```\n\n客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：\n\n```java\nRefinedCar car = new BossCar(new HybridEngine());\ncar.drive();\n```\n\n使用桥接模式的好处在于，如果要增加一种引擎，只需要针对`Engine`派生一个新的子类，如果要增加一个品牌，只需要针对`RefinedCar`派生一个子类，任何`RefinedCar`的子类都可以和任何一种`Engine`自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。\n\n```ascii\n       ┌───────────┐\n       │    Car    │\n       └───────────┘\n             ▲\n             │\n       ┌───────────┐       ┌─────────┐\n       │RefinedCar │ ─ ─ ─>│ Engine  │\n       └───────────┘       └─────────┘\n             ▲                  ▲\n    ┌────────┼────────┐         │ ┌──────────────┐\n    │        │        │         ├─│  FuelEngine  │\n┌───────┐┌───────┐┌───────┐     │ └──────────────┘\n│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐\n└───────┘└───────┘└───────┘     ├─│ElectricEngine│\n                                │ └──────────────┘\n                                │ ┌──────────────┐\n                                └─│ HybridEngine │\n                                  └──────────────┘\n```\n\n桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。","tags":["DesignPatterns"]},{"title":"HTTP协议","url":"/2020/06/09/HTTP协议/"},{"title":"适配器模式","url":"/2020/06/08/适配器模式/","content":"\n### 适配器模式\n\n> *将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。* \n>\n> <!--more-->\n\n适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？\n\n我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：\n\n![adapter](1.png)\n\n```java\npublic class Task implements Callable<Long> {\n    private long num;\n    public Task(long num) {\n        this.num = num;\n    }\n\n    public Long call() throws Exception {\n        long r = 0;\n        for (long n = 1; n <= this.num; n++) {\n            r = r + n;\n        }\n        System.out.println(\"Result: \" + r);\n        return r;\n    }\n}\n```\n\n现在，我们想通过一个线程去执行它：\n\n```java\nCallable<Long> callable = new Task(123450000L);\nThread thread = new Thread(callable); // compile error!\nthread.start();\n```\n\n发现编译不过！因为`Thread`接收`Runnable`接口，但不接收`Callable`接口，肿么办？\n\n一个办法是改写`Task`类，把实现的`Callable`改为`Runnable`，但这样做不好，因为`Task`很可能在其他地方作为`Callable`被引用，改写`Task`的接口，会导致其他正常工作的代码无法编译。\n\n另一个办法不用改写`Task`类，而是用一个Adapter，把这个`Callable`接口“变成”`Runnable`接口，这样，就可以正常编译：\n\n```java\nCallable<Long> callable = new Task(123450000L);\nThread thread = new Thread(new RunnableAdapter(callable));\nthread.start();\n```\n\n这个`RunnableAdapter`类就是Adapter，它接收一个`Callable`，输出一个`Runnable`。怎么实现这个`RunnableAdapter`呢？我们先看完整的代码：\n\n```java\npublic class RunnableAdapter implements Runnable {\n    // 引用待转换接口:\n    private Callable<?> callable;\n\n    public RunnableAdapter(Callable<?> callable) {\n        this.callable = callable;\n    }\n\n    // 实现指定接口:\n    public void run() {\n        // 将指定接口调用委托给转换接口调用:\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n编写一个Adapter的步骤如下：\n\n1. 实现目标接口，这里是`Runnable`；\n2. 内部持有一个待转换接口的引用，这里是通过字段持有`Callable`接口；\n3. 在目标接口的实现方法内部，调用待转换接口的方法。\n\n这样一来，Thread就可以接收这个`RunnableAdapter`，因为它实现了`Runnable`接口。`Thread`作为调用方，它会调用`RunnableAdapter`的`run()`方法，在这个`run()`方法内部，又调用了`Callable`的`call()`方法，相当于`Thread`通过一层转换，间接调用了`Callable`的`call()`方法。\n\n适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是`String[]`，但是需要`List`接口时，可以用一个Adapter：\n\n```java\nString[] exist = new String[] {\"Good\", \"morning\", \"Bob\", \"and\", \"Alice\"};\nSet<String> set = new HashSet<>(Arrays.asList(exist));\n```\n\n注意到`List Arrays.asList(T[])`就相当于一个转换器，它可以把数组转换为`List`。\n\n我们再看一个例子：假设我们持有一个`InputStream`，希望调用`readText(Reader)`方法，但它的参数类型是`Reader`而不是`InputStream`，怎么办？\n\n当然是使用适配器，把`InputStream`“变成”`Reader`：\n\n```java\nInputStream input = Files.newInputStream(Paths.get(\"/path/to/file\"));\nReader reader = new InputStreamReader(input, \"UTF-8\");\nreadText(reader);\n```\n\n`InputStreamReader`就是Java标准库提供的`Adapter`，它负责把一个`InputStream`适配为`Reader`。类似的还有`OutputStreamWriter`。\n\n如果我们把`readText(Reader)`方法参数从`Reader`改为`FileReader`，会有什么问题？这个时候，因为我们需要一个`FileReader`类型，就必须把`InputStream`适配为`FileReader`：\n\n```java\nFileReader reader = new InputStreamReader(input, \"UTF-8\"); // compile error!\n```\n\n直接使用`InputStreamReader`这个Adapter是不行的，因为它只能转换出`Reader`接口。事实上，要把`InputStream`转换为`FileReader`也不是不可能，但需要花费十倍以上的功夫。这时，**面向抽象编程**这一原则就体现出了威力：**持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。**\n\n","tags":["DesignPatterns"]},{"title":"原型","url":"/2020/06/08/原型/","content":"\n### 原型\n\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n>\n> <!--more-->\n\n**原型模式**，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。\n\n我们举个例子：如果我们已经有了一个`String[]`数组，想再创建一个一模一样的`String[]`数组，怎么写？\n\n实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：\n\n```java\n// 原型:\nString[] original = { \"Apple\", \"Pear\", \"Banana\" };\n// 新对象:\nString[] copy = Arrays.copyOf(original, original.length);\n```\n\n对于普通类，我们如何实现原型拷贝？Java的`Object`提供了一个`clone()`方法，它的意图就是复制一个新的对象出来，我们需要实现一个`Cloneable`接口来标识一个对象是“可复制”的：\n\n```java\npublic class Employee implements Cloneable {\n    private int id;\n    private String name;\n    private int score;\n\n    // 复制新对象并返回:\n    public Object clone() {\n        Employee employee = new Employee();\n        employee.id = this.id;\n        employee.name = this.name;\n        employee.score = this.score;\n        return employee;\n    }\n}\n```\n\n使用的时候，因为`clone()`的方法签名是定义在`Object`中，返回类型也是`Object`，所以要强制转型，比较麻烦：\n\n```java\nEmployee employee = new Employee();\nemployee.setId(123);\nemployee.setName(\"Bob\");\nemployee.setScore(88);\n// 复制新对象:\nEmployee employee2 = (Employee) employee.clone();\nSystem.out.println(employee);\nSystem.out.println(employee2);\nSystem.out.println(employee == employee2); // false\n```\n\n实际上，使用原型模式更好的方式是定义一个`copy()`方法，返回明确的类型：\n\n```java\npublic class Employee {\n    private int id;\n    private String name;\n    private int score;\n\n    public Employee copy() {\n        Student employee = new Employee();\n        employee.id = this.id;\n        employee.name = this.name;\n        employee.score = this.score;\n        return employee;\n    }\n}\n```\n\n原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。","tags":["DesignPatterns"]},{"title":"生成器","url":"/2020/06/08/生成器/","content":"\n### 生成器\n\n> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 \n>\n> <!--more-->\n\n**生成器模式（Builder）**是使用多个“小型”工厂来最终创建出一个完整对象。\n\n当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。\n\n##### 使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。\n\nJavaMail的`MimeMessage`就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是`MimeMessage`：\n\n```\nMultipart multipart = new MimeMultipart();\n// 添加text:\nBodyPart textpart = new MimeBodyPart();\ntextpart.setContent(body, \"text/html;charset=utf-8\");\nmultipart.addBodyPart(textpart);\n// 添加image:\nBodyPart imagepart = new MimeBodyPart();\nimagepart.setFileName(fileName);\nimagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, \"application/octet-stream\")));\nmultipart.addBodyPart(imagepart);\n\nMimeMessage message = new MimeMessage(session);\n// 设置发送方地址:\nmessage.setFrom(new InternetAddress(\"me@example.com\"));\n// 设置接收方地址:\nmessage.setRecipient(Message.RecipientType.TO, new InternetAddress(\"xiaoming@somewhere.com\"));\n// 设置邮件主题:\nmessage.setSubject(\"Hello\", \"UTF-8\");\n// 设置邮件内容为multipart:\nmessage.setContent(multipart);\n```\n\n##### 很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：\n\n```\nStringBuilder builder = new StringBuilder();\nbuilder.append(secure ? \"https://\" : \"http://\")\n       .append(\"www.liaoxuefeng.com\")\n       .append(\"/\")\n       .append(\"?t=0\");\nString url = builder.toString();\n```\n\n##### 由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：\n\n```\nString url = URLBuilder.builder() // 创建Builder\n        .setDomain(\"www.liaoxuefeng.com\") // 设置domain\n        .setScheme(\"https\") // 设置scheme\n        .setPath(\"/\") // 设置路径\n        .setQuery(Map.of(\"a\", \"123\", \"q\", \"K&R\")) // 设置query\n        .build(); // 完成build\n```","tags":["DesignPatterns"]},{"title":"工厂设计模式","url":"/2020/06/06/工厂设计模式/","content":"\n## 工厂设计模式\n\n### 工厂方法\n\n工厂方法即Factory Method，是一种对象创建型模式。\n\n<!--more-->\n\n工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：\n\n```ascii\n┌─────────────┐      ┌─────────────┐\n│   Product   │      │   Factory   │\n└─────────────┘      └─────────────┘\n       ▲                    ▲\n       │                    │\n┌─────────────┐      ┌─────────────┐\n│ ProductImpl │<─ ─ ─│ FactoryImpl │\n└─────────────┘      └─────────────┘\n```\n\n 例如实现一个解析字符串到`Number`的`Factory`，可以定义如下： \n\n```java\npublic class NumberFactoryImpl implements NumberFactory {\n    public Number parse(String s) {\n        return new BigDecimal(s);\n    }\n}\n```\n\n而产品接口是`Number`，`NumberFactoryImpl`返回的实际产品是`BigDecimal`。\n\n那么客户端如何创建`NumberFactoryImpl`呢？通常我们会在接口`Factory`中定义一个静态方法`getFactory()`来返回真正的子类：\n\n```java\npublic interface NumberFactory {\n    // 创建方法:\n    Number parse(String s);\n    // 获取工厂实例:\n    static NumberFactory getFactory() {\n        return impl;\n    }\n    static NumberFactory impl = new NumberFactoryImpl();\n}\n```\n\n 在客户端中，我们只需要和工厂接口`NumberFactory`以及抽象产品`Number`打交道： \n\n```java\nNumberFactory factory = NumberFactory.getFactory();\nNumber result = factory.parse(\"123.456\");\n```\n\n 调用方可以完全忽略真正的工厂`NumberFactoryImpl`和实际的产品`BigDecimal`，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。 \n\n 实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即： \n\n```java\npublic class NumberFactory {\n    public static Number parse(String s) {\n        return new BigDecimal(s);\n    }\n}\n```\n\n这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：\n\n```java\nInteger n = Integer.valueOf(100);\n```\n\n`Integer`既是产品又是静态工厂。它提供了静态方法`valueOf()`来创建`Integer`。那么这种方式和直接写`new Integer(100)`有何区别呢？我们观察`valueOf()`方法：\n\n```java\npublic final class Integer {\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n    ...\n}\n```\n\n它的好处在于，`valueOf()`内部可能会使用`new`创建一个新的`Integer`实例，但也可能直接返回一个缓存的`Integer`实例。对于调用方来说，没必要知道`Integer`创建的细节。\n\n> 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。\n\n如果调用方直接使用`Integer n = new Integer(100)`，那么就失去了使用缓存优化的可能性。\n\n我们经常使用的另一个静态工厂方法是`List.of()`：\n\n```java\nList<String> list = List.of(\"A\", \"B\", \"C\");\n```\n\n这个静态工厂方法接收可变参数，然后返回`List`接口。需要注意的是，调用方获取的产品总是`List`接口，而且并不关心它的实际类型。即使调用方知道`List`产品的实际类型是`java.util.ImmutableCollections$ListN`，也不要去强制转型为子类，因为静态工厂方法`List.of()`保证返回`List`，但也完全可以修改为返回`java.util.ArrayList`。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。\n\n> 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。\n\n和`List.of()`类似，我们使用`MessageDigest`时，为了创建某个摘要算法，总是使用静态工厂方法`getInstance(String)`：\n\n```java\nMessageDigest md5 = MessageDigest.getInstance(\"MD5\");\nMessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n```\n\n调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是`MessageDigest`这个抽象类。\n\n### 抽象工厂\n\n>  *提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。* \n\n抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。\n\n抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：\n\n```ascii\n                                ┌────────┐\n                             ─ >│ProductA│\n┌────────┐    ┌─────────┐   │   └────────┘\n│ Client │─ ─>│ Factory │─ ─\n└────────┘    └─────────┘   │   ┌────────┐\n                   ▲         ─ >│ProductB│\n           ┌───────┴───────┐    └────────┘\n           │               │\n      ┌─────────┐     ┌─────────┐\n      │Factory1 │     │Factory2 │\n      └─────────┘     └─────────┘\n           │   ┌─────────┐ │   ┌─────────┐\n            ─ >│ProductA1│  ─ >│ProductA2│\n           │   └─────────┘ │   └─────────┘\n               ┌─────────┐     ┌─────────┐\n           └ ─>│ProductB1│ └ ─>│ProductB2│\n               └─────────┘     └─────────┘\n```\n\n这种模式有点类似于多个供应商负责提供一系列类型的产品。我们举个例子：\n\n假设我们希望为用户提供一个Markdown文本转换为HTML和Word的服务，它的接口定义如下：\n\n```java\npublic interface AbstractFactory {\n    // 创建Html文档:\n    HtmlDocument createHtml(String md);\n    // 创建Word文档:\n    WordDocument createWord(String md);\n}\n```\n\n注意到上面的抽象工厂仅仅是一个接口，没有任何代码。同样的，因为`HtmlDocument`和`WordDocument`都比较复杂，现在我们并不知道如何实现它们，所以只有接口：\n\n```java\n// Html文档接口:\npublic interface HtmlDocument {\n    String toHtml();\n    void save(Path path) throws IOException;\n}\n\n// Word文档接口:\npublic interface WordDocument {\n    void save(Path path) throws IOException;\n}\n```\n\n这样，我们就定义好了抽象工厂（`AbstractFactory`）以及两个抽象产品（`HtmlDocument`和`WordDocument`）。因为实现它们比较困难，我们决定让供应商来完成。\n\n现在市场上有两家供应商：FastDoc Soft的产品便宜，并且转换速度快，而GoodDoc Soft的产品贵，但转换效果好。我们决定同时使用这两家供应商的产品，以便给免费用户和付费用户提供不同的服务。\n\n我们先看看FastDoc Soft的产品是如何实现的。首先，FastDoc Soft必须要有实际的产品，即`FastHtmlDocument`和`FastWordDocument`：\n\n```java\npublic class FastHtmlDocument implements HtmlDocument {\n    public String toHtml() {\n        ...\n    }\n    public void save(Path path) throws IOException {\n        ...\n    }\n}\n\npublic class FastWordDocument implements WordDocument {\n    public void save(Path path) throws IOException {\n        ...\n    }\n}\n```\n\n然后，FastDoc Soft必须提供一个实际的工厂来生产这两种产品，即`FastFactory`：\n\n```java\npublic class FastFactory implements AbstractFactory {\n    public HtmlDocument createHtml(String md) {\n        return new FastHtmlDocument(md);\n    }\n    public WordDocument createWord(String md) {\n        return new FastWordDocument(md);\n    }\n}\n```\n\n这样，我们就可以使用FastDoc Soft的服务了。客户端编写代码如下：\n\n```java\n// 创建AbstractFactory，实际类型是FastFactory:\nAbstractFactory factory = new FastFactory();\n// 生成Html文档:\nHtmlDocument html = factory.createHtml(\"#Hello\\nHello, world!\");\nhtml.save(Paths.get(\".\", \"fast.html\"));\n// 生成Word文档:\nWordDocument word = fastFactory.createWord(\"#Hello\\nHello, world!\");\nword.save(Paths.get(\".\", \"fast.doc\"));\n```\n\n如果我们要同时使用GoodDoc Soft的服务怎么办？因为用了抽象工厂模式，GoodDoc Soft只需要根据我们定义的抽象工厂和抽象产品接口，实现自己的实际工厂和实际产品即可：\n\n```java\n// 实际工厂:\npublic class GoodFactory implements AbstractFactory {\n    public HtmlDocument createHtml(String md) {\n        return new GoodHtmlDocument(md);\n    }\n    public WordDocument createWord(String md) {\n        return new GoodWordDocument(md);\n    }\n}\n\n// 实际产品:\npublic class GoodHtmlDocument implements HtmlDocument {\n    ...\n}\n\npublic class GoodWordDocument implements HtmlDocument {\n    ...\n}\n```\n\n客户端要使用GoodDoc Soft的服务，只需要把原来的`new FastFactory()`切换为`new GoodFactory()`即可。\n\n注意到客户端代码除了通过`new`创建了`FastFactory`或`GoodFactory`外，其余代码只引用了产品接口，并未引用任何实际产品（例如，`FastHtmlDocument`），如果把创建工厂的代码放到`AbstractFactory`中，就可以连实际工厂也屏蔽了：\n\n```java\npublic interface AbstractFactory {\n    public static AbstractFactory createFactory(String name) {\n        if (name.equalsIgnoreCase(\"fast\")) {\n            return new FastFactory();\n        } else if (name.equalsIgnoreCase(\"good\")) {\n            return new GoodFactory();\n        } else {\n            throw new IllegalArgumentException(\"Invalid factory name\");\n        }\n    }\n}\n```","tags":["DesignPatterns"]},{"title":"单例模式","url":"/2020/06/06/单例模式/","content":"\n## 单例设计模式\n\n所谓类的单例设计模式，就是采用一定的方法保证在整个软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得对象实例的方法(静态方法)。\n\n<!--more-->\n\n###### 比如*Hibernate*的*SessionFactory*，它充当数据存储源的代理，并负责创建*Session* 对象。*SessionFactory*并不是轻量级的，一般情况下，一个项目通常只需要一个 *SessionFactory*就够，这是就会使用到单例模式。 \n\n 单例模式有八种方式：\n\n- 饿汉式(静态常量)\n\n- 饿汉式（静态代码块） \n\n- 懒汉式(线程不安全) \n\n- 懒汉式(线程安全，同步方法) \n\n- 懒汉式(线程安全，同步代码块) \n\n- 双重检查\n\n- 静态内部类 \n\n- 枚举 \n\n  \n\n#### 饿汉式(静态变量)\n\n  ![img](1.png)\n\n  ```java\n  /**\n   * @Author: Wizard\n   * @Date: 2020/6/6 14:13\n   */\n  public class Singleton1 {\n      public static void main(String[] args) {\n          //Test\n          SingleTon instance1 = SingleTon.getInstance();\n          SingleTon instance2 = SingleTon.getInstance();\n          System.out.println(instance1==instance2);//true\n      }\n  }\n  //饿汉式(静态变量)\n  class SingleTon1 {\n      //1.构造器私有化, 外部不能new\n      private SingleTon1() {\n      }\n      //2.在本类内部创建对象实例\n      private final static SingleTon1 instance = new SingleTon1();\n      //3.提供一个公有的静态方法，返回实例对象\n      public static SingleTon1 getInstance() {\n        return instance;\n      }\n  }\n  ```\n\n  \n\n> 优缺点：\n>\n> - 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。 \n> - 缺点：在类装载的时候就完成实例化，没有达到*Lazy Loading*的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费\n> - 这种方式基于*classloder*机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到 *lazy loading*的效果\n> - 结论：这种单例模式可用，可能造成**内存浪费** \n\n#### 饿汉式(静态代码块)\n\n![img](2.png)\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/6 14:13\n */\n\n//饿汉式(静态代码块)\nclass SingleTon2 {\n    //1.构造器私有化, 外部不能new\n    private SingleTon2() {\n    }\n\n    //2.在本类内部创建对象实例\n    private static SingleTon2 instance;\n\n    static {\n        //在静态代码块中，创建单例对象,静态代码块只执行一次\n        instance = new SingleTon2();\n    }\n    //3.提供一个公有的静态方法，返回实例对象\n    public static SingleTon2 getInstance() {\n        return instance;\n    }\n}\n```\n\n> 优缺点和静态变量相同\n\n#### 懒汉式(线程不安全)\n\n![img](3.png)\n\n```java\n//懒汉式\nclass SingleTon3 {\n    private static SingleTon3 instance;\n\n    private SingleTon3() {\n    }\n    //提供一个静态的公有方法,当使用到该方法时，才去创建instance\n    public static SingleTon3 getInstance(){\n        if (instance==null){\n            instance = new SingleTon3();\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点： \n>\n> - 起到了Lazy Loading的效果，但是只能在单线程下使用。 \n> - 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 \n> - 结论：在实际开发中，不要使用这种方式. \n\n#### 懒汉式(线程安全，同步方法)\n\n![img](4.png)\n\n```JAVA\n//懒汉式(线程安全，同步方法)\nclass SingleTon4 {\n    private static SingleTon4 instance;\n\n    private SingleTon4() {\n    }\n    //提供一个静态的公有方法,加入同步处理的代码，解决线程安全问题\n    public static synchronized SingleTon4 getInstance(){\n        if (instance==null){\n            instance = new SingleTon4();\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点说明：\n>\n> - 解决了线程不安全问题\n> - 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低\n> - 结论：在实际开发中，不推荐使用这种方式 \n\n#### 懒汉式(线程安全，同步代码块)\n\n![img](5.png)\n\n```java\n//懒汉式(线程安全，同步代码块)\nclass SingleTon5 {\n    private static SingleTon5 instance;\n    private SingleTon5() {\n    }\n    //提供一个静态的公有方法,加入同步处理的代码，解决线程安全问题\n    public static SingleTon5 getInstance() {\n        if (instance == null) {\n            synchronized (SingleTon5.class) {\n                instance = new SingleTon5();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点说明： \n>\n> - 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低， 改为同步产生实例化的的代码块 \n> - **但是这种同步并不能起到线程同步的作用**。跟第3种实现方式遇到的情形一 致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行， 另一个线程也通过了这个判断语句，这时便会产生多个实例 \n> - 结论：在实际开发中，不能使用这种方式 \n\n#### 双重检查\n\n![img](6.png)\n\n```java\n//懒汉式(线程安全,双重检查)\nclass SingleTon6 {\n    //必须加volatile关键字的原因：new对象分为3步:1.分配空间 2.初始化对象 3.指向对象内存地址\n    // 2和3可能被编译器自动重排序,导致判断非空但是实际拿的对象还未完成初始化\n    private static volatile SingleTon6 instance;\n\n    private SingleTon6() {\n    }\n    //提供一个静态的公有方法,加入双重检查代码，解决线程安全问题,同时解决懒加载的问题\n    public static SingleTon6 getInstance() {\n        if (instance == null) {\n            synchronized (SingleTon6.class) {\n                if (instance == null) {\n                    instance = new SingleTon6();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n>  优缺点说明： \n>\n> - Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。\n> - 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步\n> - 线程安全；延迟加载；效率较高 \n>\n> - 结论：在实际开发中，推荐使用这种单例设计模式 \n\n#### 静态内部类\n\n![img](7.png)\n\n```java\n//静态内部类\nclass SingleTon7 {\n    private static volatile SingleTon7 instance;\n    private SingleTon7() {\n    }\n\n    //写一个静态内部类,该类中有一个静态属性SingleTon7\n    //静态内部类SingletonInstance在外部类SingleTon7在类装载的时候,并不会马上执行,不会导致静态内部类SingletonInstance马上装载\n    //在JVM中，类的转载是线程安全的，导致了INSTANCE的初始化是线程安全的\n    private static class SingletonInstance {\n        private static final SingleTon7 INSTANCE = new SingleTon7();\n    }\n\n    public static SingleTon7 getInstance() {\n        //当调用getInstance这个方法时,会去取静态内部类SingletonInstance里的INSTANCE属性,这时会导致SingletonInstance会被装载\n\n        return SingletonInstance.INSTANCE;\n    }\n}\n```\n\n>  优缺点说明： \n>\n> - 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。 \n> - 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。 \n> - 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 \n> - 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 \n> - 结论：推荐使用. \n\n#### 枚举\n\n![img](8.png)\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/6/6 14:38\n */\npublic class Singleton8 {\n    public static void main(String[] args) {\n        Singleton instance = Singleton.INSTANCE;\n        Singleton instance2 = Singleton.INSTANCE;\n        System.out.println(instance == instance2);//true\n        System.out.println(instance.hashCode());\n        System.out.println(instance2.hashCode());\n    }\n}\n//枚举\nenum Singleton {\n    INSTANCE;\n\n    public void ok() {\n        System.out.println(\"ok\");\n    }\n}\n```\n\n> 优缺点说明： \n>\n>- 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。\n>- 这种方式是Effective Java作者Josh Bloch 提倡的方式\n>- 结论：推荐使用 \n\n\n\n #### 单例模式在JDK 应用的源码分析 \n\n单例模式在JDK 应用的源码分析 \n\nJDK中，java.lang.Runtime就是经典的单例模式(饿汉式) \n\n\n\n### 单例模式注意事项和细节说明 \n\n1. 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需 要频繁创建销毁的对象，使用单例模式可以提高系统性能 \n2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new \n3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等) ","tags":["DesignPatterns"]},{"title":"合成复用原则","url":"/2020/06/05/合成复用原则/","content":"\n### 合成复用原则\n\n> Composite Resue Principle\n>\n> <!--more-->\n\n##### 基本介绍\n\n原则是尽量使用合成/聚合的方式，而不是使用继承。\n\n![1591350916399](1.png)\n\n```java\n不使用继承的方法：\n\n使用:\n      1.依赖(参数传递)\n      2.聚合(set)\n      3.组合(new)\n```\n\n#### 设计原则核心思想\n\n- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。\n- 针对接口编程，而不是针对实现编程\n- 为了交互对象之间的松耦合设计而努力","tags":["DesignPatterns"]},{"title":"迪米特法则","url":"/2020/06/05/迪米特法则/","content":"\n ### 基本介绍\n\n> Demeter Principle\n>\n> <!--more-->\n\n-  一个对象应该对其他对象保持最少的了解 \n- 类与类关系越密切，耦合度越大\n- 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息\n- 迪米特法则还有个更简单的定义：只与直接的朋友通信 \n- **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量 的形式出现在类的内部。 \n\n##### 细节：\n\n- 迪米特法则的核心是降低类之间的耦合 \n- 注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低 类间(对象间)耦合关系， 并不是要求完全没有依赖关系 \n\n","tags":["DesignPatterns"]},{"title":"开闭原则","url":"/2020/06/05/开闭原则/","content":"\n### 开闭原则\n\n> Open Closed Principle\n\n基本介绍\n\n<!--more-->\n\n- 开闭原则是编程中最基础、最重要的设计原则\n- 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。**用抽象构建框架，用实体扩展细节。**\n- 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n- 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。\n\n```java\npublic class Ocp{\n    public status void main(String[] args){\n        GraphicEditor graphicEditor = new GraphicEditor();\n        graphicEditor.drawShape(new Rectangle());\n    }\n}\nclass GraphicEditor{\n    public void drawShape(Shape shape){\n        shape.draw();\n    }\n}\n//Shape类，基类\nabstract class Shape{\n    int m_type;\n    public abstract void draw();//抽象方法\n}\nclass Rectangle extends Shape{\n    Rectangle(){\n        super.m_type = 1;\n    }\n    @Override\n    public void draw(){\n        System.out.println(\"绘制矩形\")\n    }\n}\nclass Circle extends Shape{\n    Circle(){\n        super.m_type = 2;\n    }\n    @Override\n    public void draw(){\n        System.out.println(\"绘制圆形\")\n    }\n}\n```\n\n","tags":["DesignPatterns"]},{"title":"里氏替换原则","url":"/2020/06/04/里氏替换原则/","content":"\n### 里氏替换原则\n\n> Liskov Substitution Principle\n\n- 里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的。\n\n  <!--more-->\n\n- 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。所有引用基类的地方必须能透明地使用其子类的对象。换句话说，既然抽象出来当作共同的实现方法就不应再具体实现类中重写。\n\n- 在使用继承时，遵守里氏替换原则，在子类中尽量不要重写父类的方法\n\n- 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。\n\n  \n\n  ```java\n  //A类\n  class A{\n      //返回两个数的差\n      public in func1(int num1,int num2){\n          return num1 - num2;\n      }\n  }\n  //B类继承了A类\n  class B extends A{\n      //    ↓重写了A的方法\n      public int func1(int a,int b){\n          return a + b;\n      }\n      public int func2(int a,int b){\n          return func1(a,b)+9;\n      }\n  }\n  ```\n\n  改进：\n\n  ```java\n  class Base{\n      //把更加基础的方法和成员写到Base类\n  }\n  \n  //A类\n  class A extends Base{\n      //返回两个数的差\n      public in func1(int num1,int num2){\n          return num1 - num2;\n      }\n  }\n  //B类继承了A类\n  class B extends Base{\n      //如果B需要使用A类的方法，使用组合关系\n      private A a = new A();\n      //    ↓重写了A的方法\n      public int func1(int a,int b){\n          return a + b;\n      }\n      public int func2(int a,int b){\n          return func1(a,b)+9;\n      }\n      \n      //使用A的方法\n      public int func3(int a,int b){\n          return this.a.func1(a,b);\n      }\n  }\n  ```\n\n  \n\n\n\n","tags":["DesignPatterns"]},{"title":"依赖倒转原则","url":"/2020/06/03/依赖倒转原则/","content":"\n### 依赖倒转原则\n\n>  Dependence Inversion Priciple\n>\n>  <!--more-->\n\n##### 基本介绍\n\n- 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n- 抽象不应该依赖细节，细节应该依赖抽象\n- 依赖倒转的中心思想是面向接口编程\n- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类\n- 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成\n\n#### 细节\n- 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好\n- 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层。利于程序扩展和优化\n- 继承时遵循里氏替换原则\n\n###### 1通过接口传递实现依赖\n```java\ninterface IOpenAndClose{\n    //抽象方法\n    public void open(ITV tv);\n}\ninterface ITV{\n    //ITV接口\n    public void play();\n}\n\nclass Htc implements ITV{\n    @Override\n    public void play() {\n        System.out.println(\"htc电视机，打开\");\n    }\n}\n//实现接口\nclass OpenAndClose implements IOpenAndClose{\n    public void open(ITV tv){\n        tv.play();\n    }\n}\n```\n##### 2.通过构造方法依赖传递\n\n```java\ninterface IOpenAndClose{\n    //抽象方法\n    public void open(ITV tv);\n}\ninterface ITV{\n    //ITV接口\n    public void play();\n}\n\nclass Htc implements ITV{\n    @Override\n    public void play() {\n        System.out.println(\"htc电视机，打开\");\n    }\n}\n//实现接口\nclass OpenAndClose implements IOpenAndClose{\n    public ITV tv;\n    public OpenAndClose(ITV tv){\n        //构造器\n        this.tv = tv;\n    }\n    public void open(){\n        tv.play();\n    }\n}\n```\n\n##### 3.通过setter方法传递\n\n```java\ninterface IOpenAndClose{\n    //抽象方法\n    public void open(ITV tv);\n    public void name(ITV tv);\n}\ninterface ITV{\n    //ITV接口\n    public void play();\n}\n\nclass Htc implements ITV{\n    @Override\n    public void play() {\n        System.out.println(\"htc电视机，打开\");\n    }\n}\n//实现接口\nclass OpenAndClose implements IOpenAndClose{\n    public ITV tv;\n    public setTv(ITV tv){\n        //构造器\n        this.tv = tv;\n    }\n    public void open(){\n        tv.play();\n    }\n}\n```\n\n","tags":["DesignPatterns"]},{"title":"接口隔离原则","url":"/2020/06/03/接口隔离原则/","content":"\n### 接口隔离原则\n\n> Interface Segregation Principle\n>\n> <!--more-->\n\n##### 基本介绍\n\n- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。\n\n- 类A通过接口Interface依赖类D，类C通过接口Interface依赖类D，如果接口Interface对于类A和来说不是最小接口那么类B和类D必须去实现他们不需要的方法。\n\n  \n\n  按隔离原则应当这样处理：\n\n  > 将接口Interface拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n\n","tags":["DesignPatterns"]},{"title":"单一职责原则","url":"/2020/06/03/单一职责原则/","content":"\n### 单一职责原则\n\n------\n\n<!--more-->\n\n##### 基本介绍\n\n> 对类来说，即一个类应该只负责一个原则。如果A负责两个不同的原则：职责1，职责2。当职责1需求变更而改变A时，可能导致职责2执行错误。所以需要将类A的粒度分解为A1，A2\n\n##### 细节\n\n- 降低类的复杂度，一个类只负责一项职责。\n- 降低类的可读性，可维护性。\n- 降低变更引起的风险。\n- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一原则。\n\n","tags":["DesignPatterns"]},{"title":"XSS跨站脚本攻击","url":"/2020/05/31/XSS跨站脚本攻击/","content":"\n### XSS跨站脚本攻击\n\n在做社区项目的时候，发现了一个XSS漏洞。\n\n![img](xss.png)\n\n<!--more-->\n\n##### 什么是XSS跨站脚本攻击？\n\n> XSS攻击全称跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。\n\n在点击回复二级评论时，JavaScript脚本会注入页面:\n\n示例：\n\n ![img](2.png) \n\n ![img](3.png) \n\n然后客户端就调用脚本alert导致无限弹窗。\n\n还可以使用\n\n```javascript\n<script>alert(document.cookie)</script>\n```\n\n获取页面cookie，比如登录的token。\n\n解决办法：\n\n> Jsoup使用标签白名单的机制用来进行防止XSS攻击\n\n参考：\n\n[[XSS跨站脚本攻击]][1]\n\n[1]: https://www.zykcoderman.xyz/web/post/detail/401 \"XSS\"","tags":["safe"]},{"title":"SQL注入式攻击","url":"/2020/05/30/SQL注入式攻击/","content":"\n### SQL注入式攻击\n\n 攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。 \n\n<!--more-->\n\n#### 常见的SQL注入式攻击主要是利用Statement的缺陷，\n\n服务端验证：\n\n```java\n@Override\n    public void login(Account account) throws SQLException {\n\n        String sql = \"insert into account values(null,\" + account.userName + \",\" + account.password + \")\";\n\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/account?characterEncoding=UTF-8\",\n                \"root\", \"password\")) {\n            try (Statement stmt = conn.createStatement()) {\n                try (ResultSet rs = stmt.executeQuery(\"SELECT id, grade, name, gender FROM students WHERE gender=1\")) {\n                    while (rs.next()) {\n                        int id = rs.getInt(1);\n                        String username = rs.getString(2);\n                        String password = rs.getString(3);\n                    }\n                }\n            }\n        }\n    }\n```\n\n客户端\n\n```html\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\">\n<script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"></script>\n<div class=\"col-xs-8 col-sm-8 col-md-8 jumbotron\">\n    <form>\n        <div class=\"form-group\">\n            <label for=\"exampleInputEmail1\">Username</label>\n            <input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Email\">\n        </div>\n        <div class=\"form-group\">\n            <label for=\"exampleInputPassword1\">Password</label>\n            <input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\">\n        </div>\n        <div class=\"form-group\">\n            <label for=\"exampleInputFile\">File input</label>\n            <input type=\"file\" id=\"exampleInputFile\">\n            <p class=\"help-block\">Example block-level help text here.</p>\n        </div>\n        <div class=\"checkbox\">\n            <label>\n                <input type=\"checkbox\"> Check me out\n            </label>\n        </div>\n        <button type=\"submit\" class=\"btn btn-default\">Submit</button>\n    </form>\n</div>\n\n```\n\n![img](1.png)\n\n如果是客户端精心构造的字符串，例如\n\n```sql\nname = \"kayleh' OR pass=\", pass = \" OR pass='\"\n' or 1= ' 1\n```\n\n命令行永远为真，导致注入成功。\n\n> 所以使用JDBC时，尽量使用速度比较快且安全的 PreparedStatement ，PreparedStatement 使用的是预编译机制。\n\n","tags":["safe"]},{"title":"维护2","url":"/2020/05/21/维护2/","content":"\n#### 维护2\n\n###### fixed 12 bugs. \n\n- 1 网站成功双线部署GitHub、Coding\n\n  境外： https://kayleh.github.io/ \n\n  境内访问： http://dqlcr5.coding-pages.com/ \n\n- 2 完善标签tags功能\n\n- 3 完善搜索功能\n\n- 4 修复3处页面重定向","tags":["maintain"]},{"title":"二叉排序树","url":"/2020/05/20/二叉排序树/","content":"\n### 二叉排序树\n\n二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。\n\n如果有相同的值，可以将该节点放在左子节点或右子节点\n\n<!--more-->\n\n​                                           数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为  \n\n​                                                              ![img](0.png)\n\n​                                                                          ↓\n\n​                                                              ![img](1.png)\n\n\n\n二叉排序树的删除情况比较复杂，有下面三种情况需要考虑\n\n1)删除叶子节点 (比如：2, 5, 9, 12)\n\n2)删除只有一颗子树的节点 (比如：1)\n\n3)删除有两颗子树的节点. (比如：7, 3，10 )\n\n```shell\n第一种情况:\n删除叶子节点 (比如：2, 5, 9, 12)\n思路\n(1) 需求先去找到要删除的结点  targetNode\n(2)  找到targetNode 的 父结点 parent \n(3)  确定 targetNode 是 parent的左子结点 还是右子结点\n(4)  根据前面的情况来对应删除\n左子结点 parent.left = null\n右子结点 parent.right = null;\n第二种情况: 删除只有一颗子树的节点 比如 1\n思路\n(1) 需求先去找到要删除的结点  targetNode\n(2)  找到targetNode 的 父结点 parent \n(3) 确定targetNode 的子结点是左子结点还是右子结点\n(4) targetNode 是 parent 的左子结点还是右子结点\n(5) 如果targetNode 有左子结点\n5. 1 如果 targetNode 是 parent 的左子结点\nparent.left = targetNode.left;\n5.2  如果 targetNode 是 parent 的右子结点\nparent.right = targetNode.left;\n(6) 如果targetNode 有右子结点\n6.1 如果 targetNode 是 parent 的左子结点\nparent.left = targetNode.right;\n6.2 如果 targetNode 是 parent 的右子结点\nparent.right = targetNode.right\n\n\n情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )\n思路\n(1) 需求先去找到要删除的结点  targetNode\n(2)  找到targetNode 的 父结点 parent \n(3)  从targetNode 的右子树找到最小的结点\n(4) 用一个临时变量，将 最小结点的值保存 temp = 11\n(5)  删除该最小结点\n(6)  targetNode.value = temp\n\n```\n\n#### 代码实现\n\n```java\npackage binarysorttree;\n\n/**\n * @Author: Wizard\n * @Date: 2020/5/20 11:42\n */\npublic class BinarySortTreeDemo {\n    public static void main(String[] args) {\n//        int[] arr = {7, 3, 10, 12, 5, 1, 9};\n        int[] arr = {7,3};\n        BinarySortTree binarySortTree = new BinarySortTree();\n        for (int i = 0; i < arr.length; i++) {\n            binarySortTree.add(new Node(arr[i]));\n        }\n        binarySortTree.infixOrder();\n\n        binarySortTree.delNode(7);\n\n        System.out.println(\"删除后\");\n        binarySortTree.infixOrder();\n    }\n}\n\n\n//创建二叉排序树\nclass BinarySortTree {\n\n    private Node root;\n\n    //查找要删除的结点\n    public Node search(int value) {\n        if (root == null) {\n            return null;\n        } else {\n            return root.search(value);\n        }\n    }\n\n    //查找父结点\n    public Node searchParent(int value) {\n        if (root == null) {\n            return null;\n        } else {\n            return root.searchParent(value);\n        }\n    }\n\n    /**\n     * 右边找最小的\n     * 左边找最大的\n     *\n     * 返回的 以node为根结点的最小结点的值\n     * 删除以node为根结点的最小结点的值\n     *\n     * @param node 传入的结点（当做二叉排序树的根结点）\n     * @return 返回的 以node为根结点的最小结点的值\n     */\n    public int delRightTreeMin(Node node) {\n        Node target = node;\n        //循环的查找左子节点，就会找到最小值\n        while (target.left != null) {\n            target = target.left;\n        }\n        //这是target就指向了最小结点\n        //删除最小结点\n        delNode(target.value);\n        return target.value;\n    }\n\n\n    //删除结点\n    public void delNode(int value) {\n\n        if (root == null) {\n            return;\n        } else {\n            //需要先去找到要删除的结点 targetNode\n            Node targetNode = search(value);\n            //如果没有找到要删除的结点\n            if (targetNode == null) {\n                return;\n            }\n            //如果发现targetNode没有父结点（就是根结点）(只有一个结点)\n            if (root.left == null && root.right == null) {\n                root = null;\n                return;\n            }\n\n            //去找到targetNode的父结点\n            Node parent = searchParent(value);\n            //如果要删除的结点是叶子结点\n            if (targetNode.left == null && targetNode.right == null) {\n                //判断targetNode是父结点的左子结点还是右子结点\n                if (parent.left != null && parent.left.value == value) {\n                    parent.left = null;\n                } else if (parent.right != null && parent.right.value == value) {\n                    parent.right = null;\n                }\n            } else if (targetNode.left != null && targetNode.right != null) {\n                //删除有两颗子树的结点\n                int min = delRightTreeMin(targetNode.right);//target右边最小的值\n\n                targetNode.value = min;\n            } else {\n                //删除只有一颗子树的结点\n                //如果要删除的结点有左子结点\n//                System.out.println(parent);\n                if (parent!=null) {\n                    if (targetNode.left != null) {\n                        //如果targetNode是parent的左子结点\n                        if (parent.left.value == value) {\n                            parent.left = targetNode.left;\n                        } else {\n                            //如果targetNode是parent的右子结点\n                            parent.right = targetNode.left;\n                        }\n                    } else {\n                        //如果要删除的结点有右子结点\n                        if (parent.left.value == value) {\n                            //如果targetNode是parent的左子结点\n                            parent.left = targetNode.right;\n                        } else {\n                            //如果targetNode是parent的右子结点\n                            parent.right = targetNode.right;\n\n                        }\n                    }\n                }else {\n                    if (root.left!=null){\n                        root = root.left;\n                    }else {\n                        root = root.right;\n                    }\n                }\n            }\n        }\n    }\n\n    //添加结点的方法\n    public void add(Node node) {\n        if (root == null) {\n            root = node;\n        } else {\n            root.add(node);\n        }\n    }\n\n    //中序遍历方法\n    public void infixOrder() {\n        if (root != null) {\n            root.infixOrder();\n        } else {\n            System.out.println(\"当前二叉排序树为空，不能遍历\");\n        }\n    }\n}\n\n\n//创建Node结点\nclass Node {\n    int value;\n    Node left;\n    Node right;\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"value=\" + value +\n                '}';\n    }\n\n\n    /**\n     * 查找要删除的结点\n     *\n     * @param value 希望删除的结点的值\n     * @return 如果找到返回该结点，否则返回null\n     */\n    public Node search(int value) {\n        if (value == this.value) {\n            //找到就是该结点\n            return this;\n        } else if (value < this.value) {\n            //如果查找的值小于当前结点，向左子树递归查找\n            //如果左子结点为空\n            if (this.left == null) {\n                return null;\n            }\n            return this.left.search(value);\n        } else {\n            //如果查找的值不小于当前结点，向右子树递归查找\n            if (this.right == null) {\n                return null;\n            }\n            return this.right.search(value);\n\n        }\n    }\n\n    /**\n     * 查找要删除结点的父结点\n     *\n     * @param value 要找到结点的值\n     * @return 返回的是要删除的结点的父结点，如果没有就返回null\n     */\n    public Node searchParent(int value) {\n\n        //如果当前结点就是要删除的结点的父结点，就返回\n        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {\n            return this;\n        } else {\n            //如果查找的值小于当前结点的值，并且当前结点的左子结点不为空\n            if (value < this.value && this.left != null) {\n                return this.left.search(value);//向左子树递归查找\n            } else if (value >= this.value && this.right != null) {\n                return this.right.search(value);//向右子树递归查找\n            } else {\n                return null;//没有找到父结点\n            }\n\n        }\n\n    }\n\n    public Node(int value) {\n        this.value = value;\n    }\n\n    //添加结点的方式\n    //递归的形式添加结点，需要满足二叉排序树的要求\n    public void add(Node node) {\n        if (node == null) {\n            return;\n        }\n        //判断传入的结点的值，和当前子树的根结点的值的关系\n        if (node.value < this.value) {\n            //如果当前结点的左子结点为null\n            if (this.left == null) {\n                //把结点挂在左子结点\n                this.left = node;\n            } else {\n                //如果左子结点不为空，向左子树递归添加\n                this.left.add(node);\n            }\n        } else {\n            //如果 添加的结点的值 大于 根结点的值\n            if (this.right == null) {\n                this.right = node;\n            } else {\n                this.right.add(node);\n            }\n        }\n    }\n\n    //中序遍历\n    public void infixOrder() {\n\n        if (this.left != null) {\n            this.left.infixOrder();\n        }\n        System.out.println(this);\n        if (this.right != null) {\n            this.right.infixOrder();\n        }\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"堆排序","url":"/2020/05/18/堆排序/","content":"\n### 堆排序\n\n1.堆排序是利用堆这种数据结构而设计的一种算法，堆排序是一种选择排序，它的最坏，最好，平均复杂度均为O(nlogn)，它也是不稳定的排序。\n\n<!--more-->\n\n2.堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。没有要求结点的左孩子的值和右孩子的值大小关系。\n\n3.每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆\n\n![img](1.gif)\n\n```java\npackage sort;\n\nimport java.util.Arrays;\n\n/**\n * @Author: Wizard\n * @Date: 2020/5/18 21:16\n */\npublic class heapSort {\n    public static void main(String[] args) {\n        //要求将数组进行升序排列\n    }\n\n    //编写一个堆排序的方法\n    public static void heapSort(int arr[]) {\n        int temp = 0;\n        System.out.println(\"堆排序！\");\n\n\n        //  i  第一个非叶子结点\n        //  这里的目的是把最大的数交换到堆顶，成为一个大顶堆结构\n        for (int i = arr.length / 2 - 1; i >= 0; i--) {\n            adjustHeap(arr, i, arr.length);\n            System.out.println(Arrays.toString(arr));\n        }\n\n\n        /*\n        将堆顶元素于末尾元素交换，将最大元素“沉”到数组末端\n        重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序\n         */\n        //一共5个数，调整4个数就可以了\n        for (int j = arr.length - 1; j > 0; j--) {\n            temp = arr[j];\n            arr[j] = arr[0];//arr[0] 是上面调整后的最大值\n            arr[0] = temp;\n            adjustHeap(arr, 0, j);\n            System.out.println(\"第\"+(arr.length-j)+\"次沉\"+Arrays.toString(arr));\n        }\n        System.out.println(Arrays.toString(arr));\n\n\n        //每次遍历把最大的数（在调整之后的父节点，第一位）沉到数组的末端\n        //然后 再调整 把最大的数交换到堆顶（adjustHeap），再沉到数组的末端的位置-1，随着j的递减，末尾的前几个数字逐渐确定（调整的范围减少）\n\n    }\n\n\n    //将一个数组(二叉树),调整为一个大顶堆\n\n    /**\n     * 功能：完成将以 i 对应的非叶子结点的树调整为大顶堆\n     * int arr[] = {4,6,8,5,9};   → i = 1 → adjustHeap → 得到{4,9,8,5,6}\n     * 再次调用adjustHeap 传入的是 i= 0 → 得到{9,6,8,5,4}\n     *\n     * @param arr    待调整的数组\n     * @param i      表示非叶子结点在数组中的索引\n     * @param lenght 表示归多少个元素继续调整，length 是在逐渐的减少\n     */\n    public static void adjustHeap(int arr[], int i, int lenght) {\n        int temp = arr[i];//取出当前元素的值，保存在临时变量，   以 i 作为父节点（局部）\n        //开始调整\n        //k = i对应的左子节点\n        for (int k = 2 * i + 1; k < lenght; k = 2 * i + 1) {\n            if (k + 1 < lenght && arr[k] < arr[k + 1]) {\n                //说明左子节点的值小于右子节点\n                k++;//让 k 指向右子节点\n            }\n            if (arr[k] > temp) {\n                //如果子节点大于父节点\n                //就把较大的值赋值给当前节点\n                arr[i] = arr[k];\n                // ! i指向k 继续循环比较\n                i = k; //把i（父节点）指向 k（子节点）。作为父节点继续循环\n            } else {\n                //如果子节点小于父节点\n                //堆排序是从左至右，从下至上\n                break;\n            }\n        }\n        //当for循环结束后，已经将以i为父节点的树的最大值，放在了最顶（局部）\n        arr[i] = temp;//将temp值放到调整后的位置\n\n        //adjustHeap()方法中依然要循环, 是因为最后在堆排序的时候是从下到上的, 排序中向上调用这个方法时 , i也会往上走, 这时再次调用adjustHeapt\n        //这时再次调用adjustHeap方法时, i就不是最后一个非叶子节点了, 会破坏原先已经排序好的大顶堆, 所以需要循环往下将被破坏的大顶堆重新建立起来\n    }\n}\n\n```\n\n","tags":["dataAlgorithm"]},{"title":"7种排序算法","url":"/2020/05/17/7种排序算法/","content":"\n\n\n## 冒泡排序\n\n- `冒泡排序（BubbleSorting)`的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部。\n\n  \n\n![img](1.png)\n\n<!--more-->\n\n代码实现\n\n```java\n// 将前面的冒泡排序算法，封装成一个方法\n    public static void bubbleSort(int[] arr) {\n        // 冒泡排序 的时间复杂度 O(n^2), 自己写出\n        int temp = 0; // 临时变量\n        boolean flag = false; // 标识变量，表示是否进行过交换\n        for (int i = 0; i < arr.length - 1; i++) {\n            for (int j = 0; j < arr.length - 1 - i; j++) {\n                // 如果前面的数比后面的数大，则交换\n                if (arr[j] > arr[j + 1]) {\n                    flag = true;\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n            //System.out.println(\"第\" + (i + 1) + \"趟排序后的数组\");\n            //System.out.println(Arrays.toString(arr));\n\n            if (!flag) {\n                // 在一趟排序中，一次交换都没有发生过\n                break;\n            } else {\n                flag = false;\n                // 重置flag!!!, 进行下次判断\n            }\n        }\n```\n\n------\n\n## 插入排序\n\n- `插入排序（insertSorting)`\n- 基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n- \n\n代码实现\n\n```java\n public static void insertSort(int attr[]) {\n        //从第2个数开始遍历 【1】\n        for (int i = 1; i < attr.length - 1; i++) {\n            // 等待插入的数的前一个数下标\n            int insertIndex = i - 1;\n            //等待插入的数的值\n            int insertValue = attr[i];\n            // insertIndex不能越界\n            // insertValue待插入到前面有序列表的数\n            // insertValue待插入的数 小于 前1个数\n            while (insertIndex >= 0 && attr[insertIndex] > insertValue) {\n                // 交换\n                //  attr[insertIndex]后移\n                attr[insertIndex + 1] = attr[insertIndex];\n                insertIndex--;\n            }\n            //当退出while循环时，说明插入的位置找到, insertIndex + 1\n            if (insertIndex + 1 != i) {\n                attr[insertIndex + 1] = insertValue;\n            }\n        }\n\n    }\n```\n\n## 选择排序\n\n- `选择排序（selectSorting)`的基本思想是：\n\n- 第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…,第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。\n\n  \n\n![img](2.png)\n\n\n\n代码实现\n\n\n\n```java\npublic class selectSort {\n    public static void selectSort(int attr[]) {\n        for (int i = 0; i < attr.length - 1; i++) {\n            //假设第一个数就是最小值\n            int minindex = 0;\n            int min = attr[0];\n            //从1开始遍历\n            for (int j = 1; j < attr.length - 1; j++) {\n                //如果第0个数（最小值）比第1个数 大\n                //说明假设的第0个并不是最小值\n                if (min > attr[j]) {\n                    min = attr[j];//重置最小值\n                    minindex = j;//重置最小值索引\n                }\n            }\n            //如果最小值的索引不是0，就发生交换\n            if (minindex != i) {\n                //把第0个数（不是最小值）赋值到 第1个数（较小值）的位置\n                attr[minindex] = attr[i];\n                //把较小值赋值给第1个数\n                attr[i] = min;\n            }\n        }\n    }\n```\n\n\n\n## 希尔排序\n\n- `冒泡排序（BubbleSorting)`的基本思想是：\n\n  把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\n\n  \n\n![img](3.png)\n\n\n\n代码实现\n\n\n\n```java\n\t\t//移动法\n        //增量gap，并逐步的缩小增量\n        for (int gap = attr.length/2;gap>0;gap/=2){\n            //从第gap个元素开始，逐个对其所在的组进行直接插入排序\n            for (int i =gap;i<attr.length;i++){\n                // 当前位置\n                int j = i;\n\n                //当前位置的值赋值给temp\n                int temp = attr[j];\n                // 如果 当前组的gap个步长前面的数大于当前位置的数\n                if(attr[j]<attr[j-gap]){\n                    while (j-gap >= 0 && temp < attr[j-gap]){\n                        //移动\n                        attr[j] = attr[j-gap];\n                        j -= gap;\n                    }\n                    //当退出while循环后，就给temp找到插入的位置\n                    attr[j] = temp;\n                }\n            }\n        }\n```\n\n\n\n## 快速排序\n\n- `快速排序（QuickSorting)`\n\n  是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列\n\n![img](4.png)\n\n\n\n代码实现\n\n\n\n```java\npublic static void quickSort(int[] arr,int left, int right) {\n        int l = left; //左下标\n        int r = right; //右下标\n        //pivot 中轴值\n        int pivot = arr[(left + right) / 2];\n        int temp = 0; //临时变量，作为交换时使用\n        //while循环的目的是让比pivot 值小放到左边\n        //比pivot 值大放到右边\n        while( l < r) {\n            //在pivot的左边一直找,找到大于等于pivot值,才退出\n            while( arr[l] < pivot) {\n                l += 1;\n            }\n            //在pivot的右边一直找,找到小于等于pivot值,才退出\n            while(arr[r] > pivot) {\n                r -= 1;\n            }\n            //如果l >= r说明pivot 的左右两的值，已经按照左边全部是\n            //小于等于pivot值，右边全部是大于等于pivot值\n            if( l >= r) {\n                break;\n            }\n            //交换\n            temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n\n            //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移\n            if(arr[l] == pivot) {\n                r -= 1;\n            }\n            //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移\n            if(arr[r] == pivot) {\n                l += 1;\n            }\n        }\n\n        // 如果 l == r, 必须l++, r--, 否则为出现栈溢出\n        if (l == r) {\n            l += 1;\n            r -= 1;\n        }\n        //向左递归\n        if(left < r) {\n            quickSort(arr, left, r);\n        }\n        //向右递归\n        if(right > l) {\n            quickSort(arr, l, right);\n        }\n    }\n```\n\n\n\n## 归并排序\n\n- `归并排序（mergeSorting)`的基本思想是：\n\n  是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案\"修补\"在一起，即分而治之)。\n\n![img](5.png)\n\n\n\n代码实现\n\n\n\n```java\n //分+合方法\n    public static void mergeSort(int[] arr, int left, int right, int[] temp) {\n        if(left < right) {\n            int mid = (left + right) / 2; //中间索引\n            //向左递归进行分解\n            mergeSort(arr, left, mid, temp);\n            //向右递归进行分解\n            mergeSort(arr, mid + 1, right, temp);\n            //合并\n            merge(arr, left, mid, right, temp);\n        }\n    }\n\n    //合并的方法\n    /**\n     *\n     * @param arr 排序的原始数组\n     * @param left 左边有序序列的初始索引\n     * @param mid 中间索引\n     * @param right 右边索引\n     * @param temp 做中转的数组\n     */\n    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {\n        int i = left; // 初始化i, 左边有序序列的初始索引\n        int j = mid + 1; //初始化j, 右边有序序列的初始索引\n        int t = 0; // 指向temp数组的当前索引\n        //(一)\n        //先把左右两边(有序)的数据按照规则填充到temp数组\n        //直到左右两边的有序序列，有一边处理完毕为止\n        while (i <= mid && j <= right) {//继续\n            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素\n            //即将左边的当前元素，填充到 temp数组\n            //然后 t++, i++\n            if(arr[i] <= arr[j]) {\n                temp[t] = arr[i];\n                t += 1;\n                i += 1;\n            } else { //反之,将右边有序序列的当前元素，填充到temp数组\n                temp[t] = arr[j];\n                t += 1;\n                j += 1;\n            }\n        }\n        //(二)\n        //把有剩余数据的一边的数据依次全部填充到temp\n        while( i <= mid) { //左边的有序序列还有剩余的元素，就全部填充到temp\n            temp[t] = arr[i];\n            t += 1;\n            i += 1;\n        }\n        while( j <= right) { //右边的有序序列还有剩余的元素，就全部填充到temp\n            temp[t] = arr[j];\n            t += 1;\n            j += 1;\n        }\n        //(三)\n        //将temp数组的元素拷贝到arr\n        //注意，并不是每次都拷贝所有\n        t = 0;\n        int tempLeft = left; //\n        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3\n        //最后一次 tempLeft = 0  right = 7\n        while(tempLeft <= right) {\n            arr[tempLeft] = temp[t];\n            t += 1;\n            tempLeft += 1;\n        }\n\n    }\n```\n\n\n\n\n\n\n\n## 基数排序\n\n- `基数排序（mergeSorting)`的基本思想是：\n\n  将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n\n![img](6.png)\n\n\n\n代码实现\n\n\n\n```java\n\n    //基数排序方法\n    public static void radixSort(int[] arr) {\n\n        //根据前面的推导过程，我们可以得到最终的基数排序代码\n\n        //1. 得到数组中最大的数的位数\n        int max = arr[0]; //假设第一数就是最大数\n        for(int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        //得到最大数是几位数\n        int maxLength = (max + \"\").length();\n\n        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组\n        //说明\n        //1. 二维数组包含10个一维数组\n        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length\n        //3. 名明确，基数排序是使用空间换时间的经典算法\n        int[][] bucket = new int[10][arr.length];\n\n        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数\n        //可以这里理解\n        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数\n        int[] bucketElementCounts = new int[10];\n\n        //这里使用循环将代码处理\n\n        for(int i = 0 , n = 1; i < maxLength; i++, n *= 10) {\n            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..\n            for(int j = 0; j < arr.length; j++) {\n                //取出每个元素的对应位的值\n                int digitOfElement = arr[j] / n % 10;\n                //放入到对应的桶中\n                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];\n                bucketElementCounts[digitOfElement]++;\n            }\n            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)\n            int index = 0;\n            //遍历每一桶，并将桶中是数据，放入到原数组\n            for(int k = 0; k < bucketElementCounts.length; k++) {\n                //如果桶中，有数据，我们才放入到原数组\n                if(bucketElementCounts[k] != 0) {\n                    //循环该桶即第k个桶(即第k个一维数组), 放入\n                    for(int l = 0; l < bucketElementCounts[k]; l++) {\n                        //取出元素放入到arr\n                        arr[index++] = bucket[k][l];\n                    }\n                }\n                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！\n                bucketElementCounts[k] = 0;\n            }\n\n        }\n\n    }\n```\n\n\n\n各个算法的复杂度\n\n![img](7.png)\n\n\n\n\n\n","tags":["dataAlgorithm"]},{"title":"计算机组成原理","url":"/2020/05/14/计算机组成原理/","content":"\n# 计算机组成原理\n\n#### 1.第一台电子计算机何时何地诞生？英文全称？\n\n1946年2月14日 美国宾夕法尼亚大学<!--more-->\n\nENIAC：电子数字积分计算机\n\nElectronic(电子的) Numerical(数字的) Integrator(综合者) And Calculator(计算机)\n\n#### 2.冯·诺依曼型计算机组成,思想?\n\n计算机组成:\n\n运算器、控制器、存储器、输入设备、输出设备。\n\n思想：\n\n采用二进制的形式表示数据和指令，将数据和指令事先保存在存储器中，按照顺序执行程序来控制计算机工作运行。\n\n#### 3.现代计算机硬件系统与冯·诺依曼型计算机组成有什么不同？\n\n相同点：\n\n现代计算机仍是冯·诺依曼体系结构。\n\n不同点：组成形式改变很大\n\n(1)逻辑元件组装成电路高度集成,把运算、控制器集成到一块CPU芯片上。\n\n(2)存储器分为三级：高速缓冲存储器Cache，主存储器(内存),外部存储器;\n\n其中Cache现在都集成在CPU里,主存由内存条实现,外部存储器主要有机械硬盘,固态硬盘等;\n\n(3)输出与输入设备主要有显示屏,鼠标,键盘.\n\n显示器有专门显示接口(集成或独立显卡)连接CPU或主存,键盘和鼠标也通过集成接口CPU.\n\n此外还配置集成网卡和声卡.\n\n(4)USB多种连接接口实现网络与多媒体连接.整个系统采用多级总线结构组成.\n\n#### 4.CPU的性能公式,性能指标,如何评价?"},{"title":"队列","url":"/2020/05/14/队列/","content":"\n### 队列\n\n##### 定义：\n\n遵循先进先出，就是队列。可以想象为排队，先排队的人先办理业务。\n\n<!--more-->\n\n- 队列是一个有序列表。\n\n- 遵循先进先出的原则。即：先存入的数据先取出，后存入的数据后取出。\n\n- 示意：数组模拟：\n\n  \n\n  ![img](2.png)\n\n队列本身是有序列表，如使用数组的结构来存储队列的数据，因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，其中 maxSize是该队列的最大容量。如图所示。\n\n\n\n用稀疏数组代替二维数组，第0行表示稀疏数组的总行，总列和所需内容的个数。\n\n代码实现\n\n```java\npackage queue;\n\nimport java.util.Scanner;\n\npublic class CircleArrayQueueDemo {\n\n  public static void main(String[] args) {\n\n    //测试\n    System.out.println(\"测试数组模拟环形队列的案例~~~\");\n\n    // 创建一个环形队列\n    CircleArray queue = new CircleArray(4); //说明设置4, 其队列的有效数据最大是3\n    char key = ' '; // 接收用户输入\n    Scanner scanner = new Scanner(System.in);//\n    boolean loop = true;\n    // 输出一个菜单\n    while (loop) {\n      System.out.println(\"s(show): 显示队列\");\n      System.out.println(\"e(exit): 退出程序\");\n      System.out.println(\"a(add): 添加数据到队列\");\n      System.out.println(\"g(get): 从队列取出数据\");\n      System.out.println(\"h(head): 查看队列头的数据\");\n      key = scanner.next().charAt(0);// 接收一个字符\n      switch (key) {\n        case 's':\n          queue.showQueue();\n          break;\n        case 'a':\n          System.out.println(\"输出一个数\");\n          int value = scanner.nextInt();\n          queue.addQueue(value);\n          break;\n        case 'g': // 取出数据\n          try {\n            int res = queue.getQueue();\n            System.out.printf(\"取出的数据是%d\\n\", res);\n          } catch (Exception e) {\n            // TODO: handle exception\n            System.out.println(e.getMessage());\n          }\n          break;\n        case 'h': // 查看队列头的数据\n          try {\n            int res = queue.headQueue();\n            System.out.printf(\"队列头的数据是%d\\n\", res);\n          } catch (Exception e) {\n            // TODO: handle exception\n            System.out.println(e.getMessage());\n          }\n          break;\n        case 'e': // 退出\n          scanner.close();\n          loop = false;\n          break;\n        default:\n          break;\n      }\n    }\n    System.out.println(\"程序退出~~\");\n  }\n\n}\n\n\nclass CircleArray {\n  private int maxSize; // 表示数组的最大容量\n  //front 变量的含义做一个调整：front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素\n  //front 的初始值 = 0\n  private int front;\n  //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.\n  //rear 的初始值 = 0\n  private int rear; // 队列尾\n  private int[] arr; // 该数据用于存放数据, 模拟队列\n\n  public CircleArray(int arrMaxSize) {\n    maxSize = arrMaxSize;\n    arr = new int[maxSize];\n  }\n\n  // 判断队列是否满\n  public boolean isFull() {\n    return (rear  + 1) % maxSize == front;\n  }\n\n  // 判断队列是否为空\n  public boolean isEmpty() {\n    return rear == front;\n  }\n\n  // 添加数据到队列\n  public void addQueue(int n) {\n    // 判断队列是否满\n    if (isFull()) {\n      System.out.println(\"队列满，不能加入数据~\");\n      return;\n    }\n    //直接将数据加入\n    arr[rear] = n;\n    //将 rear 后移, 这里必须考虑取模\n    rear = (rear + 1) % maxSize;\n  }\n\n  // 获取队列的数据, 出队列\n  public int getQueue() {\n    // 判断队列是否空\n    if (isEmpty()) {\n      // 通过抛出异常\n      throw new RuntimeException(\"队列空，不能取数据\");\n    }\n    // 这里需要分析出 front是指向队列的第一个元素\n    // 1. 先把 front 对应的值保留到一个临时变量\n    // 2. 将 front 后移, 考虑取模\n    // 3. 将临时保存的变量返回\n    int value = arr[front];\n    front = (front + 1) % maxSize;\n    return value;\n\n  }\n\n  // 显示队列的所有数据\n  public void showQueue() {\n    // 遍历\n    if (isEmpty()) {\n      System.out.println(\"队列空的，没有数据~~\");\n      return;\n    }\n    // 思路：从front开始遍历，遍历多少个元素\n    // 动脑筋\n    for (int i = front; i < front + size() ; i++) {\n      System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]);\n    }\n  }\n\n  // 求出当前队列有效数据的个数\n  public int size() {\n    // rear = 2\n    // front = 1\n    // maxSize = 3\n    return (rear + maxSize - front) % maxSize;\n  }\n\n  // 显示队列的头数据， 注意不是取出数据\n  public int headQueue() {\n    // 判断\n    if (isEmpty()) {\n      throw new RuntimeException(\"队列空的，没有数据~~\");\n    }\n    return arr[front];\n  }\n}\n```\n\n","tags":["dataAlgorithm"]},{"title":"Inversion of Control控制反转","url":"/2020/05/13/Inversion-of-Control控制反转/","content":"\n### 控制反转的定义：\n\nInversion of Control控制反转，贯穿Spring的始终，Spring的核心。由spring来负责控制对象的生命周期和对象间的关系。\n\n<!--more-->\n\nIOC的思想是反转资源获取方向.传统的资源查找方式要求组件向容器发起请求查找资源.作为回应,容器适时的返回资源,而应用IOC之后,则是容器主动的将资源推送给它所管理的组件,组件所要做的仅仅是选择一种合适的方式来接受资源,这种行为也被称为查找的被动形式.\n\n\n\n▼传统的方法获取：\n\n```java\nPojo pojo = new Pojo( );\n```\n\n\n\n▼Spring管理的bean获取：\n\n```java\n@AutowiredPojo \npojo;\n```\n\n’ 对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。‘","tags":["frame"]},{"title":"链表","url":"/2020/05/12/链表/","content":"\n链表是有序的列表，但它在内存里是无序的。\n\n![img](链表.png)\n\n<!--more-->\n\n- 链表是以节点的方式来存储,是链式存储\n- 每个节点包含data 域， next 域：指向下一个节点\n- 各个节点不一定是连续存储.\n- 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定\n\n▼单链表：\n\n![img](单链表.png)\n\n实现：\n\n```java\npackage linkedlist;\n\n/**\n * @Author\n * @Date: 2020/5/11 10:59\n */\n\nimport java.util.Stack;\n\npublic class SingleLinkedListDemo {\n\n    public static void main(String[] args) {\n        //进行测试\n        //先创建节点\n        HeroNode hero1 = new HeroNode(1, \"宋江\", \"及时雨\");\n        HeroNode hero2 = new HeroNode(2, \"卢俊义\", \"玉麒麟\");\n        HeroNode hero3 = new HeroNode(3, \"吴用\", \"智多星\");\n        HeroNode hero4 = new HeroNode(4, \"林冲\", \"豹子头\");\n\n        //创建要给链表\n        SingleLinkedList singleLinkedList = new SingleLinkedList();\n\n\n        //加入\n        singleLinkedList.add(hero1);\n        singleLinkedList.add(hero4);\n        singleLinkedList.add(hero2);\n        singleLinkedList.add(hero3);\n\n        // 测试一下单链表的反转功能\n        System.out.println(\"原来链表的情况~~\");\n        singleLinkedList.list();\n\n//    System.out.println(\"反转单链表~~\");\n//    reversetList(singleLinkedList.getHead());\n//    singleLinkedList.list();\n\n        System.out.println(\"测试逆序打印单链表, 没有改变链表的结构~~\");\n        reversetList(singleLinkedList.getHead());\n\n\n    //加入按照编号的顺序\n    singleLinkedList.addByOrder(hero1);\n    singleLinkedList.addByOrder(hero4);\n    singleLinkedList.addByOrder(hero2);\n    singleLinkedList.addByOrder(hero3);\n\n    //显示一把\n    singleLinkedList.list();\n\n    //测试修改节点的代码\n    HeroNode newHeroNode = new HeroNode(2, \"小卢\", \"玉麒麟~~\");\n    singleLinkedList.update(newHeroNode);\n\n    System.out.println(\"修改后的链表情况~~\");\n    singleLinkedList.list();\n\n    //删除一个节点\n    singleLinkedList.del(1);\n    singleLinkedList.del(4);\n    System.out.println(\"删除后的链表情况~~\");\n    singleLinkedList.list();\n\n    //测试一下 求单链表中有效节点的个数\n    System.out.println(\"有效的节点个数=\" + getLength(singleLinkedList.getHead()));//2\n\n    //测试一下看看是否得到了倒数第K个节点\n    HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3);\n    System.out.println(\"res=\" + res);\n\n\n    }\n    //将单链表反转\n    public static void reversetList(HeroNode head) {\n        //如果当前链表为空，或者只有一个节点，无需反转，直接返回\n        if(head.next == null || head.next.next == null) {\n            return ;\n        }\n\n        //定义一个辅助的指针(变量)，帮助我们遍历原来的链表\n        HeroNode cur = head.next;\n        HeroNode next = null;// 指向当前节点[cur]的下一个节点\n        HeroNode reverseHead = new HeroNode(0, \"\", \"\");\n        //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端\n        //动脑筋\n        while(cur != null) {\n            next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用\n            cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端\n            reverseHead.next = cur; //将cur 连接到新的链表上\n            cur = next;//让cur后移\n        }\n        //将head.next 指向 reverseHead.next , 实现单链表的反转\n        head.next = reverseHead.next;\n    }\n\n    //查找单链表中的倒数第k个结点 【新浪面试题】\n    //思路\n    //1. 编写一个方法，接收head节点，同时接收一个index\n    //2. index 表示是倒数第index个节点\n    //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength\n    //4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到\n    //5. 如果找到了，则返回该节点，否则返回nulll\n    public static HeroNode findLastIndexNode(HeroNode head, int index) {\n        //判断如果链表为空，返回null\n        if(head.next == null) {\n            return null;//没有找到\n        }\n        //第一个遍历得到链表的长度(节点个数)\n        int size = getLength(head);\n        //第二次遍历  size-index 位置，就是我们倒数的第K个节点\n        //先做一个index的校验\n        if(index <=0 || index > size) {\n            return null;\n        }\n        //定义给辅助变量， for 循环定位到倒数的index\n        HeroNode cur = head.next; //3 // 3 - 1 = 2\n        for(int i =0; i< size - index; i++) {\n            cur = cur.next;\n        }\n        return cur;\n\n    }\n\n    //方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)\n    /**\n     *\n     * @param head 链表的头节点\n     * @return 返回的就是有效节点的个数\n     */\n    public static int getLength(HeroNode head) {\n        if(head.next == null) { //空链表\n            return 0;\n        }\n        int length = 0;\n        //定义一个辅助的变量, 这里我们没有统计头节点\n        HeroNode cur = head.next;\n        while(cur != null) {\n            length++;\n            cur = cur.next; //遍历\n        }\n        return length;\n    }\n\n}\n\n\n//定义SingleLinkedList 管理我们的英雄\nclass SingleLinkedList {\n    //先初始化一个头节点, 头节点不要动, 不存放具体的数据\n    private HeroNode head = new HeroNode(0, \"\", \"\");\n\n\n    //返回头节点\n    public HeroNode getHead() {\n        return head;\n    }\n\n    //添加节点到单向链表\n    //思路，当不考虑编号顺序时\n    //1. 找到当前链表的最后节点\n    //2. 将最后这个节点的next 指向 新的节点\n    public void add(HeroNode heroNode) {\n\n        //因为head节点不能动，因此我们需要一个辅助遍历 temp\n        HeroNode temp = head;\n        //遍历链表，找到最后\n        while(true) {\n            //找到链表的最后\n            if(temp.next == null) {//\n                break;\n            }\n            //如果没有找到最后, 将将temp后移\n            temp = temp.next;\n        }\n        //当退出while循环时，temp就指向了链表的最后\n        //将最后这个节点的next 指向 新的节点\n        temp.next = heroNode;\n    }\n\n    //第二种方式在添加英雄时，根据排名将英雄插入到指定位置\n    //(如果有这个排名，则添加失败，并给出提示)\n    public void addByOrder(HeroNode heroNode) {\n        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置\n        //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了\n        HeroNode temp = head;\n        boolean flag = false; // flag标志添加的编号是否存在，默认为false\n        while(true) {\n            if(temp.next == null) {//说明temp已经在链表的最后\n                break; //\n            }\n            if(temp.next.no > heroNode.no) { //位置找到，就在temp的后面插入\n                break;\n            } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在\n\n                flag = true; //说明编号存在\n                break;\n            }\n            temp = temp.next; //后移，遍历当前链表\n        }\n        //判断flag 的值\n        if(flag) { //不能添加，说明编号存在\n            System.out.printf(\"准备插入的英雄的编号 %d 已经存在了, 不能加入\\n\", heroNode.no);\n        } else {\n            //插入到链表中, temp的后面\n            heroNode.next = temp.next;\n            temp.next = heroNode;\n        }\n    }\n\n    //修改节点的信息, 根据no编号来修改，即no编号不能改.\n    //说明\n    //1. 根据 newHeroNode 的 no 来修改即可\n    public void update(HeroNode newHeroNode) {\n        //判断是否空\n        if(head.next == null) {\n            System.out.println(\"链表为空~\");\n            return;\n        }\n        //找到需要修改的节点, 根据no编号\n        //定义一个辅助变量\n        HeroNode temp = head.next;\n        boolean flag = false; //表示是否找到该节点\n        while(true) {\n            if (temp == null) {\n                break; //已经遍历完链表\n            }\n            if(temp.no == newHeroNode.no) {\n                //找到\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        //根据flag 判断是否找到要修改的节点\n        if(flag) {\n            temp.name = newHeroNode.name;\n            temp.nickname = newHeroNode.nickname;\n        } else { //没有找到\n            System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no);\n        }\n    }\n\n    //删除节点\n    //思路\n    //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点\n    //2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较\n    public void del(int no) {\n        HeroNode temp = head;\n        boolean flag = false; // 标志是否找到待删除节点的\n        while(true) {\n            if(temp.next == null) { //已经到链表的最后\n                break;\n            }\n            if(temp.next.no == no) {\n                //找到的待删除节点的前一个节点temp\n                flag = true;\n                break;\n            }\n            temp = temp.next; //temp后移，遍历\n        }\n        //判断flag\n        if(flag) { //找到\n            //可以删除\n            temp.next = temp.next.next;\n        }else {\n            System.out.printf(\"要删除的 %d 节点不存在\\n\", no);\n        }\n    }\n\n    //显示链表[遍历]\n    public void list() {\n        //判断链表是否为空\n        if(head.next == null) {\n            System.out.println(\"链表为空\");\n            return;\n        }\n        //因为头节点，不能动，因此我们需要一个辅助变量来遍历\n        HeroNode temp = head.next;\n        while(true) {\n            //判断是否到链表最后\n            if(temp == null) {\n                break;\n            }\n            //输出节点的信息\n            System.out.println(temp);\n            //将temp后移， 一定小心\n            temp = temp.next;\n        }\n    }\n}\n\n//定义HeroNode ， 每个HeroNode 对象就是一个节点\nclass HeroNode {\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode next; //指向下一个节点\n    //构造器\n    public HeroNode(int no, String name, String nickname) {\n        this.no = no;\n        this.name = name;\n        this.nickname = nickname;\n    }\n    //为了显示方法，我们重新toString\n    @Override\n    public String toString() {\n        return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\";\n    }\n\n}\n\n\n\n\n▼双向链表：\n\n单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点\n\npackage linkedlist;\n\n\npublic class DoubleLinkedListDemo {\n\n    public static void main(String[] args) {\n        // 测试\n        System.out.println(\"双向链表的测试\");\n        // 先创建节点\n        HeroNode2 hero1 = new HeroNode2(1, \"宋江\", \"及时雨\");\n        HeroNode2 hero2 = new HeroNode2(2, \"卢俊义\", \"玉麒麟\");\n        HeroNode2 hero3 = new HeroNode2(3, \"吴用\", \"智多星\");\n        HeroNode2 hero4 = new HeroNode2(4, \"林冲\", \"豹子头\");\n        // 创建一个双向链表\n        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();\n        doubleLinkedList.add(hero1);\n        doubleLinkedList.add(hero2);\n        doubleLinkedList.add(hero3);\n        doubleLinkedList.add(hero4);\n\n        doubleLinkedList.list();\n\n        // 修改\n        HeroNode2 newHeroNode = new HeroNode2(4, \"公孙胜\", \"入云龙\");\n        doubleLinkedList.update(newHeroNode);\n        System.out.println(\"修改后的链表情况\");\n        doubleLinkedList.list();\n\n        // 删除\n        doubleLinkedList.del(3);\n        System.out.println(\"删除后的链表情况~~\");\n        doubleLinkedList.list();\n\n\n\n    }\n\n}\n\n// 创建一个双向链表的类\nclass DoubleLinkedList {\n\n    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据\n    private HeroNode2 head = new HeroNode2(0, \"\", \"\");\n\n    // 返回头节点\n    public HeroNode2 getHead() {\n        return head;\n    }\n\n    // 遍历双向链表的方法\n    // 显示链表[遍历]\n    public void list() {\n        // 判断链表是否为空\n        if (head.next == null) {\n            System.out.println(\"链表为空\");\n            return;\n        }\n        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历\n        HeroNode2 temp = head.next;\n        while (true) {\n            // 判断是否到链表最后\n            if (temp == null) {\n                break;\n            }\n            // 输出节点的信息\n            System.out.println(temp);\n            // 将temp后移， 一定小心\n            temp = temp.next;\n        }\n    }\n\n    // 添加一个节点到双向链表的最后.\n    public void add(HeroNode2 heroNode) {\n\n        // 因为head节点不能动，因此我们需要一个辅助遍历 temp\n        HeroNode2 temp = head;\n        // 遍历链表，找到最后\n        while (true) {\n            // 找到链表的最后\n            if (temp.next == null) {//\n                break;\n            }\n            // 如果没有找到最后, 将将temp后移\n            temp = temp.next;\n        }\n        // 当退出while循环时，temp就指向了链表的最后\n        // 形成一个双向链表\n        temp.next = heroNode;\n        heroNode.pre = temp;\n    }\n\n    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样\n    // 只是 节点类型改成 HeroNode2\n    public void update(HeroNode2 newHeroNode) {\n        // 判断是否空\n        if (head.next == null) {\n            System.out.println(\"链表为空~\");\n            return;\n        }\n        // 找到需要修改的节点, 根据no编号\n        // 定义一个辅助变量\n        HeroNode2 temp = head.next;\n        boolean flag = false; // 表示是否找到该节点\n        while (true) {\n            if (temp == null) {\n                break; // 已经遍历完链表\n            }\n            if (temp.no == newHeroNode.no) {\n                // 找到\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        // 根据flag 判断是否找到要修改的节点\n        if (flag) {\n            temp.name = newHeroNode.name;\n            temp.nickname = newHeroNode.nickname;\n        } else { // 没有找到\n            System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no);\n        }\n    }\n\n    // 从双向链表中删除一个节点,\n    // 说明\n    // 1 对于双向链表，我们可以直接找到要删除的这个节点\n    // 2 找到后，自我删除即可\n    public void del(int no) {\n\n        // 判断当前链表是否为空\n        if (head.next == null) {// 空链表\n            System.out.println(\"链表为空，无法删除\");\n            return;\n        }\n\n        HeroNode2 temp = head.next; // 辅助变量(指针)\n        boolean flag = false; // 标志是否找到待删除节点的\n        while (true) {\n            if (temp == null) { // 已经到链表的最后\n                break;\n            }\n            if (temp.no == no) {\n                // 找到的待删除节点的前一个节点temp\n                flag = true;\n                break;\n            }\n            temp = temp.next; // temp后移，遍历\n        }\n        // 判断flag\n        if (flag) { // 找到\n            // 可以删除\n            // temp.next = temp.next.next;[单向链表]\n            temp.pre.next = temp.next;\n            // 这里我们的代码有问题?\n            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针\n            if (temp.next != null) {\n                temp.next.pre = temp.pre;\n            }\n        } else {\n            System.out.printf(\"要删除的 %d 节点不存在\\n\", no);\n        }\n    }\n\n}\n\n// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点\nclass HeroNode2 {\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode2 next; // 指向下一个节点, 默认为null\n    public HeroNode2 pre; // 指向前一个节点, 默认为null\n    // 构造器\n\n    public HeroNode2(int no, String name, String nickname) {\n        this.no = no;\n        this.name = name;\n        this.nickname = nickname;\n    }\n\n    // 为了显示方法，我们重新toString\n    @Override\n    public String toString() {\n        return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\";\n    }\n\n}\n\n\n\n▼循环链表：\n\npackage linkedlist;\n\npublic class Josepfu {\n\n  public static void main(String[] args) {\n    // 测试一把看看构建环形链表，和遍历是否ok\n    CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();\n    circleSingleLinkedList.addBoy(125);// 加入5个小孩节点\n    circleSingleLinkedList.showBoy();\n\n    //测试一把小孩出圈是否正确\n    circleSingleLinkedList.countBoy(10, 20, 125); // 2->4->1->5->3\n    //String str = \"7*2*2-5+1-5+3-3\";\n  }\n\n}\n\n// 创建一个环形的单向链表\nclass CircleSingleLinkedList {\n  // 创建一个first节点,当前没有编号\n  private Boy first = null;\n\n  // 添加小孩节点，构建成一个环形的链表\n  public void addBoy(int nums) {\n    // nums 做一个数据校验\n    if (nums < 1) {\n      System.out.println(\"nums的值不正确\");\n      return;\n    }\n    Boy curBoy = null; // 辅助指针，帮助构建环形链表\n    // 使用for来创建我们的环形链表\n    for (int i = 1; i <= nums; i++) {\n      // 根据编号，创建小孩节点\n      Boy boy = new Boy(i);\n      // 如果是第一个小孩\n      if (i == 1) {\n        first = boy;\n        first.setNext(first); // 构成环\n        curBoy = first; // 让curBoy指向第一个小孩\n      } else {\n        curBoy.setNext(boy);//\n        boy.setNext(first);//\n        curBoy = boy;\n      }\n    }\n  }\n\n  // 遍历当前的环形链表\n  public void showBoy() {\n    // 判断链表是否为空\n    if (first == null) {\n      System.out.println(\"没有任何小孩~~\");\n      return;\n    }\n    // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历\n    Boy curBoy = first;\n    while (true) {\n      System.out.printf(\"小孩的编号 %d \\n\", curBoy.getNo());\n      if (curBoy.getNext() == first) {// 说明已经遍历完毕\n        break;\n      }\n      curBoy = curBoy.getNext(); // curBoy后移\n    }\n  }\n\n  // 根据用户的输入，计算出小孩出圈的顺序\n  /**\n   *\n   * @param startNo\n   *            表示从第几个小孩开始数数\n   * @param countNum\n   *            表示数几下\n   * @param nums\n   *            表示最初有多少小孩在圈中\n   */\n  public void countBoy(int startNo, int countNum, int nums) {\n    // 先对数据进行校验\n    if (first == null || startNo < 1 || startNo > nums) {\n      System.out.println(\"参数输入有误， 请重新输入\");\n      return;\n    }\n    // 创建要给辅助指针,帮助完成小孩出圈\n    Boy helper = first;\n    // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点\n    while (true) {\n      if (helper.getNext() == first) { // 说明helper指向最后小孩节点\n        break;\n      }\n      helper = helper.getNext();\n    }\n    //小孩报数前，先让 first 和  helper 移动 k - 1次\n    for(int j = 0; j < startNo - 1; j++) {\n      first = first.getNext();\n      helper = helper.getNext();\n    }\n    //当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈\n    //这里是一个循环操作，知道圈中只有一个节点\n    while(true) {\n      if(helper == first) { //说明圈中只有一个节点\n        break;\n      }\n      //让 first 和 helper 指针同时 的移动 countNum - 1\n      for(int j = 0; j < countNum - 1; j++) {\n        first = first.getNext();\n        helper = helper.getNext();\n      }\n      //这时first指向的节点，就是要出圈的小孩节点\n      System.out.printf(\"小孩%d出圈\\n\", first.getNo());\n      //这时将first指向的小孩节点出圈\n      first = first.getNext();\n      helper.setNext(first); //\n\n    }\n    System.out.printf(\"最后留在圈中的小孩编号%d \\n\", first.getNo());\n\n  }\n}\n\n// 创建一个Boy类，表示一个节点\nclass Boy {\n  private int no;// 编号\n  private Boy next; // 指向下一个节点,默认null\n\n  public Boy(int no) {\n    this.no = no;\n  }\n\n  public int getNo() {\n    return no;\n  }\n\n  public void setNo(int no) {\n    this.no = no;\n  }\n\n  public Boy getNext() {\n    return next;\n  }\n\n  public void setNext(Boy next) {\n    this.next = next;\n  }\n\n}\n\n```\n\n\n\n","tags":["dataAlgorithm"]},{"title":"栈Stack","url":"/2020/05/11/栈Stack/","content":"\n## 栈(stack)\n\n1`栈`是一个**先入后出**(FILO-First In Last Out)的有序列表。\n\n<!--more-->\n\n2栈(stack)是限制线性表中元素的插入和删除**只能在线性表的同一端**进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为**栈顶**(Top)，另一端为固定的一端，称为**栈底**(Bottom)。\n\n3.根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除\n\n```\n           ───────────────────────────────┐\n  (\\(\\       (\\(\\    (\\(\\    (\\(\\    (\\(\\ │\n (='.') <─> (='.')  (='.')  (='.')  (='.')│\nO(_\")\")    O(_\")\") O(_\")\") O(_\")\") O(_\")\")│\n           ───────────────────────────────┘\n           stack\n```\n\n<!--more-->\n\n和队列区别开\n\n```\n          ────────────────────────\n  (\\(\\      (\\(\\    (\\(\\    (\\(\\      (\\(\\\n (='.') ─> (='.')  (='.')  (='.') ─> (='.')\nO(_\")\")   O(_\")\") O(_\")\") O(_\")\")   O(_\")\")\n          ────────────────────────\n           Queue\n```\n\n---\n\n##### 栈的结构\n\n```\n           ───────────────────────────────┐\n             (\\(\\    (\\(\\    (\\(\\    (\\(\\ │\n            (='.')  (='.')  (='.')  (='.')│\n           O(_\")\") O(_\")\") O(_\")\") O(_\")\")│\n           ───────────────────────────────┘\n             ↑                        ↑\n           Top栈顶                 Bottom栈底\n          初始化为-1\n```\n\n\n\n##### 入栈\n\n```\n           ───────────────────────────────┐\n  (\\(\\               (\\(\\    (\\(\\    (\\(\\ │\n (='.')  ─>         (='.')  (='.')  (='.')│\nO(_\")\")            O(_\")\") O(_\")\") O(_\")\")│\n  data     ───────────────────────────────┘\n           push入栈\n           top++;\n           stack[top]=data     \n```\n\n##### 出栈\n\n```\n           ───────────────────────────────┐\n         (\\(\\        (\\(\\    (\\(\\    (\\(\\ │\n    <─  (='.')      (='.')  (='.')  (='.')│\n       O(_\")\")     O(_\")\") O(_\")\") O(_\")\")│\n           ───────────────────────────────┘\n           pop出栈\n          int value = stack[top];\n          top--;\n          return value;\n```\n\n","tags":["dataAlgorithm"]},{"title":"SparseArray稀疏数组","url":"/2020/05/07/SparseArray稀疏数组/","content":"\nSparseArray\n\n## 稀疏数组\n\n\n\n\n\n\n\n![img](https://mmbiz.qpic.cn/mmbiz_jpg/LqMJZoibIrPxkb7YYhRmbdmHxsFb2c7Tol4pytSR2yW4pq9wSCjiaSkxlEY2V4L1AflRGQ8HqQcibtVfRSFofENcQ/640?wx_fmt=jpeg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**（稀疏数组）**\n\n<!--more-->\n\n### 定义\n\n##### 当一个数组中大部分的值未被使用，只有少部分的值的空间使用，造成了内存的浪费，这个时候就可以用到稀疏数组，保存需要的数据，节约内存空间。\n\n当记录一个棋盘时：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/LqMJZoibIrPzz08etWsVDczAaxvuTLF53AO9Y95X14hib9758qNT74snT2caWibZhtNQHCstK4KibDDibWcIxZhcPyQ/640?wx_fmt=png)\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/LqMJZoibIrPzz08etWsVDczAaxvuTLF53Lic6f7kA2vWzahAXd97hT2SjHxbZT4DociaLjYkS4q91sApHcibtMiaBNg/640?wx_fmt=png)\n\n记录棋盘的位置，只有两个内容，其他未被使用没有意义的值浪费了内存空间\n\n使用稀疏数组代替二维数组，第0行表示稀疏数组的总行，总列和所需内容的个数。\n\n### 实现\n\n```java\npackage com.kayleh.tmall.controller;\n\n/**\n * @Author: Wizard\n * @Date: 2020/5/7 9:16\n */\npublic class SparseArray {\n    public static void main(String[] args) {\n        //创建一个二维数组\n        //0:表示没有棋子 1表示黑子 2表示蓝子\n        int chessArr[][] = new int[11][10];\n        chessArr[1][2] = 1;\n        chessArr[2][3] = 2;\n        for(int[] row:chessArr){\n            for(int data:row){\n                System.out.printf(\"%d\\t\",data);\n            }\n            System.out.println();\n        }\n\n        int[][] array = getSparseArray(chessArr);\n        System.out.println(\"-------\");\n        for(int i = 0 ; i< array.length;i++){\n            System.out.printf(\"%d\\t%d\\t%d\\t\\n\",array[i][0],array[i][1],array[i][2]);\n        }\n        System.out.println(\"--------\");\n        int[][] startArr = recovery(array);\n        for(int[] row:startArr){\n            for(int data:row){\n                System.out.printf(\"%d\\t\",data);\n            }\n            System.out.println();\n        }\n    }\n\n    /**\n     * 将普通数组转换为稀疏数组\n     * @param chessArr\n     * @return\n     */\n    public static int[][] getSparseArray(int[][] chessArr){\n        if(!checkIsRight(chessArr)){\n            return null;\n        }\n\n        //1.拿到数组后 首先获取元素的个数,然后才能建立稀疏数组\n        int sum = 0;\n        for(int[] arr:chessArr){\n            for(int i:arr){\n                if(i != 0){\n                    sum++;\n                }\n            }\n        }\n\n        //2.建立稀疏数组\n        int[][] sparseArr = new int[sum+1][3];\n        sparseArr[0][0] = chessArr.length; //行\n        sparseArr[0][1] = chessArr[0].length;//列\n        sparseArr[0][2] = sum; //元素个数\n\n        //3.数组存放\n        int count = 0;\n        for(int i = 0; i <chessArr.length; i++ ){\n            for(int j = 0; j <chessArr[i].length;j++ ){\n                if(chessArr[i][j] != 0){\n                    sparseArr[++count][0] = i;//行\n                    sparseArr[count][1] = j;//列\n                    sparseArr[count][2] = chessArr[i][j];\n                }\n            }\n        }\n\n        return sparseArr;\n    }\n\n    /**\n     * 将稀疏数组转回普通数组\n     * @param sparseArr\n     * @return\n     */\n    public static int[][] recovery(int[][] sparseArr){\n        if(!checkIsRight(sparseArr)){\n            return null;\n        }\n\n        //获取原数组的 行数和列数 并创建原数组\n        int arr[][] = new int[sparseArr[0][0]][sparseArr[0][1]];\n\n        for(int i = 1; i < sparseArr.length;i++){\n            arr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n        }\n\n        return arr;\n    }\n\n        \n    public static boolean checkIsRight(int[][] arr){\n        if(arr == null || arr.length <= 1 ){\n            return false;\n        }\n        return true;\n    }\n\n}\n```\n\n\n\n每日学习干货 ∣一个有用的公众号\n\n<img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/LqMJZoibIrPyPJDbc4wR8wu8zW98s0OTbHnwdmFpVv0pYAAblBa6lR0eT93ajVcthgdepV1ngELmGHVoq66yyFg/640?wx_fmt=jpeg\" alt=\"img\" style=\"zoom: 25%;\" />\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/LqMJZoibIrPyPJDbc4wR8wu8zW98s0OTbeYy7VLjmJiblFGanJ8zZRlUQoCKfEvNQFeeGN68vRV6icv8HOL4lW96A/640?wx_fmt=png)\n\n长按，识别二维码，加关注\n\n\n\n\n\n\n","tags":["dataAlgorithm"]},{"title":"维护1","url":"/2020/05/01/维护1/","content":"\n#### 维护1\n\n<!--more-->\n\n1.添加评论功能\n\n2.添加鼠标点击出现爱心事件\n\n","tags":["maintain"]},{"title":"Java memory model内存模型","url":"/2020/04/30/Java-memory-model内存模型/","content":"\n### Java内存模型\n\n​\tjmm规范，他规范了java虚拟机与计算机内存如何协调工作，他规定了一个线程如何及何时看到其他线程修改过的变量的值，以及在必须时，如何同步的访问共享变量。\n\n<!--more-->\n\n### jmm内存分配概念\n\n#### 堆heap:\n\n优点:运行时数据区,动态分配内存大小,有gc;\n\n缺点:因为要在运行时动态分配,所以存取速度慢,对象存储在堆上,静态类型的变量跟着类的定义一起存储在堆上.\n\n#### 栈stack:\n\n存取速度快,仅次于寄存器,\n\n缺点: 数据大小与生存期必须是确定的,缺乏灵活性,栈中主要存放基本类型变量(比如,int,short,byte,char,double,float,boolean和对象句柄),jmm要求,调用栈和本地变量存放在线程栈上\n\n当一个线程可以访问一个对象时,也可以访问对象的成员变量,如果有两个线程访问对象的成员变量,则每个线程都有对象的成员变量,则每个线程都有对象的成员变量的私有拷贝.","tags":["jvm"]},{"title":"面向对象的特征","url":"/2020/04/29/面向对象的特征/","content":"\n## 面向对象的特征有哪些方面\n\n### 封装\n\n最常见的是把属性私有化封装在一个类里面，只能通过方法去访问\n\n<!--more-->\n\n### 继承extends\n\n可以复用代码， 继承是面向对象编程的一种强大的代码复用方式； \n\n子类继承父类，从而继承了父类的方法和属性；\n\n Java只允许单继承，所有类最终的根类是`Object`； \n\n `protected`允许子类访问父类的字段和方法；  `protected`关键字可以把字段和方法的访问权限控制在继承树内部，一个`protected`字段和方法可以被其子类，以及子类的子类所访问。 \n\n父类没有无参构造器时，子类任何class调用父类构造器时，必须调用super父类有的构造器。\n\n如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法。即子类*不会继承*任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。\n\n##### 向上转型\n\n类型提升。\n\n把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。\n\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型。\n\n##### 向下转型\n\n 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。  向下转型很可能会失败。 \n\n### 抽象\n\n 由于多态的存在，每个子类都可以覆写父类的方法 \n\n如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰。\n\n因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。\n\n使用`abstract`修饰的类就是抽象类。我们无法实例化一个抽象类。\n\n- 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；\n- 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；\n- 如果不实现抽象方法，则该子类仍是一个抽象类；\n- 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。\n\n### 多态\n\n 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。\n\n 多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 \n\n- 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；\n- Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；\n- `final`修饰符有多种作用：\n  - `final`修饰的方法可以阻止被覆写；\n  - `final`修饰的class可以阻止被继承；\n  - `final`修饰的field必须在创建对象时初始化，随后不可修改。\n\n"},{"title":"动态数组","url":"/2020/04/26/动态数组/","content":"\n# 数组(Array)\n\n#### 数组是一种顺序储存的线性表,所有元素的内存地址是连续. \n\n```java\nint[] array = new int[]{20, 30, 40}\n//向内存申请了12个字节地址\n```\n\n<!--more-->\n\n![在这里插入图片描述](20200328103402109.png)\n\n- 在很多编程语言中，数组有个致命的缺点， **无法动态修改容量**。\n\n- 实际开发中我们希望数组的容量是动态变化的。\n\n  \n\n# 动态数组\n\n创建ArrayList类,创建size属性来管理数组中元素的个数,创建element属性来管理存取的数据.\n\n可以对动态数组进行增删改查操作.\n\n![](0200328103943700.png)\n\n```java\npublic class ArrayList<E> {\n    private int size;\n    private E[] elements;\n\n\t// 元素的数量\n\tint size(); \n\t// 是否为空\n\tboolean isEmpty();\n\t// 是否包含某个元素\n\tboolean contains(E element); \n\t// 添加元素到最后面\n\tvoid add(E element); \n\t// 返回index位置对应的元素\n\tE get(int index); \n\t// 设置index位置的元素\n\tE set(int index, E element); \n\t// 往index位置添加元素\n\tvoid add(int index, E element); \n\t// 删除index位置对应的元素 \n\tE remove(int index); \n\t// 查看元素的位置\n\tint indexOf(E element); \n\t// 清除所有元素\n\tvoid clear(); \n}\n\n```\n\n### 动态数组的实现\n\n#### 构造方法\n\n如果构建的数组空间小于默认空间,则会以默认空间创建数组.\n\n```java\npublic class ArrayList<E> {\n    /**\n     * 元素的数量\n     */\n    private int size;\n\n    /**\n     * 所有元素\n     */\n    private E[] elements;\n\n    /**\n     * 数组的默认容量\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\t/**\n     * 找不到元素返回-1\n     */\n    private static final int ELEMENT_NOT_FOUNT = -1;\n\n    public ArrayList() {\n        // 默认容量\n        //elements = new int[DEFAULT_CAPACITY];\n        this(DEFAULT_CAPACITY); // 调用下面的构造器\n    }\n\n    public ArrayList(int capacity) {\n        // 设置默认容量为 10\n        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;\n\n        // 因为泛型(所以传一个Object数组,然后通过强转)\n        elements = (E[]) new Object[capacity];\n    }\n}\n\n```\n\n\n\n#### 添加元素\n\n- 数组添加元素分为`在最后一个元素的后面添加新元素`和`将元素插入到某个位置（非最后面）`两种情况。\n- 第一种情况，这个`新元素需要添加到的索引`等于`当前数组元素的个数`，在ArrayList中`size`属性就是`当前数组元素的个数`，所以就是将新元素添加到数组的`size`位置上，然后`size加1`。\n\n![](20200328104623565.png)\n\n```java\npublic void add(int index, E element) {\n    elements[index] = element;\n    size++;\n}\n```\n\n- 如果是第二种情况，只需要将插入位置后面的元素向后移动即可。\n- 注意：需要从后向前移动元素，如果从前向后移动元素，那么会进行元素覆盖, 最后出错。\n\n![](20200328105012778.png)\n\n#### 数组越界\n\n添加元素,还要注意传入的索引不能越界,即不能小于0,也不能大于size.\n\n```java\n/**\n * 根据index插入元素时,判断index是否有效\n *\n * @param index\n */\nprivate void rangeCheckForAdd(int index) {\n    if (index < 0 || index > size) {\n        indexOutOfBounds(index);\n    }\n}\n```\n\n```java\n/**\n * 封装数组越界异常\n *\n * @param index\n */\nprivate void indexOutOfBounds(int index) {\n    throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size:\" + size);\n}\n\n```\n\n#### 数组扩容\n\n动态扩容思路:\n\n- 通过默认容量创建的数组,是在堆空间中随机生成的地址;如此一来再申请空间拼接到该数组后,这种方式不可能实现;\n- 我们只能再创建一个大容量的数组,然后将之前数组中的元素移动到这个数组中;然后将引用指向新数组即可!\n\n- 由于数组elements最大的容量只有10，所以当数组存满元素时，就需要对数组进行扩容。\n\n- 因为数组是无法动态扩容的，所以需要创建一个新的数组，这个数组的容量要比之前数组的容量大。\n\n- 然后在将原数组中的元素存放到新数组中，这样就实现了数组的扩容。\n\n![](2020032810554134.png)\n\n-  该方法确保默认容量为多少,为了验证`是否超过给定的默认容量`,然后进行判断是否要扩容;这里`size+1`为数组当前数量+1, 因为每次`add`都会增加一个容量。 \n\n```java\n/**\n * 确保至少要有capacity个容量\n *\n * @param capacity\n */\nprivate void ensureCapacity(int capacity) {\n\n    // 获取数组当前容量\n    int oldCapacity = elements.length;\n    // 判断是否要扩容\n    if (oldCapacity >= capacity)\n        return; // 此时不扩容\n\n    // 这种方式是扩容1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n\n    E[] newElements = (E[]) new Object[newCapacity];\n    // 将原来数组中的元素移动到新数组中\n    for (int i = 0; i < size; i++) {\n        newElements[i] = elements[i];\n    }\n    // 将数组引用指向新数组\n    elements = newElements;\n}\n\n```\n\n 实现add函数，需要在添加新元素之前，判断数组越界和扩容。 \n\n```java\n/**\n * 在index位置插入一个元素\n *\n * @param index\n * @param element\n */\npublic void add(int index, E element) {\n    // 在添加元素的时候,判断index是否有效\n    rangeCheckForAdd(index);\n\n    ensureCapacity(size + 1);\n\n    // 注意: 插入元素后,元素是从后开始往后挪\n    for (int i = size - 1; i >= index; i--) {\n        elements[i + 1] = elements[i];\n    }\n    elements[index] = element;\n    size++;\n}\n\n```\n\n 最终在最后一个元素的后面添加新元素，即添加元素到尾部的实现方式如下 \n\n```java\n/**\n * 添加元素到尾部\n *\n * @param element\n */\npublic void add(E element) {\n    // elements[size++] = element;\n    // 传入数组数量(相当于在最后插入元素)\n    add(size, element);\n}\n```\n\n#### 删除元素\n\n- 删除元素，实际上就是`移除指定位置的元素`，并将`后面的元素向前移动`。\n- 如下图，当删除索引为`3`的元素时，只需要将后面的元素向前移动，然后在去掉最后一个元素，`size减1`即可。\n\n![](20200328110106999.png)\n\n#### 数组越界\n\n-  删除元素时传入的索引不能越界, 即不能小于0, 也不能大于等于size所以我们在删除元素之前需要先进行索引检查。 \n\n  \n\n```java\nprivate void indexOutOfBounds(int index) {\n    throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size:\" + size);\n}\n\t\nprivate void rangeCheck(int index) {\n    if (index < 0 || index >= size) {\n        outOfBounds(index);\n    }\n}\n```\n\n#### 数组缩容\n\n- 当数组中的元素删除后，数组剩余的空间可能会很大，这样就会造成内存的浪费。\n\n- 所以当数组中元素删除后，我们需要对数组进行`缩容`。\n\n- 实现方法类似于扩容，当数组中容量小于某个值时，创建新的数组，然后将原有数组中的元素存入新数组即可。\n\n  \n\n```java\n/**\n * 数组缩容\n */\npublic void trim() {\n    // 获取当前数组的容量\n    int capacity = elements.length;\n    // 当size大于等于容量的一半, 或则容量已经小于默认容量(10)时, 直接返回\n    if (size >= capacity >> 1 || capacity < CAPACITY_DEFAULT) return;\n    // 计算新的容量 = 原有容量的一半\n    int newCapacity = capacity >> 1;\n    // 创建新数组\n    E[] newElements = (E[]) new Object[newCapacity];\n    // 将原数组元素存入新数组\n    for (int i = 0; i < size; i++) {\n    \tnewElements[i] = elements[i];\n    }\n    // 引用新数组\n    elements = newElements;\n}\n```\n\n 最终, remove方法实现如下 \n\n```java\n/**\n * 删除index位置的元素\n *\n * @param index\n * @return 被删除的元素\n */\npublic E remove(int index) {\n    rangeCheck(index);\n    E delEle = elements[index];\n\n    // 当删除一个元素时,需要挪动后面元素的范围\n    for (int i = index + 1; i <= size - 1; i++) {\n        elements[i - 1] = elements[i];\n    }\n    size--;\n    // 同clear的细节,当从后往前以后时,最后一个的地址需要释放\n    elements[size] = null;\n    // 判断数组是否需要缩容\n    trim();\n    return delEle;\n}\n\n/**\n * 删除传入的元素\n * @param element\n */\npublic void remove(E element){\n    remove(indexOf(element));\n}\n```\n\n#### 清空数组\n\n 清空数组时，需要将所有的元素置为null，只有这样才能真正的释放对象，然后size置为0。 \n\n![](20200328110807352.png)\n\n```java\n/**\n * 清除所有元素\n */\npublic void clear() {\n    for (int i = 0; i < size; i++) {\n        elements[i] = null;\n    }\n    size = 0;\n}\n```\n\n#### 修改元素\n\n 修改元素时，只需要将原有位置的元素`替换`掉即可，同样需要注意一下索引是否`越界`。 \n\n```java\n/**\n * 设置index位置的元素\n *\n * @param index\n * @param element\n * @return 原来的元素\n */\npublic E set(int index, E element) {\n    rangeCheck(index);\n\n    E oldEle = elements[index];\n    elements[index] = element;\n    return oldEle;\n}\n```\n\n#### 查询元素\n\n 查询元素，只需要将指定索引的元素返回，注意索引是否越界即可。 \n\n```java\n/**\n * 获取index位置的元素\n *\n * @param index\n * @return\n */\npublic E get(int index) {\n    // 约束Index\n    rangeCheck(index);\n    return elements[index];\n}\n```\n\n#### 查看元素位置\n\n- 可以通过循环, 查找元素在数组中的位置。\n- 注意：假如数组中可以存储`null`，而null是不能调用`equals`方法的，所以需要对传入的元素进行判断，如果查找的元素是`null`，需要单独处理。\n- 当元素存在时返回索引，否则返回变量`ELEMENT_ON_FOUND`的值。\n\n```java\n/**\n * 查看元素的索引\n *\n * @param element\n * @return\n */\npublic int indexOf(E element) {\n    if (element == null) {\n        // 循环判断如果element为null,直接返回null的索引\n        for (int i = 0; i < size; i++) {\n            if (elements[i] == null)\n                return i;\n        }\n    } else {\n        for (int i = 0; i < size; i++) {\n            // 因为element肯定不为null了,所以放在前面;避免空指针异常\n            if (element.equals(elements[i]))\n                return i;\n        }\n    }\n    return ELEMENT_NOT_FOUNT;\n}\n```\n\n#### 是否包含某元素\n\n 只需通过判断索引是否等于`ELEMENT_ON_FOUND`即可。 \n\n```java\n/**\n * 是否包含某个元素\n *\n * @param element\n * @return\n */\npublic boolean contains(E element) {\n    // 如果element元素可以找到\n    return indexOf(element) != ELEMENT_NOT_FOUNT;\n}\n```\n\n#### 元素的数量\n\n size的值，即为元素的数量 \n\n```java\n/**\n * 元素的数量\n *\n * @return\n */\npublic int size() {\n    return size;\n}\n\n```\n\n#### 数组是否为空\n\n 通过判断`size`的值是否为`0`即可 \n\n```java\n/**\n * 是否为空\n *\n * @return\n */\npublic boolean inEmpty() {\n    return size == 0;\n}\n\n```\n\n#### 动态数组打印\n\n 可以重写`toString`方法, 来打印`ArrayList`中的元素。 \n\n```java\n@Override\npublic String toString() {\n    // 打印格式: size=3, [10, 20, 30]\n    // 使用StringBuilder 效率高一些\n    StringBuilder string = new StringBuilder();\n    string.append(\"size=\").append(size).append(\", [\");\n    for (int i = 0; i < size; i++) {\n        string.append(elements[i]);\n        if (i != size - 1) {\n            string.append(\", \");\n        }\n    }\n    string.append(\"]\");\n    return string.toString();\n}\n\n```\n\n **这样就实现了动态数组的基本操作。** \n\n# ArrayList能否进一步优化？\n\n- 在ArrayList中，如果要删除索引0位置的元素，则需要将索引0之后的元素全部往前移一位。\n- 如果要在索引`0`位置添加元素，也需要将索引`0`及之后的元素全`部往后移一位`。\n\n![](20200328112238774.png)\n\n- 在ArrayList中`增加一个记录首元素位置的属性`。\n- 删除索引`0`位置的元素，我们只需要将`first`属性改为`1`。\n- -在索引`0`位置添加元素，则只需要将`first`属性改为`0`。\n\n![](20200328112539197.png)\n\n- 如果继续往前插入元素，则将插入的元素存放在索引`8`这个位置，并将`first`改为`8`。\n- 当要获取索引`8`下一个元素时，对索引取`模`，则拿到索引`0`位置的元素。\n\n![](D:\\Blog\\source\\_posts\\【数据结构和算法】动态数组\\20200328112630777.png)\n\n- 如果插入元素，则可选择挪动`前半段`数据或`后半段`数据。\n- 在索引`2`处插入元素`99`，可以选择将元素`22`，`33`左移，然后插入`99`即可。\n- `扩容`和`缩容`同样可以优化。\n\n![](20200413231142422.png)\n\n\n\n# 重点总结\n\n\n#### 动态扩容思路\n\n通过默认容量创建的数组,是在堆空间中随机生成的地址;如此一来\n再申请空间拼接到该数组后,这种方式不可能实现;\n我们只能再创建一个大容量的数组,然后将之前数组中的元素移动到\n这个数组中;然后将引用指向新数组即可!\n\n#### 如何确保容量是否越界\n\n该方法确保默认容量为多少, 为了验证是否超过给定的默认容量,然后进行判断是否要扩容; 这里size+1为数组当前数量+1, 因为每次add都会增加一个容量。\n\n```java\n  ensureCapacity(size + 1);\n```\n\n#### 增加泛型\n\n使用泛型, 使动态数组可以添加任何类型的数据。\n\n```java\n  elements = (E[]) new Object[capacity];\n```\n\n\n##### clear方法的过渡细节\n\n因为之前存储的都是int数据, 直接设置size=0时, 开辟的存储int类型的空间就不能被访问, 当add后, 就可以访问后面的空间, 所以此时的空间可以重复利用;\n\n当使用泛型后, 动态数组中存储的都是对象类型, 实际存储的都是对象的地址, 每一个对象的地址又有一块空间引用着; 此时如果仍设置 size=0, 当clear后,开辟的存储空间中的地址没有被销毁, 地址仍被对象空间引用着; 这样以来存储对象的空间就不会被释放; 但是存储地址的数组可以重复利用; 所以要将地址数组都置为null, 然后size=0, 这样以来,引用该地址的对象空间也就释放了!\n\n#### remove、indexOf的细节\n\n\nremove最后一个地址也要情况, 同clear细节\n在indexOf方法中,不用==比较, 因为比较的是地址值,一般重写equals方法自己定义比较内容即可;\nnull值处理: 当往数组传null的时候,indexOf的比较处理: 如果那null.equals来比较会出现空指针异常;\n","tags":["dataAlgorithm"]},{"title":"斐波那契数列","url":"/2020/04/22/斐波那契数列/","content":"\n## 斐波那契数列\n\n斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。\n\n<!--more-->\n\n#### 求：斐波那契数列的第n个数是？\n\n简单的代码就可以实现：\n\n```java\n/**\n * @Author: Wizard\n * @Date: 2020/4/22 20:38\n */\npublic class main {\n    /**\n     * 斐波那契数列\n     * @param args\n     */\n    public static void main(String[] args) {\n        System.out.println(fib(21));\n    }\n\n    public static int fib(int n) {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n\n```\n\n运用递归的写法，可以实现但是有个缺点\n\n我们可以用currentTimeMillis计算耗时 fib( 40 )：\n\n```bash\n耗时5.16秒\n```\n\n换一种算法，不实现递归。\n\n```java\n/**\n     * 0  1   2   3   4   5   6\n     * 0  1   1   2   4   8  16\n     *   fr  sd  sum\n     *       fr  sd\n     *\t思想是假设计算第3个斐波那契数时,用于计算的数是第一个数(fr)和第二个数(sd)相加,得到第三个数sum.\n     *  那么计算第四个数是第三个数加第四个数,也就是sd和sum, 把sd和sum赋值给计算第四个数计算的时候的fr和sd\t  *  就可以了.我们可以先把数列的第一个数first,第二个数second赋值为0,1.在进行for循环.\n     * @param n\n     * @return\n     */\npublic static int fib1(int n) {\n        if (n <= 1) return n;\n        int first = 0;\n        int second = 1;\n        for (int i = 0; i < n - 1; i++) {\n            int sum = first + second;\n            first = second;\n            second = sum;\n        }\n        return second;\n    }\n```\n\n\n\n当我们测试运行第123112340的数:\n\n```\n耗时0.54秒\n```\n\n性能比递归高了不少.","tags":["dataAlgorithm"]},{"title":"Spring、SpringMVC、Mybatis整合","url":"/2020/04/20/Spring、SpringMVC、Mybatis整合/","content":"\n### 整合说明\n服务器开发分为三层,表现层、业务层、持久层\n表现层使用SpringMVC实现,业务程使用Spring实现,持久层使用Mybatis实现\n使用Spring框架来整合 SpringMVC和Mybatis框架\n这里使用xml配置文件+注解的方式进行搭建\n<!-- more -->\n\n#### 最终目标\n\n##### 最终实现通过前端页面对数据库进行查询和插入,实现用户的登录注册功能\n\n### 准备\n\n#### 创建Maven工程\n![](start.png)\n\n##### 选择webapp\n![](new.png)\n![](3.png)\n\n##### 数据库准备\n``` sql\ncreate database ssm;\nuse ssm;\ncreate table account(\nid int primary key auto_increment,\nname varchar(20),\nmoney double\n);\n```\n![](data.png)\n####创建目录\n![](root.png)\n####导入依赖\n![](deloy.png)\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.kayleh</groupId>\n  <artifactId>SSM</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n  <name>SSM Maven Webapp</name>\n  <!-- FIXME change it to the project's website -->\n  <url>http://www.example.com</url>\n\n  <!--版本锁定-->\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n    <spring.version>5.0.2.RELEASE</spring.version>\n    <slf4j.version>1.6.6</slf4j.version>\n    <log4j.version>1.2.12</log4j.version>\n    <mysql.version>5.1.6</mysql.version>\n    <mybatis.version>3.4.5</mybatis.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n    <!-- spring -->\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.6.8</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aop</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-tx</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>${mysql.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>servlet-api</artifactId>\n      <version>2.5</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet.jsp</groupId>\n      <artifactId>jsp-api</artifactId>\n      <version>2.0</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>jstl</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n    <!-- log start -->\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>${log4j.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>${slf4j.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>${slf4j.version}</version>\n    </dependency>\n    <!-- log end -->\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>${mybatis.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis-spring</artifactId>\n      <version>1.3.0</version>\n    </dependency>\n    <dependency>\n      <groupId>c3p0</groupId>\n      <artifactId>c3p0</artifactId>\n      <version>0.9.1.2</version>\n      <type>jar</type>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n  <build>\n    <finalName>SSM</finalName>\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n```\n#### 编写实体类\n``` java\npackage com.kayleh.domain;\nimport java.io.Serializable;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:06\n *\n * 账户\n */\npublic class Account implements Serializable {\n    private Integer id;\n    private String name;\n    private Double money;\n    public Integer getId() {\n        return id;\n    }\n    .........\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n}\n```\n#### dao接口\n``` java\npackage com.kayleh.dao;\nimport com.kayleh.domain.Account;\nimport java.util.List;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:11\n * <p>\n * 账户dao接口\n */\npublic interface AccountDao {\n    //查询所有账户\n    public List<Account> findAll();\n    //保存账户信息\n    public void saveAccount(Account account);\n}\n```\n#### 业务service层和实现\n```java\npackage com.kayleh.service;\nimport com.kayleh.domain.Account;\nimport java.util.List;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:16\n */\npublic interface AccountService {\n    //查询所有账户\n    public List<Account> findAll();\n    //保存账户信息\n    public void saveAccount(Account account);\n}\n-----------------------------------------------------\npackage com.kayleh.service.impl;\nimport com.kayleh.domain.Account;\nimport com.kayleh.service.AccountService;\nimport org.springframework.stereotype.Service;\nimport java.util.List;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:18\n */\n@Service(\"accountService\")\npublic class AccountServiceImpl implements AccountService {\n    public List<Account> findAll() {\n        System.out.println(\"业务层:查询所有账户...\");\n        return null;\n    }\n    public void saveAccount(Account account) {\n        System.out.println(\"业务层:保存账户...\");\n    }\n}\n```\n## Spring整合\n在resource下创建Spring配置文件\n![](1.png)\n####命名空间\n```xml\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx.xsd\">\n```\n####注解扫描\n```xml\n<!-- 开启注解的扫描,希望处理service和dao,controller不需要Spring框架去处理,controller注解由SpringMVC处理 -->\n    <context:component-scan base-package=\"com.kayleh\">\n        <!-- 配置哪些注解不扫描 -->\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n```\n####测试\n```java\npackage com.kayleh.test;\nimport com.kayleh.service.AccountService;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:38\n */\npublic class TestSpring {\n    @Test\n    public void run1(){\n        //加载配置文件\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        //获取对象\n        AccountService as = (AccountService) ac.getBean(\"accountService\");\n        //调用方法\n        as.findAll();\n    }\n}\n```\n###### 运行测试,成功调用accountService\n\n---\n## 搭建和测试SpringMVC的开发环境\n1.在web.xml中配置DispatcherServlet前端控制器\n```xml\n<!-- 配置前端控制器：服务器启动必须加载,需要加载springmvc.xml配置文件 -->\n<servlet>\n<servlet-name>dispatcherServlet</servlet-name>\n<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n<!-- 配置初始化参数,创建完DispatcherServlet对象,加载springmvc.xml配置文件 -->\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>classpath:springmvc.xml</param-value>\n</init-param>\n<!-- 服务器启动的时候,让DispatcherServlet对象创建 -->\n<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n<servlet-name>dispatcherServlet</servlet-name>\n<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n2.在web.xml中配置DispatcherServlet过滤器解决中文乱码\n```xml\n<!-- 配置解决中文乱码的过滤器 -->\n<filter>\n<filter-name>characterEncodingFilter</filter-name>\n<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n<init-param>\n<param-name>encoding</param-name>\n<param-value>UTF-8</param-value>\n</init-param>\n</filter>\n<filter-mapping>\n<filter-name>characterEncodingFilter</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n3.创建springmvc.xml的配置文件,编写配置文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/mvc\nhttp://www.springframework.org/schema/mvc/spring-mvc.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- 开启注解扫描 -->\n    <context:component-scan base-package=\"com.kayleh\">\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n\n    <!--配置的视图解析器对象-->\n    <bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/pages/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n\n    <!--过滤静态资源-->\n    <mvc:resources mapping=\"/CSS/**\" location=\"/CSS/\"/>\n    <mvc:resources mapping=\"/images/**\" location=\"/images/\"/>\n    <mvc:resources mapping=\"/js/**\" location=\"/js/\"/>\n    <!--开启SpringMVC的注解支持-->\n    <mvc:annotation-driven/>\n</beans>\n```\n4. 测试SpringMVC的框架搭建是否成功\n   1.编写index.jsp和list.jsp编写,超链接\n    自带的index.jsp没有头部信息，需要重新创建\n``` xml\n    <a href=\"account/findAll\">查询所有</a>\n```\n   2.创建AccountController类,编写方法,进行测试\n    \n``` java\n    package cn.kayleh.controller;\n    import org.springframework.stereotype.Controller;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    @Controller\n    @RequestMapping(\"/account\")\n    public class AccountController {\n    /**\n    * 查询所有的数据\n    * @return\n    */\n    @RequestMapping(\"/findAll\")\n    public String findAll() {\n    System.out.println(\"表现层：查询所有账户...\");\n    return \"list\";\n    }\n    }\n```\n\n##Spring整合SpringMVC的框架\n1. 目的：在controller中能成功的调用service对象中的方法.\n2. 在项目启动的时候,就去加载applicationContext.xml的配置文件,在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文\n件）。\n```xml\n<!-- 配置Spring的监听器 -->\n<listener>\n<listener-class>org.springframework.web.context.ContextLoaderListener</listenerclass>\n</listener>\n<!-- 配置加载类路径的配置文件 -->\n<context-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>classpath:applicationContext.xml</param-value>\n</context-param>\n```\n\n\n3. 在controller中注入service对象,调用service对象的方法进行测试\n```java\npackage cn.itcast.controller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport cn.kayleh.service.AccountService;\n@Controller\n@RequestMapping(\"/account\")\npublic class AccountController {\n        @Autowired\n        private AccountService accoutService;\n/**\n* 查询所有的数据\n* @return\n*/\n@RequestMapping(\"/findAll\")\npublic String findAll() {\nSystem.out.println(\"表现层：查询所有账户...\");\naccoutService.findAll();\nreturn \"list\";\n    }\n}\n```\n\n## Spring整合MyBatis框架\n### 搭建和测试MyBatis的环境\n###### 在web项目中编写SqlMapConfig.xml的配置文件，编写核心配置文件,在后面整合进applicationContext.xml后可以删除\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\nPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n<environments default=\"mysql\">\n<environment id=\"mysql\">\n<transactionManager type=\"JDBC\"/>\n<dataSource type=\"POOLED\">\n<property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n<property name=\"url\" value=\"jdbc:mysql:///ssm\"/>\n<property name=\"username\" value=\"root\"/>\n<property name=\"password\" value=\"admin\"/>\n</dataSource>\n</environment>\n</environments>\n<!-- 使用的是注解 -->\n<mappers>\n<!-- <mapper class=\"cn.kayleh.dao.AccountDao\"/> -->\n<!-- 该包下所有的dao接口都可以使用 -->\n<package name=\"cn.kayleh.dao\"/>\n</mappers>\n</configuration>\n```\n#####在AccountDao接口的方法上添加注解，编写SQL语句\n```java\npackage com.kayleh.dao;\n\nimport com.kayleh.domain.Account;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Select;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:11\n * <p>\n * 账户dao接口\n */\n\n@Repository\npublic interface AccountDao {\n\n    //查询所有账户\n    @Select(\"select * from account\")\n    public List<Account> findAll();\n\n    //保存账户信息\n    @Insert(\"insert into account(name,money) values (#{name},#{money})\")\n    public void saveAccount(Account account);\n}\n\n```\n##### 编写测试的方法\n```java\npackage com.kayleh.test;\nimport com.kayleh.service.AccountService;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:38\n */\npublic class TestSpring {\n    @Test\n    public void run1(){\n        //加载配置文件\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        //获取对象\n        AccountService as = (AccountService) ac.getBean(\"accountService\");\n        //调用方法\n        as.findAll();\n    }\n}\n\n```\n## Spring整合MyBatis框架\n#####目的：把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中\n```xml\n <!--Srping整合MyBatis框架-->\n    <!--配置连接池-->\n    <!--引入外部配置文件-->\n<!-- <context:property-placeholder location=\"classpath:jdbc.properties\"/>-->\n    <bean id=\"ds\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssm\"/><!--省略了localhost:3306-->\n        <property name=\"user\" value=\"root\"/>\n        <property name=\"password\" value=\"admin\"/>\n    </bean>\n\n    <!--配置SqlSessionFactory工厂-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"ds\"/>\n    </bean>\n\n    <!--配置AccountDao接口所在包-->\n    <bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"basePackage\" value=\"com.kayleh.dao\" />\n    </bean>\n```\n##### 在AccountDao接口中添加@Repository注解\n##### 在service中注入dao对象，进行测试\n```java\npackage com.kayleh.dao;\n\nimport com.kayleh.domain.Account;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Select;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:11\n * <p>\n * 账户dao接口\n */\n\n@Repository\npublic interface AccountDao {\n\n    //查询所有账户\n    @Select(\"select * from account\")\n    public List<Account> findAll();\n\n    //保存账户信息\n    @Insert(\"insert into account(name,money) values (#{name},#{money})\")\n    public void saveAccount(Account account);\n}\n\n-------------------------------------------------------------\npackage com.kayleh.service.impl;\n\nimport com.kayleh.dao.AccountDao;\nimport com.kayleh.domain.Account;\nimport com.kayleh.service.AccountService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:18\n */\n\n@Service(\"accountService\")\npublic class AccountServiceImpl implements AccountService {\n\n    @Autowired\n    private AccountDao accountDao;\n\n    public List<Account> findAll() {\n        System.out.println(\"业务层:查询所有账户...\");\n        return accountDao.findAll();\n    }\n\n    public void saveAccount(Account account) {\n        System.out.println(\"业务层:保存账户...\");\n        accountDao.saveAccount(account);\n    }\n}\n\n-------------------------------------------------------------\npackage com.kayleh.controller;\n\nimport com.kayleh.domain.Account;\nimport com.kayleh.service.AccountService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.ws.RequestWrapper;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * @Author: Wizard\n * @Date: 2020/4/21 9:21\n * <p>\n * 用户web层\n */\n\n@Controller\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n    @Autowired\n    private AccountService accountService;\n\n    @RequestMapping(\"/findAll\")\n    public String findAll(Model model) {\n        System.out.println(\"表现层:查询所有的账户...\");\n\n        List<Account> list = accountService.findAll();\n\n        model.addAttribute(\"list\", list);\n\n        return \"list\";\n    }\n```\n##### 配置Spring的声明式事务管理\n```xml\napplicationContext.xml\n <!-- 配置Spring框架声明式事务管理 -->\n    <!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"ds\"/>\n    </bean>\n\n    <!-- 配置事务通知 -->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <tx:attributes>\n            <tx:method name=\"find*\" read-only=\"true\"/>\n            <tx:method name=\"*\" isolation=\"DEFAULT\"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <!-- 配置AOP增强 -->\n    <aop:config>\n        <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.kayleh.service.impl.*ServiceImpl.*(..))\"/>\n\n    </aop:config>\n```\n\n```java\n/**\n     * 保存\n     *\n     * @param account\n     * @return\n     */\n    @RequestMapping(\"/save\")\n    public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        System.out.println(\"表现层:查询所有的账户...\");\n\n        accountService.saveAccount(account);\n\n        response.sendRedirect(request.getContextPath() + \"/account/findAll\");\n        return;\n    }\n```\n","tags":["frame"]},{"title":"回文数","url":"/2020/04/19/回文数/","content":"\n### 什么是回文数？\n\n回文数指的是正序和倒序读都是一样的数，例如121从左到右，从右到左读都是121。任何一个自然数与它的倒序数相加，所得的和再与和的倒序数相加，……如此反复进行下去，经过有限次步骤后，最后必定能得到一个回文数。\n\n<!-- more -->\n\n#### 问题：判断一个数是否为回文数，是返回true，否侧抛出false。\n\n``` bash\n\n@题目来源lettcode\n\n利用Java的StringBuilder通过把整数转换为字符串来实现↓\n\n\n\nimport java.util.Scanner;\n/**\n * @Author: Wizard\n * @Date: 2020/4/12 13:14\n */\npublic class palindrome {\n    public static boolean ispalindrome(int i) {\n        String str = (new StringBuilder(i + \"\")).reverse().toString();\n        return (i + \"\").equals(str);\n    }\n    public static void main(String[] args) {\n        while (true) {\n            System.out.println(\"输入需要判断的整数\");\n            Scanner scanner = new Scanner(System.in);\n            int str1 = scanner.nextInt();\n            System.out.println(ispalindrome(str1));\n        }\n    }\n}\n/**\n * 输入需要判断的整数：1\n * false\n * 输入需要判断的整数：12121\n * true\n */\n```\n\n---\n\n``` bash \n进阶：不改变整数为字符串\n\n通过取整和取余获取整数中的数字进行比较\n/**\n * @Author: Wizard\n * @Date: 2020/4/12 13:14\n */\npublic class palindrome {\n    public static boolean ispalindrome(int i) {\n        if(i<0||(i%10==0&&i!=0))\n            return false;\n        int number = 0;\n        while(i>number){\n            number = number * 10 + i % 10;\n            i /=10;\n        }\n        return i == number || i==number/10;\n    }\n    public static void main(String[] args) {\n        while (true) {\n            System.out.println(\"输入需要判断的整数\");\n            Scanner scanner = new Scanner(System.in);\n            int str1 = scanner.nextInt();\n            System.out.println(ispalindrome(str1));\n        }\n    }\n}\n```\n\n###### 微信公众号:每日学习干货↓\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![](1.jpg) \n","tags":["dataAlgorithm"]},{"title":"【SpringMVC】-@ModelAttribute","url":"/2020/04/19/【SpringMVC】-@ModelAttribute/","content":"\n## @ModelAttribute？\n\n@ModelAttribute的原理比较复杂，需要对源码有一定的理解。它可以使被\n<!-- more -->\n@ModelAttribute修饰的方法在控制器的处理方法之前调用。\n但如果@ModelAttribute标注在方法的入参前，它可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入入参。\n\n---\n\n### 实际场景：\n\nSpring在进行数据库update全字段更新操作提交表单的时候，从页面获取的数据会封装成一个new的pojo对象，没有带的值为null；所以我们只能更新我们提交的数据。ModelAttribute暂时保存表单pojo对象，覆盖数据库保存的pojo对象的数据即可。\n\n\n\n\n``` bash\nModelAttribute提前与目标方法运行\n/**\n * @author Kayleh\n */\n@Controller\npublic class ModelAttributeTest {\n  \n  @RequestMapping(\"/update\")\n  public String update(){     \n    System.out.println(\"页面update的bean对象：\"+bean);  \n  }\n  @ModelAttribute\n  public void modelAttribute(){     \n    System.out.println(\"ModelAttribute调用了...\");  \n  }\n\n\n===========输出=========\nModelAttribute调用了...\n页面update的bean对象：bean{......}\n```\n\n###### 可以得出：ModelAttribute标注的方法总会在目标方法(update)前执行。\n\n\n### ModelAttribute可以取出隐含对象的值\n\n``` bash\n@ModelAttribute\n  public void TestModelAttribute(Map<String, Object> map){\n    \n    POJO pojo = new POJO(\"kayleh\", 1104);\n    map.put(\"value\",pojo);\n    System.out.println(\"modelAttribute方法...);\n  }\n@RequestMapping(\"/updateBook\")\n  public String updateBook(@RequestParam(value=\"author\")String author,\n      Map<String, Object> model,\n      HttpServletRequest request,\n      @ModelAttribute(\"value\")POJO pojo\n      ){\n   \n    System.out.println(pojo);\n    return \"ok\";\n  }\n```\n\n @ModelAttribute(\"value\")这里如果指定的\"value\",value就是从map取出参数的key.如果是@ModelAttribute,没有指定key,SpringMVC会默认使用返回值类型的首字母小写作为key.如pOJO.\n\n###### 微信公众号:每日学习干货↓\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![](1.jpg) \n","tags":["frame"]},{"title":"Spring架构","url":"/2020/04/19/Spring架构/","content":"\n![](spring1.jpg)\n\n<!-- more -->\n\n\n微信公众号:每日学习干货","tags":["frame"]},{"title":"并发:原理","url":"/2020/04/19/并发：原理/","content":"\n## 多线程\n\n### 为什么要创建线程池\n\n``` bash\n如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降.\n```\n<!-- more -->\n创建线程池,可以:\n1.降低资源消耗\n2.提升响应速度\n3.提高\n\n### 线程池原理\n\n``` bash\n提交一个任务到线程池中,线程池的处理流程如下:\n1.判断线程池里的核心线程是否都在执行任务,如果不是(核心线程空闲或者核心线程没有被创建)则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程.\n2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程.\n3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务.\n```\n\n### 线程池的分类\n\n``` java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler);\n```\n\nThreadPoolExecutor是线程池的真正实现,\n他通过构造方法的一系列参数，来构成不同配置的线程池。\ncorePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中\nmaximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程；\nkeepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。\nunit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。\nworkQueue：一个阻塞队列，提交的任务将会被放到这个队列里。\nthreadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。\nhandler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。\n\n### 线程池的创建方法\n\nJava通过Executors（jdk1.5并发包）提供四种线程池，分别为：\n\nnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n案例演示:\n\nnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\nnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n\nnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n``` java\nnewCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，\n若无可回收，则新建线程。\n\npackage cn.qbz.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Test111907 {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp);\n                }\n            });\n        }\n    }\n}\n\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n``` bash\nnewFixedThreadPool\n创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\npackage cn.qbz.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Test111907 {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp);\n                }\n            });\n        }\n    }\n}\n\n\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n``` bash\nnewScheduledThreadPool\n创建一个定长线程池，支持定时及周期性任务执行。\n\npackage cn.qbz.thread;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class Test111907 {\n    public static void main(String[] args) {\n        final long begin = System.currentTimeMillis();\n        ExecutorService executorService = Executors.newScheduledThreadPool(3);\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            final long time = begin;\n            executorService.schedule(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp + \"   time=\" + (System.currentTimeMillis() - time));\n                }\n            }, 5, TimeUnit.SECONDS);\n        }\n    }\n}\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n```\n\n``` bash\nnewSingleThreadExecutor\n创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，\n保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\npublic class Test111907 {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 10; i++) {\n            final int temp = i;\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"   i=\" + temp);\n                }\n            });\n        }\n    }\n}\n```\n\n微信公众号:每日学习干货"},{"title":"unix的常用指令","url":"/2020/04/19/unix/","content":"\n## unix的常用指令\n\n<!-- more -->\n\n``` bash\nls 显示指定目录下的文件目录清单相当于dos下的dir命令。\npwd 显示当前目录。\nmkdir 在当前目录下创建目录。\nrm 删除文件或目录。\ncp 复制文件。\nmv 移动文件。\ncd 切换工作目录。\nps 查看进程。\nftp 传送文件。\ntelnet 远程登录命令。\nping 用来测试本机与目标主机是否联通。\nenv 查看当前系统中的环境变量。\nmore 分屏显示指定文件的内容。\necho在终端上显示你要显示的内容，向C语言中的printf函数。\n\n```\n\n微信公众号:每日学习干货"},{"title":"Rest架构风格","url":"/2020/04/18/Rest架构/Rest架构/","content":"\n## Rest是什么?\n\n``` bash\nREST(Representational State Transfe),是一种软件架构风格，它结构清晰、符合标准、易于理解、扩展方便，并且规范了URI的风格；规范了HTTP请求动作的使用，具有对应的语义。Spring支持并推荐使用这种风格的URL地址。他可以处理除POST或GET的其他请求.\nrest可以把普通的请求转化(如:GET.POST)为规定形式的请求(DELETE等等),使URL请求地址状态化.\n```\n\n<!-- more -->\n\n## Rest实现\n\n### 配置web.xml文件,添加一个Filter过滤器\n  \n``` bash\n<filter>\n    <!--HiddenHttpMethodFilter继承HttpServletRequest类-->\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n  </filter>\n  <filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n  \n   <!--要想获取其他类型的请求,要先创建一个form表单-->\n<form action=\"pojo/1\" method=\"post\">\n    <!--添加一个_method参数,它的值就是请求的类型-->\n    <input name=\"_method\" value=\"delete\">\n    <input type=\"submit\" value=\"删除请求\">\n  </form>\n```\n\n## 注意\n\n### ≥8.0版本的Tomcat服务器Filter会拦截JSP页面,这种情况需要在index.jsp页面加上这个约定.isErrorPage=\"true\"\n\n``` bash\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n  pageEncoding=\"UTF-8\"% isErrorPage=\"true\">\n  ```\n\n## 没有HiddenHttpMethodFilter的提示话,需要绑定源码jar包.\n\n微信公众号:每日学习干货"},{"title":"SpringMVC环境搭建","url":"/2020/04/17/SpringMVC环境搭建/","content":"\n## 什么是SpringMVC？\n\n\n\n``` bash\nSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架，实现MVC模块，简化了Web开发。\n\nMVC提倡每一层只写自己的东西，不写其他任何代码。为了解耦，为了维护方便和分工合作。\n\nSpringMVC为展现层提供的基于MVC设计理念的优秀Web框架，是目前最主流的框架之一。\n```\n\n<!-- more -->\n\n\n## 环境搭建\n\n### 1.导包(Maven工程忽略) \n  需要导入log包，spring核心包，SpringMVC包\n\n``` bash\n1.junit-x.x.x.jar \n2.spring-webmvc-x.x.x.RELEASE.jar\n3.spring-aop-x.x.x.RELEASE.jar\n4.spring-beans-x.x.x.RELEASE.jar\n5.spring-context-x.x.x.RELEASE.jar\n6.spring-core-x.x.x.RELEASE.jar\n7.spring-expression-x.x.x.RELEASE.jar\n8.spring-web-x.x.x.RELEASE.jar\n9.commons-log-.x.x.x.RELEASE.jar\n```\n\n\n\n### 写配置\n\n``` bash\n\n/**\n * web.xml\n */\n<servlet>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n     <init-param>\n      <!-- contextConfigLocation：指定SpringMVC配置文件位置 -->\n       <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:springmvc.xml</param-value>\n     </init-param>  \n    <load-on-startup>1</load-on-startup>\n  </servlet>\n <servlet-mapping>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n  ===========================================================\n /**\n * springmvc.xml\n */\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:context=\"http://www.springframework.org/schema/context\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n  <!-- 这里是扫描所有组件 -->\n  <context:component-scan base-package=\"com.wizard\"></context:component-scan>\n  \n  <!-- 配置一个视图解析器 作用是拼接页面的地址，方便调用-->\n  <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <!--前缀-->\n    <property name=\"prefix\" value=\"/WEB-INF/page/\"></property>\n    <!--后缀-->\n    <property name=\"suffix\" value=\".jsp\"></property>\n  </bean>\n  \n</beans>\n```\n\n\n``` bash\n\n/*\n*view层\n*/\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<h1>来了!</h1>\n</body>\n</html>\n```\n\n\n``` bash\n\n控制器层\n/**\n * @author Kayleh\n * @Controller:标识哪个组件是控制器\n *@RequestMapping\n *  告诉SpringMVC，这个方法用来处理什么请求;\n */\n\n@Controller\npublic class firstController {//这是一次转发操作\n  @RequestMapping(\"/hello\")\n  public String firstRequest(){\n    System.out.println(\"收到请求\");\n    return \"success\";\n  }\n\n}\n```\n\n``` bash\nindex.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<a href=\"hello\">Hello bug</a>\n</body>\n</html>\n```\n\n## 运行结果\n\n\n``` bash\nHello bug\n```\n\n## 其他细节\n\n细节：\n@RequestMapping注解不仅可以写在方法前,还可以写在类前,如果写在类前,意思为当前类所有的方法的请求地址指定一个基准路径,访问firstRequest方法的路径为/类前的注解/方法的注解(/hello).\n\n@RequestMapping注解的参数(\"/hello\")的/可以不写,但习惯为了方便维护应该写上.\n\n控制器处理的请求 firstController 是请求转发操作,Tomcat访问地址栏不变\n\n如果前端控制器没有指定配置文件位置,Spring也会在/WEB-INF/xxx-servlet.xml路径下查找文件.xxx为web.xml配置的前端控制器\n\n## 详细流程\n\n 1.客户端点击链接会发送http://localhost:8080/springmvc/hello请求\n\n 2.来到Tomcat服务器\n\n 3.springMVC的前端控制器收到所有请求\n\n 4.看请求地址和@RequestMapping标注的哪个匹配,来找到使用什么类的什么方法\n\n 5.前端控制器找到了目标处理器类和目标方法,直接利用反射执行目标方法\n\n 6.方法执行完成之后会有一个返回值;SpringMVC认为这个返回值就是要去的页面\n\n 7.拿到方法返回值后,用视图解析器进行拼串得到完整的页面地址\n\n 8.拿到页面地址,前端控制器转发到页面\n\n\n ### 其他问题?\n\n1为什么web.xml中配置的拦截为\n\n``` bash\n <servlet-mapping>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n```\n\n\n为什么没有拦截index.jsp??\n\n因为Tomcat的底层本来就能拦截jsp页面,配置的\"/\"的子类web.xml相当于覆盖了Webapp的父类web.xml中的DefaultServlet,DefaultServlet的作用是处理静态资源,覆盖了DefaultServlet,也就拦截了除jsp和servlet外的静态资源,而JspServlet的配置并没有覆盖.\n\n而\"/*\"的作用是拦截所有请求,包括jsp页面.\n----------\n\n","tags":["frame"]},{"title":"Hello World","url":"/2020/04/17/HelloWord/hello-world/","content":"\n<!-- more -->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]