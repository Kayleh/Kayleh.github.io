<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Kayleh"><title>单例模式 · Kayleh</title><meta name="description" content="单例设计模式
所谓类的单例设计模式，就是采用一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得对象实例的方法(静态方法)。
比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session 对象。SessionFactory并不"><meta name="keywords" content=""><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Kayleh</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">대문</a></li><li><a href="/archives">아카이브</a></li><li><a href="/categories">카테고리</a></li><li><a href="/tags">태그</a></li><li><a href="/google8102e2f35ce9e391.html"></a></li><li><a href="/mainfest.json"></a></li><li><a href="/link/index.html">友人帐</a></li><li><a href="/about/index.html">about</a></li><li class="soc"><a href="https://github.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://twitter.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter">&nbsp;</i></a><a href="https://www.instagram.com/kayleh" target="_blank" rel="noopener noreferrer"><i class="fa fa-instagram">&nbsp;</i></a><a href="https://kayleh.top/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>单例模式</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2020-06-06</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#comments">덧글</a></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/DesignPatterns/" title="DesignPatterns" class="a-tag">DesignPatterns</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><a id="more"></a><p>所谓类的单例设计模式，就是采用一定的方法保证在整个软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得对象实例的方法(静态方法)。</p><h6 id="比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session-对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个-SessionFactory就够，这是就会使用到单例模式。"><a href="#比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session-对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个-SessionFactory就够，这是就会使用到单例模式。" class="headerlink" title="比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session 对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory就够，这是就会使用到单例模式。"></a>比如<em>Hibernate</em>的<em>SessionFactory</em>，它充当数据存储源的代理，并负责创建<em>Session</em> 对象。<em>SessionFactory</em>并不是轻量级的，一般情况下，一个项目通常只需要一个 <em>SessionFactory</em>就够，这是就会使用到单例模式。</h6><p>单例模式有八种方式：</p><ul><li><p>饿汉式(静态常量)</p></li><li><p>饿汉式（静态代码块）</p></li><li><p>懒汉式(线程不安全)</p></li><li><p>懒汉式(线程安全，同步方法)</p></li><li><p>懒汉式(线程安全，同步代码块)</p></li><li><p>双重检查</p></li><li><p>静态内部类</p></li><li><p>枚举</p></li></ul><h4 id="饿汉式-静态变量"><a href="#饿汉式-静态变量" class="headerlink" title="饿汉式(静态变量)"></a>饿汉式(静态变量)</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">  /**
   * @Author: Wizard
   * @Date: 2020/6/6 14:13
   */
  public class Singleton1 {
      public static void main(String[] args) {
          //Test
          SingleTon instance1 = SingleTon.getInstance();
          SingleTon instance2 = SingleTon.getInstance();
          System.out.println(instance1==instance2);//true
      }
  }
  //饿汉式(静态变量)
  class SingleTon1 {
      //1.构造器私有化, 外部不能new
      private SingleTon1() {
      }
      //2.在本类内部创建对象实例
      private final static SingleTon1 instance = new SingleTon1();
      //3.提供一个公有的静态方法，返回实例对象
      public static SingleTon1 getInstance() {
        return instance;
      }
  }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点：</p><ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到<em>Lazy Loading</em>的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于<em>classloder</em>机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到 <em>lazy loading</em>的效果</li><li>结论：这种单例模式可用，可能造成<strong>内存浪费</strong></li></ul></blockquote><h4 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/2.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/**
 * @Author: Wizard
 * @Date: 2020/6/6 14:13
 */

//饿汉式(静态代码块)
class SingleTon2 {
    //1.构造器私有化, 外部不能new
    private SingleTon2() {
    }

    //2.在本类内部创建对象实例
    private static SingleTon2 instance;

    static {
        //在静态代码块中，创建单例对象,静态代码块只执行一次
        instance = new SingleTon2();
    }
    //3.提供一个公有的静态方法，返回实例对象
    public static SingleTon2 getInstance() {
        return instance;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点和静态变量相同</p></blockquote><h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/3.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//懒汉式
class SingleTon3 {
    private static SingleTon3 instance;

    private SingleTon3() {
    }
    //提供一个静态的公有方法,当使用到该方法时，才去创建instance
    public static SingleTon3 getInstance(){
        if (instance==null){
            instance = new SingleTon3();
        }
        return instance;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点：</p><ul><li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不要使用这种方式.</li></ul></blockquote><h4 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/4.png" alt="img"></p><pre class="line-numbers language-lang-JAVA"><code class="language-lang-JAVA">//懒汉式(线程安全，同步方法)
class SingleTon4 {
    private static SingleTon4 instance;

    private SingleTon4() {
    }
    //提供一个静态的公有方法,加入同步处理的代码，解决线程安全问题
    public static synchronized SingleTon4 getInstance(){
        if (instance==null){
            instance = new SingleTon4();
        }
        return instance;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点说明：</p><ul><li>解决了线程不安全问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低</li><li>结论：在实际开发中，不推荐使用这种方式</li></ul></blockquote><h4 id="懒汉式-线程安全，同步代码块"><a href="#懒汉式-线程安全，同步代码块" class="headerlink" title="懒汉式(线程安全，同步代码块)"></a>懒汉式(线程安全，同步代码块)</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/5.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//懒汉式(线程安全，同步代码块)
class SingleTon5 {
    private static SingleTon5 instance;
    private SingleTon5() {
    }
    //提供一个静态的公有方法,加入同步处理的代码，解决线程安全问题
    public static SingleTon5 getInstance() {
        if (instance == null) {
            synchronized (SingleTon5.class) {
                instance = new SingleTon5();
            }
        }
        return instance;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点说明：</p><ul><li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低， 改为同步产生实例化的的代码块</li><li><strong>但是这种同步并不能起到线程同步的作用</strong>。跟第3种实现方式遇到的情形一 致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行， 另一个线程也通过了这个判断语句，这时便会产生多个实例</li><li>结论：在实际开发中，不能使用这种方式</li></ul></blockquote><h4 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/6.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//懒汉式(线程安全,双重检查)
class SingleTon6 {
    //必须加volatile关键字的原因：new对象分为3步:1.分配空间 2.初始化对象 3.指向对象内存地址
    // 2和3可能被编译器自动重排序,导致判断非空但是实际拿的对象还未完成初始化
    private static volatile SingleTon6 instance;

    private SingleTon6() {
    }
    //提供一个静态的公有方法,加入双重检查代码，解决线程安全问题,同时解决懒加载的问题
    public static SingleTon6 getInstance() {
        if (instance == null) {
            synchronized (SingleTon6.class) {
                if (instance == null) {
                    instance = new SingleTon6();
                }
            }
        }
        return instance;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点说明：</p><ul><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步</li><li><p>线程安全；延迟加载；效率较高</p></li><li><p>结论：在实际开发中，推荐使用这种单例设计模式</p></li></ul></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/7.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//静态内部类
class SingleTon7 {
    private static volatile SingleTon7 instance;
    private SingleTon7() {
    }

    //写一个静态内部类,该类中有一个静态属性SingleTon7
    //静态内部类SingletonInstance在外部类SingleTon7在类装载的时候,并不会马上执行,不会导致静态内部类SingletonInstance马上装载
    //在JVM中，类的转载是线程安全的，导致了INSTANCE的初始化是线程安全的
    private static class SingletonInstance {
        private static final SingleTon7 INSTANCE = new SingleTon7();
    }

    public static SingleTon7 getInstance() {
        //当调用getInstance这个方法时,会去取静态内部类SingletonInstance里的INSTANCE属性,这时会导致SingletonInstance会被装载

        return SingletonInstance.INSTANCE;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点说明：</p><ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li><li>结论：推荐使用.</li></ul></blockquote><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><img src="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/8.png" alt="img"></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/**
 * @Author: Wizard
 * @Date: 2020/6/6 14:38
 */
public class Singleton8 {
    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance == instance2);//true
        System.out.println(instance.hashCode());
        System.out.println(instance2.hashCode());
    }
}
//枚举
enum Singleton {
    INSTANCE;

    public void ok() {
        System.out.println("ok");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点说明：</p><ul><li>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。</li><li>这种方式是Effective Java作者Josh Bloch 提倡的方式</li><li>结论：推荐使用</li></ul></blockquote><h4 id="单例模式在JDK-应用的源码分析"><a href="#单例模式在JDK-应用的源码分析" class="headerlink" title="单例模式在JDK 应用的源码分析"></a>单例模式在JDK 应用的源码分析</h4><p>单例模式在JDK 应用的源码分析</p><p>JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)</p><h3 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明"></a>单例模式注意事项和细节说明</h3><ol><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需 要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</li><li>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等)</li></ol><p></p></div><div class="share"><span>공유하기</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=https://kayleh.top/单例模式/%20Kayleh%20单例模式" target="_blank" rel="noopener" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="工厂设计模式"><i class="fa fa-angle-double-left"></i>&nbsp;이전 포스트: 工厂设计模式</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/" title="合成复用原则">다음 포스트: 合成复用原则&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname="kayleh",disqus_identifier="单例模式/",disqus_title="单例模式",disqus_url="https://kayleh.top/单例模式/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//kayleh.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="https://kayleh.top" rel="noopener noreferrer">Kayleh</a></p><span>visitors:<span id="busuanzi_value_site_pv"></span></span></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/dao.js"></script><script src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/busuanzi/busuanzi.pure.mini.js"></script><script data-ad-client="ca-pub-7457165067653912" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></body></html>